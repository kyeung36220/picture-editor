/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/domFunctions.js":
/*!*****************************!*\
  !*** ./src/domFunctions.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: () => (/* binding */ addClass),\n/* harmony export */   addId: () => (/* binding */ addId),\n/* harmony export */   append: () => (/* binding */ append),\n/* harmony export */   capitalize: () => (/* binding */ capitalize),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   createUIItem: () => (/* binding */ createUIItem),\n/* harmony export */   editText: () => (/* binding */ editText),\n/* harmony export */   editValue: () => (/* binding */ editValue),\n/* harmony export */   getId: () => (/* binding */ getId),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   removeClass: () => (/* binding */ removeClass),\n/* harmony export */   select: () => (/* binding */ select)\n/* harmony export */ });\nfunction select(item) {\n  return document.querySelector(item);\n}\nfunction create(item) {\n  return document.createElement(item);\n}\nfunction editText(item, text) {\n  item.textContent = text;\n}\nfunction addClass(item, className) {\n  item.classList.add(className);\n}\nfunction removeClass(item, className) {\n  item.classList.remove(className);\n}\nfunction append(parent, child) {\n  parent.appendChild(child);\n}\nfunction capitalize(val) {\n  return String(val).charAt(0).toUpperCase() + String(val).slice(1);\n}\nfunction insert(parent, item, beforeWhatIndex) {\n  parent.insertBefore(item, parent.children[beforeWhatIndex]);\n}\nfunction addId(item, idName) {\n  item.id = idName;\n}\nfunction getId(item) {\n  return item.id;\n}\nfunction editValue(item, value) {\n  item.value = value;\n}\nfunction createUIItem(stringTitle, typeOfElement, arrayOfExtraClasses, appendingParent) {\n  const item = create(typeOfElement);\n  if (stringTitle != \"\") {\n    addClass(item, stringTitle);\n  }\n  if (arrayOfExtraClasses.length > 0) {\n    for (let i = 0; i < arrayOfExtraClasses.length; i++) {\n      addClass(item, arrayOfExtraClasses[i]);\n    }\n  }\n  if (appendingParent != \"\") {\n    append(appendingParent, item);\n  }\n  return item;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZG9tRnVuY3Rpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFPLFNBQVNBLE1BQU1BLENBQUNDLElBQUksRUFBRTtFQUN6QixPQUFPQyxRQUFRLENBQUNDLGFBQWEsQ0FBQ0YsSUFBSSxDQUFDO0FBQ3ZDO0FBRU8sU0FBU0csTUFBTUEsQ0FBQ0gsSUFBSSxFQUFFO0VBQ3pCLE9BQU9DLFFBQVEsQ0FBQ0csYUFBYSxDQUFDSixJQUFJLENBQUM7QUFDdkM7QUFFTyxTQUFTSyxRQUFRQSxDQUFDTCxJQUFJLEVBQUVNLElBQUksRUFBRTtFQUNqQ04sSUFBSSxDQUFDTyxXQUFXLEdBQUdELElBQUk7QUFDM0I7QUFFTyxTQUFTRSxRQUFRQSxDQUFDUixJQUFJLEVBQUVTLFNBQVMsRUFBRTtFQUN0Q1QsSUFBSSxDQUFDVSxTQUFTLENBQUNDLEdBQUcsQ0FBQ0YsU0FBUyxDQUFDO0FBQ2pDO0FBRU8sU0FBU0csV0FBV0EsQ0FBQ1osSUFBSSxFQUFFUyxTQUFTLEVBQUU7RUFDekNULElBQUksQ0FBQ1UsU0FBUyxDQUFDRyxNQUFNLENBQUNKLFNBQVMsQ0FBQztBQUNwQztBQUVPLFNBQVNLLE1BQU1BLENBQUNDLE1BQU0sRUFBRUMsS0FBSyxFQUFFO0VBQ2xDRCxNQUFNLENBQUNFLFdBQVcsQ0FBQ0QsS0FBSyxDQUFDO0FBQzdCO0FBRU8sU0FBU0UsVUFBVUEsQ0FBQ0MsR0FBRyxFQUFFO0VBQzVCLE9BQU9DLE1BQU0sQ0FBQ0QsR0FBRyxDQUFDLENBQUNFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQ0MsV0FBVyxDQUFDLENBQUMsR0FBR0YsTUFBTSxDQUFDRCxHQUFHLENBQUMsQ0FBQ0ksS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNyRTtBQUVPLFNBQVNDLE1BQU1BLENBQUNULE1BQU0sRUFBRWYsSUFBSSxFQUFFeUIsZUFBZSxFQUFFO0VBQ2xEVixNQUFNLENBQUNXLFlBQVksQ0FBQzFCLElBQUksRUFBRWUsTUFBTSxDQUFDWSxRQUFRLENBQUNGLGVBQWUsQ0FBQyxDQUFDO0FBQy9EO0FBRU8sU0FBU0csS0FBS0EsQ0FBQzVCLElBQUksRUFBRTZCLE1BQU0sRUFBRTtFQUNoQzdCLElBQUksQ0FBQzhCLEVBQUUsR0FBR0QsTUFBTTtBQUNwQjtBQUVPLFNBQVNFLEtBQUtBLENBQUUvQixJQUFJLEVBQUU7RUFDekIsT0FBT0EsSUFBSSxDQUFDOEIsRUFBRTtBQUNsQjtBQUNPLFNBQVNFLFNBQVNBLENBQUNoQyxJQUFJLEVBQUVpQyxLQUFLLEVBQUU7RUFDbkNqQyxJQUFJLENBQUNpQyxLQUFLLEdBQUdBLEtBQUs7QUFDdEI7QUFFTyxTQUFTQyxZQUFZQSxDQUFDQyxXQUFXLEVBQUVDLGFBQWEsRUFBRUMsbUJBQW1CLEVBQUVDLGVBQWUsRUFBRTtFQUMzRixNQUFNdEMsSUFBSSxHQUFHRyxNQUFNLENBQUNpQyxhQUFhLENBQUM7RUFFbEMsSUFBSUQsV0FBVyxJQUFJLEVBQUUsRUFBRTtJQUNuQjNCLFFBQVEsQ0FBQ1IsSUFBSSxFQUFFbUMsV0FBVyxDQUFDO0VBQy9CO0VBRUEsSUFBSUUsbUJBQW1CLENBQUNFLE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDaEMsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdILG1CQUFtQixDQUFDRSxNQUFNLEVBQUVDLENBQUMsRUFBRSxFQUFFO01BQ2pEaEMsUUFBUSxDQUFDUixJQUFJLEVBQUVxQyxtQkFBbUIsQ0FBQ0csQ0FBQyxDQUFDLENBQUM7SUFDMUM7RUFDSjtFQUVBLElBQUlGLGVBQWUsSUFBSSxFQUFFLEVBQUU7SUFDdkJ4QixNQUFNLENBQUN3QixlQUFlLEVBQUV0QyxJQUFJLENBQUM7RUFDakM7RUFFQSxPQUFPQSxJQUFJO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrdGVtcGxhdGUvLi9zcmMvZG9tRnVuY3Rpb25zLmpzP2I0ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdChpdGVtKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaXRlbSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoaXRlbSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0ZW0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWRpdFRleHQoaXRlbSwgdGV4dCkge1xuICAgIGl0ZW0udGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoaXRlbSwgY2xhc3NOYW1lKSB7XG4gICAgaXRlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhpdGVtLCBjbGFzc05hbWUpIHtcbiAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUodmFsKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgU3RyaW5nKHZhbCkuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnQocGFyZW50LCBpdGVtLCBiZWZvcmVXaGF0SW5kZXgpIHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGl0ZW0sIHBhcmVudC5jaGlsZHJlbltiZWZvcmVXaGF0SW5kZXhdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZElkKGl0ZW0sIGlkTmFtZSkge1xuICAgIGl0ZW0uaWQgPSBpZE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJZCAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLmlkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVkaXRWYWx1ZShpdGVtLCB2YWx1ZSkge1xuICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVJSXRlbShzdHJpbmdUaXRsZSwgdHlwZU9mRWxlbWVudCwgYXJyYXlPZkV4dHJhQ2xhc3NlcywgYXBwZW5kaW5nUGFyZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IGNyZWF0ZSh0eXBlT2ZFbGVtZW50KTtcblxuICAgIGlmIChzdHJpbmdUaXRsZSAhPSBcIlwiKSB7XG4gICAgICAgIGFkZENsYXNzKGl0ZW0sIHN0cmluZ1RpdGxlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJyYXlPZkV4dHJhQ2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlPZkV4dHJhQ2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRkQ2xhc3MoaXRlbSwgYXJyYXlPZkV4dHJhQ2xhc3Nlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXBwZW5kaW5nUGFyZW50ICE9IFwiXCIpIHtcbiAgICAgICAgYXBwZW5kKGFwcGVuZGluZ1BhcmVudCwgaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW07XG59Il0sIm5hbWVzIjpbInNlbGVjdCIsIml0ZW0iLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGUiLCJjcmVhdGVFbGVtZW50IiwiZWRpdFRleHQiLCJ0ZXh0IiwidGV4dENvbnRlbnQiLCJhZGRDbGFzcyIsImNsYXNzTmFtZSIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZUNsYXNzIiwicmVtb3ZlIiwiYXBwZW5kIiwicGFyZW50IiwiY2hpbGQiLCJhcHBlbmRDaGlsZCIsImNhcGl0YWxpemUiLCJ2YWwiLCJTdHJpbmciLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiaW5zZXJ0IiwiYmVmb3JlV2hhdEluZGV4IiwiaW5zZXJ0QmVmb3JlIiwiY2hpbGRyZW4iLCJhZGRJZCIsImlkTmFtZSIsImlkIiwiZ2V0SWQiLCJlZGl0VmFsdWUiLCJ2YWx1ZSIsImNyZWF0ZVVJSXRlbSIsInN0cmluZ1RpdGxlIiwidHlwZU9mRWxlbWVudCIsImFycmF5T2ZFeHRyYUNsYXNzZXMiLCJhcHBlbmRpbmdQYXJlbnQiLCJsZW5ndGgiLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/domFunctions.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _imgly_background_removal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @imgly/background-removal */ \"./node_modules/@imgly/background-removal/dist/index.mjs\");\n/* harmony import */ var _removeBackgroundPageDOM__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./removeBackgroundPageDOM */ \"./src/removeBackgroundPageDOM.js\");\n\n\n\nfunction initialize() {\n  (0,_removeBackgroundPageDOM__WEBPACK_IMPORTED_MODULE_2__.initializeRemoveBackgroundPage)();\n  const imageInput = document.querySelector(\"input\");\n  const removeBackgroundButton = document.querySelector(\"#removeBackgroundButton\");\n  let config = {\n    progress: (key, current, total) => {\n      console.log(`Downloading ${key}: ${current} of ${total}`);\n    }\n  };\n  removeBackgroundButton.addEventListener(\"click\", () => {\n    if (!imageInput.files.length) {\n      alert(\"Please select an image first.\");\n      return;\n    }\n    (0,_imgly_background_removal__WEBPACK_IMPORTED_MODULE_1__.removeBackground)(imageInput.files[0], config).then(processedImage => {\n      const newImage = document.createElement(\"img\");\n      newImage.src = URL.createObjectURL(processedImage);\n      newImage.classList.add(\"image\");\n      document.querySelector(\".imageContainer\").remove();\n      const contentContainer = document.querySelector(\".contentContainer\");\n      contentContainer.appendChild(newImage);\n    }).catch(error => console.error(\"Background removal failed:\", error));\n  });\n}\ninitialize();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFzQjtBQUNzQztBQUNlO0FBRTNFLFNBQVNFLFVBQVVBLENBQUEsRUFBRztFQUNwQkQsd0ZBQThCLENBQUMsQ0FBQztFQUNoQyxNQUFNRSxVQUFVLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLE9BQU8sQ0FBQztFQUNsRCxNQUFNQyxzQkFBc0IsR0FBR0YsUUFBUSxDQUFDQyxhQUFhLENBQUMseUJBQXlCLENBQUM7RUFFaEYsSUFBSUUsTUFBTSxHQUFHO0lBQ1hDLFFBQVEsRUFBRUEsQ0FBQ0MsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLEtBQUssS0FBSztNQUNqQ0MsT0FBTyxDQUFDQyxHQUFHLENBQUMsZUFBZUosR0FBRyxLQUFLQyxPQUFPLE9BQU9DLEtBQUssRUFBRSxDQUFDO0lBQzNEO0VBQ0YsQ0FBQztFQUVETCxzQkFBc0IsQ0FBQ1EsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE1BQU07SUFFckQsSUFBSSxDQUFDWCxVQUFVLENBQUNZLEtBQUssQ0FBQ0MsTUFBTSxFQUFFO01BQzVCQyxLQUFLLENBQUMsK0JBQStCLENBQUM7TUFDdEM7SUFDRjtJQUVBakIsMkVBQWdCLENBQUNHLFVBQVUsQ0FBQ1ksS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFUixNQUFNLENBQUMsQ0FBQ1csSUFBSSxDQUFFQyxjQUFjLElBQUs7TUFDbkUsTUFBTUMsUUFBUSxHQUFHaEIsUUFBUSxDQUFDaUIsYUFBYSxDQUFDLEtBQUssQ0FBQztNQUM5Q0QsUUFBUSxDQUFDRSxHQUFHLEdBQUdDLEdBQUcsQ0FBQ0MsZUFBZSxDQUFDTCxjQUFjLENBQUM7TUFDbERDLFFBQVEsQ0FBQ0ssU0FBUyxDQUFDQyxHQUFHLENBQUMsT0FBTyxDQUFDO01BRS9CdEIsUUFBUSxDQUFDQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQ3NCLE1BQU0sQ0FBQyxDQUFDO01BRWxELE1BQU1DLGdCQUFnQixHQUFHeEIsUUFBUSxDQUFDQyxhQUFhLENBQUMsbUJBQW1CLENBQUM7TUFDcEV1QixnQkFBZ0IsQ0FBQ0MsV0FBVyxDQUFDVCxRQUFRLENBQUM7SUFDeEMsQ0FBQyxDQUFDLENBQ0RVLEtBQUssQ0FBRUMsS0FBSyxJQUFLbkIsT0FBTyxDQUFDbUIsS0FBSyxDQUFDLDRCQUE0QixFQUFFQSxLQUFLLENBQUMsQ0FBQztFQUN6RSxDQUFDLENBQUM7QUFDSjtBQUVBN0IsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrdGVtcGxhdGUvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuL3N0eWxlcy5jc3NcIjtcbmltcG9ydCB7IHJlbW92ZUJhY2tncm91bmQgfSBmcm9tIFwiQGltZ2x5L2JhY2tncm91bmQtcmVtb3ZhbFwiXG5pbXBvcnQgeyBpbml0aWFsaXplUmVtb3ZlQmFja2dyb3VuZFBhZ2UgfSBmcm9tIFwiLi9yZW1vdmVCYWNrZ3JvdW5kUGFnZURPTVwiO1xuXG5mdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICBpbml0aWFsaXplUmVtb3ZlQmFja2dyb3VuZFBhZ2UoKVxuICBjb25zdCBpbWFnZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpXG4gIGNvbnN0IHJlbW92ZUJhY2tncm91bmRCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3JlbW92ZUJhY2tncm91bmRCdXR0b25cIilcblxuICBsZXQgY29uZmlnID0ge1xuICAgIHByb2dyZXNzOiAoa2V5LCBjdXJyZW50LCB0b3RhbCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYERvd25sb2FkaW5nICR7a2V5fTogJHtjdXJyZW50fSBvZiAke3RvdGFsfWApO1xuICAgIH1cbiAgfTtcblxuICByZW1vdmVCYWNrZ3JvdW5kQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG5cbiAgICBpZiAoIWltYWdlSW5wdXQuZmlsZXMubGVuZ3RoKSB7XG4gICAgICBhbGVydChcIlBsZWFzZSBzZWxlY3QgYW4gaW1hZ2UgZmlyc3QuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbW92ZUJhY2tncm91bmQoaW1hZ2VJbnB1dC5maWxlc1swXSwgY29uZmlnKS50aGVuKChwcm9jZXNzZWRJbWFnZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIG5ld0ltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocHJvY2Vzc2VkSW1hZ2UpXG4gICAgICAgIG5ld0ltYWdlLmNsYXNzTGlzdC5hZGQoXCJpbWFnZVwiKVxuXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuaW1hZ2VDb250YWluZXJcIikucmVtb3ZlKClcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmNvbnRlbnRDb250YWluZXJcIilcbiAgICAgICAgY29udGVudENvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdJbWFnZSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiBjb25zb2xlLmVycm9yKFwiQmFja2dyb3VuZCByZW1vdmFsIGZhaWxlZDpcIiwgZXJyb3IpKTtcbiAgfSlcbn1cblxuaW5pdGlhbGl6ZSgpXG4iXSwibmFtZXMiOlsicmVtb3ZlQmFja2dyb3VuZCIsImluaXRpYWxpemVSZW1vdmVCYWNrZ3JvdW5kUGFnZSIsImluaXRpYWxpemUiLCJpbWFnZUlucHV0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwicmVtb3ZlQmFja2dyb3VuZEJ1dHRvbiIsImNvbmZpZyIsInByb2dyZXNzIiwia2V5IiwiY3VycmVudCIsInRvdGFsIiwiY29uc29sZSIsImxvZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJmaWxlcyIsImxlbmd0aCIsImFsZXJ0IiwidGhlbiIsInByb2Nlc3NlZEltYWdlIiwibmV3SW1hZ2UiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiY29udGVudENvbnRhaW5lciIsImFwcGVuZENoaWxkIiwiY2F0Y2giLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/removeBackgroundPageDOM.js":
/*!****************************************!*\
  !*** ./src/removeBackgroundPageDOM.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeRemoveBackgroundPage: () => (/* binding */ initializeRemoveBackgroundPage)\n/* harmony export */ });\n/* harmony import */ var _domFunctions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domFunctions */ \"./src/domFunctions.js\");\n\nfunction initializeRemoveBackgroundPage() {\n  const body = document.querySelector(\"body\");\n  const removeBackgroundPage = (0,_domFunctions__WEBPACK_IMPORTED_MODULE_0__.createUIItem)(\"removeBackgroundPage\", \"div\", [], body);\n  removeBackgroundPage.id = \"removeBackgroundPage\";\n  const title = (0,_domFunctions__WEBPACK_IMPORTED_MODULE_0__.createUIItem)(\"title\", \"div\", [], removeBackgroundPage);\n  title.textContent = \"Remove Background\";\n  const pictureUploadButton = (0,_domFunctions__WEBPACK_IMPORTED_MODULE_0__.createUIItem)(\"pictureUpload\", \"input\", [], removeBackgroundPage);\n  pictureUploadButton.id = \"pictureUpload\";\n  pictureUploadButton.type = \"file\";\n  pictureUploadButton.accept = \"image/png, image/jpeg\";\n  const removeBackgroundButton = (0,_domFunctions__WEBPACK_IMPORTED_MODULE_0__.createUIItem)(\"removeBackgroundButton\", \"div\", [], removeBackgroundPage);\n  removeBackgroundButton.id = \"removeBackgroundButton\";\n  removeBackgroundButton.textContent = \"Remove Background\";\n  const contentContainer = (0,_domFunctions__WEBPACK_IMPORTED_MODULE_0__.createUIItem)(\"contentContainer\", \"div\", [], removeBackgroundPage);\n  const imageContainer = (0,_domFunctions__WEBPACK_IMPORTED_MODULE_0__.createUIItem)(\"imageContainer\", \"image\", [], contentContainer);\n  imageContainer.src = \"#\";\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVtb3ZlQmFja2dyb3VuZFBhZ2VET00uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEM7QUFHdkMsU0FBU0MsOEJBQThCQSxDQUFBLEVBQUc7RUFDN0MsTUFBTUMsSUFBSSxHQUFHQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxNQUFNLENBQUM7RUFFM0MsTUFBTUMsb0JBQW9CLEdBQUdMLDJEQUFZLENBQUMsc0JBQXNCLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRUUsSUFBSSxDQUFDO0VBQ2xGRyxvQkFBb0IsQ0FBQ0MsRUFBRSxHQUFHLHNCQUFzQjtFQUVoRCxNQUFNQyxLQUFLLEdBQUdQLDJEQUFZLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUVLLG9CQUFvQixDQUFDO0VBQ3BFRSxLQUFLLENBQUNDLFdBQVcsR0FBRyxtQkFBbUI7RUFFdkMsTUFBTUMsbUJBQW1CLEdBQUdULDJEQUFZLENBQUMsZUFBZSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUVLLG9CQUFvQixDQUFDO0VBQzVGSSxtQkFBbUIsQ0FBQ0gsRUFBRSxHQUFHLGVBQWU7RUFDeENHLG1CQUFtQixDQUFDQyxJQUFJLEdBQUcsTUFBTTtFQUNqQ0QsbUJBQW1CLENBQUNFLE1BQU0sR0FBRyx1QkFBdUI7RUFFcEQsTUFBTUMsc0JBQXNCLEdBQUdaLDJEQUFZLENBQUMsd0JBQXdCLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRUssb0JBQW9CLENBQUM7RUFDdEdPLHNCQUFzQixDQUFDTixFQUFFLEdBQUcsd0JBQXdCO0VBQ3BETSxzQkFBc0IsQ0FBQ0osV0FBVyxHQUFHLG1CQUFtQjtFQUV4RCxNQUFNSyxnQkFBZ0IsR0FBR2IsMkRBQVksQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFSyxvQkFBb0IsQ0FBQztFQUMxRixNQUFNUyxjQUFjLEdBQUdkLDJEQUFZLENBQUMsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRWEsZ0JBQWdCLENBQUM7RUFDcEZDLGNBQWMsQ0FBQ0MsR0FBRyxHQUFHLEdBQUc7QUFFNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrdGVtcGxhdGUvLi9zcmMvcmVtb3ZlQmFja2dyb3VuZFBhZ2VET00uanM/MTY4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVVSUl0ZW0gfSBmcm9tIFwiLi9kb21GdW5jdGlvbnNcIjtcblxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlbW92ZUJhY2tncm91bmRQYWdlKCkge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKVxuXG4gICAgY29uc3QgcmVtb3ZlQmFja2dyb3VuZFBhZ2UgPSBjcmVhdGVVSUl0ZW0oXCJyZW1vdmVCYWNrZ3JvdW5kUGFnZVwiLCBcImRpdlwiLCBbXSwgYm9keSlcbiAgICByZW1vdmVCYWNrZ3JvdW5kUGFnZS5pZCA9IFwicmVtb3ZlQmFja2dyb3VuZFBhZ2VcIlxuXG4gICAgY29uc3QgdGl0bGUgPSBjcmVhdGVVSUl0ZW0oXCJ0aXRsZVwiLCBcImRpdlwiLCBbXSwgcmVtb3ZlQmFja2dyb3VuZFBhZ2UpXG4gICAgdGl0bGUudGV4dENvbnRlbnQgPSBcIlJlbW92ZSBCYWNrZ3JvdW5kXCJcblxuICAgIGNvbnN0IHBpY3R1cmVVcGxvYWRCdXR0b24gPSBjcmVhdGVVSUl0ZW0oXCJwaWN0dXJlVXBsb2FkXCIsIFwiaW5wdXRcIiwgW10sIHJlbW92ZUJhY2tncm91bmRQYWdlKVxuICAgIHBpY3R1cmVVcGxvYWRCdXR0b24uaWQgPSBcInBpY3R1cmVVcGxvYWRcIlxuICAgIHBpY3R1cmVVcGxvYWRCdXR0b24udHlwZSA9IFwiZmlsZVwiXG4gICAgcGljdHVyZVVwbG9hZEJ1dHRvbi5hY2NlcHQgPSBcImltYWdlL3BuZywgaW1hZ2UvanBlZ1wiXG5cbiAgICBjb25zdCByZW1vdmVCYWNrZ3JvdW5kQnV0dG9uID0gY3JlYXRlVUlJdGVtKFwicmVtb3ZlQmFja2dyb3VuZEJ1dHRvblwiLCBcImRpdlwiLCBbXSwgcmVtb3ZlQmFja2dyb3VuZFBhZ2UpXG4gICAgcmVtb3ZlQmFja2dyb3VuZEJ1dHRvbi5pZCA9IFwicmVtb3ZlQmFja2dyb3VuZEJ1dHRvblwiXG4gICAgcmVtb3ZlQmFja2dyb3VuZEJ1dHRvbi50ZXh0Q29udGVudCA9IFwiUmVtb3ZlIEJhY2tncm91bmRcIlxuXG4gICAgY29uc3QgY29udGVudENvbnRhaW5lciA9IGNyZWF0ZVVJSXRlbShcImNvbnRlbnRDb250YWluZXJcIiwgXCJkaXZcIiwgW10sIHJlbW92ZUJhY2tncm91bmRQYWdlKVxuICAgIGNvbnN0IGltYWdlQ29udGFpbmVyID0gY3JlYXRlVUlJdGVtKFwiaW1hZ2VDb250YWluZXJcIiwgXCJpbWFnZVwiLCBbXSwgY29udGVudENvbnRhaW5lcilcbiAgICBpbWFnZUNvbnRhaW5lci5zcmMgPSBcIiNcIlxuXG59Il0sIm5hbWVzIjpbImNyZWF0ZVVJSXRlbSIsImluaXRpYWxpemVSZW1vdmVCYWNrZ3JvdW5kUGFnZSIsImJvZHkiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJyZW1vdmVCYWNrZ3JvdW5kUGFnZSIsImlkIiwidGl0bGUiLCJ0ZXh0Q29udGVudCIsInBpY3R1cmVVcGxvYWRCdXR0b24iLCJ0eXBlIiwiYWNjZXB0IiwicmVtb3ZlQmFja2dyb3VuZEJ1dHRvbiIsImNvbnRlbnRDb250YWluZXIiLCJpbWFnZUNvbnRhaW5lciIsInNyYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/removeBackgroundPageDOM.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ \"./node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `*, *::before, *::after {\n  box-sizing: border-box;\n}\n\n* {\n  margin: 0;\n}\n\nbody {\n  line-height: 1.5;\n  -webkit-font-smoothing: antialiased;\n}\n\nimg, picture, video, canvas, svg {\n  display: block;\n  max-width: 100%;\n}\n\ninput, button, textarea, select {\n  font: inherit;\n}\n\np, h1, h2, h3, h4, h5, h6 {\n  overflow-wrap: break-word;\n}\n\np {\n  text-wrap: pretty;\n}\nh1, h2, h3, h4, h5, h6 {\n  text-wrap: balance;\n}\n\n#root, #__next {\n  isolation: isolate;\n}\n\n:root {\n  --colorOne: #635985;\n  --colorTwo: #443C68;\n  --colorThree: #393053;\n  --colorFour: #18122B;\n  font-family: \"Teko\";\n}\n\nbody {\n    background-color: var(--colorFour);\n    font-family: \"Varela Round\";\n}\n\nimg {\n  width: 700px;\n}\n\n#removeBackgroundPage {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n\n#removeBackgroundPage .title {\n  color: white;\n  font-size: 4rem;\n}\n\n#removeBackgroundPage .contentContainer {\n  display: flex;\n}\n\n#removeBackgroundPage .imageContainer {\n  width: 600px;\n  min-height: 600px;\n  border: 4px solid white;\n}\n\n#removeBackgroundPage .image {\n  max-height: 600px;\n  width: auto;\n  border: 4px solid white;\n}\n\n#removeBackgroundButton {\n  background-color: white;\n  width: fit-content\n}\n\n#removeBackgroundButton:hover {\n  cursor: pointer;\n}\n\n#pictureUpload {\n  color: white;\n}`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/styles.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,sBAAsB;AACxB;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,gBAAgB;EAChB,mCAAmC;AACrC;;AAEA;EACE,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,iBAAiB;AACnB;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,mBAAmB;EACnB,mBAAmB;EACnB,qBAAqB;EACrB,oBAAoB;EACpB,mBAAmB;AACrB;;AAEA;IACI,kCAAkC;IAClC,2BAA2B;AAC/B;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,YAAY;EACZ,eAAe;AACjB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,uBAAuB;AACzB;;AAEA;EACE,iBAAiB;EACjB,WAAW;EACX,uBAAuB;AACzB;;AAEA;EACE,uBAAuB;EACvB;AACF;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,YAAY;AACd\",\"sourcesContent\":[\"*, *::before, *::after {\\n  box-sizing: border-box;\\n}\\n\\n* {\\n  margin: 0;\\n}\\n\\nbody {\\n  line-height: 1.5;\\n  -webkit-font-smoothing: antialiased;\\n}\\n\\nimg, picture, video, canvas, svg {\\n  display: block;\\n  max-width: 100%;\\n}\\n\\ninput, button, textarea, select {\\n  font: inherit;\\n}\\n\\np, h1, h2, h3, h4, h5, h6 {\\n  overflow-wrap: break-word;\\n}\\n\\np {\\n  text-wrap: pretty;\\n}\\nh1, h2, h3, h4, h5, h6 {\\n  text-wrap: balance;\\n}\\n\\n#root, #__next {\\n  isolation: isolate;\\n}\\n\\n:root {\\n  --colorOne: #635985;\\n  --colorTwo: #443C68;\\n  --colorThree: #393053;\\n  --colorFour: #18122B;\\n  font-family: \\\"Teko\\\";\\n}\\n\\nbody {\\n    background-color: var(--colorFour);\\n    font-family: \\\"Varela Round\\\";\\n}\\n\\nimg {\\n  width: 700px;\\n}\\n\\n#removeBackgroundPage {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n#removeBackgroundPage .title {\\n  color: white;\\n  font-size: 4rem;\\n}\\n\\n#removeBackgroundPage .contentContainer {\\n  display: flex;\\n}\\n\\n#removeBackgroundPage .imageContainer {\\n  width: 600px;\\n  min-height: 600px;\\n  border: 4px solid white;\\n}\\n\\n#removeBackgroundPage .image {\\n  max-height: 600px;\\n  width: auto;\\n  border: 4px solid white;\\n}\\n\\n#removeBackgroundButton {\\n  background-color: white;\\n  width: fit-content\\n}\\n\\n#removeBackgroundButton:hover {\\n  cursor: pointer;\\n}\\n\\n#pictureUpload {\\n  color: white;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9zdHlsZXMuY3NzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEc7QUFDakI7QUFDekYsOEJBQThCLG1GQUEyQixDQUFDLDRGQUFxQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMsT0FBTyxpRkFBaUYsWUFBWSxPQUFPLEtBQUssVUFBVSxNQUFNLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxVQUFVLFVBQVUsT0FBTyxLQUFLLFVBQVUsTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFVBQVUsT0FBTyxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssWUFBWSxNQUFNLE1BQU0sS0FBSyxVQUFVLE9BQU8sS0FBSyxVQUFVLGlEQUFpRCwyQkFBMkIsR0FBRyxPQUFPLGNBQWMsR0FBRyxVQUFVLHFCQUFxQix3Q0FBd0MsR0FBRyxzQ0FBc0MsbUJBQW1CLG9CQUFvQixHQUFHLHFDQUFxQyxrQkFBa0IsR0FBRywrQkFBK0IsOEJBQThCLEdBQUcsT0FBTyxzQkFBc0IsR0FBRywwQkFBMEIsdUJBQXVCLEdBQUcsb0JBQW9CLHVCQUF1QixHQUFHLFdBQVcsd0JBQXdCLHdCQUF3QiwwQkFBMEIseUJBQXlCLDBCQUEwQixHQUFHLFVBQVUseUNBQXlDLG9DQUFvQyxHQUFHLFNBQVMsaUJBQWlCLEdBQUcsMkJBQTJCLGtCQUFrQiwyQkFBMkIsNEJBQTRCLHdCQUF3QixHQUFHLGtDQUFrQyxpQkFBaUIsb0JBQW9CLEdBQUcsNkNBQTZDLGtCQUFrQixHQUFHLDJDQUEyQyxpQkFBaUIsc0JBQXNCLDRCQUE0QixHQUFHLGtDQUFrQyxzQkFBc0IsZ0JBQWdCLDRCQUE0QixHQUFHLDZCQUE2Qiw0QkFBNEIseUJBQXlCLG1DQUFtQyxvQkFBb0IsR0FBRyxvQkFBb0IsaUJBQWlCLEdBQUcsbUJBQW1CO0FBQzFuRTtBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFja3RlbXBsYXRlLy4vc3JjL3N0eWxlcy5jc3M/ZTlhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgKiwgKjo6YmVmb3JlLCAqOjphZnRlciB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG59XG5cbioge1xuICBtYXJnaW46IDA7XG59XG5cbmJvZHkge1xuICBsaW5lLWhlaWdodDogMS41O1xuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbn1cblxuaW1nLCBwaWN0dXJlLCB2aWRlbywgY2FudmFzLCBzdmcge1xuICBkaXNwbGF5OiBibG9jaztcbiAgbWF4LXdpZHRoOiAxMDAlO1xufVxuXG5pbnB1dCwgYnV0dG9uLCB0ZXh0YXJlYSwgc2VsZWN0IHtcbiAgZm9udDogaW5oZXJpdDtcbn1cblxucCwgaDEsIGgyLCBoMywgaDQsIGg1LCBoNiB7XG4gIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XG59XG5cbnAge1xuICB0ZXh0LXdyYXA6IHByZXR0eTtcbn1cbmgxLCBoMiwgaDMsIGg0LCBoNSwgaDYge1xuICB0ZXh0LXdyYXA6IGJhbGFuY2U7XG59XG5cbiNyb290LCAjX19uZXh0IHtcbiAgaXNvbGF0aW9uOiBpc29sYXRlO1xufVxuXG46cm9vdCB7XG4gIC0tY29sb3JPbmU6ICM2MzU5ODU7XG4gIC0tY29sb3JUd286ICM0NDNDNjg7XG4gIC0tY29sb3JUaHJlZTogIzM5MzA1MztcbiAgLS1jb2xvckZvdXI6ICMxODEyMkI7XG4gIGZvbnQtZmFtaWx5OiBcIlRla29cIjtcbn1cblxuYm9keSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3JGb3VyKTtcbiAgICBmb250LWZhbWlseTogXCJWYXJlbGEgUm91bmRcIjtcbn1cblxuaW1nIHtcbiAgd2lkdGg6IDcwMHB4O1xufVxuXG4jcmVtb3ZlQmFja2dyb3VuZFBhZ2Uge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuI3JlbW92ZUJhY2tncm91bmRQYWdlIC50aXRsZSB7XG4gIGNvbG9yOiB3aGl0ZTtcbiAgZm9udC1zaXplOiA0cmVtO1xufVxuXG4jcmVtb3ZlQmFja2dyb3VuZFBhZ2UgLmNvbnRlbnRDb250YWluZXIge1xuICBkaXNwbGF5OiBmbGV4O1xufVxuXG4jcmVtb3ZlQmFja2dyb3VuZFBhZ2UgLmltYWdlQ29udGFpbmVyIHtcbiAgd2lkdGg6IDYwMHB4O1xuICBtaW4taGVpZ2h0OiA2MDBweDtcbiAgYm9yZGVyOiA0cHggc29saWQgd2hpdGU7XG59XG5cbiNyZW1vdmVCYWNrZ3JvdW5kUGFnZSAuaW1hZ2Uge1xuICBtYXgtaGVpZ2h0OiA2MDBweDtcbiAgd2lkdGg6IGF1dG87XG4gIGJvcmRlcjogNHB4IHNvbGlkIHdoaXRlO1xufVxuXG4jcmVtb3ZlQmFja2dyb3VuZEJ1dHRvbiB7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICB3aWR0aDogZml0LWNvbnRlbnRcbn1cblxuI3JlbW92ZUJhY2tncm91bmRCdXR0b246aG92ZXIge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbiNwaWN0dXJlVXBsb2FkIHtcbiAgY29sb3I6IHdoaXRlO1xufWAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlcy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSxTQUFTO0FBQ1g7O0FBRUE7RUFDRSxnQkFBZ0I7RUFDaEIsbUNBQW1DO0FBQ3JDOztBQUVBO0VBQ0UsY0FBYztFQUNkLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxhQUFhO0FBQ2Y7O0FBRUE7RUFDRSx5QkFBeUI7QUFDM0I7O0FBRUE7RUFDRSxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLG1CQUFtQjtFQUNuQixtQkFBbUI7RUFDbkIscUJBQXFCO0VBQ3JCLG9CQUFvQjtFQUNwQixtQkFBbUI7QUFDckI7O0FBRUE7SUFDSSxrQ0FBa0M7SUFDbEMsMkJBQTJCO0FBQy9COztBQUVBO0VBQ0UsWUFBWTtBQUNkOztBQUVBO0VBQ0UsYUFBYTtFQUNiLHNCQUFzQjtFQUN0Qix1QkFBdUI7RUFDdkIsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsWUFBWTtFQUNaLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxhQUFhO0FBQ2Y7O0FBRUE7RUFDRSxZQUFZO0VBQ1osaUJBQWlCO0VBQ2pCLHVCQUF1QjtBQUN6Qjs7QUFFQTtFQUNFLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsdUJBQXVCO0FBQ3pCOztBQUVBO0VBQ0UsdUJBQXVCO0VBQ3ZCO0FBQ0Y7O0FBRUE7RUFDRSxlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsWUFBWTtBQUNkXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIiosICo6OmJlZm9yZSwgKjo6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuXFxuKiB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbmJvZHkge1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbn1cXG5cXG5pbWcsIHBpY3R1cmUsIHZpZGVvLCBjYW52YXMsIHN2ZyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1heC13aWR0aDogMTAwJTtcXG59XFxuXFxuaW5wdXQsIGJ1dHRvbiwgdGV4dGFyZWEsIHNlbGVjdCB7XFxuICBmb250OiBpbmhlcml0O1xcbn1cXG5cXG5wLCBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2IHtcXG4gIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XFxufVxcblxcbnAge1xcbiAgdGV4dC13cmFwOiBwcmV0dHk7XFxufVxcbmgxLCBoMiwgaDMsIGg0LCBoNSwgaDYge1xcbiAgdGV4dC13cmFwOiBiYWxhbmNlO1xcbn1cXG5cXG4jcm9vdCwgI19fbmV4dCB7XFxuICBpc29sYXRpb246IGlzb2xhdGU7XFxufVxcblxcbjpyb290IHtcXG4gIC0tY29sb3JPbmU6ICM2MzU5ODU7XFxuICAtLWNvbG9yVHdvOiAjNDQzQzY4O1xcbiAgLS1jb2xvclRocmVlOiAjMzkzMDUzO1xcbiAgLS1jb2xvckZvdXI6ICMxODEyMkI7XFxuICBmb250LWZhbWlseTogXFxcIlRla29cXFwiO1xcbn1cXG5cXG5ib2R5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3JGb3VyKTtcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJWYXJlbGEgUm91bmRcXFwiO1xcbn1cXG5cXG5pbWcge1xcbiAgd2lkdGg6IDcwMHB4O1xcbn1cXG5cXG4jcmVtb3ZlQmFja2dyb3VuZFBhZ2Uge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbiNyZW1vdmVCYWNrZ3JvdW5kUGFnZSAudGl0bGUge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC1zaXplOiA0cmVtO1xcbn1cXG5cXG4jcmVtb3ZlQmFja2dyb3VuZFBhZ2UgLmNvbnRlbnRDb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuI3JlbW92ZUJhY2tncm91bmRQYWdlIC5pbWFnZUNvbnRhaW5lciB7XFxuICB3aWR0aDogNjAwcHg7XFxuICBtaW4taGVpZ2h0OiA2MDBweDtcXG4gIGJvcmRlcjogNHB4IHNvbGlkIHdoaXRlO1xcbn1cXG5cXG4jcmVtb3ZlQmFja2dyb3VuZFBhZ2UgLmltYWdlIHtcXG4gIG1heC1oZWlnaHQ6IDYwMHB4O1xcbiAgd2lkdGg6IGF1dG87XFxuICBib3JkZXI6IDRweCBzb2xpZCB3aGl0ZTtcXG59XFxuXFxuI3JlbW92ZUJhY2tncm91bmRCdXR0b24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICB3aWR0aDogZml0LWNvbnRlbnRcXG59XFxuXFxuI3JlbW92ZUJhY2tncm91bmRCdXR0b246aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4jcGljdHVyZVVwbG9hZCB7XFxuICBjb2xvcjogd2hpdGU7XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./src/styles.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2t0ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzP2FmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzLmNzcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxNQUErRjtBQUMvRixNQUFxRjtBQUNyRixNQUE0RjtBQUM1RixNQUErRztBQUMvRyxNQUF3RztBQUN4RyxNQUF3RztBQUN4RyxNQUFvRztBQUNwRztBQUNBOztBQUVBOztBQUVBLDRCQUE0QixxR0FBbUI7QUFDL0Msd0JBQXdCLGtIQUFhO0FBQ3JDLGlCQUFpQix1R0FBYTtBQUM5QixpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLHVGQUFPOzs7O0FBSThDO0FBQ3RFLE9BQU8saUVBQWUsdUZBQU8sSUFBSSx1RkFBTyxVQUFVLHVGQUFPLG1CQUFtQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFja3RlbXBsYXRlLy4vc3JjL3N0eWxlcy5jc3M/NDRiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xub3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlcy5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/styles.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2t0ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanM/YjIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2t0ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcz9kZTZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ZGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2t0ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2t0ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzPzFkZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ }),

/***/ "./node_modules/@imgly/background-removal/dist/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@imgly/background-removal/dist/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alphamask: () => (/* binding */ alphamask),\n/* harmony export */   applySegmentationMask: () => (/* binding */ applySegmentationMask),\n/* harmony export */   preload: () => (/* binding */ preload),\n/* harmony export */   removeBackground: () => (/* binding */ removeBackground),\n/* harmony export */   removeForeground: () => (/* binding */ removeForeground),\n/* harmony export */   segmentForeground: () => (/* binding */ segmentForeground)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// ../../node_modules/lodash/lodash.js\nvar require_lodash = __commonJS({\n  \"../../node_modules/lodash/lodash.js\"(exports, module) {\n    (function() {\n      var undefined2;\n      var VERSION = \"4.17.21\";\n      var LARGE_ARRAY_SIZE = 200;\n      var CORE_ERROR_TEXT = \"Unsupported core-js use. Try https://npms.io/search?q=ponyfill.\", FUNC_ERROR_TEXT = \"Expected a function\", INVALID_TEMPL_VAR_ERROR_TEXT = \"Invalid `variable` option passed into `_.template`\";\n      var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n      var MAX_MEMOIZE_SIZE = 500;\n      var PLACEHOLDER = \"__lodash_placeholder__\";\n      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;\n      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;\n      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;\n      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = \"...\";\n      var HOT_COUNT = 800, HOT_SPAN = 16;\n      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;\n      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;\n      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n      var wrapFlags = [\n        [\"ary\", WRAP_ARY_FLAG],\n        [\"bind\", WRAP_BIND_FLAG],\n        [\"bindKey\", WRAP_BIND_KEY_FLAG],\n        [\"curry\", WRAP_CURRY_FLAG],\n        [\"curryRight\", WRAP_CURRY_RIGHT_FLAG],\n        [\"flip\", WRAP_FLIP_FLAG],\n        [\"partial\", WRAP_PARTIAL_FLAG],\n        [\"partialRight\", WRAP_PARTIAL_RIGHT_FLAG],\n        [\"rearg\", WRAP_REARG_FLAG]\n      ];\n      var argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", asyncTag = \"[object AsyncFunction]\", boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", domExcTag = \"[object DOMException]\", errorTag = \"[object Error]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", mapTag = \"[object Map]\", numberTag = \"[object Number]\", nullTag = \"[object Null]\", objectTag = \"[object Object]\", promiseTag = \"[object Promise]\", proxyTag = \"[object Proxy]\", regexpTag = \"[object RegExp]\", setTag = \"[object Set]\", stringTag = \"[object String]\", symbolTag = \"[object Symbol]\", undefinedTag = \"[object Undefined]\", weakMapTag = \"[object WeakMap]\", weakSetTag = \"[object WeakSet]\";\n      var arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\n      var reEmptyStringLeading = /\\b__p \\+= '';/g, reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g, reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>\"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n      var reEscape = /<%-([\\s\\S]+?)%>/g, reEvaluate = /<%([\\s\\S]+?)%>/g, reInterpolate = /<%=([\\s\\S]+?)%>/g;\n      var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/, rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n      var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);\n      var reTrimStart = /^\\s+/;\n      var reWhitespace = /\\s/;\n      var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/, reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/, reSplitDetails = /,? & /;\n      var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n      var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n      var reEscapeChar = /\\\\(\\\\)?/g;\n      var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n      var reFlags = /\\w*$/;\n      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n      var reIsBinary = /^0b[01]+$/i;\n      var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n      var reIsOctal = /^0o[0-7]+$/i;\n      var reIsUint = /^(?:0|[1-9]\\d*)$/;\n      var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n      var reNoMatch = /($^)/;\n      var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n      var rsAstralRange = \"\\\\ud800-\\\\udfff\", rsComboMarksRange = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = \"\\\\u2700-\\\\u27bf\", rsLowerRange = \"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\", rsMathOpRange = \"\\\\xac\\\\xb1\\\\xd7\\\\xf7\", rsNonCharRange = \"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\", rsPunctuationRange = \"\\\\u2000-\\\\u206f\", rsSpaceRange = \" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\", rsUpperRange = \"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\", rsVarRange = \"\\\\ufe0e\\\\ufe0f\", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n      var rsApos = \"['\\u2019]\", rsAstral = \"[\" + rsAstralRange + \"]\", rsBreak = \"[\" + rsBreakRange + \"]\", rsCombo = \"[\" + rsComboRange + \"]\", rsDigits = \"\\\\d+\", rsDingbat = \"[\" + rsDingbatRange + \"]\", rsLower = \"[\" + rsLowerRange + \"]\", rsMisc = \"[^\" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + \"]\", rsFitz = \"\\\\ud83c[\\\\udffb-\\\\udfff]\", rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\", rsNonAstral = \"[^\" + rsAstralRange + \"]\", rsRegional = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\", rsSurrPair = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\", rsUpper = \"[\" + rsUpperRange + \"]\", rsZWJ = \"\\\\u200d\";\n      var rsMiscLower = \"(?:\" + rsLower + \"|\" + rsMisc + \")\", rsMiscUpper = \"(?:\" + rsUpper + \"|\" + rsMisc + \")\", rsOptContrLower = \"(?:\" + rsApos + \"(?:d|ll|m|re|s|t|ve))?\", rsOptContrUpper = \"(?:\" + rsApos + \"(?:D|LL|M|RE|S|T|VE))?\", reOptMod = rsModifier + \"?\", rsOptVar = \"[\" + rsVarRange + \"]?\", rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [rsNonAstral, rsRegional, rsSurrPair].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\", rsOrdLower = \"\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])\", rsOrdUpper = \"\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])\", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = \"(?:\" + [rsDingbat, rsRegional, rsSurrPair].join(\"|\") + \")\" + rsSeq, rsSymbol = \"(?:\" + [rsNonAstral + rsCombo + \"?\", rsCombo, rsRegional, rsSurrPair, rsAstral].join(\"|\") + \")\";\n      var reApos = RegExp(rsApos, \"g\");\n      var reComboMark = RegExp(rsCombo, \"g\");\n      var reUnicode = RegExp(rsFitz + \"(?=\" + rsFitz + \")|\" + rsSymbol + rsSeq, \"g\");\n      var reUnicodeWord = RegExp([\n        rsUpper + \"?\" + rsLower + \"+\" + rsOptContrLower + \"(?=\" + [rsBreak, rsUpper, \"$\"].join(\"|\") + \")\",\n        rsMiscUpper + \"+\" + rsOptContrUpper + \"(?=\" + [rsBreak, rsUpper + rsMiscLower, \"$\"].join(\"|\") + \")\",\n        rsUpper + \"?\" + rsMiscLower + \"+\" + rsOptContrLower,\n        rsUpper + \"+\" + rsOptContrUpper,\n        rsOrdUpper,\n        rsOrdLower,\n        rsDigits,\n        rsEmoji\n      ].join(\"|\"), \"g\");\n      var reHasUnicode = RegExp(\"[\" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + \"]\");\n      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n      var contextProps = [\n        \"Array\",\n        \"Buffer\",\n        \"DataView\",\n        \"Date\",\n        \"Error\",\n        \"Float32Array\",\n        \"Float64Array\",\n        \"Function\",\n        \"Int8Array\",\n        \"Int16Array\",\n        \"Int32Array\",\n        \"Map\",\n        \"Math\",\n        \"Object\",\n        \"Promise\",\n        \"RegExp\",\n        \"Set\",\n        \"String\",\n        \"Symbol\",\n        \"TypeError\",\n        \"Uint8Array\",\n        \"Uint8ClampedArray\",\n        \"Uint16Array\",\n        \"Uint32Array\",\n        \"WeakMap\",\n        \"_\",\n        \"clearTimeout\",\n        \"isFinite\",\n        \"parseInt\",\n        \"setTimeout\"\n      ];\n      var templateCounter = -1;\n      var typedArrayTags = {};\n      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n      var cloneableTags = {};\n      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;\n      var deburredLetters = {\n        // Latin-1 Supplement block.\n        \"\\xC0\": \"A\",\n        \"\\xC1\": \"A\",\n        \"\\xC2\": \"A\",\n        \"\\xC3\": \"A\",\n        \"\\xC4\": \"A\",\n        \"\\xC5\": \"A\",\n        \"\\xE0\": \"a\",\n        \"\\xE1\": \"a\",\n        \"\\xE2\": \"a\",\n        \"\\xE3\": \"a\",\n        \"\\xE4\": \"a\",\n        \"\\xE5\": \"a\",\n        \"\\xC7\": \"C\",\n        \"\\xE7\": \"c\",\n        \"\\xD0\": \"D\",\n        \"\\xF0\": \"d\",\n        \"\\xC8\": \"E\",\n        \"\\xC9\": \"E\",\n        \"\\xCA\": \"E\",\n        \"\\xCB\": \"E\",\n        \"\\xE8\": \"e\",\n        \"\\xE9\": \"e\",\n        \"\\xEA\": \"e\",\n        \"\\xEB\": \"e\",\n        \"\\xCC\": \"I\",\n        \"\\xCD\": \"I\",\n        \"\\xCE\": \"I\",\n        \"\\xCF\": \"I\",\n        \"\\xEC\": \"i\",\n        \"\\xED\": \"i\",\n        \"\\xEE\": \"i\",\n        \"\\xEF\": \"i\",\n        \"\\xD1\": \"N\",\n        \"\\xF1\": \"n\",\n        \"\\xD2\": \"O\",\n        \"\\xD3\": \"O\",\n        \"\\xD4\": \"O\",\n        \"\\xD5\": \"O\",\n        \"\\xD6\": \"O\",\n        \"\\xD8\": \"O\",\n        \"\\xF2\": \"o\",\n        \"\\xF3\": \"o\",\n        \"\\xF4\": \"o\",\n        \"\\xF5\": \"o\",\n        \"\\xF6\": \"o\",\n        \"\\xF8\": \"o\",\n        \"\\xD9\": \"U\",\n        \"\\xDA\": \"U\",\n        \"\\xDB\": \"U\",\n        \"\\xDC\": \"U\",\n        \"\\xF9\": \"u\",\n        \"\\xFA\": \"u\",\n        \"\\xFB\": \"u\",\n        \"\\xFC\": \"u\",\n        \"\\xDD\": \"Y\",\n        \"\\xFD\": \"y\",\n        \"\\xFF\": \"y\",\n        \"\\xC6\": \"Ae\",\n        \"\\xE6\": \"ae\",\n        \"\\xDE\": \"Th\",\n        \"\\xFE\": \"th\",\n        \"\\xDF\": \"ss\",\n        // Latin Extended-A block.\n        \"\\u0100\": \"A\",\n        \"\\u0102\": \"A\",\n        \"\\u0104\": \"A\",\n        \"\\u0101\": \"a\",\n        \"\\u0103\": \"a\",\n        \"\\u0105\": \"a\",\n        \"\\u0106\": \"C\",\n        \"\\u0108\": \"C\",\n        \"\\u010A\": \"C\",\n        \"\\u010C\": \"C\",\n        \"\\u0107\": \"c\",\n        \"\\u0109\": \"c\",\n        \"\\u010B\": \"c\",\n        \"\\u010D\": \"c\",\n        \"\\u010E\": \"D\",\n        \"\\u0110\": \"D\",\n        \"\\u010F\": \"d\",\n        \"\\u0111\": \"d\",\n        \"\\u0112\": \"E\",\n        \"\\u0114\": \"E\",\n        \"\\u0116\": \"E\",\n        \"\\u0118\": \"E\",\n        \"\\u011A\": \"E\",\n        \"\\u0113\": \"e\",\n        \"\\u0115\": \"e\",\n        \"\\u0117\": \"e\",\n        \"\\u0119\": \"e\",\n        \"\\u011B\": \"e\",\n        \"\\u011C\": \"G\",\n        \"\\u011E\": \"G\",\n        \"\\u0120\": \"G\",\n        \"\\u0122\": \"G\",\n        \"\\u011D\": \"g\",\n        \"\\u011F\": \"g\",\n        \"\\u0121\": \"g\",\n        \"\\u0123\": \"g\",\n        \"\\u0124\": \"H\",\n        \"\\u0126\": \"H\",\n        \"\\u0125\": \"h\",\n        \"\\u0127\": \"h\",\n        \"\\u0128\": \"I\",\n        \"\\u012A\": \"I\",\n        \"\\u012C\": \"I\",\n        \"\\u012E\": \"I\",\n        \"\\u0130\": \"I\",\n        \"\\u0129\": \"i\",\n        \"\\u012B\": \"i\",\n        \"\\u012D\": \"i\",\n        \"\\u012F\": \"i\",\n        \"\\u0131\": \"i\",\n        \"\\u0134\": \"J\",\n        \"\\u0135\": \"j\",\n        \"\\u0136\": \"K\",\n        \"\\u0137\": \"k\",\n        \"\\u0138\": \"k\",\n        \"\\u0139\": \"L\",\n        \"\\u013B\": \"L\",\n        \"\\u013D\": \"L\",\n        \"\\u013F\": \"L\",\n        \"\\u0141\": \"L\",\n        \"\\u013A\": \"l\",\n        \"\\u013C\": \"l\",\n        \"\\u013E\": \"l\",\n        \"\\u0140\": \"l\",\n        \"\\u0142\": \"l\",\n        \"\\u0143\": \"N\",\n        \"\\u0145\": \"N\",\n        \"\\u0147\": \"N\",\n        \"\\u014A\": \"N\",\n        \"\\u0144\": \"n\",\n        \"\\u0146\": \"n\",\n        \"\\u0148\": \"n\",\n        \"\\u014B\": \"n\",\n        \"\\u014C\": \"O\",\n        \"\\u014E\": \"O\",\n        \"\\u0150\": \"O\",\n        \"\\u014D\": \"o\",\n        \"\\u014F\": \"o\",\n        \"\\u0151\": \"o\",\n        \"\\u0154\": \"R\",\n        \"\\u0156\": \"R\",\n        \"\\u0158\": \"R\",\n        \"\\u0155\": \"r\",\n        \"\\u0157\": \"r\",\n        \"\\u0159\": \"r\",\n        \"\\u015A\": \"S\",\n        \"\\u015C\": \"S\",\n        \"\\u015E\": \"S\",\n        \"\\u0160\": \"S\",\n        \"\\u015B\": \"s\",\n        \"\\u015D\": \"s\",\n        \"\\u015F\": \"s\",\n        \"\\u0161\": \"s\",\n        \"\\u0162\": \"T\",\n        \"\\u0164\": \"T\",\n        \"\\u0166\": \"T\",\n        \"\\u0163\": \"t\",\n        \"\\u0165\": \"t\",\n        \"\\u0167\": \"t\",\n        \"\\u0168\": \"U\",\n        \"\\u016A\": \"U\",\n        \"\\u016C\": \"U\",\n        \"\\u016E\": \"U\",\n        \"\\u0170\": \"U\",\n        \"\\u0172\": \"U\",\n        \"\\u0169\": \"u\",\n        \"\\u016B\": \"u\",\n        \"\\u016D\": \"u\",\n        \"\\u016F\": \"u\",\n        \"\\u0171\": \"u\",\n        \"\\u0173\": \"u\",\n        \"\\u0174\": \"W\",\n        \"\\u0175\": \"w\",\n        \"\\u0176\": \"Y\",\n        \"\\u0177\": \"y\",\n        \"\\u0178\": \"Y\",\n        \"\\u0179\": \"Z\",\n        \"\\u017B\": \"Z\",\n        \"\\u017D\": \"Z\",\n        \"\\u017A\": \"z\",\n        \"\\u017C\": \"z\",\n        \"\\u017E\": \"z\",\n        \"\\u0132\": \"IJ\",\n        \"\\u0133\": \"ij\",\n        \"\\u0152\": \"Oe\",\n        \"\\u0153\": \"oe\",\n        \"\\u0149\": \"'n\",\n        \"\\u017F\": \"s\"\n      };\n      var htmlEscapes = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n      };\n      var htmlUnescapes = {\n        \"&amp;\": \"&\",\n        \"&lt;\": \"<\",\n        \"&gt;\": \">\",\n        \"&quot;\": '\"',\n        \"&#39;\": \"'\"\n      };\n      var stringEscapes = {\n        \"\\\\\": \"\\\\\",\n        \"'\": \"'\",\n        \"\\n\": \"n\",\n        \"\\r\": \"r\",\n        \"\\u2028\": \"u2028\",\n        \"\\u2029\": \"u2029\"\n      };\n      var freeParseFloat = parseFloat, freeParseInt = parseInt;\n      var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n      var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n      var root = freeGlobal || freeSelf || Function(\"return this\")();\n      var freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n      var freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n      var moduleExports = freeModule && freeModule.exports === freeExports;\n      var freeProcess = moduleExports && freeGlobal.process;\n      var nodeUtil = function() {\n        try {\n          var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n          if (types) {\n            return types;\n          }\n          return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n        } catch (e) {\n        }\n      }();\n      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n      function apply(func, thisArg, args) {\n        switch (args.length) {\n          case 0:\n            return func.call(thisArg);\n          case 1:\n            return func.call(thisArg, args[0]);\n          case 2:\n            return func.call(thisArg, args[0], args[1]);\n          case 3:\n            return func.call(thisArg, args[0], args[1], args[2]);\n        }\n        return func.apply(thisArg, args);\n      }\n      function arrayAggregator(array, setter, iteratee, accumulator) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n          var value = array[index];\n          setter(accumulator, value, iteratee(value), array);\n        }\n        return accumulator;\n      }\n      function arrayEach(array, iteratee) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n          if (iteratee(array[index], index, array) === false) {\n            break;\n          }\n        }\n        return array;\n      }\n      function arrayEachRight(array, iteratee) {\n        var length = array == null ? 0 : array.length;\n        while (length--) {\n          if (iteratee(array[length], length, array) === false) {\n            break;\n          }\n        }\n        return array;\n      }\n      function arrayEvery(array, predicate) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n          if (!predicate(array[index], index, array)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      function arrayFilter(array, predicate) {\n        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n        while (++index < length) {\n          var value = array[index];\n          if (predicate(value, index, array)) {\n            result[resIndex++] = value;\n          }\n        }\n        return result;\n      }\n      function arrayIncludes(array, value) {\n        var length = array == null ? 0 : array.length;\n        return !!length && baseIndexOf(array, value, 0) > -1;\n      }\n      function arrayIncludesWith(array, value, comparator) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n          if (comparator(value, array[index])) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function arrayMap(array, iteratee) {\n        var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n        while (++index < length) {\n          result[index] = iteratee(array[index], index, array);\n        }\n        return result;\n      }\n      function arrayPush(array, values) {\n        var index = -1, length = values.length, offset = array.length;\n        while (++index < length) {\n          array[offset + index] = values[index];\n        }\n        return array;\n      }\n      function arrayReduce(array, iteratee, accumulator, initAccum) {\n        var index = -1, length = array == null ? 0 : array.length;\n        if (initAccum && length) {\n          accumulator = array[++index];\n        }\n        while (++index < length) {\n          accumulator = iteratee(accumulator, array[index], index, array);\n        }\n        return accumulator;\n      }\n      function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n        var length = array == null ? 0 : array.length;\n        if (initAccum && length) {\n          accumulator = array[--length];\n        }\n        while (length--) {\n          accumulator = iteratee(accumulator, array[length], length, array);\n        }\n        return accumulator;\n      }\n      function arraySome(array, predicate) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n          if (predicate(array[index], index, array)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      var asciiSize = baseProperty(\"length\");\n      function asciiToArray(string) {\n        return string.split(\"\");\n      }\n      function asciiWords(string) {\n        return string.match(reAsciiWord) || [];\n      }\n      function baseFindKey(collection, predicate, eachFunc) {\n        var result;\n        eachFunc(collection, function(value, key, collection2) {\n          if (predicate(value, key, collection2)) {\n            result = key;\n            return false;\n          }\n        });\n        return result;\n      }\n      function baseFindIndex(array, predicate, fromIndex, fromRight) {\n        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);\n        while (fromRight ? index-- : ++index < length) {\n          if (predicate(array[index], index, array)) {\n            return index;\n          }\n        }\n        return -1;\n      }\n      function baseIndexOf(array, value, fromIndex) {\n        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);\n      }\n      function baseIndexOfWith(array, value, fromIndex, comparator) {\n        var index = fromIndex - 1, length = array.length;\n        while (++index < length) {\n          if (comparator(array[index], value)) {\n            return index;\n          }\n        }\n        return -1;\n      }\n      function baseIsNaN(value) {\n        return value !== value;\n      }\n      function baseMean(array, iteratee) {\n        var length = array == null ? 0 : array.length;\n        return length ? baseSum(array, iteratee) / length : NAN;\n      }\n      function baseProperty(key) {\n        return function(object) {\n          return object == null ? undefined2 : object[key];\n        };\n      }\n      function basePropertyOf(object) {\n        return function(key) {\n          return object == null ? undefined2 : object[key];\n        };\n      }\n      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n        eachFunc(collection, function(value, index, collection2) {\n          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);\n        });\n        return accumulator;\n      }\n      function baseSortBy(array, comparer) {\n        var length = array.length;\n        array.sort(comparer);\n        while (length--) {\n          array[length] = array[length].value;\n        }\n        return array;\n      }\n      function baseSum(array, iteratee) {\n        var result, index = -1, length = array.length;\n        while (++index < length) {\n          var current = iteratee(array[index]);\n          if (current !== undefined2) {\n            result = result === undefined2 ? current : result + current;\n          }\n        }\n        return result;\n      }\n      function baseTimes(n, iteratee) {\n        var index = -1, result = Array(n);\n        while (++index < n) {\n          result[index] = iteratee(index);\n        }\n        return result;\n      }\n      function baseToPairs(object, props) {\n        return arrayMap(props, function(key) {\n          return [key, object[key]];\n        });\n      }\n      function baseTrim(string) {\n        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n      }\n      function baseUnary(func) {\n        return function(value) {\n          return func(value);\n        };\n      }\n      function baseValues(object, props) {\n        return arrayMap(props, function(key) {\n          return object[key];\n        });\n      }\n      function cacheHas(cache, key) {\n        return cache.has(key);\n      }\n      function charsStartIndex(strSymbols, chrSymbols) {\n        var index = -1, length = strSymbols.length;\n        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {\n        }\n        return index;\n      }\n      function charsEndIndex(strSymbols, chrSymbols) {\n        var index = strSymbols.length;\n        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {\n        }\n        return index;\n      }\n      function countHolders(array, placeholder) {\n        var length = array.length, result = 0;\n        while (length--) {\n          if (array[length] === placeholder) {\n            ++result;\n          }\n        }\n        return result;\n      }\n      var deburrLetter = basePropertyOf(deburredLetters);\n      var escapeHtmlChar = basePropertyOf(htmlEscapes);\n      function escapeStringChar(chr) {\n        return \"\\\\\" + stringEscapes[chr];\n      }\n      function getValue(object, key) {\n        return object == null ? undefined2 : object[key];\n      }\n      function hasUnicode(string) {\n        return reHasUnicode.test(string);\n      }\n      function hasUnicodeWord(string) {\n        return reHasUnicodeWord.test(string);\n      }\n      function iteratorToArray(iterator) {\n        var data, result = [];\n        while (!(data = iterator.next()).done) {\n          result.push(data.value);\n        }\n        return result;\n      }\n      function mapToArray(map) {\n        var index = -1, result = Array(map.size);\n        map.forEach(function(value, key) {\n          result[++index] = [key, value];\n        });\n        return result;\n      }\n      function overArg(func, transform) {\n        return function(arg) {\n          return func(transform(arg));\n        };\n      }\n      function replaceHolders(array, placeholder) {\n        var index = -1, length = array.length, resIndex = 0, result = [];\n        while (++index < length) {\n          var value = array[index];\n          if (value === placeholder || value === PLACEHOLDER) {\n            array[index] = PLACEHOLDER;\n            result[resIndex++] = index;\n          }\n        }\n        return result;\n      }\n      function setToArray(set) {\n        var index = -1, result = Array(set.size);\n        set.forEach(function(value) {\n          result[++index] = value;\n        });\n        return result;\n      }\n      function setToPairs(set) {\n        var index = -1, result = Array(set.size);\n        set.forEach(function(value) {\n          result[++index] = [value, value];\n        });\n        return result;\n      }\n      function strictIndexOf(array, value, fromIndex) {\n        var index = fromIndex - 1, length = array.length;\n        while (++index < length) {\n          if (array[index] === value) {\n            return index;\n          }\n        }\n        return -1;\n      }\n      function strictLastIndexOf(array, value, fromIndex) {\n        var index = fromIndex + 1;\n        while (index--) {\n          if (array[index] === value) {\n            return index;\n          }\n        }\n        return index;\n      }\n      function stringSize(string) {\n        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);\n      }\n      function stringToArray(string) {\n        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n      }\n      function trimmedEndIndex(string) {\n        var index = string.length;\n        while (index-- && reWhitespace.test(string.charAt(index))) {\n        }\n        return index;\n      }\n      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n      function unicodeSize(string) {\n        var result = reUnicode.lastIndex = 0;\n        while (reUnicode.test(string)) {\n          ++result;\n        }\n        return result;\n      }\n      function unicodeToArray(string) {\n        return string.match(reUnicode) || [];\n      }\n      function unicodeWords(string) {\n        return string.match(reUnicodeWord) || [];\n      }\n      var runInContext = function runInContext2(context) {\n        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;\n        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;\n        var coreJsData = context[\"__core-js_shared__\"];\n        var funcToString = funcProto.toString;\n        var hasOwnProperty = objectProto.hasOwnProperty;\n        var idCounter = 0;\n        var maskSrcKey = function() {\n          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n          return uid ? \"Symbol(src)_1.\" + uid : \"\";\n        }();\n        var nativeObjectToString = objectProto.toString;\n        var objectCtorString = funcToString.call(Object2);\n        var oldDash = root._;\n        var reIsNative = RegExp2(\n          \"^\" + funcToString.call(hasOwnProperty).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n        );\n        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;\n        var defineProperty = function() {\n          try {\n            var func = getNative(Object2, \"defineProperty\");\n            func({}, \"\", {});\n            return func;\n          } catch (e) {\n          }\n        }();\n        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;\n        var DataView = getNative(context, \"DataView\"), Map2 = getNative(context, \"Map\"), Promise2 = getNative(context, \"Promise\"), Set2 = getNative(context, \"Set\"), WeakMap2 = getNative(context, \"WeakMap\"), nativeCreate = getNative(Object2, \"create\");\n        var metaMap = WeakMap2 && new WeakMap2();\n        var realNames = {};\n        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);\n        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;\n        function lodash(value) {\n          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n            if (value instanceof LodashWrapper) {\n              return value;\n            }\n            if (hasOwnProperty.call(value, \"__wrapped__\")) {\n              return wrapperClone(value);\n            }\n          }\n          return new LodashWrapper(value);\n        }\n        var baseCreate = function() {\n          function object() {\n          }\n          return function(proto) {\n            if (!isObject(proto)) {\n              return {};\n            }\n            if (objectCreate) {\n              return objectCreate(proto);\n            }\n            object.prototype = proto;\n            var result2 = new object();\n            object.prototype = undefined2;\n            return result2;\n          };\n        }();\n        function baseLodash() {\n        }\n        function LodashWrapper(value, chainAll) {\n          this.__wrapped__ = value;\n          this.__actions__ = [];\n          this.__chain__ = !!chainAll;\n          this.__index__ = 0;\n          this.__values__ = undefined2;\n        }\n        lodash.templateSettings = {\n          /**\n           * Used to detect `data` property values to be HTML-escaped.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */\n          \"escape\": reEscape,\n          /**\n           * Used to detect code to be evaluated.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */\n          \"evaluate\": reEvaluate,\n          /**\n           * Used to detect `data` property values to inject.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */\n          \"interpolate\": reInterpolate,\n          /**\n           * Used to reference the data object in the template text.\n           *\n           * @memberOf _.templateSettings\n           * @type {string}\n           */\n          \"variable\": \"\",\n          /**\n           * Used to import variables into the compiled template.\n           *\n           * @memberOf _.templateSettings\n           * @type {Object}\n           */\n          \"imports\": {\n            /**\n             * A reference to the `lodash` function.\n             *\n             * @memberOf _.templateSettings.imports\n             * @type {Function}\n             */\n            \"_\": lodash\n          }\n        };\n        lodash.prototype = baseLodash.prototype;\n        lodash.prototype.constructor = lodash;\n        LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n        LodashWrapper.prototype.constructor = LodashWrapper;\n        function LazyWrapper(value) {\n          this.__wrapped__ = value;\n          this.__actions__ = [];\n          this.__dir__ = 1;\n          this.__filtered__ = false;\n          this.__iteratees__ = [];\n          this.__takeCount__ = MAX_ARRAY_LENGTH;\n          this.__views__ = [];\n        }\n        function lazyClone() {\n          var result2 = new LazyWrapper(this.__wrapped__);\n          result2.__actions__ = copyArray(this.__actions__);\n          result2.__dir__ = this.__dir__;\n          result2.__filtered__ = this.__filtered__;\n          result2.__iteratees__ = copyArray(this.__iteratees__);\n          result2.__takeCount__ = this.__takeCount__;\n          result2.__views__ = copyArray(this.__views__);\n          return result2;\n        }\n        function lazyReverse() {\n          if (this.__filtered__) {\n            var result2 = new LazyWrapper(this);\n            result2.__dir__ = -1;\n            result2.__filtered__ = true;\n          } else {\n            result2 = this.clone();\n            result2.__dir__ *= -1;\n          }\n          return result2;\n        }\n        function lazyValue() {\n          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);\n          if (!isArr || !isRight && arrLength == length && takeCount == length) {\n            return baseWrapperValue(array, this.__actions__);\n          }\n          var result2 = [];\n          outer:\n            while (length-- && resIndex < takeCount) {\n              index += dir;\n              var iterIndex = -1, value = array[index];\n              while (++iterIndex < iterLength) {\n                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);\n                if (type == LAZY_MAP_FLAG) {\n                  value = computed;\n                } else if (!computed) {\n                  if (type == LAZY_FILTER_FLAG) {\n                    continue outer;\n                  } else {\n                    break outer;\n                  }\n                }\n              }\n              result2[resIndex++] = value;\n            }\n          return result2;\n        }\n        LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n        LazyWrapper.prototype.constructor = LazyWrapper;\n        function Hash(entries) {\n          var index = -1, length = entries == null ? 0 : entries.length;\n          this.clear();\n          while (++index < length) {\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n          }\n        }\n        function hashClear() {\n          this.__data__ = nativeCreate ? nativeCreate(null) : {};\n          this.size = 0;\n        }\n        function hashDelete(key) {\n          var result2 = this.has(key) && delete this.__data__[key];\n          this.size -= result2 ? 1 : 0;\n          return result2;\n        }\n        function hashGet(key) {\n          var data = this.__data__;\n          if (nativeCreate) {\n            var result2 = data[key];\n            return result2 === HASH_UNDEFINED ? undefined2 : result2;\n          }\n          return hasOwnProperty.call(data, key) ? data[key] : undefined2;\n        }\n        function hashHas(key) {\n          var data = this.__data__;\n          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);\n        }\n        function hashSet(key, value) {\n          var data = this.__data__;\n          this.size += this.has(key) ? 0 : 1;\n          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;\n          return this;\n        }\n        Hash.prototype.clear = hashClear;\n        Hash.prototype[\"delete\"] = hashDelete;\n        Hash.prototype.get = hashGet;\n        Hash.prototype.has = hashHas;\n        Hash.prototype.set = hashSet;\n        function ListCache(entries) {\n          var index = -1, length = entries == null ? 0 : entries.length;\n          this.clear();\n          while (++index < length) {\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n          }\n        }\n        function listCacheClear() {\n          this.__data__ = [];\n          this.size = 0;\n        }\n        function listCacheDelete(key) {\n          var data = this.__data__, index = assocIndexOf(data, key);\n          if (index < 0) {\n            return false;\n          }\n          var lastIndex = data.length - 1;\n          if (index == lastIndex) {\n            data.pop();\n          } else {\n            splice.call(data, index, 1);\n          }\n          --this.size;\n          return true;\n        }\n        function listCacheGet(key) {\n          var data = this.__data__, index = assocIndexOf(data, key);\n          return index < 0 ? undefined2 : data[index][1];\n        }\n        function listCacheHas(key) {\n          return assocIndexOf(this.__data__, key) > -1;\n        }\n        function listCacheSet(key, value) {\n          var data = this.__data__, index = assocIndexOf(data, key);\n          if (index < 0) {\n            ++this.size;\n            data.push([key, value]);\n          } else {\n            data[index][1] = value;\n          }\n          return this;\n        }\n        ListCache.prototype.clear = listCacheClear;\n        ListCache.prototype[\"delete\"] = listCacheDelete;\n        ListCache.prototype.get = listCacheGet;\n        ListCache.prototype.has = listCacheHas;\n        ListCache.prototype.set = listCacheSet;\n        function MapCache(entries) {\n          var index = -1, length = entries == null ? 0 : entries.length;\n          this.clear();\n          while (++index < length) {\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n          }\n        }\n        function mapCacheClear() {\n          this.size = 0;\n          this.__data__ = {\n            \"hash\": new Hash(),\n            \"map\": new (Map2 || ListCache)(),\n            \"string\": new Hash()\n          };\n        }\n        function mapCacheDelete(key) {\n          var result2 = getMapData(this, key)[\"delete\"](key);\n          this.size -= result2 ? 1 : 0;\n          return result2;\n        }\n        function mapCacheGet(key) {\n          return getMapData(this, key).get(key);\n        }\n        function mapCacheHas(key) {\n          return getMapData(this, key).has(key);\n        }\n        function mapCacheSet(key, value) {\n          var data = getMapData(this, key), size2 = data.size;\n          data.set(key, value);\n          this.size += data.size == size2 ? 0 : 1;\n          return this;\n        }\n        MapCache.prototype.clear = mapCacheClear;\n        MapCache.prototype[\"delete\"] = mapCacheDelete;\n        MapCache.prototype.get = mapCacheGet;\n        MapCache.prototype.has = mapCacheHas;\n        MapCache.prototype.set = mapCacheSet;\n        function SetCache(values2) {\n          var index = -1, length = values2 == null ? 0 : values2.length;\n          this.__data__ = new MapCache();\n          while (++index < length) {\n            this.add(values2[index]);\n          }\n        }\n        function setCacheAdd(value) {\n          this.__data__.set(value, HASH_UNDEFINED);\n          return this;\n        }\n        function setCacheHas(value) {\n          return this.__data__.has(value);\n        }\n        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n        SetCache.prototype.has = setCacheHas;\n        function Stack(entries) {\n          var data = this.__data__ = new ListCache(entries);\n          this.size = data.size;\n        }\n        function stackClear() {\n          this.__data__ = new ListCache();\n          this.size = 0;\n        }\n        function stackDelete(key) {\n          var data = this.__data__, result2 = data[\"delete\"](key);\n          this.size = data.size;\n          return result2;\n        }\n        function stackGet(key) {\n          return this.__data__.get(key);\n        }\n        function stackHas(key) {\n          return this.__data__.has(key);\n        }\n        function stackSet(key, value) {\n          var data = this.__data__;\n          if (data instanceof ListCache) {\n            var pairs = data.__data__;\n            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n              pairs.push([key, value]);\n              this.size = ++data.size;\n              return this;\n            }\n            data = this.__data__ = new MapCache(pairs);\n          }\n          data.set(key, value);\n          this.size = data.size;\n          return this;\n        }\n        Stack.prototype.clear = stackClear;\n        Stack.prototype[\"delete\"] = stackDelete;\n        Stack.prototype.get = stackGet;\n        Stack.prototype.has = stackHas;\n        Stack.prototype.set = stackSet;\n        function arrayLikeKeys(value, inherited) {\n          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;\n          for (var key in value) {\n            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n            (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n            isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n            isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n            isIndex(key, length)))) {\n              result2.push(key);\n            }\n          }\n          return result2;\n        }\n        function arraySample(array) {\n          var length = array.length;\n          return length ? array[baseRandom(0, length - 1)] : undefined2;\n        }\n        function arraySampleSize(array, n) {\n          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n        }\n        function arrayShuffle(array) {\n          return shuffleSelf(copyArray(array));\n        }\n        function assignMergeValue(object, key, value) {\n          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {\n            baseAssignValue(object, key, value);\n          }\n        }\n        function assignValue(object, key, value) {\n          var objValue = object[key];\n          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {\n            baseAssignValue(object, key, value);\n          }\n        }\n        function assocIndexOf(array, key) {\n          var length = array.length;\n          while (length--) {\n            if (eq(array[length][0], key)) {\n              return length;\n            }\n          }\n          return -1;\n        }\n        function baseAggregator(collection, setter, iteratee2, accumulator) {\n          baseEach(collection, function(value, key, collection2) {\n            setter(accumulator, value, iteratee2(value), collection2);\n          });\n          return accumulator;\n        }\n        function baseAssign(object, source) {\n          return object && copyObject(source, keys(source), object);\n        }\n        function baseAssignIn(object, source) {\n          return object && copyObject(source, keysIn(source), object);\n        }\n        function baseAssignValue(object, key, value) {\n          if (key == \"__proto__\" && defineProperty) {\n            defineProperty(object, key, {\n              \"configurable\": true,\n              \"enumerable\": true,\n              \"value\": value,\n              \"writable\": true\n            });\n          } else {\n            object[key] = value;\n          }\n        }\n        function baseAt(object, paths) {\n          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;\n          while (++index < length) {\n            result2[index] = skip ? undefined2 : get(object, paths[index]);\n          }\n          return result2;\n        }\n        function baseClamp(number, lower, upper) {\n          if (number === number) {\n            if (upper !== undefined2) {\n              number = number <= upper ? number : upper;\n            }\n            if (lower !== undefined2) {\n              number = number >= lower ? number : lower;\n            }\n          }\n          return number;\n        }\n        function baseClone(value, bitmask, customizer, key, object, stack) {\n          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;\n          if (customizer) {\n            result2 = object ? customizer(value, key, object, stack) : customizer(value);\n          }\n          if (result2 !== undefined2) {\n            return result2;\n          }\n          if (!isObject(value)) {\n            return value;\n          }\n          var isArr = isArray(value);\n          if (isArr) {\n            result2 = initCloneArray(value);\n            if (!isDeep) {\n              return copyArray(value, result2);\n            }\n          } else {\n            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;\n            if (isBuffer(value)) {\n              return cloneBuffer(value, isDeep);\n            }\n            if (tag == objectTag || tag == argsTag || isFunc && !object) {\n              result2 = isFlat || isFunc ? {} : initCloneObject(value);\n              if (!isDeep) {\n                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));\n              }\n            } else {\n              if (!cloneableTags[tag]) {\n                return object ? value : {};\n              }\n              result2 = initCloneByTag(value, tag, isDeep);\n            }\n          }\n          stack || (stack = new Stack());\n          var stacked = stack.get(value);\n          if (stacked) {\n            return stacked;\n          }\n          stack.set(value, result2);\n          if (isSet(value)) {\n            value.forEach(function(subValue) {\n              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n            });\n          } else if (isMap(value)) {\n            value.forEach(function(subValue, key2) {\n              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n            });\n          }\n          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;\n          var props = isArr ? undefined2 : keysFunc(value);\n          arrayEach(props || value, function(subValue, key2) {\n            if (props) {\n              key2 = subValue;\n              subValue = value[key2];\n            }\n            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n          });\n          return result2;\n        }\n        function baseConforms(source) {\n          var props = keys(source);\n          return function(object) {\n            return baseConformsTo(object, source, props);\n          };\n        }\n        function baseConformsTo(object, source, props) {\n          var length = props.length;\n          if (object == null) {\n            return !length;\n          }\n          object = Object2(object);\n          while (length--) {\n            var key = props[length], predicate = source[key], value = object[key];\n            if (value === undefined2 && !(key in object) || !predicate(value)) {\n              return false;\n            }\n          }\n          return true;\n        }\n        function baseDelay(func, wait, args) {\n          if (typeof func != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          return setTimeout(function() {\n            func.apply(undefined2, args);\n          }, wait);\n        }\n        function baseDifference(array, values2, iteratee2, comparator) {\n          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;\n          if (!length) {\n            return result2;\n          }\n          if (iteratee2) {\n            values2 = arrayMap(values2, baseUnary(iteratee2));\n          }\n          if (comparator) {\n            includes2 = arrayIncludesWith;\n            isCommon = false;\n          } else if (values2.length >= LARGE_ARRAY_SIZE) {\n            includes2 = cacheHas;\n            isCommon = false;\n            values2 = new SetCache(values2);\n          }\n          outer:\n            while (++index < length) {\n              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);\n              value = comparator || value !== 0 ? value : 0;\n              if (isCommon && computed === computed) {\n                var valuesIndex = valuesLength;\n                while (valuesIndex--) {\n                  if (values2[valuesIndex] === computed) {\n                    continue outer;\n                  }\n                }\n                result2.push(value);\n              } else if (!includes2(values2, computed, comparator)) {\n                result2.push(value);\n              }\n            }\n          return result2;\n        }\n        var baseEach = createBaseEach(baseForOwn);\n        var baseEachRight = createBaseEach(baseForOwnRight, true);\n        function baseEvery(collection, predicate) {\n          var result2 = true;\n          baseEach(collection, function(value, index, collection2) {\n            result2 = !!predicate(value, index, collection2);\n            return result2;\n          });\n          return result2;\n        }\n        function baseExtremum(array, iteratee2, comparator) {\n          var index = -1, length = array.length;\n          while (++index < length) {\n            var value = array[index], current = iteratee2(value);\n            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {\n              var computed = current, result2 = value;\n            }\n          }\n          return result2;\n        }\n        function baseFill(array, value, start, end) {\n          var length = array.length;\n          start = toInteger(start);\n          if (start < 0) {\n            start = -start > length ? 0 : length + start;\n          }\n          end = end === undefined2 || end > length ? length : toInteger(end);\n          if (end < 0) {\n            end += length;\n          }\n          end = start > end ? 0 : toLength(end);\n          while (start < end) {\n            array[start++] = value;\n          }\n          return array;\n        }\n        function baseFilter(collection, predicate) {\n          var result2 = [];\n          baseEach(collection, function(value, index, collection2) {\n            if (predicate(value, index, collection2)) {\n              result2.push(value);\n            }\n          });\n          return result2;\n        }\n        function baseFlatten(array, depth, predicate, isStrict, result2) {\n          var index = -1, length = array.length;\n          predicate || (predicate = isFlattenable);\n          result2 || (result2 = []);\n          while (++index < length) {\n            var value = array[index];\n            if (depth > 0 && predicate(value)) {\n              if (depth > 1) {\n                baseFlatten(value, depth - 1, predicate, isStrict, result2);\n              } else {\n                arrayPush(result2, value);\n              }\n            } else if (!isStrict) {\n              result2[result2.length] = value;\n            }\n          }\n          return result2;\n        }\n        var baseFor = createBaseFor();\n        var baseForRight = createBaseFor(true);\n        function baseForOwn(object, iteratee2) {\n          return object && baseFor(object, iteratee2, keys);\n        }\n        function baseForOwnRight(object, iteratee2) {\n          return object && baseForRight(object, iteratee2, keys);\n        }\n        function baseFunctions(object, props) {\n          return arrayFilter(props, function(key) {\n            return isFunction(object[key]);\n          });\n        }\n        function baseGet(object, path) {\n          path = castPath(path, object);\n          var index = 0, length = path.length;\n          while (object != null && index < length) {\n            object = object[toKey(path[index++])];\n          }\n          return index && index == length ? object : undefined2;\n        }\n        function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n          var result2 = keysFunc(object);\n          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));\n        }\n        function baseGetTag(value) {\n          if (value == null) {\n            return value === undefined2 ? undefinedTag : nullTag;\n          }\n          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);\n        }\n        function baseGt(value, other) {\n          return value > other;\n        }\n        function baseHas(object, key) {\n          return object != null && hasOwnProperty.call(object, key);\n        }\n        function baseHasIn(object, key) {\n          return object != null && key in Object2(object);\n        }\n        function baseInRange(number, start, end) {\n          return number >= nativeMin(start, end) && number < nativeMax(start, end);\n        }\n        function baseIntersection(arrays, iteratee2, comparator) {\n          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];\n          while (othIndex--) {\n            var array = arrays[othIndex];\n            if (othIndex && iteratee2) {\n              array = arrayMap(array, baseUnary(iteratee2));\n            }\n            maxLength = nativeMin(array.length, maxLength);\n            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;\n          }\n          array = arrays[0];\n          var index = -1, seen = caches[0];\n          outer:\n            while (++index < length && result2.length < maxLength) {\n              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n              value = comparator || value !== 0 ? value : 0;\n              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {\n                othIndex = othLength;\n                while (--othIndex) {\n                  var cache = caches[othIndex];\n                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {\n                    continue outer;\n                  }\n                }\n                if (seen) {\n                  seen.push(computed);\n                }\n                result2.push(value);\n              }\n            }\n          return result2;\n        }\n        function baseInverter(object, setter, iteratee2, accumulator) {\n          baseForOwn(object, function(value, key, object2) {\n            setter(accumulator, iteratee2(value), key, object2);\n          });\n          return accumulator;\n        }\n        function baseInvoke(object, path, args) {\n          path = castPath(path, object);\n          object = parent(object, path);\n          var func = object == null ? object : object[toKey(last(path))];\n          return func == null ? undefined2 : apply(func, object, args);\n        }\n        function baseIsArguments(value) {\n          return isObjectLike(value) && baseGetTag(value) == argsTag;\n        }\n        function baseIsArrayBuffer(value) {\n          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n        }\n        function baseIsDate(value) {\n          return isObjectLike(value) && baseGetTag(value) == dateTag;\n        }\n        function baseIsEqual(value, other, bitmask, customizer, stack) {\n          if (value === other) {\n            return true;\n          }\n          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n            return value !== value && other !== other;\n          }\n          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n        }\n        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);\n          objTag = objTag == argsTag ? objectTag : objTag;\n          othTag = othTag == argsTag ? objectTag : othTag;\n          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;\n          if (isSameTag && isBuffer(object)) {\n            if (!isBuffer(other)) {\n              return false;\n            }\n            objIsArr = true;\n            objIsObj = false;\n          }\n          if (isSameTag && !objIsObj) {\n            stack || (stack = new Stack());\n            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n          }\n          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n            var objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n            if (objIsWrapped || othIsWrapped) {\n              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n              stack || (stack = new Stack());\n              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n            }\n          }\n          if (!isSameTag) {\n            return false;\n          }\n          stack || (stack = new Stack());\n          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n        }\n        function baseIsMap(value) {\n          return isObjectLike(value) && getTag(value) == mapTag;\n        }\n        function baseIsMatch(object, source, matchData, customizer) {\n          var index = matchData.length, length = index, noCustomizer = !customizer;\n          if (object == null) {\n            return !length;\n          }\n          object = Object2(object);\n          while (index--) {\n            var data = matchData[index];\n            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n              return false;\n            }\n          }\n          while (++index < length) {\n            data = matchData[index];\n            var key = data[0], objValue = object[key], srcValue = data[1];\n            if (noCustomizer && data[2]) {\n              if (objValue === undefined2 && !(key in object)) {\n                return false;\n              }\n            } else {\n              var stack = new Stack();\n              if (customizer) {\n                var result2 = customizer(objValue, srcValue, key, object, source, stack);\n              }\n              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {\n                return false;\n              }\n            }\n          }\n          return true;\n        }\n        function baseIsNative(value) {\n          if (!isObject(value) || isMasked(value)) {\n            return false;\n          }\n          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n          return pattern.test(toSource(value));\n        }\n        function baseIsRegExp(value) {\n          return isObjectLike(value) && baseGetTag(value) == regexpTag;\n        }\n        function baseIsSet(value) {\n          return isObjectLike(value) && getTag(value) == setTag;\n        }\n        function baseIsTypedArray(value) {\n          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n        }\n        function baseIteratee(value) {\n          if (typeof value == \"function\") {\n            return value;\n          }\n          if (value == null) {\n            return identity;\n          }\n          if (typeof value == \"object\") {\n            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n          }\n          return property(value);\n        }\n        function baseKeys(object) {\n          if (!isPrototype(object)) {\n            return nativeKeys(object);\n          }\n          var result2 = [];\n          for (var key in Object2(object)) {\n            if (hasOwnProperty.call(object, key) && key != \"constructor\") {\n              result2.push(key);\n            }\n          }\n          return result2;\n        }\n        function baseKeysIn(object) {\n          if (!isObject(object)) {\n            return nativeKeysIn(object);\n          }\n          var isProto = isPrototype(object), result2 = [];\n          for (var key in object) {\n            if (!(key == \"constructor\" && (isProto || !hasOwnProperty.call(object, key)))) {\n              result2.push(key);\n            }\n          }\n          return result2;\n        }\n        function baseLt(value, other) {\n          return value < other;\n        }\n        function baseMap(collection, iteratee2) {\n          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];\n          baseEach(collection, function(value, key, collection2) {\n            result2[++index] = iteratee2(value, key, collection2);\n          });\n          return result2;\n        }\n        function baseMatches(source) {\n          var matchData = getMatchData(source);\n          if (matchData.length == 1 && matchData[0][2]) {\n            return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n          }\n          return function(object) {\n            return object === source || baseIsMatch(object, source, matchData);\n          };\n        }\n        function baseMatchesProperty(path, srcValue) {\n          if (isKey(path) && isStrictComparable(srcValue)) {\n            return matchesStrictComparable(toKey(path), srcValue);\n          }\n          return function(object) {\n            var objValue = get(object, path);\n            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n          };\n        }\n        function baseMerge(object, source, srcIndex, customizer, stack) {\n          if (object === source) {\n            return;\n          }\n          baseFor(source, function(srcValue, key) {\n            stack || (stack = new Stack());\n            if (isObject(srcValue)) {\n              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n            } else {\n              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + \"\", object, source, stack) : undefined2;\n              if (newValue === undefined2) {\n                newValue = srcValue;\n              }\n              assignMergeValue(object, key, newValue);\n            }\n          }, keysIn);\n        }\n        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);\n          if (stacked) {\n            assignMergeValue(object, key, stacked);\n            return;\n          }\n          var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : undefined2;\n          var isCommon = newValue === undefined2;\n          if (isCommon) {\n            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n            newValue = srcValue;\n            if (isArr || isBuff || isTyped) {\n              if (isArray(objValue)) {\n                newValue = objValue;\n              } else if (isArrayLikeObject(objValue)) {\n                newValue = copyArray(objValue);\n              } else if (isBuff) {\n                isCommon = false;\n                newValue = cloneBuffer(srcValue, true);\n              } else if (isTyped) {\n                isCommon = false;\n                newValue = cloneTypedArray(srcValue, true);\n              } else {\n                newValue = [];\n              }\n            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n              newValue = objValue;\n              if (isArguments(objValue)) {\n                newValue = toPlainObject(objValue);\n              } else if (!isObject(objValue) || isFunction(objValue)) {\n                newValue = initCloneObject(srcValue);\n              }\n            } else {\n              isCommon = false;\n            }\n          }\n          if (isCommon) {\n            stack.set(srcValue, newValue);\n            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n            stack[\"delete\"](srcValue);\n          }\n          assignMergeValue(object, key, newValue);\n        }\n        function baseNth(array, n) {\n          var length = array.length;\n          if (!length) {\n            return;\n          }\n          n += n < 0 ? length : 0;\n          return isIndex(n, length) ? array[n] : undefined2;\n        }\n        function baseOrderBy(collection, iteratees, orders) {\n          if (iteratees.length) {\n            iteratees = arrayMap(iteratees, function(iteratee2) {\n              if (isArray(iteratee2)) {\n                return function(value) {\n                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);\n                };\n              }\n              return iteratee2;\n            });\n          } else {\n            iteratees = [identity];\n          }\n          var index = -1;\n          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n          var result2 = baseMap(collection, function(value, key, collection2) {\n            var criteria = arrayMap(iteratees, function(iteratee2) {\n              return iteratee2(value);\n            });\n            return { \"criteria\": criteria, \"index\": ++index, \"value\": value };\n          });\n          return baseSortBy(result2, function(object, other) {\n            return compareMultiple(object, other, orders);\n          });\n        }\n        function basePick(object, paths) {\n          return basePickBy(object, paths, function(value, path) {\n            return hasIn(object, path);\n          });\n        }\n        function basePickBy(object, paths, predicate) {\n          var index = -1, length = paths.length, result2 = {};\n          while (++index < length) {\n            var path = paths[index], value = baseGet(object, path);\n            if (predicate(value, path)) {\n              baseSet(result2, castPath(path, object), value);\n            }\n          }\n          return result2;\n        }\n        function basePropertyDeep(path) {\n          return function(object) {\n            return baseGet(object, path);\n          };\n        }\n        function basePullAll(array, values2, iteratee2, comparator) {\n          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;\n          if (array === values2) {\n            values2 = copyArray(values2);\n          }\n          if (iteratee2) {\n            seen = arrayMap(array, baseUnary(iteratee2));\n          }\n          while (++index < length) {\n            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;\n            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {\n              if (seen !== array) {\n                splice.call(seen, fromIndex, 1);\n              }\n              splice.call(array, fromIndex, 1);\n            }\n          }\n          return array;\n        }\n        function basePullAt(array, indexes) {\n          var length = array ? indexes.length : 0, lastIndex = length - 1;\n          while (length--) {\n            var index = indexes[length];\n            if (length == lastIndex || index !== previous) {\n              var previous = index;\n              if (isIndex(index)) {\n                splice.call(array, index, 1);\n              } else {\n                baseUnset(array, index);\n              }\n            }\n          }\n          return array;\n        }\n        function baseRandom(lower, upper) {\n          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n        }\n        function baseRange(start, end, step, fromRight) {\n          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);\n          while (length--) {\n            result2[fromRight ? length : ++index] = start;\n            start += step;\n          }\n          return result2;\n        }\n        function baseRepeat(string, n) {\n          var result2 = \"\";\n          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n            return result2;\n          }\n          do {\n            if (n % 2) {\n              result2 += string;\n            }\n            n = nativeFloor(n / 2);\n            if (n) {\n              string += string;\n            }\n          } while (n);\n          return result2;\n        }\n        function baseRest(func, start) {\n          return setToString(overRest(func, start, identity), func + \"\");\n        }\n        function baseSample(collection) {\n          return arraySample(values(collection));\n        }\n        function baseSampleSize(collection, n) {\n          var array = values(collection);\n          return shuffleSelf(array, baseClamp(n, 0, array.length));\n        }\n        function baseSet(object, path, value, customizer) {\n          if (!isObject(object)) {\n            return object;\n          }\n          path = castPath(path, object);\n          var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n          while (nested != null && ++index < length) {\n            var key = toKey(path[index]), newValue = value;\n            if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n              return object;\n            }\n            if (index != lastIndex) {\n              var objValue = nested[key];\n              newValue = customizer ? customizer(objValue, key, nested) : undefined2;\n              if (newValue === undefined2) {\n                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n              }\n            }\n            assignValue(nested, key, newValue);\n            nested = nested[key];\n          }\n          return object;\n        }\n        var baseSetData = !metaMap ? identity : function(func, data) {\n          metaMap.set(func, data);\n          return func;\n        };\n        var baseSetToString = !defineProperty ? identity : function(func, string) {\n          return defineProperty(func, \"toString\", {\n            \"configurable\": true,\n            \"enumerable\": false,\n            \"value\": constant(string),\n            \"writable\": true\n          });\n        };\n        function baseShuffle(collection) {\n          return shuffleSelf(values(collection));\n        }\n        function baseSlice(array, start, end) {\n          var index = -1, length = array.length;\n          if (start < 0) {\n            start = -start > length ? 0 : length + start;\n          }\n          end = end > length ? length : end;\n          if (end < 0) {\n            end += length;\n          }\n          length = start > end ? 0 : end - start >>> 0;\n          start >>>= 0;\n          var result2 = Array2(length);\n          while (++index < length) {\n            result2[index] = array[index + start];\n          }\n          return result2;\n        }\n        function baseSome(collection, predicate) {\n          var result2;\n          baseEach(collection, function(value, index, collection2) {\n            result2 = predicate(value, index, collection2);\n            return !result2;\n          });\n          return !!result2;\n        }\n        function baseSortedIndex(array, value, retHighest) {\n          var low = 0, high = array == null ? low : array.length;\n          if (typeof value == \"number\" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n            while (low < high) {\n              var mid = low + high >>> 1, computed = array[mid];\n              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {\n                low = mid + 1;\n              } else {\n                high = mid;\n              }\n            }\n            return high;\n          }\n          return baseSortedIndexBy(array, value, identity, retHighest);\n        }\n        function baseSortedIndexBy(array, value, iteratee2, retHighest) {\n          var low = 0, high = array == null ? 0 : array.length;\n          if (high === 0) {\n            return 0;\n          }\n          value = iteratee2(value);\n          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;\n          while (low < high) {\n            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);\n            if (valIsNaN) {\n              var setLow = retHighest || othIsReflexive;\n            } else if (valIsUndefined) {\n              setLow = othIsReflexive && (retHighest || othIsDefined);\n            } else if (valIsNull) {\n              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n            } else if (valIsSymbol) {\n              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n            } else if (othIsNull || othIsSymbol) {\n              setLow = false;\n            } else {\n              setLow = retHighest ? computed <= value : computed < value;\n            }\n            if (setLow) {\n              low = mid + 1;\n            } else {\n              high = mid;\n            }\n          }\n          return nativeMin(high, MAX_ARRAY_INDEX);\n        }\n        function baseSortedUniq(array, iteratee2) {\n          var index = -1, length = array.length, resIndex = 0, result2 = [];\n          while (++index < length) {\n            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n            if (!index || !eq(computed, seen)) {\n              var seen = computed;\n              result2[resIndex++] = value === 0 ? 0 : value;\n            }\n          }\n          return result2;\n        }\n        function baseToNumber(value) {\n          if (typeof value == \"number\") {\n            return value;\n          }\n          if (isSymbol(value)) {\n            return NAN;\n          }\n          return +value;\n        }\n        function baseToString(value) {\n          if (typeof value == \"string\") {\n            return value;\n          }\n          if (isArray(value)) {\n            return arrayMap(value, baseToString) + \"\";\n          }\n          if (isSymbol(value)) {\n            return symbolToString ? symbolToString.call(value) : \"\";\n          }\n          var result2 = value + \"\";\n          return result2 == \"0\" && 1 / value == -INFINITY ? \"-0\" : result2;\n        }\n        function baseUniq(array, iteratee2, comparator) {\n          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;\n          if (comparator) {\n            isCommon = false;\n            includes2 = arrayIncludesWith;\n          } else if (length >= LARGE_ARRAY_SIZE) {\n            var set2 = iteratee2 ? null : createSet(array);\n            if (set2) {\n              return setToArray(set2);\n            }\n            isCommon = false;\n            includes2 = cacheHas;\n            seen = new SetCache();\n          } else {\n            seen = iteratee2 ? [] : result2;\n          }\n          outer:\n            while (++index < length) {\n              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n              value = comparator || value !== 0 ? value : 0;\n              if (isCommon && computed === computed) {\n                var seenIndex = seen.length;\n                while (seenIndex--) {\n                  if (seen[seenIndex] === computed) {\n                    continue outer;\n                  }\n                }\n                if (iteratee2) {\n                  seen.push(computed);\n                }\n                result2.push(value);\n              } else if (!includes2(seen, computed, comparator)) {\n                if (seen !== result2) {\n                  seen.push(computed);\n                }\n                result2.push(value);\n              }\n            }\n          return result2;\n        }\n        function baseUnset(object, path) {\n          path = castPath(path, object);\n          object = parent(object, path);\n          return object == null || delete object[toKey(last(path))];\n        }\n        function baseUpdate(object, path, updater, customizer) {\n          return baseSet(object, path, updater(baseGet(object, path)), customizer);\n        }\n        function baseWhile(array, predicate, isDrop, fromRight) {\n          var length = array.length, index = fromRight ? length : -1;\n          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {\n          }\n          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);\n        }\n        function baseWrapperValue(value, actions) {\n          var result2 = value;\n          if (result2 instanceof LazyWrapper) {\n            result2 = result2.value();\n          }\n          return arrayReduce(actions, function(result3, action) {\n            return action.func.apply(action.thisArg, arrayPush([result3], action.args));\n          }, result2);\n        }\n        function baseXor(arrays, iteratee2, comparator) {\n          var length = arrays.length;\n          if (length < 2) {\n            return length ? baseUniq(arrays[0]) : [];\n          }\n          var index = -1, result2 = Array2(length);\n          while (++index < length) {\n            var array = arrays[index], othIndex = -1;\n            while (++othIndex < length) {\n              if (othIndex != index) {\n                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);\n              }\n            }\n          }\n          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);\n        }\n        function baseZipObject(props, values2, assignFunc) {\n          var index = -1, length = props.length, valsLength = values2.length, result2 = {};\n          while (++index < length) {\n            var value = index < valsLength ? values2[index] : undefined2;\n            assignFunc(result2, props[index], value);\n          }\n          return result2;\n        }\n        function castArrayLikeObject(value) {\n          return isArrayLikeObject(value) ? value : [];\n        }\n        function castFunction(value) {\n          return typeof value == \"function\" ? value : identity;\n        }\n        function castPath(value, object) {\n          if (isArray(value)) {\n            return value;\n          }\n          return isKey(value, object) ? [value] : stringToPath(toString(value));\n        }\n        var castRest = baseRest;\n        function castSlice(array, start, end) {\n          var length = array.length;\n          end = end === undefined2 ? length : end;\n          return !start && end >= length ? array : baseSlice(array, start, end);\n        }\n        var clearTimeout = ctxClearTimeout || function(id) {\n          return root.clearTimeout(id);\n        };\n        function cloneBuffer(buffer, isDeep) {\n          if (isDeep) {\n            return buffer.slice();\n          }\n          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n          buffer.copy(result2);\n          return result2;\n        }\n        function cloneArrayBuffer(arrayBuffer) {\n          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);\n          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));\n          return result2;\n        }\n        function cloneDataView(dataView, isDeep) {\n          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n        }\n        function cloneRegExp(regexp) {\n          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n          result2.lastIndex = regexp.lastIndex;\n          return result2;\n        }\n        function cloneSymbol(symbol) {\n          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};\n        }\n        function cloneTypedArray(typedArray, isDeep) {\n          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n        }\n        function compareAscending(value, other) {\n          if (value !== other) {\n            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);\n            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);\n            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n              return 1;\n            }\n            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n              return -1;\n            }\n          }\n          return 0;\n        }\n        function compareMultiple(object, other, orders) {\n          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;\n          while (++index < length) {\n            var result2 = compareAscending(objCriteria[index], othCriteria[index]);\n            if (result2) {\n              if (index >= ordersLength) {\n                return result2;\n              }\n              var order = orders[index];\n              return result2 * (order == \"desc\" ? -1 : 1);\n            }\n          }\n          return object.index - other.index;\n        }\n        function composeArgs(args, partials, holders, isCurried) {\n          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;\n          while (++leftIndex < leftLength) {\n            result2[leftIndex] = partials[leftIndex];\n          }\n          while (++argsIndex < holdersLength) {\n            if (isUncurried || argsIndex < argsLength) {\n              result2[holders[argsIndex]] = args[argsIndex];\n            }\n          }\n          while (rangeLength--) {\n            result2[leftIndex++] = args[argsIndex++];\n          }\n          return result2;\n        }\n        function composeArgsRight(args, partials, holders, isCurried) {\n          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;\n          while (++argsIndex < rangeLength) {\n            result2[argsIndex] = args[argsIndex];\n          }\n          var offset = argsIndex;\n          while (++rightIndex < rightLength) {\n            result2[offset + rightIndex] = partials[rightIndex];\n          }\n          while (++holdersIndex < holdersLength) {\n            if (isUncurried || argsIndex < argsLength) {\n              result2[offset + holders[holdersIndex]] = args[argsIndex++];\n            }\n          }\n          return result2;\n        }\n        function copyArray(source, array) {\n          var index = -1, length = source.length;\n          array || (array = Array2(length));\n          while (++index < length) {\n            array[index] = source[index];\n          }\n          return array;\n        }\n        function copyObject(source, props, object, customizer) {\n          var isNew = !object;\n          object || (object = {});\n          var index = -1, length = props.length;\n          while (++index < length) {\n            var key = props[index];\n            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;\n            if (newValue === undefined2) {\n              newValue = source[key];\n            }\n            if (isNew) {\n              baseAssignValue(object, key, newValue);\n            } else {\n              assignValue(object, key, newValue);\n            }\n          }\n          return object;\n        }\n        function copySymbols(source, object) {\n          return copyObject(source, getSymbols(source), object);\n        }\n        function copySymbolsIn(source, object) {\n          return copyObject(source, getSymbolsIn(source), object);\n        }\n        function createAggregator(setter, initializer) {\n          return function(collection, iteratee2) {\n            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};\n            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);\n          };\n        }\n        function createAssigner(assigner) {\n          return baseRest(function(object, sources) {\n            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;\n            customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : undefined2;\n            if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n              customizer = length < 3 ? undefined2 : customizer;\n              length = 1;\n            }\n            object = Object2(object);\n            while (++index < length) {\n              var source = sources[index];\n              if (source) {\n                assigner(object, source, index, customizer);\n              }\n            }\n            return object;\n          });\n        }\n        function createBaseEach(eachFunc, fromRight) {\n          return function(collection, iteratee2) {\n            if (collection == null) {\n              return collection;\n            }\n            if (!isArrayLike(collection)) {\n              return eachFunc(collection, iteratee2);\n            }\n            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);\n            while (fromRight ? index-- : ++index < length) {\n              if (iteratee2(iterable[index], index, iterable) === false) {\n                break;\n              }\n            }\n            return collection;\n          };\n        }\n        function createBaseFor(fromRight) {\n          return function(object, iteratee2, keysFunc) {\n            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;\n            while (length--) {\n              var key = props[fromRight ? length : ++index];\n              if (iteratee2(iterable[key], key, iterable) === false) {\n                break;\n              }\n            }\n            return object;\n          };\n        }\n        function createBind(func, bitmask, thisArg) {\n          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);\n          function wrapper() {\n            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n            return fn.apply(isBind ? thisArg : this, arguments);\n          }\n          return wrapper;\n        }\n        function createCaseFirst(methodName) {\n          return function(string) {\n            string = toString(string);\n            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;\n            var chr = strSymbols ? strSymbols[0] : string.charAt(0);\n            var trailing = strSymbols ? castSlice(strSymbols, 1).join(\"\") : string.slice(1);\n            return chr[methodName]() + trailing;\n          };\n        }\n        function createCompounder(callback) {\n          return function(string) {\n            return arrayReduce(words(deburr(string).replace(reApos, \"\")), callback, \"\");\n          };\n        }\n        function createCtor(Ctor) {\n          return function() {\n            var args = arguments;\n            switch (args.length) {\n              case 0:\n                return new Ctor();\n              case 1:\n                return new Ctor(args[0]);\n              case 2:\n                return new Ctor(args[0], args[1]);\n              case 3:\n                return new Ctor(args[0], args[1], args[2]);\n              case 4:\n                return new Ctor(args[0], args[1], args[2], args[3]);\n              case 5:\n                return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n              case 6:\n                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n              case 7:\n                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n            }\n            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);\n            return isObject(result2) ? result2 : thisBinding;\n          };\n        }\n        function createCurry(func, bitmask, arity) {\n          var Ctor = createCtor(func);\n          function wrapper() {\n            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);\n            while (index--) {\n              args[index] = arguments[index];\n            }\n            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);\n            length -= holders.length;\n            if (length < arity) {\n              return createRecurry(\n                func,\n                bitmask,\n                createHybrid,\n                wrapper.placeholder,\n                undefined2,\n                args,\n                holders,\n                undefined2,\n                undefined2,\n                arity - length\n              );\n            }\n            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n            return apply(fn, this, args);\n          }\n          return wrapper;\n        }\n        function createFind(findIndexFunc) {\n          return function(collection, predicate, fromIndex) {\n            var iterable = Object2(collection);\n            if (!isArrayLike(collection)) {\n              var iteratee2 = getIteratee(predicate, 3);\n              collection = keys(collection);\n              predicate = function(key) {\n                return iteratee2(iterable[key], key, iterable);\n              };\n            }\n            var index = findIndexFunc(collection, predicate, fromIndex);\n            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;\n          };\n        }\n        function createFlow(fromRight) {\n          return flatRest(function(funcs) {\n            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;\n            if (fromRight) {\n              funcs.reverse();\n            }\n            while (index--) {\n              var func = funcs[index];\n              if (typeof func != \"function\") {\n                throw new TypeError2(FUNC_ERROR_TEXT);\n              }\n              if (prereq && !wrapper && getFuncName(func) == \"wrapper\") {\n                var wrapper = new LodashWrapper([], true);\n              }\n            }\n            index = wrapper ? index : length;\n            while (++index < length) {\n              func = funcs[index];\n              var funcName = getFuncName(func), data = funcName == \"wrapper\" ? getData(func) : undefined2;\n              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {\n                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n              } else {\n                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);\n              }\n            }\n            return function() {\n              var args = arguments, value = args[0];\n              if (wrapper && args.length == 1 && isArray(value)) {\n                return wrapper.plant(value).value();\n              }\n              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;\n              while (++index2 < length) {\n                result2 = funcs[index2].call(this, result2);\n              }\n              return result2;\n            };\n          });\n        }\n        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {\n          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);\n          function wrapper() {\n            var length = arguments.length, args = Array2(length), index = length;\n            while (index--) {\n              args[index] = arguments[index];\n            }\n            if (isCurried) {\n              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);\n            }\n            if (partials) {\n              args = composeArgs(args, partials, holders, isCurried);\n            }\n            if (partialsRight) {\n              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n            }\n            length -= holdersCount;\n            if (isCurried && length < arity) {\n              var newHolders = replaceHolders(args, placeholder);\n              return createRecurry(\n                func,\n                bitmask,\n                createHybrid,\n                wrapper.placeholder,\n                thisArg,\n                args,\n                newHolders,\n                argPos,\n                ary2,\n                arity - length\n              );\n            }\n            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;\n            length = args.length;\n            if (argPos) {\n              args = reorder(args, argPos);\n            } else if (isFlip && length > 1) {\n              args.reverse();\n            }\n            if (isAry && ary2 < length) {\n              args.length = ary2;\n            }\n            if (this && this !== root && this instanceof wrapper) {\n              fn = Ctor || createCtor(fn);\n            }\n            return fn.apply(thisBinding, args);\n          }\n          return wrapper;\n        }\n        function createInverter(setter, toIteratee) {\n          return function(object, iteratee2) {\n            return baseInverter(object, setter, toIteratee(iteratee2), {});\n          };\n        }\n        function createMathOperation(operator, defaultValue) {\n          return function(value, other) {\n            var result2;\n            if (value === undefined2 && other === undefined2) {\n              return defaultValue;\n            }\n            if (value !== undefined2) {\n              result2 = value;\n            }\n            if (other !== undefined2) {\n              if (result2 === undefined2) {\n                return other;\n              }\n              if (typeof value == \"string\" || typeof other == \"string\") {\n                value = baseToString(value);\n                other = baseToString(other);\n              } else {\n                value = baseToNumber(value);\n                other = baseToNumber(other);\n              }\n              result2 = operator(value, other);\n            }\n            return result2;\n          };\n        }\n        function createOver(arrayFunc) {\n          return flatRest(function(iteratees) {\n            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n            return baseRest(function(args) {\n              var thisArg = this;\n              return arrayFunc(iteratees, function(iteratee2) {\n                return apply(iteratee2, thisArg, args);\n              });\n            });\n          });\n        }\n        function createPadding(length, chars) {\n          chars = chars === undefined2 ? \" \" : baseToString(chars);\n          var charsLength = chars.length;\n          if (charsLength < 2) {\n            return charsLength ? baseRepeat(chars, length) : chars;\n          }\n          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join(\"\") : result2.slice(0, length);\n        }\n        function createPartial(func, bitmask, thisArg, partials) {\n          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);\n          function wrapper() {\n            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n            while (++leftIndex < leftLength) {\n              args[leftIndex] = partials[leftIndex];\n            }\n            while (argsLength--) {\n              args[leftIndex++] = arguments[++argsIndex];\n            }\n            return apply(fn, isBind ? thisArg : this, args);\n          }\n          return wrapper;\n        }\n        function createRange(fromRight) {\n          return function(start, end, step) {\n            if (step && typeof step != \"number\" && isIterateeCall(start, end, step)) {\n              end = step = undefined2;\n            }\n            start = toFinite(start);\n            if (end === undefined2) {\n              end = start;\n              start = 0;\n            } else {\n              end = toFinite(end);\n            }\n            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);\n            return baseRange(start, end, step, fromRight);\n          };\n        }\n        function createRelationalOperation(operator) {\n          return function(value, other) {\n            if (!(typeof value == \"string\" && typeof other == \"string\")) {\n              value = toNumber(value);\n              other = toNumber(other);\n            }\n            return operator(value, other);\n          };\n        }\n        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {\n          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;\n          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;\n          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n          }\n          var newData = [\n            func,\n            bitmask,\n            thisArg,\n            newPartials,\n            newHolders,\n            newPartialsRight,\n            newHoldersRight,\n            argPos,\n            ary2,\n            arity\n          ];\n          var result2 = wrapFunc.apply(undefined2, newData);\n          if (isLaziable(func)) {\n            setData(result2, newData);\n          }\n          result2.placeholder = placeholder;\n          return setWrapToString(result2, func, bitmask);\n        }\n        function createRound(methodName) {\n          var func = Math2[methodName];\n          return function(number, precision) {\n            number = toNumber(number);\n            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n            if (precision && nativeIsFinite(number)) {\n              var pair = (toString(number) + \"e\").split(\"e\"), value = func(pair[0] + \"e\" + (+pair[1] + precision));\n              pair = (toString(value) + \"e\").split(\"e\");\n              return +(pair[0] + \"e\" + (+pair[1] - precision));\n            }\n            return func(number);\n          };\n        }\n        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {\n          return new Set2(values2);\n        };\n        function createToPairs(keysFunc) {\n          return function(object) {\n            var tag = getTag(object);\n            if (tag == mapTag) {\n              return mapToArray(object);\n            }\n            if (tag == setTag) {\n              return setToPairs(object);\n            }\n            return baseToPairs(object, keysFunc(object));\n          };\n        }\n        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {\n          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n          if (!isBindKey && typeof func != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          var length = partials ? partials.length : 0;\n          if (!length) {\n            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n            partials = holders = undefined2;\n          }\n          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);\n          arity = arity === undefined2 ? arity : toInteger(arity);\n          length -= holders ? holders.length : 0;\n          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n            var partialsRight = partials, holdersRight = holders;\n            partials = holders = undefined2;\n          }\n          var data = isBindKey ? undefined2 : getData(func);\n          var newData = [\n            func,\n            bitmask,\n            thisArg,\n            partials,\n            holders,\n            partialsRight,\n            holdersRight,\n            argPos,\n            ary2,\n            arity\n          ];\n          if (data) {\n            mergeData(newData, data);\n          }\n          func = newData[0];\n          bitmask = newData[1];\n          thisArg = newData[2];\n          partials = newData[3];\n          holders = newData[4];\n          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);\n          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n          }\n          if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n            var result2 = createBind(func, bitmask, thisArg);\n          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n            result2 = createCurry(func, bitmask, arity);\n          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n            result2 = createPartial(func, bitmask, thisArg, partials);\n          } else {\n            result2 = createHybrid.apply(undefined2, newData);\n          }\n          var setter = data ? baseSetData : setData;\n          return setWrapToString(setter(result2, newData), func, bitmask);\n        }\n        function customDefaultsAssignIn(objValue, srcValue, key, object) {\n          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {\n            return srcValue;\n          }\n          return objValue;\n        }\n        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n          if (isObject(objValue) && isObject(srcValue)) {\n            stack.set(srcValue, objValue);\n            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);\n            stack[\"delete\"](srcValue);\n          }\n          return objValue;\n        }\n        function customOmitClone(value) {\n          return isPlainObject(value) ? undefined2 : value;\n        }\n        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;\n          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n            return false;\n          }\n          var arrStacked = stack.get(array);\n          var othStacked = stack.get(other);\n          if (arrStacked && othStacked) {\n            return arrStacked == other && othStacked == array;\n          }\n          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;\n          stack.set(array, other);\n          stack.set(other, array);\n          while (++index < arrLength) {\n            var arrValue = array[index], othValue = other[index];\n            if (customizer) {\n              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n            }\n            if (compared !== undefined2) {\n              if (compared) {\n                continue;\n              }\n              result2 = false;\n              break;\n            }\n            if (seen) {\n              if (!arraySome(other, function(othValue2, othIndex) {\n                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n                result2 = false;\n                break;\n              }\n            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              result2 = false;\n              break;\n            }\n          }\n          stack[\"delete\"](array);\n          stack[\"delete\"](other);\n          return result2;\n        }\n        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n          switch (tag) {\n            case dataViewTag:\n              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n                return false;\n              }\n              object = object.buffer;\n              other = other.buffer;\n            case arrayBufferTag:\n              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {\n                return false;\n              }\n              return true;\n            case boolTag:\n            case dateTag:\n            case numberTag:\n              return eq(+object, +other);\n            case errorTag:\n              return object.name == other.name && object.message == other.message;\n            case regexpTag:\n            case stringTag:\n              return object == other + \"\";\n            case mapTag:\n              var convert = mapToArray;\n            case setTag:\n              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n              convert || (convert = setToArray);\n              if (object.size != other.size && !isPartial) {\n                return false;\n              }\n              var stacked = stack.get(object);\n              if (stacked) {\n                return stacked == other;\n              }\n              bitmask |= COMPARE_UNORDERED_FLAG;\n              stack.set(object, other);\n              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n              stack[\"delete\"](object);\n              return result2;\n            case symbolTag:\n              if (symbolValueOf) {\n                return symbolValueOf.call(object) == symbolValueOf.call(other);\n              }\n          }\n          return false;\n        }\n        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n          if (objLength != othLength && !isPartial) {\n            return false;\n          }\n          var index = objLength;\n          while (index--) {\n            var key = objProps[index];\n            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n              return false;\n            }\n          }\n          var objStacked = stack.get(object);\n          var othStacked = stack.get(other);\n          if (objStacked && othStacked) {\n            return objStacked == other && othStacked == object;\n          }\n          var result2 = true;\n          stack.set(object, other);\n          stack.set(other, object);\n          var skipCtor = isPartial;\n          while (++index < objLength) {\n            key = objProps[index];\n            var objValue = object[key], othValue = other[key];\n            if (customizer) {\n              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n            }\n            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n              result2 = false;\n              break;\n            }\n            skipCtor || (skipCtor = key == \"constructor\");\n          }\n          if (result2 && !skipCtor) {\n            var objCtor = object.constructor, othCtor = other.constructor;\n            if (objCtor != othCtor && (\"constructor\" in object && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n              result2 = false;\n            }\n          }\n          stack[\"delete\"](object);\n          stack[\"delete\"](other);\n          return result2;\n        }\n        function flatRest(func) {\n          return setToString(overRest(func, undefined2, flatten), func + \"\");\n        }\n        function getAllKeys(object) {\n          return baseGetAllKeys(object, keys, getSymbols);\n        }\n        function getAllKeysIn(object) {\n          return baseGetAllKeys(object, keysIn, getSymbolsIn);\n        }\n        var getData = !metaMap ? noop : function(func) {\n          return metaMap.get(func);\n        };\n        function getFuncName(func) {\n          var result2 = func.name + \"\", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;\n          while (length--) {\n            var data = array[length], otherFunc = data.func;\n            if (otherFunc == null || otherFunc == func) {\n              return data.name;\n            }\n          }\n          return result2;\n        }\n        function getHolder(func) {\n          var object = hasOwnProperty.call(lodash, \"placeholder\") ? lodash : func;\n          return object.placeholder;\n        }\n        function getIteratee() {\n          var result2 = lodash.iteratee || iteratee;\n          result2 = result2 === iteratee ? baseIteratee : result2;\n          return arguments.length ? result2(arguments[0], arguments[1]) : result2;\n        }\n        function getMapData(map2, key) {\n          var data = map2.__data__;\n          return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n        }\n        function getMatchData(object) {\n          var result2 = keys(object), length = result2.length;\n          while (length--) {\n            var key = result2[length], value = object[key];\n            result2[length] = [key, value, isStrictComparable(value)];\n          }\n          return result2;\n        }\n        function getNative(object, key) {\n          var value = getValue(object, key);\n          return baseIsNative(value) ? value : undefined2;\n        }\n        function getRawTag(value) {\n          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n          try {\n            value[symToStringTag] = undefined2;\n            var unmasked = true;\n          } catch (e) {\n          }\n          var result2 = nativeObjectToString.call(value);\n          if (unmasked) {\n            if (isOwn) {\n              value[symToStringTag] = tag;\n            } else {\n              delete value[symToStringTag];\n            }\n          }\n          return result2;\n        }\n        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n          if (object == null) {\n            return [];\n          }\n          object = Object2(object);\n          return arrayFilter(nativeGetSymbols(object), function(symbol) {\n            return propertyIsEnumerable.call(object, symbol);\n          });\n        };\n        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n          var result2 = [];\n          while (object) {\n            arrayPush(result2, getSymbols(object));\n            object = getPrototype(object);\n          }\n          return result2;\n        };\n        var getTag = baseGetTag;\n        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {\n          getTag = function(value) {\n            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : \"\";\n            if (ctorString) {\n              switch (ctorString) {\n                case dataViewCtorString:\n                  return dataViewTag;\n                case mapCtorString:\n                  return mapTag;\n                case promiseCtorString:\n                  return promiseTag;\n                case setCtorString:\n                  return setTag;\n                case weakMapCtorString:\n                  return weakMapTag;\n              }\n            }\n            return result2;\n          };\n        }\n        function getView(start, end, transforms) {\n          var index = -1, length = transforms.length;\n          while (++index < length) {\n            var data = transforms[index], size2 = data.size;\n            switch (data.type) {\n              case \"drop\":\n                start += size2;\n                break;\n              case \"dropRight\":\n                end -= size2;\n                break;\n              case \"take\":\n                end = nativeMin(end, start + size2);\n                break;\n              case \"takeRight\":\n                start = nativeMax(start, end - size2);\n                break;\n            }\n          }\n          return { \"start\": start, \"end\": end };\n        }\n        function getWrapDetails(source) {\n          var match = source.match(reWrapDetails);\n          return match ? match[1].split(reSplitDetails) : [];\n        }\n        function hasPath(object, path, hasFunc) {\n          path = castPath(path, object);\n          var index = -1, length = path.length, result2 = false;\n          while (++index < length) {\n            var key = toKey(path[index]);\n            if (!(result2 = object != null && hasFunc(object, key))) {\n              break;\n            }\n            object = object[key];\n          }\n          if (result2 || ++index != length) {\n            return result2;\n          }\n          length = object == null ? 0 : object.length;\n          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n        }\n        function initCloneArray(array) {\n          var length = array.length, result2 = new array.constructor(length);\n          if (length && typeof array[0] == \"string\" && hasOwnProperty.call(array, \"index\")) {\n            result2.index = array.index;\n            result2.input = array.input;\n          }\n          return result2;\n        }\n        function initCloneObject(object) {\n          return typeof object.constructor == \"function\" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};\n        }\n        function initCloneByTag(object, tag, isDeep) {\n          var Ctor = object.constructor;\n          switch (tag) {\n            case arrayBufferTag:\n              return cloneArrayBuffer(object);\n            case boolTag:\n            case dateTag:\n              return new Ctor(+object);\n            case dataViewTag:\n              return cloneDataView(object, isDeep);\n            case float32Tag:\n            case float64Tag:\n            case int8Tag:\n            case int16Tag:\n            case int32Tag:\n            case uint8Tag:\n            case uint8ClampedTag:\n            case uint16Tag:\n            case uint32Tag:\n              return cloneTypedArray(object, isDeep);\n            case mapTag:\n              return new Ctor();\n            case numberTag:\n            case stringTag:\n              return new Ctor(object);\n            case regexpTag:\n              return cloneRegExp(object);\n            case setTag:\n              return new Ctor();\n            case symbolTag:\n              return cloneSymbol(object);\n          }\n        }\n        function insertWrapDetails(source, details) {\n          var length = details.length;\n          if (!length) {\n            return source;\n          }\n          var lastIndex = length - 1;\n          details[lastIndex] = (length > 1 ? \"& \" : \"\") + details[lastIndex];\n          details = details.join(length > 2 ? \", \" : \" \");\n          return source.replace(reWrapComment, \"{\\n/* [wrapped with \" + details + \"] */\\n\");\n        }\n        function isFlattenable(value) {\n          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n        }\n        function isIndex(value, length) {\n          var type = typeof value;\n          length = length == null ? MAX_SAFE_INTEGER : length;\n          return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);\n        }\n        function isIterateeCall(value, index, object) {\n          if (!isObject(object)) {\n            return false;\n          }\n          var type = typeof index;\n          if (type == \"number\" ? isArrayLike(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n            return eq(object[index], value);\n          }\n          return false;\n        }\n        function isKey(value, object) {\n          if (isArray(value)) {\n            return false;\n          }\n          var type = typeof value;\n          if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol(value)) {\n            return true;\n          }\n          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);\n        }\n        function isKeyable(value) {\n          var type = typeof value;\n          return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n        }\n        function isLaziable(func) {\n          var funcName = getFuncName(func), other = lodash[funcName];\n          if (typeof other != \"function\" || !(funcName in LazyWrapper.prototype)) {\n            return false;\n          }\n          if (func === other) {\n            return true;\n          }\n          var data = getData(other);\n          return !!data && func === data[0];\n        }\n        function isMasked(func) {\n          return !!maskSrcKey && maskSrcKey in func;\n        }\n        var isMaskable = coreJsData ? isFunction : stubFalse;\n        function isPrototype(value) {\n          var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto;\n          return value === proto;\n        }\n        function isStrictComparable(value) {\n          return value === value && !isObject(value);\n        }\n        function matchesStrictComparable(key, srcValue) {\n          return function(object) {\n            if (object == null) {\n              return false;\n            }\n            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));\n          };\n        }\n        function memoizeCapped(func) {\n          var result2 = memoize2(func, function(key) {\n            if (cache.size === MAX_MEMOIZE_SIZE) {\n              cache.clear();\n            }\n            return key;\n          });\n          var cache = result2.cache;\n          return result2;\n        }\n        function mergeData(data, source) {\n          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;\n          if (!(isCommon || isCombo)) {\n            return data;\n          }\n          if (srcBitmask & WRAP_BIND_FLAG) {\n            data[2] = source[2];\n            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n          }\n          var value = source[3];\n          if (value) {\n            var partials = data[3];\n            data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n          }\n          value = source[5];\n          if (value) {\n            partials = data[5];\n            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n          }\n          value = source[7];\n          if (value) {\n            data[7] = value;\n          }\n          if (srcBitmask & WRAP_ARY_FLAG) {\n            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n          }\n          if (data[9] == null) {\n            data[9] = source[9];\n          }\n          data[0] = source[0];\n          data[1] = newBitmask;\n          return data;\n        }\n        function nativeKeysIn(object) {\n          var result2 = [];\n          if (object != null) {\n            for (var key in Object2(object)) {\n              result2.push(key);\n            }\n          }\n          return result2;\n        }\n        function objectToString(value) {\n          return nativeObjectToString.call(value);\n        }\n        function overRest(func, start, transform2) {\n          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);\n          return function() {\n            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);\n            while (++index < length) {\n              array[index] = args[start + index];\n            }\n            index = -1;\n            var otherArgs = Array2(start + 1);\n            while (++index < start) {\n              otherArgs[index] = args[index];\n            }\n            otherArgs[start] = transform2(array);\n            return apply(func, this, otherArgs);\n          };\n        }\n        function parent(object, path) {\n          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n        }\n        function reorder(array, indexes) {\n          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);\n          while (length--) {\n            var index = indexes[length];\n            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;\n          }\n          return array;\n        }\n        function safeGet(object, key) {\n          if (key === \"constructor\" && typeof object[key] === \"function\") {\n            return;\n          }\n          if (key == \"__proto__\") {\n            return;\n          }\n          return object[key];\n        }\n        var setData = shortOut(baseSetData);\n        var setTimeout = ctxSetTimeout || function(func, wait) {\n          return root.setTimeout(func, wait);\n        };\n        var setToString = shortOut(baseSetToString);\n        function setWrapToString(wrapper, reference, bitmask) {\n          var source = reference + \"\";\n          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n        }\n        function shortOut(func) {\n          var count = 0, lastCalled = 0;\n          return function() {\n            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n            lastCalled = stamp;\n            if (remaining > 0) {\n              if (++count >= HOT_COUNT) {\n                return arguments[0];\n              }\n            } else {\n              count = 0;\n            }\n            return func.apply(undefined2, arguments);\n          };\n        }\n        function shuffleSelf(array, size2) {\n          var index = -1, length = array.length, lastIndex = length - 1;\n          size2 = size2 === undefined2 ? length : size2;\n          while (++index < size2) {\n            var rand = baseRandom(index, lastIndex), value = array[rand];\n            array[rand] = array[index];\n            array[index] = value;\n          }\n          array.length = size2;\n          return array;\n        }\n        var stringToPath = memoizeCapped(function(string) {\n          var result2 = [];\n          if (string.charCodeAt(0) === 46) {\n            result2.push(\"\");\n          }\n          string.replace(rePropName, function(match, number, quote, subString) {\n            result2.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n          });\n          return result2;\n        });\n        function toKey(value) {\n          if (typeof value == \"string\" || isSymbol(value)) {\n            return value;\n          }\n          var result2 = value + \"\";\n          return result2 == \"0\" && 1 / value == -INFINITY ? \"-0\" : result2;\n        }\n        function toSource(func) {\n          if (func != null) {\n            try {\n              return funcToString.call(func);\n            } catch (e) {\n            }\n            try {\n              return func + \"\";\n            } catch (e) {\n            }\n          }\n          return \"\";\n        }\n        function updateWrapDetails(details, bitmask) {\n          arrayEach(wrapFlags, function(pair) {\n            var value = \"_.\" + pair[0];\n            if (bitmask & pair[1] && !arrayIncludes(details, value)) {\n              details.push(value);\n            }\n          });\n          return details.sort();\n        }\n        function wrapperClone(wrapper) {\n          if (wrapper instanceof LazyWrapper) {\n            return wrapper.clone();\n          }\n          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n          result2.__actions__ = copyArray(wrapper.__actions__);\n          result2.__index__ = wrapper.__index__;\n          result2.__values__ = wrapper.__values__;\n          return result2;\n        }\n        function chunk(array, size2, guard) {\n          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {\n            size2 = 1;\n          } else {\n            size2 = nativeMax(toInteger(size2), 0);\n          }\n          var length = array == null ? 0 : array.length;\n          if (!length || size2 < 1) {\n            return [];\n          }\n          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));\n          while (index < length) {\n            result2[resIndex++] = baseSlice(array, index, index += size2);\n          }\n          return result2;\n        }\n        function compact(array) {\n          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];\n          while (++index < length) {\n            var value = array[index];\n            if (value) {\n              result2[resIndex++] = value;\n            }\n          }\n          return result2;\n        }\n        function concat() {\n          var length = arguments.length;\n          if (!length) {\n            return [];\n          }\n          var args = Array2(length - 1), array = arguments[0], index = length;\n          while (index--) {\n            args[index - 1] = arguments[index];\n          }\n          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n        }\n        var difference = baseRest(function(array, values2) {\n          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];\n        });\n        var differenceBy = baseRest(function(array, values2) {\n          var iteratee2 = last(values2);\n          if (isArrayLikeObject(iteratee2)) {\n            iteratee2 = undefined2;\n          }\n          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];\n        });\n        var differenceWith = baseRest(function(array, values2) {\n          var comparator = last(values2);\n          if (isArrayLikeObject(comparator)) {\n            comparator = undefined2;\n          }\n          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];\n        });\n        function drop(array, n, guard) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return [];\n          }\n          n = guard || n === undefined2 ? 1 : toInteger(n);\n          return baseSlice(array, n < 0 ? 0 : n, length);\n        }\n        function dropRight(array, n, guard) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return [];\n          }\n          n = guard || n === undefined2 ? 1 : toInteger(n);\n          n = length - n;\n          return baseSlice(array, 0, n < 0 ? 0 : n);\n        }\n        function dropRightWhile(array, predicate) {\n          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];\n        }\n        function dropWhile(array, predicate) {\n          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];\n        }\n        function fill(array, value, start, end) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return [];\n          }\n          if (start && typeof start != \"number\" && isIterateeCall(array, value, start)) {\n            start = 0;\n            end = length;\n          }\n          return baseFill(array, value, start, end);\n        }\n        function findIndex(array, predicate, fromIndex) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return -1;\n          }\n          var index = fromIndex == null ? 0 : toInteger(fromIndex);\n          if (index < 0) {\n            index = nativeMax(length + index, 0);\n          }\n          return baseFindIndex(array, getIteratee(predicate, 3), index);\n        }\n        function findLastIndex(array, predicate, fromIndex) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return -1;\n          }\n          var index = length - 1;\n          if (fromIndex !== undefined2) {\n            index = toInteger(fromIndex);\n            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n          }\n          return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n        }\n        function flatten(array) {\n          var length = array == null ? 0 : array.length;\n          return length ? baseFlatten(array, 1) : [];\n        }\n        function flattenDeep(array) {\n          var length = array == null ? 0 : array.length;\n          return length ? baseFlatten(array, INFINITY) : [];\n        }\n        function flattenDepth(array, depth) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return [];\n          }\n          depth = depth === undefined2 ? 1 : toInteger(depth);\n          return baseFlatten(array, depth);\n        }\n        function fromPairs(pairs) {\n          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};\n          while (++index < length) {\n            var pair = pairs[index];\n            result2[pair[0]] = pair[1];\n          }\n          return result2;\n        }\n        function head(array) {\n          return array && array.length ? array[0] : undefined2;\n        }\n        function indexOf(array, value, fromIndex) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return -1;\n          }\n          var index = fromIndex == null ? 0 : toInteger(fromIndex);\n          if (index < 0) {\n            index = nativeMax(length + index, 0);\n          }\n          return baseIndexOf(array, value, index);\n        }\n        function initial(array) {\n          var length = array == null ? 0 : array.length;\n          return length ? baseSlice(array, 0, -1) : [];\n        }\n        var intersection = baseRest(function(arrays) {\n          var mapped = arrayMap(arrays, castArrayLikeObject);\n          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];\n        });\n        var intersectionBy = baseRest(function(arrays) {\n          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);\n          if (iteratee2 === last(mapped)) {\n            iteratee2 = undefined2;\n          } else {\n            mapped.pop();\n          }\n          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];\n        });\n        var intersectionWith = baseRest(function(arrays) {\n          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);\n          comparator = typeof comparator == \"function\" ? comparator : undefined2;\n          if (comparator) {\n            mapped.pop();\n          }\n          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];\n        });\n        function join(array, separator) {\n          return array == null ? \"\" : nativeJoin.call(array, separator);\n        }\n        function last(array) {\n          var length = array == null ? 0 : array.length;\n          return length ? array[length - 1] : undefined2;\n        }\n        function lastIndexOf(array, value, fromIndex) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return -1;\n          }\n          var index = length;\n          if (fromIndex !== undefined2) {\n            index = toInteger(fromIndex);\n            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n          }\n          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);\n        }\n        function nth(array, n) {\n          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;\n        }\n        var pull = baseRest(pullAll);\n        function pullAll(array, values2) {\n          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;\n        }\n        function pullAllBy(array, values2, iteratee2) {\n          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;\n        }\n        function pullAllWith(array, values2, comparator) {\n          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;\n        }\n        var pullAt = flatRest(function(array, indexes) {\n          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);\n          basePullAt(array, arrayMap(indexes, function(index) {\n            return isIndex(index, length) ? +index : index;\n          }).sort(compareAscending));\n          return result2;\n        });\n        function remove(array, predicate) {\n          var result2 = [];\n          if (!(array && array.length)) {\n            return result2;\n          }\n          var index = -1, indexes = [], length = array.length;\n          predicate = getIteratee(predicate, 3);\n          while (++index < length) {\n            var value = array[index];\n            if (predicate(value, index, array)) {\n              result2.push(value);\n              indexes.push(index);\n            }\n          }\n          basePullAt(array, indexes);\n          return result2;\n        }\n        function reverse(array) {\n          return array == null ? array : nativeReverse.call(array);\n        }\n        function slice(array, start, end) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return [];\n          }\n          if (end && typeof end != \"number\" && isIterateeCall(array, start, end)) {\n            start = 0;\n            end = length;\n          } else {\n            start = start == null ? 0 : toInteger(start);\n            end = end === undefined2 ? length : toInteger(end);\n          }\n          return baseSlice(array, start, end);\n        }\n        function sortedIndex(array, value) {\n          return baseSortedIndex(array, value);\n        }\n        function sortedIndexBy(array, value, iteratee2) {\n          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));\n        }\n        function sortedIndexOf(array, value) {\n          var length = array == null ? 0 : array.length;\n          if (length) {\n            var index = baseSortedIndex(array, value);\n            if (index < length && eq(array[index], value)) {\n              return index;\n            }\n          }\n          return -1;\n        }\n        function sortedLastIndex(array, value) {\n          return baseSortedIndex(array, value, true);\n        }\n        function sortedLastIndexBy(array, value, iteratee2) {\n          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);\n        }\n        function sortedLastIndexOf(array, value) {\n          var length = array == null ? 0 : array.length;\n          if (length) {\n            var index = baseSortedIndex(array, value, true) - 1;\n            if (eq(array[index], value)) {\n              return index;\n            }\n          }\n          return -1;\n        }\n        function sortedUniq(array) {\n          return array && array.length ? baseSortedUniq(array) : [];\n        }\n        function sortedUniqBy(array, iteratee2) {\n          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];\n        }\n        function tail(array) {\n          var length = array == null ? 0 : array.length;\n          return length ? baseSlice(array, 1, length) : [];\n        }\n        function take(array, n, guard) {\n          if (!(array && array.length)) {\n            return [];\n          }\n          n = guard || n === undefined2 ? 1 : toInteger(n);\n          return baseSlice(array, 0, n < 0 ? 0 : n);\n        }\n        function takeRight(array, n, guard) {\n          var length = array == null ? 0 : array.length;\n          if (!length) {\n            return [];\n          }\n          n = guard || n === undefined2 ? 1 : toInteger(n);\n          n = length - n;\n          return baseSlice(array, n < 0 ? 0 : n, length);\n        }\n        function takeRightWhile(array, predicate) {\n          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];\n        }\n        function takeWhile(array, predicate) {\n          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];\n        }\n        var union = baseRest(function(arrays) {\n          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n        });\n        var unionBy = baseRest(function(arrays) {\n          var iteratee2 = last(arrays);\n          if (isArrayLikeObject(iteratee2)) {\n            iteratee2 = undefined2;\n          }\n          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));\n        });\n        var unionWith = baseRest(function(arrays) {\n          var comparator = last(arrays);\n          comparator = typeof comparator == \"function\" ? comparator : undefined2;\n          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);\n        });\n        function uniq(array) {\n          return array && array.length ? baseUniq(array) : [];\n        }\n        function uniqBy(array, iteratee2) {\n          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];\n        }\n        function uniqWith(array, comparator) {\n          comparator = typeof comparator == \"function\" ? comparator : undefined2;\n          return array && array.length ? baseUniq(array, undefined2, comparator) : [];\n        }\n        function unzip(array) {\n          if (!(array && array.length)) {\n            return [];\n          }\n          var length = 0;\n          array = arrayFilter(array, function(group) {\n            if (isArrayLikeObject(group)) {\n              length = nativeMax(group.length, length);\n              return true;\n            }\n          });\n          return baseTimes(length, function(index) {\n            return arrayMap(array, baseProperty(index));\n          });\n        }\n        function unzipWith(array, iteratee2) {\n          if (!(array && array.length)) {\n            return [];\n          }\n          var result2 = unzip(array);\n          if (iteratee2 == null) {\n            return result2;\n          }\n          return arrayMap(result2, function(group) {\n            return apply(iteratee2, undefined2, group);\n          });\n        }\n        var without = baseRest(function(array, values2) {\n          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];\n        });\n        var xor = baseRest(function(arrays) {\n          return baseXor(arrayFilter(arrays, isArrayLikeObject));\n        });\n        var xorBy = baseRest(function(arrays) {\n          var iteratee2 = last(arrays);\n          if (isArrayLikeObject(iteratee2)) {\n            iteratee2 = undefined2;\n          }\n          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));\n        });\n        var xorWith = baseRest(function(arrays) {\n          var comparator = last(arrays);\n          comparator = typeof comparator == \"function\" ? comparator : undefined2;\n          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);\n        });\n        var zip = baseRest(unzip);\n        function zipObject(props, values2) {\n          return baseZipObject(props || [], values2 || [], assignValue);\n        }\n        function zipObjectDeep(props, values2) {\n          return baseZipObject(props || [], values2 || [], baseSet);\n        }\n        var zipWith = baseRest(function(arrays) {\n          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;\n          iteratee2 = typeof iteratee2 == \"function\" ? (arrays.pop(), iteratee2) : undefined2;\n          return unzipWith(arrays, iteratee2);\n        });\n        function chain(value) {\n          var result2 = lodash(value);\n          result2.__chain__ = true;\n          return result2;\n        }\n        function tap(value, interceptor) {\n          interceptor(value);\n          return value;\n        }\n        function thru(value, interceptor) {\n          return interceptor(value);\n        }\n        var wrapperAt = flatRest(function(paths) {\n          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {\n            return baseAt(object, paths);\n          };\n          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {\n            return this.thru(interceptor);\n          }\n          value = value.slice(start, +start + (length ? 1 : 0));\n          value.__actions__.push({\n            \"func\": thru,\n            \"args\": [interceptor],\n            \"thisArg\": undefined2\n          });\n          return new LodashWrapper(value, this.__chain__).thru(function(array) {\n            if (length && !array.length) {\n              array.push(undefined2);\n            }\n            return array;\n          });\n        });\n        function wrapperChain() {\n          return chain(this);\n        }\n        function wrapperCommit() {\n          return new LodashWrapper(this.value(), this.__chain__);\n        }\n        function wrapperNext() {\n          if (this.__values__ === undefined2) {\n            this.__values__ = toArray(this.value());\n          }\n          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];\n          return { \"done\": done, \"value\": value };\n        }\n        function wrapperToIterator() {\n          return this;\n        }\n        function wrapperPlant(value) {\n          var result2, parent2 = this;\n          while (parent2 instanceof baseLodash) {\n            var clone2 = wrapperClone(parent2);\n            clone2.__index__ = 0;\n            clone2.__values__ = undefined2;\n            if (result2) {\n              previous.__wrapped__ = clone2;\n            } else {\n              result2 = clone2;\n            }\n            var previous = clone2;\n            parent2 = parent2.__wrapped__;\n          }\n          previous.__wrapped__ = value;\n          return result2;\n        }\n        function wrapperReverse() {\n          var value = this.__wrapped__;\n          if (value instanceof LazyWrapper) {\n            var wrapped = value;\n            if (this.__actions__.length) {\n              wrapped = new LazyWrapper(this);\n            }\n            wrapped = wrapped.reverse();\n            wrapped.__actions__.push({\n              \"func\": thru,\n              \"args\": [reverse],\n              \"thisArg\": undefined2\n            });\n            return new LodashWrapper(wrapped, this.__chain__);\n          }\n          return this.thru(reverse);\n        }\n        function wrapperValue() {\n          return baseWrapperValue(this.__wrapped__, this.__actions__);\n        }\n        var countBy = createAggregator(function(result2, value, key) {\n          if (hasOwnProperty.call(result2, key)) {\n            ++result2[key];\n          } else {\n            baseAssignValue(result2, key, 1);\n          }\n        });\n        function every(collection, predicate, guard) {\n          var func = isArray(collection) ? arrayEvery : baseEvery;\n          if (guard && isIterateeCall(collection, predicate, guard)) {\n            predicate = undefined2;\n          }\n          return func(collection, getIteratee(predicate, 3));\n        }\n        function filter(collection, predicate) {\n          var func = isArray(collection) ? arrayFilter : baseFilter;\n          return func(collection, getIteratee(predicate, 3));\n        }\n        var find = createFind(findIndex);\n        var findLast = createFind(findLastIndex);\n        function flatMap(collection, iteratee2) {\n          return baseFlatten(map(collection, iteratee2), 1);\n        }\n        function flatMapDeep(collection, iteratee2) {\n          return baseFlatten(map(collection, iteratee2), INFINITY);\n        }\n        function flatMapDepth(collection, iteratee2, depth) {\n          depth = depth === undefined2 ? 1 : toInteger(depth);\n          return baseFlatten(map(collection, iteratee2), depth);\n        }\n        function forEach(collection, iteratee2) {\n          var func = isArray(collection) ? arrayEach : baseEach;\n          return func(collection, getIteratee(iteratee2, 3));\n        }\n        function forEachRight(collection, iteratee2) {\n          var func = isArray(collection) ? arrayEachRight : baseEachRight;\n          return func(collection, getIteratee(iteratee2, 3));\n        }\n        var groupBy = createAggregator(function(result2, value, key) {\n          if (hasOwnProperty.call(result2, key)) {\n            result2[key].push(value);\n          } else {\n            baseAssignValue(result2, key, [value]);\n          }\n        });\n        function includes(collection, value, fromIndex, guard) {\n          collection = isArrayLike(collection) ? collection : values(collection);\n          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;\n          var length = collection.length;\n          if (fromIndex < 0) {\n            fromIndex = nativeMax(length + fromIndex, 0);\n          }\n          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;\n        }\n        var invokeMap = baseRest(function(collection, path, args) {\n          var index = -1, isFunc = typeof path == \"function\", result2 = isArrayLike(collection) ? Array2(collection.length) : [];\n          baseEach(collection, function(value) {\n            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n          });\n          return result2;\n        });\n        var keyBy = createAggregator(function(result2, value, key) {\n          baseAssignValue(result2, key, value);\n        });\n        function map(collection, iteratee2) {\n          var func = isArray(collection) ? arrayMap : baseMap;\n          return func(collection, getIteratee(iteratee2, 3));\n        }\n        function orderBy(collection, iteratees, orders, guard) {\n          if (collection == null) {\n            return [];\n          }\n          if (!isArray(iteratees)) {\n            iteratees = iteratees == null ? [] : [iteratees];\n          }\n          orders = guard ? undefined2 : orders;\n          if (!isArray(orders)) {\n            orders = orders == null ? [] : [orders];\n          }\n          return baseOrderBy(collection, iteratees, orders);\n        }\n        var partition = createAggregator(function(result2, value, key) {\n          result2[key ? 0 : 1].push(value);\n        }, function() {\n          return [[], []];\n        });\n        function reduce(collection, iteratee2, accumulator) {\n          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;\n          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);\n        }\n        function reduceRight(collection, iteratee2, accumulator) {\n          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;\n          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);\n        }\n        function reject(collection, predicate) {\n          var func = isArray(collection) ? arrayFilter : baseFilter;\n          return func(collection, negate(getIteratee(predicate, 3)));\n        }\n        function sample(collection) {\n          var func = isArray(collection) ? arraySample : baseSample;\n          return func(collection);\n        }\n        function sampleSize(collection, n, guard) {\n          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {\n            n = 1;\n          } else {\n            n = toInteger(n);\n          }\n          var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n          return func(collection, n);\n        }\n        function shuffle(collection) {\n          var func = isArray(collection) ? arrayShuffle : baseShuffle;\n          return func(collection);\n        }\n        function size(collection) {\n          if (collection == null) {\n            return 0;\n          }\n          if (isArrayLike(collection)) {\n            return isString(collection) ? stringSize(collection) : collection.length;\n          }\n          var tag = getTag(collection);\n          if (tag == mapTag || tag == setTag) {\n            return collection.size;\n          }\n          return baseKeys(collection).length;\n        }\n        function some(collection, predicate, guard) {\n          var func = isArray(collection) ? arraySome : baseSome;\n          if (guard && isIterateeCall(collection, predicate, guard)) {\n            predicate = undefined2;\n          }\n          return func(collection, getIteratee(predicate, 3));\n        }\n        var sortBy = baseRest(function(collection, iteratees) {\n          if (collection == null) {\n            return [];\n          }\n          var length = iteratees.length;\n          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n            iteratees = [];\n          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n            iteratees = [iteratees[0]];\n          }\n          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n        });\n        var now = ctxNow || function() {\n          return root.Date.now();\n        };\n        function after(n, func) {\n          if (typeof func != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          n = toInteger(n);\n          return function() {\n            if (--n < 1) {\n              return func.apply(this, arguments);\n            }\n          };\n        }\n        function ary(func, n, guard) {\n          n = guard ? undefined2 : n;\n          n = func && n == null ? func.length : n;\n          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);\n        }\n        function before(n, func) {\n          var result2;\n          if (typeof func != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          n = toInteger(n);\n          return function() {\n            if (--n > 0) {\n              result2 = func.apply(this, arguments);\n            }\n            if (n <= 1) {\n              func = undefined2;\n            }\n            return result2;\n          };\n        }\n        var bind = baseRest(function(func, thisArg, partials) {\n          var bitmask = WRAP_BIND_FLAG;\n          if (partials.length) {\n            var holders = replaceHolders(partials, getHolder(bind));\n            bitmask |= WRAP_PARTIAL_FLAG;\n          }\n          return createWrap(func, bitmask, thisArg, partials, holders);\n        });\n        var bindKey = baseRest(function(object, key, partials) {\n          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n          if (partials.length) {\n            var holders = replaceHolders(partials, getHolder(bindKey));\n            bitmask |= WRAP_PARTIAL_FLAG;\n          }\n          return createWrap(key, bitmask, object, partials, holders);\n        });\n        function curry(func, arity, guard) {\n          arity = guard ? undefined2 : arity;\n          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);\n          result2.placeholder = curry.placeholder;\n          return result2;\n        }\n        function curryRight(func, arity, guard) {\n          arity = guard ? undefined2 : arity;\n          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);\n          result2.placeholder = curryRight.placeholder;\n          return result2;\n        }\n        function debounce(func, wait, options) {\n          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n          if (typeof func != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          wait = toNumber(wait) || 0;\n          if (isObject(options)) {\n            leading = !!options.leading;\n            maxing = \"maxWait\" in options;\n            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n            trailing = \"trailing\" in options ? !!options.trailing : trailing;\n          }\n          function invokeFunc(time) {\n            var args = lastArgs, thisArg = lastThis;\n            lastArgs = lastThis = undefined2;\n            lastInvokeTime = time;\n            result2 = func.apply(thisArg, args);\n            return result2;\n          }\n          function leadingEdge(time) {\n            lastInvokeTime = time;\n            timerId = setTimeout(timerExpired, wait);\n            return leading ? invokeFunc(time) : result2;\n          }\n          function remainingWait(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n          }\n          function shouldInvoke(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n          }\n          function timerExpired() {\n            var time = now();\n            if (shouldInvoke(time)) {\n              return trailingEdge(time);\n            }\n            timerId = setTimeout(timerExpired, remainingWait(time));\n          }\n          function trailingEdge(time) {\n            timerId = undefined2;\n            if (trailing && lastArgs) {\n              return invokeFunc(time);\n            }\n            lastArgs = lastThis = undefined2;\n            return result2;\n          }\n          function cancel() {\n            if (timerId !== undefined2) {\n              clearTimeout(timerId);\n            }\n            lastInvokeTime = 0;\n            lastArgs = lastCallTime = lastThis = timerId = undefined2;\n          }\n          function flush() {\n            return timerId === undefined2 ? result2 : trailingEdge(now());\n          }\n          function debounced() {\n            var time = now(), isInvoking = shouldInvoke(time);\n            lastArgs = arguments;\n            lastThis = this;\n            lastCallTime = time;\n            if (isInvoking) {\n              if (timerId === undefined2) {\n                return leadingEdge(lastCallTime);\n              }\n              if (maxing) {\n                clearTimeout(timerId);\n                timerId = setTimeout(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n              }\n            }\n            if (timerId === undefined2) {\n              timerId = setTimeout(timerExpired, wait);\n            }\n            return result2;\n          }\n          debounced.cancel = cancel;\n          debounced.flush = flush;\n          return debounced;\n        }\n        var defer = baseRest(function(func, args) {\n          return baseDelay(func, 1, args);\n        });\n        var delay = baseRest(function(func, wait, args) {\n          return baseDelay(func, toNumber(wait) || 0, args);\n        });\n        function flip(func) {\n          return createWrap(func, WRAP_FLIP_FLAG);\n        }\n        function memoize2(func, resolver) {\n          if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          var memoized = function() {\n            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n            if (cache.has(key)) {\n              return cache.get(key);\n            }\n            var result2 = func.apply(this, args);\n            memoized.cache = cache.set(key, result2) || cache;\n            return result2;\n          };\n          memoized.cache = new (memoize2.Cache || MapCache)();\n          return memoized;\n        }\n        memoize2.Cache = MapCache;\n        function negate(predicate) {\n          if (typeof predicate != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          return function() {\n            var args = arguments;\n            switch (args.length) {\n              case 0:\n                return !predicate.call(this);\n              case 1:\n                return !predicate.call(this, args[0]);\n              case 2:\n                return !predicate.call(this, args[0], args[1]);\n              case 3:\n                return !predicate.call(this, args[0], args[1], args[2]);\n            }\n            return !predicate.apply(this, args);\n          };\n        }\n        function once(func) {\n          return before(2, func);\n        }\n        var overArgs = castRest(function(func, transforms) {\n          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n          var funcsLength = transforms.length;\n          return baseRest(function(args) {\n            var index = -1, length = nativeMin(args.length, funcsLength);\n            while (++index < length) {\n              args[index] = transforms[index].call(this, args[index]);\n            }\n            return apply(func, this, args);\n          });\n        });\n        var partial = baseRest(function(func, partials) {\n          var holders = replaceHolders(partials, getHolder(partial));\n          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);\n        });\n        var partialRight = baseRest(function(func, partials) {\n          var holders = replaceHolders(partials, getHolder(partialRight));\n          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);\n        });\n        var rearg = flatRest(function(func, indexes) {\n          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);\n        });\n        function rest(func, start) {\n          if (typeof func != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          start = start === undefined2 ? start : toInteger(start);\n          return baseRest(func, start);\n        }\n        function spread(func, start) {\n          if (typeof func != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          start = start == null ? 0 : nativeMax(toInteger(start), 0);\n          return baseRest(function(args) {\n            var array = args[start], otherArgs = castSlice(args, 0, start);\n            if (array) {\n              arrayPush(otherArgs, array);\n            }\n            return apply(func, this, otherArgs);\n          });\n        }\n        function throttle(func, wait, options) {\n          var leading = true, trailing = true;\n          if (typeof func != \"function\") {\n            throw new TypeError2(FUNC_ERROR_TEXT);\n          }\n          if (isObject(options)) {\n            leading = \"leading\" in options ? !!options.leading : leading;\n            trailing = \"trailing\" in options ? !!options.trailing : trailing;\n          }\n          return debounce(func, wait, {\n            \"leading\": leading,\n            \"maxWait\": wait,\n            \"trailing\": trailing\n          });\n        }\n        function unary(func) {\n          return ary(func, 1);\n        }\n        function wrap(value, wrapper) {\n          return partial(castFunction(wrapper), value);\n        }\n        function castArray() {\n          if (!arguments.length) {\n            return [];\n          }\n          var value = arguments[0];\n          return isArray(value) ? value : [value];\n        }\n        function clone(value) {\n          return baseClone(value, CLONE_SYMBOLS_FLAG);\n        }\n        function cloneWith(value, customizer) {\n          customizer = typeof customizer == \"function\" ? customizer : undefined2;\n          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n        }\n        function cloneDeep(value) {\n          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n        }\n        function cloneDeepWith(value, customizer) {\n          customizer = typeof customizer == \"function\" ? customizer : undefined2;\n          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n        }\n        function conformsTo(object, source) {\n          return source == null || baseConformsTo(object, source, keys(source));\n        }\n        function eq(value, other) {\n          return value === other || value !== value && other !== other;\n        }\n        var gt = createRelationalOperation(baseGt);\n        var gte = createRelationalOperation(function(value, other) {\n          return value >= other;\n        });\n        var isArguments = baseIsArguments(function() {\n          return arguments;\n        }()) ? baseIsArguments : function(value) {\n          return isObjectLike(value) && hasOwnProperty.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n        };\n        var isArray = Array2.isArray;\n        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n        function isArrayLike(value) {\n          return value != null && isLength(value.length) && !isFunction(value);\n        }\n        function isArrayLikeObject(value) {\n          return isObjectLike(value) && isArrayLike(value);\n        }\n        function isBoolean(value) {\n          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;\n        }\n        var isBuffer = nativeIsBuffer || stubFalse;\n        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n        function isElement(value) {\n          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n        }\n        function isEmpty(value) {\n          if (value == null) {\n            return true;\n          }\n          if (isArrayLike(value) && (isArray(value) || typeof value == \"string\" || typeof value.splice == \"function\" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n            return !value.length;\n          }\n          var tag = getTag(value);\n          if (tag == mapTag || tag == setTag) {\n            return !value.size;\n          }\n          if (isPrototype(value)) {\n            return !baseKeys(value).length;\n          }\n          for (var key in value) {\n            if (hasOwnProperty.call(value, key)) {\n              return false;\n            }\n          }\n          return true;\n        }\n        function isEqual(value, other) {\n          return baseIsEqual(value, other);\n        }\n        function isEqualWith(value, other, customizer) {\n          customizer = typeof customizer == \"function\" ? customizer : undefined2;\n          var result2 = customizer ? customizer(value, other) : undefined2;\n          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;\n        }\n        function isError(value) {\n          if (!isObjectLike(value)) {\n            return false;\n          }\n          var tag = baseGetTag(value);\n          return tag == errorTag || tag == domExcTag || typeof value.message == \"string\" && typeof value.name == \"string\" && !isPlainObject(value);\n        }\n        function isFinite2(value) {\n          return typeof value == \"number\" && nativeIsFinite(value);\n        }\n        function isFunction(value) {\n          if (!isObject(value)) {\n            return false;\n          }\n          var tag = baseGetTag(value);\n          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n        }\n        function isInteger(value) {\n          return typeof value == \"number\" && value == toInteger(value);\n        }\n        function isLength(value) {\n          return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n        }\n        function isObject(value) {\n          var type = typeof value;\n          return value != null && (type == \"object\" || type == \"function\");\n        }\n        function isObjectLike(value) {\n          return value != null && typeof value == \"object\";\n        }\n        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n        function isMatch(object, source) {\n          return object === source || baseIsMatch(object, source, getMatchData(source));\n        }\n        function isMatchWith(object, source, customizer) {\n          customizer = typeof customizer == \"function\" ? customizer : undefined2;\n          return baseIsMatch(object, source, getMatchData(source), customizer);\n        }\n        function isNaN2(value) {\n          return isNumber(value) && value != +value;\n        }\n        function isNative(value) {\n          if (isMaskable(value)) {\n            throw new Error2(CORE_ERROR_TEXT);\n          }\n          return baseIsNative(value);\n        }\n        function isNull(value) {\n          return value === null;\n        }\n        function isNil(value) {\n          return value == null;\n        }\n        function isNumber(value) {\n          return typeof value == \"number\" || isObjectLike(value) && baseGetTag(value) == numberTag;\n        }\n        function isPlainObject(value) {\n          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n            return false;\n          }\n          var proto = getPrototype(value);\n          if (proto === null) {\n            return true;\n          }\n          var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n          return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n        }\n        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n        function isSafeInteger(value) {\n          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n        }\n        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n        function isString(value) {\n          return typeof value == \"string\" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;\n        }\n        function isSymbol(value) {\n          return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag;\n        }\n        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n        function isUndefined(value) {\n          return value === undefined2;\n        }\n        function isWeakMap(value) {\n          return isObjectLike(value) && getTag(value) == weakMapTag;\n        }\n        function isWeakSet(value) {\n          return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n        }\n        var lt = createRelationalOperation(baseLt);\n        var lte = createRelationalOperation(function(value, other) {\n          return value <= other;\n        });\n        function toArray(value) {\n          if (!value) {\n            return [];\n          }\n          if (isArrayLike(value)) {\n            return isString(value) ? stringToArray(value) : copyArray(value);\n          }\n          if (symIterator && value[symIterator]) {\n            return iteratorToArray(value[symIterator]());\n          }\n          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;\n          return func(value);\n        }\n        function toFinite(value) {\n          if (!value) {\n            return value === 0 ? value : 0;\n          }\n          value = toNumber(value);\n          if (value === INFINITY || value === -INFINITY) {\n            var sign = value < 0 ? -1 : 1;\n            return sign * MAX_INTEGER;\n          }\n          return value === value ? value : 0;\n        }\n        function toInteger(value) {\n          var result2 = toFinite(value), remainder = result2 % 1;\n          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;\n        }\n        function toLength(value) {\n          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n        }\n        function toNumber(value) {\n          if (typeof value == \"number\") {\n            return value;\n          }\n          if (isSymbol(value)) {\n            return NAN;\n          }\n          if (isObject(value)) {\n            var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n            value = isObject(other) ? other + \"\" : other;\n          }\n          if (typeof value != \"string\") {\n            return value === 0 ? value : +value;\n          }\n          value = baseTrim(value);\n          var isBinary = reIsBinary.test(value);\n          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n        }\n        function toPlainObject(value) {\n          return copyObject(value, keysIn(value));\n        }\n        function toSafeInteger(value) {\n          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;\n        }\n        function toString(value) {\n          return value == null ? \"\" : baseToString(value);\n        }\n        var assign = createAssigner(function(object, source) {\n          if (isPrototype(source) || isArrayLike(source)) {\n            copyObject(source, keys(source), object);\n            return;\n          }\n          for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n              assignValue(object, key, source[key]);\n            }\n          }\n        });\n        var assignIn = createAssigner(function(object, source) {\n          copyObject(source, keysIn(source), object);\n        });\n        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n          copyObject(source, keysIn(source), object, customizer);\n        });\n        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n          copyObject(source, keys(source), object, customizer);\n        });\n        var at = flatRest(baseAt);\n        function create(prototype, properties) {\n          var result2 = baseCreate(prototype);\n          return properties == null ? result2 : baseAssign(result2, properties);\n        }\n        var defaults = baseRest(function(object, sources) {\n          object = Object2(object);\n          var index = -1;\n          var length = sources.length;\n          var guard = length > 2 ? sources[2] : undefined2;\n          if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n            length = 1;\n          }\n          while (++index < length) {\n            var source = sources[index];\n            var props = keysIn(source);\n            var propsIndex = -1;\n            var propsLength = props.length;\n            while (++propsIndex < propsLength) {\n              var key = props[propsIndex];\n              var value = object[key];\n              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {\n                object[key] = source[key];\n              }\n            }\n          }\n          return object;\n        });\n        var defaultsDeep = baseRest(function(args) {\n          args.push(undefined2, customDefaultsMerge);\n          return apply(mergeWith, undefined2, args);\n        });\n        function findKey(object, predicate) {\n          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n        }\n        function findLastKey(object, predicate) {\n          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n        }\n        function forIn(object, iteratee2) {\n          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);\n        }\n        function forInRight(object, iteratee2) {\n          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);\n        }\n        function forOwn(object, iteratee2) {\n          return object && baseForOwn(object, getIteratee(iteratee2, 3));\n        }\n        function forOwnRight(object, iteratee2) {\n          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));\n        }\n        function functions(object) {\n          return object == null ? [] : baseFunctions(object, keys(object));\n        }\n        function functionsIn(object) {\n          return object == null ? [] : baseFunctions(object, keysIn(object));\n        }\n        function get(object, path, defaultValue) {\n          var result2 = object == null ? undefined2 : baseGet(object, path);\n          return result2 === undefined2 ? defaultValue : result2;\n        }\n        function has(object, path) {\n          return object != null && hasPath(object, path, baseHas);\n        }\n        function hasIn(object, path) {\n          return object != null && hasPath(object, path, baseHasIn);\n        }\n        var invert = createInverter(function(result2, value, key) {\n          if (value != null && typeof value.toString != \"function\") {\n            value = nativeObjectToString.call(value);\n          }\n          result2[value] = key;\n        }, constant(identity));\n        var invertBy = createInverter(function(result2, value, key) {\n          if (value != null && typeof value.toString != \"function\") {\n            value = nativeObjectToString.call(value);\n          }\n          if (hasOwnProperty.call(result2, value)) {\n            result2[value].push(key);\n          } else {\n            result2[value] = [key];\n          }\n        }, getIteratee);\n        var invoke = baseRest(baseInvoke);\n        function keys(object) {\n          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n        }\n        function keysIn(object) {\n          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n        }\n        function mapKeys(object, iteratee2) {\n          var result2 = {};\n          iteratee2 = getIteratee(iteratee2, 3);\n          baseForOwn(object, function(value, key, object2) {\n            baseAssignValue(result2, iteratee2(value, key, object2), value);\n          });\n          return result2;\n        }\n        function mapValues(object, iteratee2) {\n          var result2 = {};\n          iteratee2 = getIteratee(iteratee2, 3);\n          baseForOwn(object, function(value, key, object2) {\n            baseAssignValue(result2, key, iteratee2(value, key, object2));\n          });\n          return result2;\n        }\n        var merge = createAssigner(function(object, source, srcIndex) {\n          baseMerge(object, source, srcIndex);\n        });\n        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n          baseMerge(object, source, srcIndex, customizer);\n        });\n        var omit = flatRest(function(object, paths) {\n          var result2 = {};\n          if (object == null) {\n            return result2;\n          }\n          var isDeep = false;\n          paths = arrayMap(paths, function(path) {\n            path = castPath(path, object);\n            isDeep || (isDeep = path.length > 1);\n            return path;\n          });\n          copyObject(object, getAllKeysIn(object), result2);\n          if (isDeep) {\n            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n          }\n          var length = paths.length;\n          while (length--) {\n            baseUnset(result2, paths[length]);\n          }\n          return result2;\n        });\n        function omitBy(object, predicate) {\n          return pickBy(object, negate(getIteratee(predicate)));\n        }\n        var pick = flatRest(function(object, paths) {\n          return object == null ? {} : basePick(object, paths);\n        });\n        function pickBy(object, predicate) {\n          if (object == null) {\n            return {};\n          }\n          var props = arrayMap(getAllKeysIn(object), function(prop) {\n            return [prop];\n          });\n          predicate = getIteratee(predicate);\n          return basePickBy(object, props, function(value, path) {\n            return predicate(value, path[0]);\n          });\n        }\n        function result(object, path, defaultValue) {\n          path = castPath(path, object);\n          var index = -1, length = path.length;\n          if (!length) {\n            length = 1;\n            object = undefined2;\n          }\n          while (++index < length) {\n            var value = object == null ? undefined2 : object[toKey(path[index])];\n            if (value === undefined2) {\n              index = length;\n              value = defaultValue;\n            }\n            object = isFunction(value) ? value.call(object) : value;\n          }\n          return object;\n        }\n        function set(object, path, value) {\n          return object == null ? object : baseSet(object, path, value);\n        }\n        function setWith(object, path, value, customizer) {\n          customizer = typeof customizer == \"function\" ? customizer : undefined2;\n          return object == null ? object : baseSet(object, path, value, customizer);\n        }\n        var toPairs = createToPairs(keys);\n        var toPairsIn = createToPairs(keysIn);\n        function transform(object, iteratee2, accumulator) {\n          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n          iteratee2 = getIteratee(iteratee2, 4);\n          if (accumulator == null) {\n            var Ctor = object && object.constructor;\n            if (isArrLike) {\n              accumulator = isArr ? new Ctor() : [];\n            } else if (isObject(object)) {\n              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n            } else {\n              accumulator = {};\n            }\n          }\n          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {\n            return iteratee2(accumulator, value, index, object2);\n          });\n          return accumulator;\n        }\n        function unset(object, path) {\n          return object == null ? true : baseUnset(object, path);\n        }\n        function update(object, path, updater) {\n          return object == null ? object : baseUpdate(object, path, castFunction(updater));\n        }\n        function updateWith(object, path, updater, customizer) {\n          customizer = typeof customizer == \"function\" ? customizer : undefined2;\n          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n        }\n        function values(object) {\n          return object == null ? [] : baseValues(object, keys(object));\n        }\n        function valuesIn(object) {\n          return object == null ? [] : baseValues(object, keysIn(object));\n        }\n        function clamp(number, lower, upper) {\n          if (upper === undefined2) {\n            upper = lower;\n            lower = undefined2;\n          }\n          if (upper !== undefined2) {\n            upper = toNumber(upper);\n            upper = upper === upper ? upper : 0;\n          }\n          if (lower !== undefined2) {\n            lower = toNumber(lower);\n            lower = lower === lower ? lower : 0;\n          }\n          return baseClamp(toNumber(number), lower, upper);\n        }\n        function inRange(number, start, end) {\n          start = toFinite(start);\n          if (end === undefined2) {\n            end = start;\n            start = 0;\n          } else {\n            end = toFinite(end);\n          }\n          number = toNumber(number);\n          return baseInRange(number, start, end);\n        }\n        function random(lower, upper, floating) {\n          if (floating && typeof floating != \"boolean\" && isIterateeCall(lower, upper, floating)) {\n            upper = floating = undefined2;\n          }\n          if (floating === undefined2) {\n            if (typeof upper == \"boolean\") {\n              floating = upper;\n              upper = undefined2;\n            } else if (typeof lower == \"boolean\") {\n              floating = lower;\n              lower = undefined2;\n            }\n          }\n          if (lower === undefined2 && upper === undefined2) {\n            lower = 0;\n            upper = 1;\n          } else {\n            lower = toFinite(lower);\n            if (upper === undefined2) {\n              upper = lower;\n              lower = 0;\n            } else {\n              upper = toFinite(upper);\n            }\n          }\n          if (lower > upper) {\n            var temp = lower;\n            lower = upper;\n            upper = temp;\n          }\n          if (floating || lower % 1 || upper % 1) {\n            var rand = nativeRandom();\n            return nativeMin(lower + rand * (upper - lower + freeParseFloat(\"1e-\" + ((rand + \"\").length - 1))), upper);\n          }\n          return baseRandom(lower, upper);\n        }\n        var camelCase = createCompounder(function(result2, word, index) {\n          word = word.toLowerCase();\n          return result2 + (index ? capitalize(word) : word);\n        });\n        function capitalize(string) {\n          return upperFirst(toString(string).toLowerCase());\n        }\n        function deburr(string) {\n          string = toString(string);\n          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, \"\");\n        }\n        function endsWith(string, target, position) {\n          string = toString(string);\n          target = baseToString(target);\n          var length = string.length;\n          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);\n          var end = position;\n          position -= target.length;\n          return position >= 0 && string.slice(position, end) == target;\n        }\n        function escape(string) {\n          string = toString(string);\n          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;\n        }\n        function escapeRegExp(string) {\n          string = toString(string);\n          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, \"\\\\$&\") : string;\n        }\n        var kebabCase = createCompounder(function(result2, word, index) {\n          return result2 + (index ? \"-\" : \"\") + word.toLowerCase();\n        });\n        var lowerCase = createCompounder(function(result2, word, index) {\n          return result2 + (index ? \" \" : \"\") + word.toLowerCase();\n        });\n        var lowerFirst = createCaseFirst(\"toLowerCase\");\n        function pad(string, length, chars) {\n          string = toString(string);\n          length = toInteger(length);\n          var strLength = length ? stringSize(string) : 0;\n          if (!length || strLength >= length) {\n            return string;\n          }\n          var mid = (length - strLength) / 2;\n          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);\n        }\n        function padEnd(string, length, chars) {\n          string = toString(string);\n          length = toInteger(length);\n          var strLength = length ? stringSize(string) : 0;\n          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;\n        }\n        function padStart(string, length, chars) {\n          string = toString(string);\n          length = toInteger(length);\n          var strLength = length ? stringSize(string) : 0;\n          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;\n        }\n        function parseInt2(string, radix, guard) {\n          if (guard || radix == null) {\n            radix = 0;\n          } else if (radix) {\n            radix = +radix;\n          }\n          return nativeParseInt(toString(string).replace(reTrimStart, \"\"), radix || 0);\n        }\n        function repeat(string, n, guard) {\n          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {\n            n = 1;\n          } else {\n            n = toInteger(n);\n          }\n          return baseRepeat(toString(string), n);\n        }\n        function replace() {\n          var args = arguments, string = toString(args[0]);\n          return args.length < 3 ? string : string.replace(args[1], args[2]);\n        }\n        var snakeCase = createCompounder(function(result2, word, index) {\n          return result2 + (index ? \"_\" : \"\") + word.toLowerCase();\n        });\n        function split(string, separator, limit) {\n          if (limit && typeof limit != \"number\" && isIterateeCall(string, separator, limit)) {\n            separator = limit = undefined2;\n          }\n          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;\n          if (!limit) {\n            return [];\n          }\n          string = toString(string);\n          if (string && (typeof separator == \"string\" || separator != null && !isRegExp(separator))) {\n            separator = baseToString(separator);\n            if (!separator && hasUnicode(string)) {\n              return castSlice(stringToArray(string), 0, limit);\n            }\n          }\n          return string.split(separator, limit);\n        }\n        var startCase = createCompounder(function(result2, word, index) {\n          return result2 + (index ? \" \" : \"\") + upperFirst(word);\n        });\n        function startsWith(string, target, position) {\n          string = toString(string);\n          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);\n          target = baseToString(target);\n          return string.slice(position, position + target.length) == target;\n        }\n        function template(string, options, guard) {\n          var settings = lodash.templateSettings;\n          if (guard && isIterateeCall(string, options, guard)) {\n            options = undefined2;\n          }\n          string = toString(string);\n          options = assignInWith({}, options, settings, customDefaultsAssignIn);\n          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);\n          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = \"__p += '\";\n          var reDelimiters = RegExp2(\n            (options.escape || reNoMatch).source + \"|\" + interpolate.source + \"|\" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + \"|\" + (options.evaluate || reNoMatch).source + \"|$\",\n            \"g\"\n          );\n          var sourceURL = \"//# sourceURL=\" + (hasOwnProperty.call(options, \"sourceURL\") ? (options.sourceURL + \"\").replace(/\\s/g, \" \") : \"lodash.templateSources[\" + ++templateCounter + \"]\") + \"\\n\";\n          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n            interpolateValue || (interpolateValue = esTemplateValue);\n            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n            if (escapeValue) {\n              isEscaping = true;\n              source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n            }\n            if (evaluateValue) {\n              isEvaluating = true;\n              source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n            }\n            if (interpolateValue) {\n              source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n            }\n            index = offset + match.length;\n            return match;\n          });\n          source += \"';\\n\";\n          var variable = hasOwnProperty.call(options, \"variable\") && options.variable;\n          if (!variable) {\n            source = \"with (obj) {\\n\" + source + \"\\n}\\n\";\n          } else if (reForbiddenIdentifierChars.test(variable)) {\n            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);\n          }\n          source = (isEvaluating ? source.replace(reEmptyStringLeading, \"\") : source).replace(reEmptyStringMiddle, \"$1\").replace(reEmptyStringTrailing, \"$1;\");\n          source = \"function(\" + (variable || \"obj\") + \") {\\n\" + (variable ? \"\" : \"obj || (obj = {});\\n\") + \"var __t, __p = ''\" + (isEscaping ? \", __e = _.escape\" : \"\") + (isEvaluating ? \", __j = Array.prototype.join;\\nfunction print() { __p += __j.call(arguments, '') }\\n\" : \";\\n\") + source + \"return __p\\n}\";\n          var result2 = attempt(function() {\n            return Function2(importsKeys, sourceURL + \"return \" + source).apply(undefined2, importsValues);\n          });\n          result2.source = source;\n          if (isError(result2)) {\n            throw result2;\n          }\n          return result2;\n        }\n        function toLower(value) {\n          return toString(value).toLowerCase();\n        }\n        function toUpper(value) {\n          return toString(value).toUpperCase();\n        }\n        function trim(string, chars, guard) {\n          string = toString(string);\n          if (string && (guard || chars === undefined2)) {\n            return baseTrim(string);\n          }\n          if (!string || !(chars = baseToString(chars))) {\n            return string;\n          }\n          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;\n          return castSlice(strSymbols, start, end).join(\"\");\n        }\n        function trimEnd(string, chars, guard) {\n          string = toString(string);\n          if (string && (guard || chars === undefined2)) {\n            return string.slice(0, trimmedEndIndex(string) + 1);\n          }\n          if (!string || !(chars = baseToString(chars))) {\n            return string;\n          }\n          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n          return castSlice(strSymbols, 0, end).join(\"\");\n        }\n        function trimStart(string, chars, guard) {\n          string = toString(string);\n          if (string && (guard || chars === undefined2)) {\n            return string.replace(reTrimStart, \"\");\n          }\n          if (!string || !(chars = baseToString(chars))) {\n            return string;\n          }\n          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));\n          return castSlice(strSymbols, start).join(\"\");\n        }\n        function truncate(string, options) {\n          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;\n          if (isObject(options)) {\n            var separator = \"separator\" in options ? options.separator : separator;\n            length = \"length\" in options ? toInteger(options.length) : length;\n            omission = \"omission\" in options ? baseToString(options.omission) : omission;\n          }\n          string = toString(string);\n          var strLength = string.length;\n          if (hasUnicode(string)) {\n            var strSymbols = stringToArray(string);\n            strLength = strSymbols.length;\n          }\n          if (length >= strLength) {\n            return string;\n          }\n          var end = length - stringSize(omission);\n          if (end < 1) {\n            return omission;\n          }\n          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join(\"\") : string.slice(0, end);\n          if (separator === undefined2) {\n            return result2 + omission;\n          }\n          if (strSymbols) {\n            end += result2.length - end;\n          }\n          if (isRegExp(separator)) {\n            if (string.slice(end).search(separator)) {\n              var match, substring = result2;\n              if (!separator.global) {\n                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + \"g\");\n              }\n              separator.lastIndex = 0;\n              while (match = separator.exec(substring)) {\n                var newEnd = match.index;\n              }\n              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);\n            }\n          } else if (string.indexOf(baseToString(separator), end) != end) {\n            var index = result2.lastIndexOf(separator);\n            if (index > -1) {\n              result2 = result2.slice(0, index);\n            }\n          }\n          return result2 + omission;\n        }\n        function unescape(string) {\n          string = toString(string);\n          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;\n        }\n        var upperCase = createCompounder(function(result2, word, index) {\n          return result2 + (index ? \" \" : \"\") + word.toUpperCase();\n        });\n        var upperFirst = createCaseFirst(\"toUpperCase\");\n        function words(string, pattern, guard) {\n          string = toString(string);\n          pattern = guard ? undefined2 : pattern;\n          if (pattern === undefined2) {\n            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n          }\n          return string.match(pattern) || [];\n        }\n        var attempt = baseRest(function(func, args) {\n          try {\n            return apply(func, undefined2, args);\n          } catch (e) {\n            return isError(e) ? e : new Error2(e);\n          }\n        });\n        var bindAll = flatRest(function(object, methodNames) {\n          arrayEach(methodNames, function(key) {\n            key = toKey(key);\n            baseAssignValue(object, key, bind(object[key], object));\n          });\n          return object;\n        });\n        function cond(pairs) {\n          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();\n          pairs = !length ? [] : arrayMap(pairs, function(pair) {\n            if (typeof pair[1] != \"function\") {\n              throw new TypeError2(FUNC_ERROR_TEXT);\n            }\n            return [toIteratee(pair[0]), pair[1]];\n          });\n          return baseRest(function(args) {\n            var index = -1;\n            while (++index < length) {\n              var pair = pairs[index];\n              if (apply(pair[0], this, args)) {\n                return apply(pair[1], this, args);\n              }\n            }\n          });\n        }\n        function conforms(source) {\n          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n        }\n        function constant(value) {\n          return function() {\n            return value;\n          };\n        }\n        function defaultTo(value, defaultValue) {\n          return value == null || value !== value ? defaultValue : value;\n        }\n        var flow = createFlow();\n        var flowRight = createFlow(true);\n        function identity(value) {\n          return value;\n        }\n        function iteratee(func) {\n          return baseIteratee(typeof func == \"function\" ? func : baseClone(func, CLONE_DEEP_FLAG));\n        }\n        function matches(source) {\n          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n        }\n        function matchesProperty(path, srcValue) {\n          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n        }\n        var method = baseRest(function(path, args) {\n          return function(object) {\n            return baseInvoke(object, path, args);\n          };\n        });\n        var methodOf = baseRest(function(object, args) {\n          return function(path) {\n            return baseInvoke(object, path, args);\n          };\n        });\n        function mixin(object, source, options) {\n          var props = keys(source), methodNames = baseFunctions(source, props);\n          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {\n            options = source;\n            source = object;\n            object = this;\n            methodNames = baseFunctions(source, keys(source));\n          }\n          var chain2 = !(isObject(options) && \"chain\" in options) || !!options.chain, isFunc = isFunction(object);\n          arrayEach(methodNames, function(methodName) {\n            var func = source[methodName];\n            object[methodName] = func;\n            if (isFunc) {\n              object.prototype[methodName] = function() {\n                var chainAll = this.__chain__;\n                if (chain2 || chainAll) {\n                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);\n                  actions.push({ \"func\": func, \"args\": arguments, \"thisArg\": object });\n                  result2.__chain__ = chainAll;\n                  return result2;\n                }\n                return func.apply(object, arrayPush([this.value()], arguments));\n              };\n            }\n          });\n          return object;\n        }\n        function noConflict() {\n          if (root._ === this) {\n            root._ = oldDash;\n          }\n          return this;\n        }\n        function noop() {\n        }\n        function nthArg(n) {\n          n = toInteger(n);\n          return baseRest(function(args) {\n            return baseNth(args, n);\n          });\n        }\n        var over = createOver(arrayMap);\n        var overEvery = createOver(arrayEvery);\n        var overSome = createOver(arraySome);\n        function property(path) {\n          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n        }\n        function propertyOf(object) {\n          return function(path) {\n            return object == null ? undefined2 : baseGet(object, path);\n          };\n        }\n        var range = createRange();\n        var rangeRight = createRange(true);\n        function stubArray() {\n          return [];\n        }\n        function stubFalse() {\n          return false;\n        }\n        function stubObject() {\n          return {};\n        }\n        function stubString() {\n          return \"\";\n        }\n        function stubTrue() {\n          return true;\n        }\n        function times(n, iteratee2) {\n          n = toInteger(n);\n          if (n < 1 || n > MAX_SAFE_INTEGER) {\n            return [];\n          }\n          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);\n          iteratee2 = getIteratee(iteratee2);\n          n -= MAX_ARRAY_LENGTH;\n          var result2 = baseTimes(length, iteratee2);\n          while (++index < n) {\n            iteratee2(index);\n          }\n          return result2;\n        }\n        function toPath(value) {\n          if (isArray(value)) {\n            return arrayMap(value, toKey);\n          }\n          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n        }\n        function uniqueId(prefix) {\n          var id = ++idCounter;\n          return toString(prefix) + id;\n        }\n        var add = createMathOperation(function(augend, addend) {\n          return augend + addend;\n        }, 0);\n        var ceil = createRound(\"ceil\");\n        var divide = createMathOperation(function(dividend, divisor) {\n          return dividend / divisor;\n        }, 1);\n        var floor = createRound(\"floor\");\n        function max(array) {\n          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;\n        }\n        function maxBy(array, iteratee2) {\n          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;\n        }\n        function mean(array) {\n          return baseMean(array, identity);\n        }\n        function meanBy(array, iteratee2) {\n          return baseMean(array, getIteratee(iteratee2, 2));\n        }\n        function min(array) {\n          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;\n        }\n        function minBy(array, iteratee2) {\n          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;\n        }\n        var multiply = createMathOperation(function(multiplier, multiplicand) {\n          return multiplier * multiplicand;\n        }, 1);\n        var round = createRound(\"round\");\n        var subtract = createMathOperation(function(minuend, subtrahend) {\n          return minuend - subtrahend;\n        }, 0);\n        function sum(array) {\n          return array && array.length ? baseSum(array, identity) : 0;\n        }\n        function sumBy(array, iteratee2) {\n          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;\n        }\n        lodash.after = after;\n        lodash.ary = ary;\n        lodash.assign = assign;\n        lodash.assignIn = assignIn;\n        lodash.assignInWith = assignInWith;\n        lodash.assignWith = assignWith;\n        lodash.at = at;\n        lodash.before = before;\n        lodash.bind = bind;\n        lodash.bindAll = bindAll;\n        lodash.bindKey = bindKey;\n        lodash.castArray = castArray;\n        lodash.chain = chain;\n        lodash.chunk = chunk;\n        lodash.compact = compact;\n        lodash.concat = concat;\n        lodash.cond = cond;\n        lodash.conforms = conforms;\n        lodash.constant = constant;\n        lodash.countBy = countBy;\n        lodash.create = create;\n        lodash.curry = curry;\n        lodash.curryRight = curryRight;\n        lodash.debounce = debounce;\n        lodash.defaults = defaults;\n        lodash.defaultsDeep = defaultsDeep;\n        lodash.defer = defer;\n        lodash.delay = delay;\n        lodash.difference = difference;\n        lodash.differenceBy = differenceBy;\n        lodash.differenceWith = differenceWith;\n        lodash.drop = drop;\n        lodash.dropRight = dropRight;\n        lodash.dropRightWhile = dropRightWhile;\n        lodash.dropWhile = dropWhile;\n        lodash.fill = fill;\n        lodash.filter = filter;\n        lodash.flatMap = flatMap;\n        lodash.flatMapDeep = flatMapDeep;\n        lodash.flatMapDepth = flatMapDepth;\n        lodash.flatten = flatten;\n        lodash.flattenDeep = flattenDeep;\n        lodash.flattenDepth = flattenDepth;\n        lodash.flip = flip;\n        lodash.flow = flow;\n        lodash.flowRight = flowRight;\n        lodash.fromPairs = fromPairs;\n        lodash.functions = functions;\n        lodash.functionsIn = functionsIn;\n        lodash.groupBy = groupBy;\n        lodash.initial = initial;\n        lodash.intersection = intersection;\n        lodash.intersectionBy = intersectionBy;\n        lodash.intersectionWith = intersectionWith;\n        lodash.invert = invert;\n        lodash.invertBy = invertBy;\n        lodash.invokeMap = invokeMap;\n        lodash.iteratee = iteratee;\n        lodash.keyBy = keyBy;\n        lodash.keys = keys;\n        lodash.keysIn = keysIn;\n        lodash.map = map;\n        lodash.mapKeys = mapKeys;\n        lodash.mapValues = mapValues;\n        lodash.matches = matches;\n        lodash.matchesProperty = matchesProperty;\n        lodash.memoize = memoize2;\n        lodash.merge = merge;\n        lodash.mergeWith = mergeWith;\n        lodash.method = method;\n        lodash.methodOf = methodOf;\n        lodash.mixin = mixin;\n        lodash.negate = negate;\n        lodash.nthArg = nthArg;\n        lodash.omit = omit;\n        lodash.omitBy = omitBy;\n        lodash.once = once;\n        lodash.orderBy = orderBy;\n        lodash.over = over;\n        lodash.overArgs = overArgs;\n        lodash.overEvery = overEvery;\n        lodash.overSome = overSome;\n        lodash.partial = partial;\n        lodash.partialRight = partialRight;\n        lodash.partition = partition;\n        lodash.pick = pick;\n        lodash.pickBy = pickBy;\n        lodash.property = property;\n        lodash.propertyOf = propertyOf;\n        lodash.pull = pull;\n        lodash.pullAll = pullAll;\n        lodash.pullAllBy = pullAllBy;\n        lodash.pullAllWith = pullAllWith;\n        lodash.pullAt = pullAt;\n        lodash.range = range;\n        lodash.rangeRight = rangeRight;\n        lodash.rearg = rearg;\n        lodash.reject = reject;\n        lodash.remove = remove;\n        lodash.rest = rest;\n        lodash.reverse = reverse;\n        lodash.sampleSize = sampleSize;\n        lodash.set = set;\n        lodash.setWith = setWith;\n        lodash.shuffle = shuffle;\n        lodash.slice = slice;\n        lodash.sortBy = sortBy;\n        lodash.sortedUniq = sortedUniq;\n        lodash.sortedUniqBy = sortedUniqBy;\n        lodash.split = split;\n        lodash.spread = spread;\n        lodash.tail = tail;\n        lodash.take = take;\n        lodash.takeRight = takeRight;\n        lodash.takeRightWhile = takeRightWhile;\n        lodash.takeWhile = takeWhile;\n        lodash.tap = tap;\n        lodash.throttle = throttle;\n        lodash.thru = thru;\n        lodash.toArray = toArray;\n        lodash.toPairs = toPairs;\n        lodash.toPairsIn = toPairsIn;\n        lodash.toPath = toPath;\n        lodash.toPlainObject = toPlainObject;\n        lodash.transform = transform;\n        lodash.unary = unary;\n        lodash.union = union;\n        lodash.unionBy = unionBy;\n        lodash.unionWith = unionWith;\n        lodash.uniq = uniq;\n        lodash.uniqBy = uniqBy;\n        lodash.uniqWith = uniqWith;\n        lodash.unset = unset;\n        lodash.unzip = unzip;\n        lodash.unzipWith = unzipWith;\n        lodash.update = update;\n        lodash.updateWith = updateWith;\n        lodash.values = values;\n        lodash.valuesIn = valuesIn;\n        lodash.without = without;\n        lodash.words = words;\n        lodash.wrap = wrap;\n        lodash.xor = xor;\n        lodash.xorBy = xorBy;\n        lodash.xorWith = xorWith;\n        lodash.zip = zip;\n        lodash.zipObject = zipObject;\n        lodash.zipObjectDeep = zipObjectDeep;\n        lodash.zipWith = zipWith;\n        lodash.entries = toPairs;\n        lodash.entriesIn = toPairsIn;\n        lodash.extend = assignIn;\n        lodash.extendWith = assignInWith;\n        mixin(lodash, lodash);\n        lodash.add = add;\n        lodash.attempt = attempt;\n        lodash.camelCase = camelCase;\n        lodash.capitalize = capitalize;\n        lodash.ceil = ceil;\n        lodash.clamp = clamp;\n        lodash.clone = clone;\n        lodash.cloneDeep = cloneDeep;\n        lodash.cloneDeepWith = cloneDeepWith;\n        lodash.cloneWith = cloneWith;\n        lodash.conformsTo = conformsTo;\n        lodash.deburr = deburr;\n        lodash.defaultTo = defaultTo;\n        lodash.divide = divide;\n        lodash.endsWith = endsWith;\n        lodash.eq = eq;\n        lodash.escape = escape;\n        lodash.escapeRegExp = escapeRegExp;\n        lodash.every = every;\n        lodash.find = find;\n        lodash.findIndex = findIndex;\n        lodash.findKey = findKey;\n        lodash.findLast = findLast;\n        lodash.findLastIndex = findLastIndex;\n        lodash.findLastKey = findLastKey;\n        lodash.floor = floor;\n        lodash.forEach = forEach;\n        lodash.forEachRight = forEachRight;\n        lodash.forIn = forIn;\n        lodash.forInRight = forInRight;\n        lodash.forOwn = forOwn;\n        lodash.forOwnRight = forOwnRight;\n        lodash.get = get;\n        lodash.gt = gt;\n        lodash.gte = gte;\n        lodash.has = has;\n        lodash.hasIn = hasIn;\n        lodash.head = head;\n        lodash.identity = identity;\n        lodash.includes = includes;\n        lodash.indexOf = indexOf;\n        lodash.inRange = inRange;\n        lodash.invoke = invoke;\n        lodash.isArguments = isArguments;\n        lodash.isArray = isArray;\n        lodash.isArrayBuffer = isArrayBuffer;\n        lodash.isArrayLike = isArrayLike;\n        lodash.isArrayLikeObject = isArrayLikeObject;\n        lodash.isBoolean = isBoolean;\n        lodash.isBuffer = isBuffer;\n        lodash.isDate = isDate;\n        lodash.isElement = isElement;\n        lodash.isEmpty = isEmpty;\n        lodash.isEqual = isEqual;\n        lodash.isEqualWith = isEqualWith;\n        lodash.isError = isError;\n        lodash.isFinite = isFinite2;\n        lodash.isFunction = isFunction;\n        lodash.isInteger = isInteger;\n        lodash.isLength = isLength;\n        lodash.isMap = isMap;\n        lodash.isMatch = isMatch;\n        lodash.isMatchWith = isMatchWith;\n        lodash.isNaN = isNaN2;\n        lodash.isNative = isNative;\n        lodash.isNil = isNil;\n        lodash.isNull = isNull;\n        lodash.isNumber = isNumber;\n        lodash.isObject = isObject;\n        lodash.isObjectLike = isObjectLike;\n        lodash.isPlainObject = isPlainObject;\n        lodash.isRegExp = isRegExp;\n        lodash.isSafeInteger = isSafeInteger;\n        lodash.isSet = isSet;\n        lodash.isString = isString;\n        lodash.isSymbol = isSymbol;\n        lodash.isTypedArray = isTypedArray;\n        lodash.isUndefined = isUndefined;\n        lodash.isWeakMap = isWeakMap;\n        lodash.isWeakSet = isWeakSet;\n        lodash.join = join;\n        lodash.kebabCase = kebabCase;\n        lodash.last = last;\n        lodash.lastIndexOf = lastIndexOf;\n        lodash.lowerCase = lowerCase;\n        lodash.lowerFirst = lowerFirst;\n        lodash.lt = lt;\n        lodash.lte = lte;\n        lodash.max = max;\n        lodash.maxBy = maxBy;\n        lodash.mean = mean;\n        lodash.meanBy = meanBy;\n        lodash.min = min;\n        lodash.minBy = minBy;\n        lodash.stubArray = stubArray;\n        lodash.stubFalse = stubFalse;\n        lodash.stubObject = stubObject;\n        lodash.stubString = stubString;\n        lodash.stubTrue = stubTrue;\n        lodash.multiply = multiply;\n        lodash.nth = nth;\n        lodash.noConflict = noConflict;\n        lodash.noop = noop;\n        lodash.now = now;\n        lodash.pad = pad;\n        lodash.padEnd = padEnd;\n        lodash.padStart = padStart;\n        lodash.parseInt = parseInt2;\n        lodash.random = random;\n        lodash.reduce = reduce;\n        lodash.reduceRight = reduceRight;\n        lodash.repeat = repeat;\n        lodash.replace = replace;\n        lodash.result = result;\n        lodash.round = round;\n        lodash.runInContext = runInContext2;\n        lodash.sample = sample;\n        lodash.size = size;\n        lodash.snakeCase = snakeCase;\n        lodash.some = some;\n        lodash.sortedIndex = sortedIndex;\n        lodash.sortedIndexBy = sortedIndexBy;\n        lodash.sortedIndexOf = sortedIndexOf;\n        lodash.sortedLastIndex = sortedLastIndex;\n        lodash.sortedLastIndexBy = sortedLastIndexBy;\n        lodash.sortedLastIndexOf = sortedLastIndexOf;\n        lodash.startCase = startCase;\n        lodash.startsWith = startsWith;\n        lodash.subtract = subtract;\n        lodash.sum = sum;\n        lodash.sumBy = sumBy;\n        lodash.template = template;\n        lodash.times = times;\n        lodash.toFinite = toFinite;\n        lodash.toInteger = toInteger;\n        lodash.toLength = toLength;\n        lodash.toLower = toLower;\n        lodash.toNumber = toNumber;\n        lodash.toSafeInteger = toSafeInteger;\n        lodash.toString = toString;\n        lodash.toUpper = toUpper;\n        lodash.trim = trim;\n        lodash.trimEnd = trimEnd;\n        lodash.trimStart = trimStart;\n        lodash.truncate = truncate;\n        lodash.unescape = unescape;\n        lodash.uniqueId = uniqueId;\n        lodash.upperCase = upperCase;\n        lodash.upperFirst = upperFirst;\n        lodash.each = forEach;\n        lodash.eachRight = forEachRight;\n        lodash.first = head;\n        mixin(lodash, function() {\n          var source = {};\n          baseForOwn(lodash, function(func, methodName) {\n            if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n              source[methodName] = func;\n            }\n          });\n          return source;\n        }(), { \"chain\": false });\n        lodash.VERSION = VERSION;\n        arrayEach([\"bind\", \"bindKey\", \"curry\", \"curryRight\", \"partial\", \"partialRight\"], function(methodName) {\n          lodash[methodName].placeholder = lodash;\n        });\n        arrayEach([\"drop\", \"take\"], function(methodName, index) {\n          LazyWrapper.prototype[methodName] = function(n) {\n            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);\n            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();\n            if (result2.__filtered__) {\n              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);\n            } else {\n              result2.__views__.push({\n                \"size\": nativeMin(n, MAX_ARRAY_LENGTH),\n                \"type\": methodName + (result2.__dir__ < 0 ? \"Right\" : \"\")\n              });\n            }\n            return result2;\n          };\n          LazyWrapper.prototype[methodName + \"Right\"] = function(n) {\n            return this.reverse()[methodName](n).reverse();\n          };\n        });\n        arrayEach([\"filter\", \"map\", \"takeWhile\"], function(methodName, index) {\n          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n          LazyWrapper.prototype[methodName] = function(iteratee2) {\n            var result2 = this.clone();\n            result2.__iteratees__.push({\n              \"iteratee\": getIteratee(iteratee2, 3),\n              \"type\": type\n            });\n            result2.__filtered__ = result2.__filtered__ || isFilter;\n            return result2;\n          };\n        });\n        arrayEach([\"head\", \"last\"], function(methodName, index) {\n          var takeName = \"take\" + (index ? \"Right\" : \"\");\n          LazyWrapper.prototype[methodName] = function() {\n            return this[takeName](1).value()[0];\n          };\n        });\n        arrayEach([\"initial\", \"tail\"], function(methodName, index) {\n          var dropName = \"drop\" + (index ? \"\" : \"Right\");\n          LazyWrapper.prototype[methodName] = function() {\n            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n          };\n        });\n        LazyWrapper.prototype.compact = function() {\n          return this.filter(identity);\n        };\n        LazyWrapper.prototype.find = function(predicate) {\n          return this.filter(predicate).head();\n        };\n        LazyWrapper.prototype.findLast = function(predicate) {\n          return this.reverse().find(predicate);\n        };\n        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n          if (typeof path == \"function\") {\n            return new LazyWrapper(this);\n          }\n          return this.map(function(value) {\n            return baseInvoke(value, path, args);\n          });\n        });\n        LazyWrapper.prototype.reject = function(predicate) {\n          return this.filter(negate(getIteratee(predicate)));\n        };\n        LazyWrapper.prototype.slice = function(start, end) {\n          start = toInteger(start);\n          var result2 = this;\n          if (result2.__filtered__ && (start > 0 || end < 0)) {\n            return new LazyWrapper(result2);\n          }\n          if (start < 0) {\n            result2 = result2.takeRight(-start);\n          } else if (start) {\n            result2 = result2.drop(start);\n          }\n          if (end !== undefined2) {\n            end = toInteger(end);\n            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);\n          }\n          return result2;\n        };\n        LazyWrapper.prototype.takeRightWhile = function(predicate) {\n          return this.reverse().takeWhile(predicate).reverse();\n        };\n        LazyWrapper.prototype.toArray = function() {\n          return this.take(MAX_ARRAY_LENGTH);\n        };\n        baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? \"take\" + (methodName == \"last\" ? \"Right\" : \"\") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);\n          if (!lodashFunc) {\n            return;\n          }\n          lodash.prototype[methodName] = function() {\n            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);\n            var interceptor = function(value2) {\n              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));\n              return isTaker && chainAll ? result3[0] : result3;\n            };\n            if (useLazy && checkIteratee && typeof iteratee2 == \"function\" && iteratee2.length != 1) {\n              isLazy = useLazy = false;\n            }\n            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;\n            if (!retUnwrapped && useLazy) {\n              value = onlyLazy ? value : new LazyWrapper(this);\n              var result2 = func.apply(value, args);\n              result2.__actions__.push({ \"func\": thru, \"args\": [interceptor], \"thisArg\": undefined2 });\n              return new LodashWrapper(result2, chainAll);\n            }\n            if (isUnwrapped && onlyLazy) {\n              return func.apply(this, args);\n            }\n            result2 = this.thru(interceptor);\n            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;\n          };\n        });\n        arrayEach([\"pop\", \"push\", \"shift\", \"sort\", \"splice\", \"unshift\"], function(methodName) {\n          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? \"tap\" : \"thru\", retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n          lodash.prototype[methodName] = function() {\n            var args = arguments;\n            if (retUnwrapped && !this.__chain__) {\n              var value = this.value();\n              return func.apply(isArray(value) ? value : [], args);\n            }\n            return this[chainName](function(value2) {\n              return func.apply(isArray(value2) ? value2 : [], args);\n            });\n          };\n        });\n        baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n          var lodashFunc = lodash[methodName];\n          if (lodashFunc) {\n            var key = lodashFunc.name + \"\";\n            if (!hasOwnProperty.call(realNames, key)) {\n              realNames[key] = [];\n            }\n            realNames[key].push({ \"name\": methodName, \"func\": lodashFunc });\n          }\n        });\n        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{\n          \"name\": \"wrapper\",\n          \"func\": undefined2\n        }];\n        LazyWrapper.prototype.clone = lazyClone;\n        LazyWrapper.prototype.reverse = lazyReverse;\n        LazyWrapper.prototype.value = lazyValue;\n        lodash.prototype.at = wrapperAt;\n        lodash.prototype.chain = wrapperChain;\n        lodash.prototype.commit = wrapperCommit;\n        lodash.prototype.next = wrapperNext;\n        lodash.prototype.plant = wrapperPlant;\n        lodash.prototype.reverse = wrapperReverse;\n        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n        lodash.prototype.first = lodash.prototype.head;\n        if (symIterator) {\n          lodash.prototype[symIterator] = wrapperToIterator;\n        }\n        return lodash;\n      };\n      var _ = runInContext();\n      if (typeof define == \"function\" && typeof define.amd == \"object\" && define.amd) {\n        root._ = _;\n        define(function() {\n          return _;\n        });\n      } else if (freeModule) {\n        (freeModule.exports = _)._ = _;\n        freeExports._ = _;\n      } else {\n        root._ = _;\n      }\n    }).call(exports);\n  }\n});\n\n// ../../node_modules/iota-array/iota.js\nvar require_iota = __commonJS({\n  \"../../node_modules/iota-array/iota.js\"(exports, module) {\n    \"use strict\";\n    function iota(n) {\n      var result = new Array(n);\n      for (var i = 0; i < n; ++i) {\n        result[i] = i;\n      }\n      return result;\n    }\n    module.exports = iota;\n  }\n});\n\n// ../../node_modules/is-buffer/index.js\nvar require_is_buffer = __commonJS({\n  \"../../node_modules/is-buffer/index.js\"(exports, module) {\n    module.exports = function(obj) {\n      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n    };\n    function isBuffer(obj) {\n      return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n    }\n    function isSlowBuffer(obj) {\n      return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isBuffer(obj.slice(0, 0));\n    }\n  }\n});\n\n// ../../node_modules/ndarray/ndarray.js\nvar require_ndarray = __commonJS({\n  \"../../node_modules/ndarray/ndarray.js\"(exports, module) {\n    var iota = require_iota();\n    var isBuffer = require_is_buffer();\n    var hasTypedArrays = typeof Float64Array !== \"undefined\";\n    function compare1st(a, b) {\n      return a[0] - b[0];\n    }\n    function order() {\n      var stride = this.stride;\n      var terms = new Array(stride.length);\n      var i;\n      for (i = 0; i < terms.length; ++i) {\n        terms[i] = [Math.abs(stride[i]), i];\n      }\n      terms.sort(compare1st);\n      var result = new Array(terms.length);\n      for (i = 0; i < result.length; ++i) {\n        result[i] = terms[i][1];\n      }\n      return result;\n    }\n    function compileConstructor(dtype, dimension) {\n      var className = [\"View\", dimension, \"d\", dtype].join(\"\");\n      if (dimension < 0) {\n        className = \"View_Nil\" + dtype;\n      }\n      var useGetters = dtype === \"generic\";\n      if (dimension === -1) {\n        var code = \"function \" + className + \"(a){this.data=a;};var proto=\" + className + \".prototype;proto.dtype='\" + dtype + \"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new \" + className + \"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_\" + className + \"(a){return new \" + className + \"(a);}\";\n        var procedure = new Function(code);\n        return procedure();\n      } else if (dimension === 0) {\n        var code = \"function \" + className + \"(a,d) {this.data = a;this.offset = d};var proto=\" + className + \".prototype;proto.dtype='\" + dtype + \"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function \" + className + \"_copy() {return new \" + className + \"(this.data,this.offset)};proto.pick=function \" + className + \"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function \" + className + \"_get(){return \" + (useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\") + \"};proto.set=function \" + className + \"_set(v){return \" + (useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\") + \"};return function construct_\" + className + \"(a,b,c,d){return new \" + className + \"(a,d)}\";\n        var procedure = new Function(\"TrivialArray\", code);\n        return procedure(CACHED_CONSTRUCTORS[dtype][0]);\n      }\n      var code = [\"'use strict'\"];\n      var indices = iota(dimension);\n      var args = indices.map(function(i2) {\n        return \"i\" + i2;\n      });\n      var index_str = \"this.offset+\" + indices.map(function(i2) {\n        return \"this.stride[\" + i2 + \"]*i\" + i2;\n      }).join(\"+\");\n      var shapeArg = indices.map(function(i2) {\n        return \"b\" + i2;\n      }).join(\",\");\n      var strideArg = indices.map(function(i2) {\n        return \"c\" + i2;\n      }).join(\",\");\n      code.push(\n        \"function \" + className + \"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n        \"this.shape=[\" + shapeArg + \"]\",\n        \"this.stride=[\" + strideArg + \"]\",\n        \"this.offset=d|0}\",\n        \"var proto=\" + className + \".prototype\",\n        \"proto.dtype='\" + dtype + \"'\",\n        \"proto.dimension=\" + dimension\n      );\n      code.push(\n        \"Object.defineProperty(proto,'size',{get:function \" + className + \"_size(){return \" + indices.map(function(i2) {\n          return \"this.shape[\" + i2 + \"]\";\n        }).join(\"*\"),\n        \"}})\"\n      );\n      if (dimension === 1) {\n        code.push(\"proto.order=[0]\");\n      } else {\n        code.push(\"Object.defineProperty(proto,'order',{get:\");\n        if (dimension < 4) {\n          code.push(\"function \" + className + \"_order(){\");\n          if (dimension === 2) {\n            code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\");\n          } else if (dimension === 3) {\n            code.push(\n              \"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})\"\n            );\n          }\n        } else {\n          code.push(\"ORDER})\");\n        }\n      }\n      code.push(\n        \"proto.set=function \" + className + \"_set(\" + args.join(\",\") + \",v){\"\n      );\n      if (useGetters) {\n        code.push(\"return this.data.set(\" + index_str + \",v)}\");\n      } else {\n        code.push(\"return this.data[\" + index_str + \"]=v}\");\n      }\n      code.push(\"proto.get=function \" + className + \"_get(\" + args.join(\",\") + \"){\");\n      if (useGetters) {\n        code.push(\"return this.data.get(\" + index_str + \")}\");\n      } else {\n        code.push(\"return this.data[\" + index_str + \"]}\");\n      }\n      code.push(\n        \"proto.index=function \" + className + \"_index(\",\n        args.join(),\n        \"){return \" + index_str + \"}\"\n      );\n      code.push(\"proto.hi=function \" + className + \"_hi(\" + args.join(\",\") + \"){return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n        return [\"(typeof i\", i2, \"!=='number'||i\", i2, \"<0)?this.shape[\", i2, \"]:i\", i2, \"|0\"].join(\"\");\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"this.stride[\" + i2 + \"]\";\n      }).join(\",\") + \",this.offset)}\");\n      var a_vars = indices.map(function(i2) {\n        return \"a\" + i2 + \"=this.shape[\" + i2 + \"]\";\n      });\n      var c_vars = indices.map(function(i2) {\n        return \"c\" + i2 + \"=this.stride[\" + i2 + \"]\";\n      });\n      code.push(\"proto.lo=function \" + className + \"_lo(\" + args.join(\",\") + \"){var b=this.offset,d=0,\" + a_vars.join(\",\") + \",\" + c_vars.join(\",\"));\n      for (var i = 0; i < dimension; ++i) {\n        code.push(\n          \"if(typeof i\" + i + \"==='number'&&i\" + i + \">=0){d=i\" + i + \"|0;b+=c\" + i + \"*d;a\" + i + \"-=d}\"\n        );\n      }\n      code.push(\"return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n        return \"a\" + i2;\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"c\" + i2;\n      }).join(\",\") + \",b)}\");\n      code.push(\"proto.step=function \" + className + \"_step(\" + args.join(\",\") + \"){var \" + indices.map(function(i2) {\n        return \"a\" + i2 + \"=this.shape[\" + i2 + \"]\";\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"b\" + i2 + \"=this.stride[\" + i2 + \"]\";\n      }).join(\",\") + \",c=this.offset,d=0,ceil=Math.ceil\");\n      for (var i = 0; i < dimension; ++i) {\n        code.push(\n          \"if(typeof i\" + i + \"==='number'){d=i\" + i + \"|0;if(d<0){c+=b\" + i + \"*(a\" + i + \"-1);a\" + i + \"=ceil(-a\" + i + \"/d)}else{a\" + i + \"=ceil(a\" + i + \"/d)}b\" + i + \"*=d}\"\n        );\n      }\n      code.push(\"return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n        return \"a\" + i2;\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"b\" + i2;\n      }).join(\",\") + \",c)}\");\n      var tShape = new Array(dimension);\n      var tStride = new Array(dimension);\n      for (var i = 0; i < dimension; ++i) {\n        tShape[i] = \"a[i\" + i + \"]\";\n        tStride[i] = \"b[i\" + i + \"]\";\n      }\n      code.push(\n        \"proto.transpose=function \" + className + \"_transpose(\" + args + \"){\" + args.map(function(n, idx) {\n          return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\";\n        }).join(\";\"),\n        \"var a=this.shape,b=this.stride;return new \" + className + \"(this.data,\" + tShape.join(\",\") + \",\" + tStride.join(\",\") + \",this.offset)}\"\n      );\n      code.push(\"proto.pick=function \" + className + \"_pick(\" + args + \"){var a=[],b=[],c=this.offset\");\n      for (var i = 0; i < dimension; ++i) {\n        code.push(\"if(typeof i\" + i + \"==='number'&&i\" + i + \">=0){c=(c+this.stride[\" + i + \"]*i\" + i + \")|0}else{a.push(this.shape[\" + i + \"]);b.push(this.stride[\" + i + \"])}\");\n      }\n      code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\");\n      code.push(\"return function construct_\" + className + \"(data,shape,stride,offset){return new \" + className + \"(data,\" + indices.map(function(i2) {\n        return \"shape[\" + i2 + \"]\";\n      }).join(\",\") + \",\" + indices.map(function(i2) {\n        return \"stride[\" + i2 + \"]\";\n      }).join(\",\") + \",offset)}\");\n      var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"));\n      return procedure(CACHED_CONSTRUCTORS[dtype], order);\n    }\n    function arrayDType(data) {\n      if (isBuffer(data)) {\n        return \"buffer\";\n      }\n      if (hasTypedArrays) {\n        switch (Object.prototype.toString.call(data)) {\n          case \"[object Float64Array]\":\n            return \"float64\";\n          case \"[object Float32Array]\":\n            return \"float32\";\n          case \"[object Int8Array]\":\n            return \"int8\";\n          case \"[object Int16Array]\":\n            return \"int16\";\n          case \"[object Int32Array]\":\n            return \"int32\";\n          case \"[object Uint8Array]\":\n            return \"uint8\";\n          case \"[object Uint16Array]\":\n            return \"uint16\";\n          case \"[object Uint32Array]\":\n            return \"uint32\";\n          case \"[object Uint8ClampedArray]\":\n            return \"uint8_clamped\";\n          case \"[object BigInt64Array]\":\n            return \"bigint64\";\n          case \"[object BigUint64Array]\":\n            return \"biguint64\";\n        }\n      }\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      return \"generic\";\n    }\n    var CACHED_CONSTRUCTORS = {\n      \"float32\": [],\n      \"float64\": [],\n      \"int8\": [],\n      \"int16\": [],\n      \"int32\": [],\n      \"uint8\": [],\n      \"uint16\": [],\n      \"uint32\": [],\n      \"array\": [],\n      \"uint8_clamped\": [],\n      \"bigint64\": [],\n      \"biguint64\": [],\n      \"buffer\": [],\n      \"generic\": []\n    };\n    function wrappedNDArrayCtor(data, shape, stride, offset) {\n      if (data === void 0) {\n        var ctor = CACHED_CONSTRUCTORS.array[0];\n        return ctor([]);\n      } else if (typeof data === \"number\") {\n        data = [data];\n      }\n      if (shape === void 0) {\n        shape = [data.length];\n      }\n      var d = shape.length;\n      if (stride === void 0) {\n        stride = new Array(d);\n        for (var i = d - 1, sz = 1; i >= 0; --i) {\n          stride[i] = sz;\n          sz *= shape[i];\n        }\n      }\n      if (offset === void 0) {\n        offset = 0;\n        for (var i = 0; i < d; ++i) {\n          if (stride[i] < 0) {\n            offset -= (shape[i] - 1) * stride[i];\n          }\n        }\n      }\n      var dtype = arrayDType(data);\n      var ctor_list = CACHED_CONSTRUCTORS[dtype];\n      while (ctor_list.length <= d + 1) {\n        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));\n      }\n      var ctor = ctor_list[d + 1];\n      return ctor(data, shape, stride, offset);\n    }\n    module.exports = wrappedNDArrayCtor;\n  }\n});\n\n// src/api/v1.ts\nvar import_lodash = __toESM(require_lodash());\n\n// src/utils.ts\nvar import_ndarray2 = __toESM(require_ndarray());\n\n// src/MimeType.ts\nvar MimeType = class _MimeType {\n  constructor(type, params) {\n    this.type = \"application/octet-stream\";\n    this.params = {};\n    this.type = type;\n    this.params = params;\n  }\n  toString() {\n    const paramsStr = [];\n    for (const key in this.params) {\n      const value = this.params[key];\n      paramsStr.push(`${key}=${value}`);\n    }\n    return [this.type, ...paramsStr].join(\";\");\n  }\n  static create(type, params) {\n    return new _MimeType(type, params);\n  }\n  isIdentical(other) {\n    return this.type === other.type && this.params === other.params;\n  }\n  isEqual(other) {\n    return this.type === other.type;\n  }\n  static fromString(mimeType) {\n    const [type, ...paramsArr] = mimeType.split(\";\");\n    const params = {};\n    for (const param of paramsArr) {\n      const [key, value] = param.split(\"=\");\n      params[key.trim()] = value.trim();\n    }\n    return new _MimeType(type, params);\n  }\n};\n\n// src/codecs.ts\nvar import_ndarray = __toESM(require_ndarray());\nasync function imageDecode(blob) {\n  const mime = MimeType.fromString(blob.type);\n  switch (mime.type) {\n    case \"image/x-alpha8\": {\n      const width = parseInt(mime.params[\"width\"]);\n      const height = parseInt(mime.params[\"height\"]);\n      return (0, import_ndarray.default)(new Uint8Array(await blob.arrayBuffer()), [\n        height,\n        width,\n        1\n      ]);\n    }\n    case \"image/x-rgba8\": {\n      const width = parseInt(mime.params[\"width\"]);\n      const height = parseInt(mime.params[\"height\"]);\n      return (0, import_ndarray.default)(new Uint8Array(await blob.arrayBuffer()), [\n        height,\n        width,\n        4\n      ]);\n    }\n    case \"application/octet-stream\":\n    case `image/png`:\n    case `image/jpeg`:\n    case `image/jpg`:\n    case `image/webp`: {\n      const imageBitmap = await createImageBitmap(blob);\n      const imageData = imageBitmapToImageData(imageBitmap);\n      return (0, import_ndarray.default)(new Uint8Array(imageData.data), [\n        imageData.height,\n        imageData.width,\n        4\n      ]);\n    }\n    default:\n      throw new Error(\n        `Invalid format: ${mime.type} with params: ${mime.params}`\n      );\n  }\n}\nasync function imageEncode(imageTensor, quality = 0.8, format = \"image/png\") {\n  const [height, width, channels] = imageTensor.shape;\n  switch (format) {\n    case \"image/x-alpha8\":\n    case \"image/x-rgba8\": {\n      const mime = MimeType.create(format, {\n        width: width.toString(),\n        height: height.toString()\n      });\n      return new Blob([imageTensor.data], { type: mime.toString() });\n    }\n    case `image/png`:\n    case `image/jpeg`:\n    case `image/webp`: {\n      const imageData = new ImageData(\n        new Uint8ClampedArray(imageTensor.data),\n        width,\n        height\n      );\n      var canvas = createCanvas(imageData.width, imageData.height);\n      var ctx = canvas.getContext(\"2d\");\n      ctx.putImageData(imageData, 0, 0);\n      return canvas.convertToBlob({ quality, type: format });\n    }\n    default:\n      throw new Error(`Invalid format: ${format}`);\n  }\n}\n\n// src/url.ts\nfunction isAbsoluteURI(url) {\n  const regExp = new RegExp(\"^(?:[a-z+]+:)?//\", \"i\");\n  return regExp.test(url);\n}\nfunction ensureAbsoluteURI(url, baseUrl) {\n  if (isAbsoluteURI(url)) {\n    return url;\n  } else {\n    return new URL(url, baseUrl).href;\n  }\n}\n\n// src/utils.ts\nfunction imageBitmapToImageData(imageBitmap) {\n  var canvas = createCanvas(imageBitmap.width, imageBitmap.height);\n  var ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageBitmap, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\nfunction createTypeArray(length) {\n  if (typeof Uint8Array !== \"undefined\") {\n    return new Uint8Array(length);\n  } else if (typeof Uint8ClampedArray !== \"undefined\") {\n    return new Uint8ClampedArray(length);\n  } else if (typeof Uint16Array !== \"undefined\") {\n    return new Uint16Array(length);\n  } else if (typeof Uint32Array !== \"undefined\") {\n    return new Uint32Array(length);\n  } else if (typeof Float32Array !== \"undefined\") {\n    return new Float32Array(length);\n  } else if (typeof Float64Array !== \"undefined\") {\n    return new Float64Array(length);\n  } else {\n    throw new Error(\"TypedArray not supported\");\n  }\n}\nfunction tensorResizeBilinear(imageTensor, newWidth, newHeight, proportional = false) {\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  let scaleX = srcWidth / newWidth;\n  let scaleY = srcHeight / newHeight;\n  if (proportional) {\n    const downscaling = Math.max(scaleX, scaleY) > 1;\n    scaleX = scaleY = downscaling ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);\n  }\n  const resizedImageData = (0, import_ndarray2.default)(\n    createTypeArray(srcChannels * newWidth * newHeight),\n    [newHeight, newWidth, srcChannels]\n  );\n  for (let y = 0; y < newHeight; y++) {\n    for (let x = 0; x < newWidth; x++) {\n      const srcX = x * scaleX;\n      const srcY = y * scaleY;\n      const x1 = Math.max(Math.floor(srcX), 0);\n      const x2 = Math.min(Math.ceil(srcX), srcWidth - 1);\n      const y1 = Math.max(Math.floor(srcY), 0);\n      const y2 = Math.min(Math.ceil(srcY), srcHeight - 1);\n      const dx = srcX - x1;\n      const dy = srcY - y1;\n      for (let c = 0; c < srcChannels; c++) {\n        const p1 = imageTensor.get(y1, x1, c);\n        const p2 = imageTensor.get(y1, x2, c);\n        const p3 = imageTensor.get(y2, x1, c);\n        const p4 = imageTensor.get(y2, x2, c);\n        const interpolatedValue = (1 - dx) * (1 - dy) * p1 + dx * (1 - dy) * p2 + (1 - dx) * dy * p3 + dx * dy * p4;\n        resizedImageData.set(y, x, c, interpolatedValue);\n      }\n    }\n  }\n  return resizedImageData;\n}\nfunction tensorHWCtoBCHW(imageTensor, mean = [128, 128, 128], std = [256, 256, 256]) {\n  var imageBufferData = imageTensor.data;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  const stride = srcHeight * srcWidth;\n  const float32Data = new Float32Array(3 * stride);\n  for (let i = 0, j = 0; i < imageBufferData.length; i += 4, j += 1) {\n    float32Data[j] = (imageBufferData[i] - mean[0]) / std[0];\n    float32Data[j + stride] = (imageBufferData[i + 1] - mean[1]) / std[1];\n    float32Data[j + stride + stride] = (imageBufferData[i + 2] - mean[2]) / std[2];\n  }\n  return (0, import_ndarray2.default)(float32Data, [1, 3, srcHeight, srcWidth]);\n}\nasync function imageSourceToImageData(image, config) {\n  if (typeof image === \"string\") {\n    image = ensureAbsoluteURI(image, config.publicPath);\n    image = new URL(image);\n  }\n  if (image instanceof URL) {\n    const response = await fetch(image, {});\n    image = await response.blob();\n  }\n  if (image instanceof ArrayBuffer || ArrayBuffer.isView(image)) {\n    image = new Blob([image]);\n  }\n  if (image instanceof Blob) {\n    image = await imageDecode(image);\n  }\n  return image;\n}\nfunction convertFloat32ToUint8(float32Array) {\n  const uint8Array = new Uint8Array(float32Array.data.length);\n  for (let i = 0; i < float32Array.data.length; i++) {\n    uint8Array[i] = float32Array.data[i] * 255;\n  }\n  return (0, import_ndarray2.default)(uint8Array, float32Array.shape);\n}\nfunction createCanvas(width, height) {\n  let canvas = void 0;\n  if (typeof OffscreenCanvas !== \"undefined\") {\n    canvas = new OffscreenCanvas(width, height);\n  } else {\n    canvas = document.createElement(\"canvas\");\n  }\n  if (!canvas) {\n    throw new Error(\n      `Canvas nor OffscreenCanvas are available in the current context.`\n    );\n  }\n  return canvas;\n}\n\n// src/onnx.ts\nvar import_ndarray3 = __toESM(require_ndarray());\n\n// src/capabilities.js\nvar webgpu = async () => {\n  if (navigator.gpu === void 0)\n    return false;\n  const adapter = await navigator.gpu.requestAdapter();\n  return adapter !== null;\n};\nvar maxNumThreads = () => navigator.hardwareConcurrency ?? 4;\n\n// src/resource.ts\nasync function loadAsUrl(url, config) {\n  return URL.createObjectURL(await loadAsBlob(url, config));\n}\nasync function loadAsBlob(key, config) {\n  const resourceUrl = new URL(\"resources.json\", config.publicPath);\n  const resourceResponse = await fetch(resourceUrl);\n  if (!resourceResponse.ok) {\n    throw new Error(\n      `Resource metadata not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n  const resourceMap = await resourceResponse.json();\n  const entry = resourceMap[key];\n  if (!entry) {\n    throw new Error(\n      `Resource ${key} not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n  const chunks = entry.chunks;\n  let downloadedSize = 0;\n  const responses = chunks.map(async (chunk) => {\n    const chunkSize = chunk.offsets[1] - chunk.offsets[0];\n    const url = config.publicPath ? new URL(chunk.name, config.publicPath).toString() : chunk.name;\n    const response = await fetch(url, config.fetchArgs);\n    const blob = await response.blob();\n    if (chunkSize !== blob.size) {\n      throw new Error(\n        `Failed to fetch ${key} with size ${chunkSize} but got ${blob.size}`\n      );\n    }\n    if (config.progress) {\n      downloadedSize += chunkSize;\n      config.progress(`fetch:${key}`, downloadedSize, entry.size);\n    }\n    return blob;\n  });\n  const allChunkData = await Promise.all(responses);\n  const data = new Blob(allChunkData, { type: entry.mime });\n  if (data.size !== entry.size) {\n    throw new Error(\n      `Failed to fetch ${key} with size ${entry.size} but got ${data.size}`\n    );\n  }\n  return data;\n}\n\n// src/onnx.ts\nvar ort = null;\nvar getOrt = async (useWebGPU) => {\n  if (ort !== null) {\n    return ort;\n  }\n  if (useWebGPU) {\n    ort = (await __webpack_require__.e(/*! import() */ \"vendors-node_modules_onnxruntime-web_dist_ort_webgpu_bundle_min_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! onnxruntime-web/webgpu */ \"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?79d7\"))).default;\n  } else {\n    ort = (await __webpack_require__.e(/*! import() */ \"vendors-node_modules_onnxruntime-web_dist_ort_bundle_min_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! onnxruntime-web */ \"./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?3a96\"))).default;\n  }\n  return ort;\n};\nasync function createOnnxSession(model, config) {\n  const useWebGPU = config.device === \"gpu\" && await webgpu();\n  const proxyToWorker = useWebGPU && config.proxyToWorker;\n  const executionProviders = [useWebGPU ? \"webgpu\" : \"wasm\"];\n  const ort2 = await getOrt(useWebGPU);\n  if (config.debug) {\n    console.debug(\"\tUsing WebGPU:\", useWebGPU);\n    console.debug(\"\tProxy to Worker:\", proxyToWorker);\n    ort2.env.debug = true;\n    ort2.env.logLevel = \"verbose\";\n  }\n  ort2.env.wasm.numThreads = maxNumThreads();\n  ort2.env.wasm.proxy = proxyToWorker;\n  const baseFilePath = useWebGPU ? \"/onnxruntime-web/ort-wasm-simd-threaded.jsep\" : \"/onnxruntime-web/ort-wasm-simd-threaded\";\n  const wasmPath = await loadAsUrl(`${baseFilePath}.wasm`, config);\n  const mjsPath = await loadAsUrl(`${baseFilePath}.mjs`, config);\n  ort2.env.wasm.wasmPaths = {\n    mjs: mjsPath,\n    wasm: wasmPath\n  };\n  if (config.debug) {\n    console.debug(\"ort.env.wasm:\", ort2.env.wasm);\n  }\n  const ortConfig = {\n    executionProviders,\n    graphOptimizationLevel: \"all\",\n    executionMode: \"parallel\",\n    enableCpuMemArena: true\n  };\n  const session = await ort2.InferenceSession.create(model, ortConfig).catch(\n    (e) => {\n      throw new Error(\n        `Failed to create session: \"${e}\". Please check if the publicPath is set correctly.`\n      );\n    }\n  );\n  return session;\n}\nasync function runOnnxSession(session, inputs, outputs, config) {\n  const useWebGPU = config.device === \"gpu\" && await webgpu();\n  const ort2 = await getOrt(useWebGPU);\n  const feeds = {};\n  for (const [key, tensor] of inputs) {\n    feeds[key] = new ort2.Tensor(\n      \"float32\",\n      new Float32Array(tensor.data),\n      tensor.shape\n    );\n  }\n  const outputData = await session.run(feeds, {});\n  const outputKVPairs = [];\n  for (const key of outputs) {\n    const output = outputData[key];\n    const shape = output.dims;\n    const data = output.data;\n    const tensor = (0, import_ndarray3.default)(data, shape);\n    outputKVPairs.push(tensor);\n  }\n  return outputKVPairs;\n}\n\n// ../../node_modules/zod/lib/index.mjs\nvar util;\n(function(util2) {\n  util2.assertEqual = (val) => val;\n  function assertIs(_arg) {\n  }\n  util2.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error();\n  }\n  util2.assertNever = assertNever;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n    const filtered = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e) {\n      return obj[e];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === \"function\" ? (obj) => Object.keys(obj) : (object) => {\n    const keys = [];\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return void 0;\n  };\n  util2.isInteger = typeof Number.isInteger === \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n  function joinValues(array, separator = \" | \") {\n    return array.map((val) => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n  }\n  util2.joinValues = joinValues;\n  util2.jsonStringifyReplacer = (_, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n      // second overwrites first\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]);\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"symbol\":\n      return ZodParsedType.symbol;\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\nvar ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\"\n]);\nvar quotelessJson = (obj) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nvar ZodError = class _ZodError extends Error {\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n  get errors() {\n    return this.issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue) {\n      return issue.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue));\n        } else {\n          let curr = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i];\n            const terminal = i === issue.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  static assert(value) {\n    if (!(value instanceof _ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n        fieldErrors[sub.path[0]].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nZodError.create = (issues) => {\n  const error = new ZodError(issues);\n  return error;\n};\nvar errorMap = (issue, _ctx) => {\n  let message;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message = \"Required\";\n      } else {\n        message = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === \"object\") {\n        if (\"includes\" in issue.validation) {\n          message = `Invalid input: must include \"${issue.validation.includes}\"`;\n          if (typeof issue.validation.position === \"number\") {\n            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n          }\n        } else if (\"startsWith\" in issue.validation) {\n          message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue.validation) {\n          message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== \"regex\") {\n        message = `Invalid ${issue.validation}`;\n      } else {\n        message = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === \"array\")\n        message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n      else\n        message = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === \"array\")\n        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === \"bigint\")\n        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n      else\n        message = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    case ZodIssueCode.not_finite:\n      message = \"Number must be finite\";\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message };\n};\nvar overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n  overrideErrorMap = map;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\nvar makeIssue = (params) => {\n  const { data, path, errorMaps, issueData } = params;\n  const fullPath = [...path, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== void 0) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  }\n  let errorMessage = \"\";\n  const maps = errorMaps.filter((m) => !!m).slice().reverse();\n  for (const map of maps) {\n    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap();\n  const issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      ctx.schemaErrorMap,\n      overrideMap,\n      overrideMap === errorMap ? void 0 : errorMap\n      // then global default map\n    ].filter((x) => !!x)\n  });\n  ctx.common.issues.push(issue);\n}\nvar ParseStatus = class _ParseStatus {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    if (this.value === \"valid\")\n      this.value = \"dirty\";\n  }\n  abort() {\n    if (this.value !== \"aborted\")\n      this.value = \"aborted\";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === \"aborted\")\n        return INVALID;\n      if (s.status === \"dirty\")\n        status.dirty();\n      arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return _ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\")\n        return INVALID;\n      if (value.status === \"aborted\")\n        return INVALID;\n      if (key.status === \"dirty\")\n        status.dirty();\n      if (value.status === \"dirty\")\n        status.dirty();\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n};\nvar INVALID = Object.freeze({\n  status: \"aborted\"\n});\nvar DIRTY = (value) => ({ status: \"dirty\", value });\nvar OK = (value) => ({ status: \"valid\", value });\nvar isAborted = (x) => x.status === \"aborted\";\nvar isDirty = (x) => x.status === \"dirty\";\nvar isValid = (x) => x.status === \"valid\";\nvar isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f)\n    throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n    throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\")\n    throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f)\n    throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n    throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n  errorUtil2.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nvar _ZodEnum_cache;\nvar _ZodNativeEnum_cache;\nvar ParseInputLazyPath = class {\n  constructor(parent, value, path, key) {\n    this._cachedPath = [];\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (this._key instanceof Array) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n    return this._cachedPath;\n  }\n};\nvar handleResult = (ctx, result) => {\n  if (isValid(result)) {\n    return { success: true, data: result.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error(\"Validation failed but no issues detected.\");\n    }\n    return {\n      success: false,\n      get error() {\n        if (this._error)\n          return this._error;\n        const error = new ZodError(ctx.common.issues);\n        this._error = error;\n        return this._error;\n      }\n    };\n  }\n};\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    var _a, _b;\n    const { message } = params;\n    if (iss.code === \"invalid_enum_value\") {\n      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };\n    }\n    if (iss.code !== \"invalid_type\")\n      return { message: ctx.defaultError };\n    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\nvar ZodType = class {\n  constructor(def) {\n    this.spa = this.safeParseAsync;\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n  }\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params) {\n    const result = this.safeParse(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  safeParse(data, params) {\n    var _a;\n    const ctx = {\n      common: {\n        issues: [],\n        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\n      },\n      path: (params === null || params === void 0 ? void 0 : params.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result);\n  }\n  async parseAsync(data, params) {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n        async: true\n      },\n      path: (params === null || params === void 0 ? void 0 : params.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check, message) {\n    const getIssueProperties = (val) => {\n      if (typeof message === \"string\" || typeof message === \"undefined\") {\n        return { message };\n      } else if (typeof message === \"function\") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  optional() {\n    return ZodOptional.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray.create(this, this._def);\n  }\n  promise() {\n    return ZodPromise.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n  transform(transform) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n  let regex = `([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d`;\n  if (args.precision) {\n    regex = `${regex}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    regex = `${regex}(\\\\.\\\\d+)?`;\n  }\n  return regex;\n}\nfunction timeRegex(args) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset)\n    opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join(\"|\")})`;\n  return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n  if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nvar ZodString = class _ZodString extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"length\") {\n        const tooBig = input.data.length > check.value;\n        const tooSmall = input.data.length < check.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          }\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"emoji\") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, \"u\");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"emoji\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"nanoid\") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"nanoid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid2\") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid2\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ulid\") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ulid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch (_a) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"includes\") {\n        if (!input.data.includes(check.value, check.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { includes: check.value, position: check.position },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"toLowerCase\") {\n        input.data = input.data.toLowerCase();\n      } else if (check.kind === \"toUpperCase\") {\n        input.data = input.data.toUpperCase();\n      } else if (check.kind === \"startsWith\") {\n        if (!input.data.startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!input.data.endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"datetime\") {\n        const regex = datetimeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"datetime\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"date\") {\n        const regex = dateRegex;\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"date\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"time\") {\n        const regex = timeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"time\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"duration\") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"duration\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ip\") {\n        if (!isValidIP(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ip\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64\") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _regex(regex, validation, message) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  _addCheck(check) {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  email(message) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n  }\n  url(message) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n  }\n  emoji(message) {\n    return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n  }\n  uuid(message) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n  }\n  nanoid(message) {\n    return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n  }\n  cuid(message) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n  }\n  cuid2(message) {\n    return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n  }\n  ulid(message) {\n    return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n  }\n  base64(message) {\n    return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n  }\n  ip(options) {\n    return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n  }\n  datetime(options) {\n    var _a, _b;\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"datetime\",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"datetime\",\n      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n    });\n  }\n  date(message) {\n    return this._addCheck({ kind: \"date\", message });\n  }\n  time(options) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"time\",\n        precision: null,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"time\",\n      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n    });\n  }\n  duration(message) {\n    return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: \"includes\",\n      value,\n      position: options === null || options === void 0 ? void 0 : options.position,\n      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  /**\n   * @deprecated Use z.string().min(1) instead.\n   * @see {@link ZodString.min}\n   */\n  nonempty(message) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n  trim() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  toLowerCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n    });\n  }\n  toUpperCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n};\nZodString.create = (params) => {\n  var _a;\n  return new ZodString({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n    ...processCreateParams(params)\n  });\n};\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / Math.pow(10, decCount);\n}\nvar ZodNumber = class _ZodNumber extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"finite\") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  finite(message) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message)\n    });\n  }\n  safe(message) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max = null, min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n        return true;\n      } else if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      } else if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n};\nZodNumber.create = (params) => {\n  return new ZodNumber({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBigInt = class _ZodBigInt extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = BigInt(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.bigint,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: \"bigint\",\n            minimum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: \"bigint\",\n            maximum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (input.data % check.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n};\nZodBigInt.create = (params) => {\n  var _a;\n  return new ZodBigInt({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBoolean = class extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBoolean.create = (params) => {\n  return new ZodBoolean({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDate = class _ZodDate extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            minimum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            maximum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check) {\n    return new _ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max != null ? new Date(max) : null;\n  }\n};\nZodDate.create = (params) => {\n  return new ZodDate({\n    checks: [],\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSymbol = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodSymbol.create = (params) => {\n  return new ZodSymbol({\n    typeName: ZodFirstPartyTypeKind.ZodSymbol,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUndefined = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodUndefined.create = (params) => {\n  return new ZodUndefined({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNull = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodNull.create = (params) => {\n  return new ZodNull({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params)\n  });\n};\nvar ZodAny = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodAny.create = (params) => {\n  return new ZodAny({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnknown = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodUnknown.create = (params) => {\n  return new ZodUnknown({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNever = class extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n};\nZodNever.create = (params) => {\n  return new ZodNever({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params)\n  });\n};\nvar ZodVoid = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodVoid.create = (params) => {\n  return new ZodVoid({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params)\n  });\n};\nvar ZodArray = class _ZodArray extends ZodType {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: tooSmall ? def.exactLength.value : void 0,\n          maximum: tooBig ? def.exactLength.value : void 0,\n          type: \"array\",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all([...ctx.data].map((item, i) => {\n        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n      })).then((result2) => {\n        return ParseStatus.mergeArray(status, result2);\n      });\n    }\n    const result = [...ctx.data].map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new _ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxLength, message) {\n    return new _ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) }\n    });\n  }\n  length(len, message) {\n    return new _ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) }\n    });\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodArray.create = (schema, params) => {\n  return new ZodArray({\n    type: schema,\n    minLength: null,\n    maxLength: null,\n    exactLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params)\n  });\n};\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\nvar ZodObject = class _ZodObject extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    return this._cached = { shape, keys };\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\")\n        ;\n      else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key)\n            //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          syncPairs.push({\n            key,\n            value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    errorUtil.errToObj;\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...message !== void 0 ? {\n        errorMap: (issue, ctx) => {\n          var _a, _b, _c, _d;\n          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n          if (issue.code === \"unrecognized_keys\")\n            return {\n              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(augmentation) {\n    return new _ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(merging) {\n    const merged = new _ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(key, schema) {\n    return this.augment({ [key]: schema });\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(index) {\n    return new _ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    util.objectKeys(mask).forEach((key) => {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      const fieldSchema = this.shape[key];\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n        while (newField instanceof ZodOptional) {\n          newField = newField._def.innerType;\n        }\n        newShape[key] = newField;\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n};\nZodObject.create = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.strictCreate = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strict\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.lazycreate = (shape, params) => {\n  return new ZodObject({\n    shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results) {\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = void 0;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === \"valid\") {\n          return result;\n        } else if (result.status === \"dirty\" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nZodUnion.create = (types, params) => {\n  return new ZodUnion({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params)\n  });\n};\nvar getDiscriminator = (type) => {\n  if (type instanceof ZodLazy) {\n    return getDiscriminator(type.schema);\n  } else if (type instanceof ZodEffects) {\n    return getDiscriminator(type.innerType());\n  } else if (type instanceof ZodLiteral) {\n    return [type.value];\n  } else if (type instanceof ZodEnum) {\n    return type.options;\n  } else if (type instanceof ZodNativeEnum) {\n    return util.objectValues(type.enum);\n  } else if (type instanceof ZodDefault) {\n    return getDiscriminator(type._def.innerType);\n  } else if (type instanceof ZodUndefined) {\n    return [void 0];\n  } else if (type instanceof ZodNull) {\n    return [null];\n  } else if (type instanceof ZodOptional) {\n    return [void 0, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodNullable) {\n    return [null, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodBranded) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodReadonly) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodCatch) {\n    return getDiscriminator(type._def.innerType);\n  } else {\n    return [];\n  }\n};\nvar ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.optionsMap.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(discriminator, options, params) {\n    const optionsMap = /* @__PURE__ */ new Map();\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n        optionsMap.set(value, type);\n      }\n    }\n    return new _ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n};\nfunction mergeValues(a, b) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n  if (a === b) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\nvar ZodIntersection = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n};\nZodIntersection.create = (left, right, params) => {\n  return new ZodIntersection({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params)\n  });\n};\nvar ZodTuple = class _ZodTuple extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      status.dirty();\n    }\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      if (!schema)\n        return null;\n      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x) => !!x);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new _ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n};\nZodTuple.create = (schemas, params) => {\n  if (!Array.isArray(schemas)) {\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  }\n  return new ZodTuple({\n    items: schemas,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\nvar ZodRecord = class _ZodRecord extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType) {\n      return new _ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new _ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n};\nvar ZodMap = class extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = /* @__PURE__ */ new Map();\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n};\nZodMap.create = (keyType, valueType, params) => {\n  return new ZodMap({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSet = class _ZodSet extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def = this._def;\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = /* @__PURE__ */ new Set();\n      for (const element of elements2) {\n        if (element.status === \"aborted\")\n          return INVALID;\n        if (element.status === \"dirty\")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message) {\n    return new _ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxSize, message) {\n    return new _ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodSet.create = (valueType, params) => {\n  return new ZodSet({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params)\n  });\n};\nvar ZodFunction = class _ZodFunction extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error\n        }\n      });\n    }\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      const me = this;\n      return OK(async function(...args) {\n        const error = new ZodError([]);\n        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs);\n        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {\n          error.addIssue(makeReturnsIssue(result, e));\n          throw error;\n        });\n        return parsedReturns;\n      });\n    } else {\n      const me = this;\n      return OK(function(...args) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new _ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new _ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params) {\n    return new _ZodFunction({\n      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n};\nvar ZodLazy = class extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n};\nZodLazy.create = (getter, params) => {\n  return new ZodLazy({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params)\n  });\n};\nvar ZodLiteral = class extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nZodLiteral.create = (value, params) => {\n  return new ZodLiteral({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params)\n  });\n};\nfunction createZodEnum(values, params) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\nvar ZodEnum = class _ZodEnum extends ZodType {\n  constructor() {\n    super(...arguments);\n    _ZodEnum_cache.set(this, void 0);\n  }\n  _parse(input) {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n    }\n    if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  extract(values, newDef = this._def) {\n    return _ZodEnum.create(values, {\n      ...this._def,\n      ...newDef\n    });\n  }\n  exclude(values, newDef = this._def) {\n    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n      ...this._def,\n      ...newDef\n    });\n  }\n};\n_ZodEnum_cache = /* @__PURE__ */ new WeakMap();\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    _ZodNativeEnum_cache.set(this, void 0);\n  }\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\n    }\n    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\n_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();\nZodNativeEnum.create = (values, params) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params)\n  });\n};\nvar ZodPromise = class extends ZodType {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n};\nZodPromise.create = (schema, params) => {\n  return new ZodPromise({\n    type: schema,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params)\n  });\n};\nvar ZodEffects = class extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed2) => {\n          if (status.value === \"aborted\")\n            return INVALID;\n          const result = await this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n          if (result.status === \"aborted\")\n            return INVALID;\n          if (result.status === \"dirty\")\n            return DIRTY(result.value);\n          if (status.value === \"dirty\")\n            return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === \"aborted\")\n          return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (result.status === \"aborted\")\n          return INVALID;\n        if (result.status === \"dirty\")\n          return DIRTY(result.value);\n        if (status.value === \"dirty\")\n          return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc) => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === \"aborted\")\n          return INVALID;\n        if (inner.status === \"dirty\")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\")\n            return INVALID;\n          if (inner.status === \"dirty\")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base))\n          return base;\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base))\n            return base;\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n};\nZodEffects.create = (schema, effect, params) => {\n  return new ZodEffects({\n    schema,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n  return new ZodEffects({\n    schema,\n    effect: { type: \"preprocess\", transform: preprocess },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params)\n  });\n};\nvar ZodOptional = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(void 0);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodOptional.create = (type, params) => {\n  return new ZodOptional({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNullable = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodNullable.create = (type, params) => {\n  return new ZodNullable({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDefault = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nZodDefault.create = (type, params) => {\n  return new ZodDefault({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodDefault,\n    defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n    ...processCreateParams(params)\n  });\n};\nvar ZodCatch = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    };\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    if (isAsync(result)) {\n      return result.then((result2) => {\n        return {\n          status: \"valid\",\n          value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n            get error() {\n              return new ZodError(newCtx.common.issues);\n            },\n            input: newCtx.data\n          })\n        };\n      });\n    } else {\n      return {\n        status: \"valid\",\n        value: result.status === \"valid\" ? result.value : this._def.catchValue({\n          get error() {\n            return new ZodError(newCtx.common.issues);\n          },\n          input: newCtx.data\n        })\n      };\n    }\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n};\nZodCatch.create = (type, params) => {\n  return new ZodCatch({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodCatch,\n    catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNaN = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n};\nZodNaN.create = (params) => {\n  return new ZodNaN({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params)\n  });\n};\nvar BRAND = Symbol(\"zod_brand\");\nvar ZodBranded = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n};\nvar ZodPipeline = class _ZodPipeline extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inResult.status === \"aborted\")\n          return INVALID;\n        if (inResult.status === \"dirty\") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      if (inResult.status === \"aborted\")\n        return INVALID;\n      if (inResult.status === \"dirty\") {\n        status.dirty();\n        return {\n          status: \"dirty\",\n          value: inResult.value\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n  }\n  static create(a, b) {\n    return new _ZodPipeline({\n      in: a,\n      out: b,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline\n    });\n  }\n};\nvar ZodReadonly = class extends ZodType {\n  _parse(input) {\n    const result = this._def.innerType._parse(input);\n    const freeze = (data) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodReadonly.create = (type, params) => {\n  return new ZodReadonly({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodReadonly,\n    ...processCreateParams(params)\n  });\n};\nfunction custom(check, params = {}, fatal) {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      var _a, _b;\n      if (!check(data)) {\n        const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n        const p2 = typeof p === \"string\" ? { message: p } : p;\n        ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n      }\n    });\n  return ZodAny.create();\n}\nvar late = {\n  object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n  ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n  ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n  ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n  ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n  ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n  ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\n  ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n  ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n  ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n  ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n  ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n  ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n  ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n  ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n  ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n  ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n  ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n  ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n  ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n  ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n  ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n  ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n  ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n  ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n  ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n  ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n  ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n  ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n  ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n  ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n  ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\n  ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n  ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n  ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\n  ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params = {\n  message: `Input not instance of ${cls.name}`\n}) => custom((data) => data instanceof cls, params);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar symbolType = ZodSymbol.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\nvar ostring = () => stringType().optional();\nvar onumber = () => numberType().optional();\nvar oboolean = () => booleanType().optional();\nvar coerce = {\n  string: (arg) => ZodString.create({ ...arg, coerce: true }),\n  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),\n  boolean: (arg) => ZodBoolean.create({\n    ...arg,\n    coerce: true\n  }),\n  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),\n  date: (arg) => ZodDate.create({ ...arg, coerce: true })\n};\nvar NEVER = INVALID;\nvar z = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  defaultErrorMap: errorMap,\n  setErrorMap,\n  getErrorMap,\n  makeIssue,\n  EMPTY_PATH,\n  addIssueToContext,\n  ParseStatus,\n  INVALID,\n  DIRTY,\n  OK,\n  isAborted,\n  isDirty,\n  isValid,\n  isAsync,\n  get util() {\n    return util;\n  },\n  get objectUtil() {\n    return objectUtil;\n  },\n  ZodParsedType,\n  getParsedType,\n  ZodType,\n  datetimeRegex,\n  ZodString,\n  ZodNumber,\n  ZodBigInt,\n  ZodBoolean,\n  ZodDate,\n  ZodSymbol,\n  ZodUndefined,\n  ZodNull,\n  ZodAny,\n  ZodUnknown,\n  ZodNever,\n  ZodVoid,\n  ZodArray,\n  ZodObject,\n  ZodUnion,\n  ZodDiscriminatedUnion,\n  ZodIntersection,\n  ZodTuple,\n  ZodRecord,\n  ZodMap,\n  ZodSet,\n  ZodFunction,\n  ZodLazy,\n  ZodLiteral,\n  ZodEnum,\n  ZodNativeEnum,\n  ZodPromise,\n  ZodEffects,\n  ZodTransformer: ZodEffects,\n  ZodOptional,\n  ZodNullable,\n  ZodDefault,\n  ZodCatch,\n  ZodNaN,\n  BRAND,\n  ZodBranded,\n  ZodPipeline,\n  ZodReadonly,\n  custom,\n  Schema: ZodType,\n  ZodSchema: ZodType,\n  late,\n  get ZodFirstPartyTypeKind() {\n    return ZodFirstPartyTypeKind;\n  },\n  coerce,\n  any: anyType,\n  array: arrayType,\n  bigint: bigIntType,\n  boolean: booleanType,\n  date: dateType,\n  discriminatedUnion: discriminatedUnionType,\n  effect: effectsType,\n  \"enum\": enumType,\n  \"function\": functionType,\n  \"instanceof\": instanceOfType,\n  intersection: intersectionType,\n  lazy: lazyType,\n  literal: literalType,\n  map: mapType,\n  nan: nanType,\n  nativeEnum: nativeEnumType,\n  never: neverType,\n  \"null\": nullType,\n  nullable: nullableType,\n  number: numberType,\n  object: objectType,\n  oboolean,\n  onumber,\n  optional: optionalType,\n  ostring,\n  pipeline: pipelineType,\n  preprocess: preprocessType,\n  promise: promiseType,\n  record: recordType,\n  set: setType,\n  strictObject: strictObjectType,\n  string: stringType,\n  symbol: symbolType,\n  transformer: effectsType,\n  tuple: tupleType,\n  \"undefined\": undefinedType,\n  union: unionType,\n  unknown: unknownType,\n  \"void\": voidType,\n  NEVER,\n  ZodIssueCode,\n  quotelessJson,\n  ZodError\n});\n\n// package.json\nvar package_default = {\n  name: \"@imgly/background-removal\",\n  version: \"1.5.8\",\n  description: \"Background Removal in the Browser\",\n  keywords: [\n    \"background-removal\",\n    \"client-side\",\n    \"data-privacy\",\n    \"image-segmentation\",\n    \"image-matting\",\n    \"onnx\"\n  ],\n  repository: {\n    type: \"git\",\n    url: \"git+https://github.com/imgly/background-removal-js.git\"\n  },\n  license: \"SEE LICENSE IN LICENSE.md\",\n  author: {\n    name: \"IMG.LY GmbH\",\n    email: \"support@img.ly\",\n    url: \"https://img.ly\"\n  },\n  bugs: {\n    email: \"support@img.ly\"\n  },\n  source: \"./src/index.ts\",\n  main: \"./dist/index.cjs\",\n  module: \"./dist/index.mjs\",\n  types: \"./dist/src/index.d.ts\",\n  exports: {\n    \".\": {\n      require: \"./dist/index.cjs\",\n      import: \"./dist/index.mjs\",\n      types: \"./dist/src/index.d.ts\"\n    }\n  },\n  homepage: \"https://img.ly/showcases/cesdk/web/background-removal\",\n  files: [\n    \"LICENSE.md\",\n    \"README.md\",\n    \"CHANGELOG.md\",\n    \"ThirdPartyLicenses.json\",\n    \"dist/\",\n    \"bin/\"\n  ],\n  scripts: {\n    start: \"npm run watch\",\n    clean: \"npx rimraf dist\",\n    test: \"true\",\n    resources: \"node ../../scripts/package-resources.mjs\",\n    \"changelog:create\": \"node ../../scripts/changelog/changelog-create.mjs\",\n    \"changelog:generate\": \"node ../../scripts/changelog/changelog-generate.mjs\",\n    build: \"npm run clean && npm run types && npm run resources && npm run changelog:generate && node scripts/build.mjs\",\n    types: \" npx tsc --declaration --emitDeclarationOnly --declarationDir dist --declarationMap\",\n    watch: \"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs\",\n    \"publish:latest\": \"npm publish --tag latest --access public\",\n    \"publish:next\": \"npm publish --tag next --access public\",\n    \"package:pack\": \"npm pack . --pack-destination ../../releases\",\n    lint: \"npx prettier --write .\"\n  },\n  dependencies: {\n    \"lodash-es\": \"^4.17.21\",\n    ndarray: \"~1.0.0\",\n    zod: \"^3.23.8\"\n  },\n  peerDependencies: {\n    \"onnxruntime-web\": \"1.21.0-dev.20250114-228dd16893\"\n  },\n  devDependencies: {\n    \"@types/lodash-es\": \"^4.17.12\",\n    \"@types/ndarray\": \"~1.0.14\",\n    \"@types/node\": \"~20.3.0\",\n    assert: \"~2.0.0\",\n    esbuild: \"~0.18.0\",\n    glob: \"~10.3.0\",\n    \"npm-dts\": \"~1.3.0\",\n    process: \"~0.11.0\",\n    \"ts-loader\": \"~9.4.0\",\n    tslib: \"~2.5.0\",\n    typescript: \"~5.1.0\",\n    util: \"~0.12.0\",\n    webpack: \"~5.85.0\",\n    \"webpack-cli\": \"~5.1.0\"\n  },\n  bundleDependencies: []\n};\n\n// src/schema.ts\nvar ConfigSchema = z.object({\n  publicPath: z.string().optional().describe(\"The public path to the wasm files and the onnx model.\").default(\n    \"https://staticimgly.com/@imgly/background-removal-data/${PACKAGE_VERSION}/dist/\"\n  ).transform((val) => {\n    return val.replace(\"${PACKAGE_NAME}\", package_default.name).replace(\"${PACKAGE_VERSION}\", package_default.version);\n  }),\n  debug: z.boolean().default(false).describe(\"Whether to enable debug logging.\"),\n  rescale: z.boolean().default(true).describe(\"Whether to rescale the image.\"),\n  device: z.enum([\"cpu\", \"gpu\"]).default(\"cpu\").describe(\"The device to run the model on.\"),\n  proxyToWorker: z.boolean().default(false).describe(\"Whether to proxy inference to a web worker.\"),\n  fetchArgs: z.any().default({}).describe(\"Arguments to pass to fetch when loading the model.\"),\n  progress: z.function().args(z.string(), z.number(), z.number()).returns(z.void()).describe(\"Progress callback.\").optional(),\n  model: z.preprocess(\n    (val) => {\n      switch (val) {\n        case \"large\":\n          return \"isnet\";\n        case \"small\":\n          return \"isnet_quint8\";\n        case \"medium\":\n          return \"isnet_fp16\";\n        default:\n          return val;\n      }\n    },\n    z.enum([\"isnet\", \"isnet_fp16\", \"isnet_quint8\"])\n  ).default(\"medium\"),\n  output: z.object({\n    format: z.enum([\n      \"image/png\",\n      \"image/jpeg\",\n      \"image/webp\",\n      \"image/x-rgba8\",\n      \"image/x-alpha8\"\n    ]).default(\"image/png\"),\n    quality: z.number().default(0.8)\n  }).default({})\n}).default({}).transform((config) => {\n  if (config.debug)\n    console.log(\"Config:\", config);\n  if (config.debug && !config.progress) {\n    config.progress = config.progress ?? ((key, current, total) => {\n      console.debug(`Downloading ${key}: ${current} of ${total}`);\n    });\n    if (!crossOriginIsolated) {\n      if (config.debug)\n        console.debug(\n          \"Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer.\"\n        );\n    }\n  }\n  return config;\n});\nfunction validateConfig(configuration) {\n  return ConfigSchema.parse(configuration ?? {});\n}\n\n// src/inference.ts\nvar import_ndarray4 = __toESM(require_ndarray());\nasync function initBase(config) {\n  if (config.debug)\n    console.debug(\"Loading model...\", config.model);\n  const model = config.model;\n  const blob = await loadAsBlob(`/models/${model}`, config);\n  const arrayBuffer = await blob.arrayBuffer();\n  const session = await createOnnxSession(arrayBuffer, config);\n  return session;\n}\nasync function initInference(config) {\n  config = validateConfig(config);\n  const base = await initBase(config);\n  return { config, session: { base } };\n}\nasync function runInference(imageTensor, config, session) {\n  const resolution = 1024;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  const keepAspect = false;\n  let resizedImageTensor = tensorResizeBilinear(\n    imageTensor,\n    resolution,\n    resolution,\n    keepAspect\n  );\n  const inputTensor = tensorHWCtoBCHW(resizedImageTensor);\n  let predictionsDict = await runOnnxSession(\n    session.base,\n    [[\"input\", inputTensor]],\n    [\"output\"],\n    config\n  );\n  let alphamask2 = (0, import_ndarray4.default)(predictionsDict[0].data, [resolution, resolution, 1]);\n  let alphamaskU8 = convertFloat32ToUint8(alphamask2);\n  if (config.rescale) {\n    alphamaskU8 = tensorResizeBilinear(\n      alphamaskU8,\n      srcWidth,\n      srcHeight,\n      keepAspect\n    );\n    return [alphamaskU8, imageTensor];\n  } else {\n    return [alphamaskU8, resizedImageTensor];\n  }\n}\n\n// src/api/v1.ts\nvar init = (0, import_lodash.memoize)(initInference, (config) => JSON.stringify(config));\nasync function preload(configuration) {\n  await init(configuration);\n  return;\n}\nasync function removeBackground(image, configuration) {\n  const { config, session } = await init(configuration);\n  if (config.progress)\n    config.progress(\"compute:decode\", 0, 4);\n  const inputImageTensor = await imageSourceToImageData(image, config);\n  config.progress?.(\"compute:inference\", 1, 4);\n  const [alphamask2, imageTensor] = await runInference(\n    inputImageTensor,\n    config,\n    session\n  );\n  config.progress?.(\"compute:mask\", 2, 4);\n  const outImageTensor = imageTensor;\n  const [width, height] = outImageTensor.shape;\n  const stride = width * height;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = alphamask2.data[i];\n  }\n  config.progress?.(\"compute:encode\", 3, 4);\n  const outImage = await imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n  config.progress?.(\"compute:encode\", 4, 4);\n  return outImage;\n}\nasync function removeForeground(image, configuration) {\n  const { config, session } = await init(configuration);\n  const imageTensor = await imageSourceToImageData(image, config);\n  const [alphamask2, imageInput] = await runInference(\n    imageTensor,\n    config,\n    session\n  );\n  const outImageTensor = imageInput;\n  const [width, height, channels] = outImageTensor.shape;\n  const stride = width * height;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = 255 - alphamask2.data[i];\n  }\n  const outImage = await imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n  return outImage;\n}\nvar alphamask = segmentForeground;\nasync function segmentForeground(image, configuration) {\n  const { config, session } = await init(configuration);\n  const imageTensor = await imageSourceToImageData(image, config);\n  let [height, width, channels] = imageTensor.shape;\n  const [alphamask2, imageInput] = await runInference(\n    imageTensor,\n    config,\n    session\n  );\n  const stride = width * height;\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    const index = 4 * i;\n    let alpha = alphamask2.data[i];\n    outImageTensor.data[index] = 255;\n    outImageTensor.data[index + 1] = 255;\n    outImageTensor.data[index + 2] = 255;\n    outImageTensor.data[index + 3] = alpha;\n  }\n  const outImage = await imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n  return outImage;\n}\nasync function applySegmentationMask(image, mask, config) {\n  config = validateConfig(config);\n  const imageTensor = await imageSourceToImageData(image, config);\n  const [imageHeight, imageWidth, imageChannels] = imageTensor.shape;\n  const maskTensor = await imageSourceToImageData(mask, config);\n  const [maskHeight, maskWidth, maskChannels] = maskTensor.shape;\n  const alphaMask = maskHeight !== imageHeight || maskWidth !== imageWidth ? tensorResizeBilinear(maskTensor, imageWidth, imageHeight) : maskTensor;\n  const stride = imageWidth * imageHeight;\n  for (let i = 0; i < stride; i += 1) {\n    const idxImage = imageChannels * i;\n    const idxMask = maskChannels * i;\n    imageTensor.data[idxImage + 3] = alphaMask.data[idxMask + 3];\n  }\n  const outImage = await imageEncode(\n    imageTensor,\n    config.output.quality,\n    config.output.format\n  );\n  return outImage;\n}\n\n/*! Bundled license information:\n\nlodash/lodash.js:\n  (**\n   * @license\n   * Lodash <https://lodash.com/>\n   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   *)\n\nis-buffer/index.js:\n  (*!\n   * Determine if an object is a Buffer\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGltZ2x5L2JhY2tncm91bmQtcmVtb3ZhbC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFHQUFxRztBQUNwSixtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsNkJBQTZCLDZEQUE2RDtBQUMxRjtBQUNBLCtDQUErQztBQUMvQztBQUNBLDhCQUE4QixNQUFNLGFBQWEsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdnQkFBd2dCLEVBQUU7QUFDMWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGNBQWM7QUFDZCxhQUFhO0FBQ2IsYUFBYTtBQUNiLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRCxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRKQUE0SjtBQUM1SiwyREFBMkQsd0NBQXdDLEVBQUUsb0hBQW9ILHFCQUFxQixnQ0FBZ0MsUUFBUSw4QkFBOEI7QUFDcFQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBb0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUyxNQUFNLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0REFBNEQ7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3Q0FBd0M7QUFDMUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYyxzQ0FBc0MsNEJBQTRCLHVCQUF1QixXQUFXLGFBQWEsbUJBQW1CLHdDQUF3Qyx3REFBd0QsMENBQTBDLGlDQUFpQyxzQkFBc0IsYUFBYSwrQ0FBK0MsaUNBQWlDO0FBQ2xlO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscURBQXFELGNBQWMsaUJBQWlCLHNDQUFzQyw0QkFBNEIsdUJBQXVCLG9CQUFvQixrQkFBa0IsYUFBYSx3Q0FBd0MsZ0ZBQWdGLHFEQUFxRCw2Q0FBNkMsaUNBQWlDLHlEQUF5RCx1RkFBdUYsNENBQTRDLDJGQUEyRixxREFBcUQsa0NBQWtDO0FBQ3owQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0NBQXNDO0FBQ25GO0FBQ0EsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0RBQXdEO0FBQ3hEO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsK0ZBQStGO0FBQy9GLFlBQVk7QUFDWjtBQUNBLHVHQUF1RyxVQUFVLFVBQVUsZ0JBQWdCLGVBQWUsZ0JBQWdCLEtBQUssaUJBQWlCLGVBQWUsZ0JBQWdCLGVBQWUsZ0JBQWdCLEtBQUssa0JBQWtCO0FBQ3JSO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFFBQVE7QUFDUix5REFBeUQ7QUFDekQ7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQSwyREFBMkQ7QUFDM0QsUUFBUTtBQUNSLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyw2QkFBNkI7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLGdGQUFnRjtBQUNoRixzQkFBc0IsZUFBZTtBQUNyQztBQUNBLDJEQUEyRCxlQUFlLGdCQUFnQixjQUFjO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyxtQkFBbUI7QUFDMUIsb0ZBQW9GO0FBQ3BGO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsNENBQTRDLGVBQWUsUUFBUSw2QkFBNkIsK0JBQStCLEtBQUssOEJBQThCLGNBQWM7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPLG1CQUFtQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxTQUFTLFNBQVM7QUFDbEIsd0NBQXdDLHVHQUF1RztBQUMvSTtBQUNBLDBFQUEwRTtBQUMxRSxzQkFBc0IsZUFBZTtBQUNyQyxtRUFBbUUsMENBQTBDLEtBQUssOEJBQThCLCtCQUErQjtBQUMvSztBQUNBLGdEQUFnRCw2QkFBNkI7QUFDN0UsdUZBQXVGO0FBQ3ZGO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyx3QkFBd0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLEdBQUcsTUFBTTtBQUNyQztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXLGVBQWUsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDRDQUE0Qyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQyxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLLFlBQVksV0FBVyxVQUFVLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0EseUJBQXlCLEtBQUssWUFBWSxZQUFZLFVBQVUsVUFBVTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvUUFBZ0M7QUFDakQsSUFBSTtBQUNKLGlCQUFpQiwrT0FBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25ELHFDQUFxQyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxJQUFJO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsY0FBYztBQUNkLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhCQUE4QixlQUFlLGFBQWEsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMkRBQTJEO0FBQzlHO0FBQ0E7QUFDQSxrREFBa0Qsa0NBQWtDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQSxnREFBZ0QsK0JBQStCLGNBQWMsZUFBZTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQkFBMEI7QUFDOUU7QUFDQSx5QkFBeUIsU0FBUyxvREFBb0QsMEJBQTBCO0FBQ2hIO0FBQ0EsVUFBVTtBQUNWLHVEQUF1RCw0QkFBNEI7QUFDbkYsVUFBVTtBQUNWLHFEQUFxRCwwQkFBMEI7QUFDL0UsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkJBQTZCLGlCQUFpQjtBQUM5QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzRUFBc0UsRUFBRSxlQUFlO0FBQy9IO0FBQ0EseUNBQXlDLGlFQUFpRSxFQUFFLGVBQWU7QUFDM0g7QUFDQSxvQ0FBb0Msb0dBQW9HLEVBQUUsY0FBYztBQUN4SjtBQUNBLGtDQUFrQyxvR0FBb0csRUFBRSxnQ0FBZ0M7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxRUFBcUUsRUFBRSxlQUFlO0FBQzlIO0FBQ0EseUNBQXlDLGlFQUFpRSxFQUFFLGVBQWU7QUFDM0g7QUFDQSxvQ0FBb0MsbUZBQW1GLEVBQUUsY0FBYztBQUN2STtBQUNBLG9DQUFvQyxtRkFBbUYsRUFBRSxjQUFjO0FBQ3ZJO0FBQ0Esa0NBQWtDLHlGQUF5RixFQUFFLGdDQUFnQztBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0NBQWtDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQix3QkFBd0I7QUFDbEQsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxVQUFVO0FBQy9FO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVFQUF1RTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUNBQW1DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1DQUFtQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEdBQUc7QUFDN0I7QUFDQSxxQ0FBcUMsR0FBRztBQUN4Qyw4QkFBOEIsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxlQUFlLEdBQUc7QUFDckcsK0JBQStCLEdBQUc7QUFDbEM7QUFDQSwrRkFBK0YsR0FBRztBQUNsRyx5QkFBeUIsc0JBQXNCLEtBQUssZ0JBQWdCO0FBQ3BFO0FBQ0EsNkVBQTZFLEVBQUU7QUFDL0UsNkJBQTZCLElBQUksR0FBRyxFQUFFLGFBQWEsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEdBQUcsRUFBRSxXQUFXLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxHQUFHLEVBQUUsV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksR0FBRyxFQUFFLFdBQVcsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEdBQUcsRUFBRSxXQUFXLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxHQUFHLEVBQUUsV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksbUNBQW1DLEVBQUUsU0FBUyxJQUFJLE1BQU0sRUFBRSxpQ0FBaUMsRUFBRSxTQUFTLElBQUk7QUFDelksbUNBQW1DLEVBQUUsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUU7QUFDOUUsaUhBQWlILEVBQUU7QUFDbkgsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU0sT0FBTyxFQUFFLGdCQUFnQjtBQUM5QyxJQUFJO0FBQ0osZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQixHQUFHLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxNQUFNLEVBQUU7QUFDbEMsYUFBYSxNQUFNLEdBQUcsZUFBZTtBQUNyQyx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaURBQWlEO0FBQzNFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQStDO0FBQzNFO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQTZDO0FBQ3pFO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQStDO0FBQzNFO0FBQ0E7QUFDQSw0QkFBNEIsOENBQThDO0FBQzFFO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7QUFDQSw0QkFBNEIsOENBQThDO0FBQzFFO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQStDO0FBQzNFO0FBQ0E7QUFDQSw0QkFBNEIsOENBQThDO0FBQzFFO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7QUFDQSw0QkFBNEIsNENBQTRDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixrREFBa0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELHFCQUFxQjtBQUNyQixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCLHNCQUFzQixjQUFjO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUiw4Q0FBOEMsNkNBQTZDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsOENBQThDLDZDQUE2QztBQUMzRjtBQUNBO0FBQ0EsNkZBQTZGLHFDQUFxQztBQUNsSSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysa0JBQWtCO0FBQ2pIO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQsdUJBQXVCLHNDQUFzQztBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0MsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNDQUFzQyxzQkFBc0I7QUFDNUQsa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBLDBCQUEwQixhQUFhLG9DQUFvQyxnQkFBZ0I7QUFDM0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVk7QUFDZixDQUFDLFlBQVk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJLElBQUksU0FBUyxLQUFLLE1BQU07QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGltZ2x5L2JhY2tncm91bmQtcmVtb3ZhbC9kaXN0L2luZGV4Lm1qcz85ZTAzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzXG52YXIgcmVxdWlyZV9sb2Rhc2ggPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1bmRlZmluZWQyO1xuICAgICAgdmFyIFZFUlNJT04gPSBcIjQuMTcuMjFcIjtcbiAgICAgIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuICAgICAgdmFyIENPUkVfRVJST1JfVEVYVCA9IFwiVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuXCIsIEZVTkNfRVJST1JfVEVYVCA9IFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiLCBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gXCJJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYFwiO1xuICAgICAgdmFyIEhBU0hfVU5ERUZJTkVEID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI7XG4gICAgICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcbiAgICAgIHZhciBQTEFDRUhPTERFUiA9IFwiX19sb2Rhc2hfcGxhY2Vob2xkZXJfX1wiO1xuICAgICAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsIENMT05FX0ZMQVRfRkxBRyA9IDIsIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG4gICAgICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLCBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcbiAgICAgIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsIFdSQVBfQ1VSUllfRkxBRyA9IDgsIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LCBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LCBXUkFQX0FSWV9GTEFHID0gMTI4LCBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuICAgICAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSBcIi4uLlwiO1xuICAgICAgdmFyIEhPVF9DT1VOVCA9IDgwMCwgSE9UX1NQQU4gPSAxNjtcbiAgICAgIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSwgTEFaWV9NQVBfRkxBRyA9IDIsIExBWllfV0hJTEVfRkxBRyA9IDM7XG4gICAgICB2YXIgSU5GSU5JVFkgPSAxIC8gMCwgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsIE1BWF9JTlRFR0VSID0gMTc5NzY5MzEzNDg2MjMxNTdlMjkyLCBOQU4gPSAwIC8gMDtcbiAgICAgIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSwgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG4gICAgICB2YXIgd3JhcEZsYWdzID0gW1xuICAgICAgICBbXCJhcnlcIiwgV1JBUF9BUllfRkxBR10sXG4gICAgICAgIFtcImJpbmRcIiwgV1JBUF9CSU5EX0ZMQUddLFxuICAgICAgICBbXCJiaW5kS2V5XCIsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgICAgIFtcImN1cnJ5XCIsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgICAgIFtcImN1cnJ5UmlnaHRcIiwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICAgICAgW1wiZmxpcFwiLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgICAgIFtcInBhcnRpYWxcIiwgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgICAgICBbXCJwYXJ0aWFsUmlnaHRcIiwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgICAgICBbXCJyZWFyZ1wiLCBXUkFQX1JFQVJHX0ZMQUddXG4gICAgICBdO1xuICAgICAgdmFyIGFyZ3NUYWcgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCBhcnJheVRhZyA9IFwiW29iamVjdCBBcnJheV1cIiwgYXN5bmNUYWcgPSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiwgYm9vbFRhZyA9IFwiW29iamVjdCBCb29sZWFuXVwiLCBkYXRlVGFnID0gXCJbb2JqZWN0IERhdGVdXCIsIGRvbUV4Y1RhZyA9IFwiW29iamVjdCBET01FeGNlcHRpb25dXCIsIGVycm9yVGFnID0gXCJbb2JqZWN0IEVycm9yXVwiLCBmdW5jVGFnID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBnZW5UYWcgPSBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIsIG1hcFRhZyA9IFwiW29iamVjdCBNYXBdXCIsIG51bWJlclRhZyA9IFwiW29iamVjdCBOdW1iZXJdXCIsIG51bGxUYWcgPSBcIltvYmplY3QgTnVsbF1cIiwgb2JqZWN0VGFnID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgcHJvbWlzZVRhZyA9IFwiW29iamVjdCBQcm9taXNlXVwiLCBwcm94eVRhZyA9IFwiW29iamVjdCBQcm94eV1cIiwgcmVnZXhwVGFnID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgc2V0VGFnID0gXCJbb2JqZWN0IFNldF1cIiwgc3RyaW5nVGFnID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgc3ltYm9sVGFnID0gXCJbb2JqZWN0IFN5bWJvbF1cIiwgdW5kZWZpbmVkVGFnID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIiwgd2Vha01hcFRhZyA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCB3ZWFrU2V0VGFnID0gXCJbb2JqZWN0IFdlYWtTZXRdXCI7XG4gICAgICB2YXIgYXJyYXlCdWZmZXJUYWcgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIGRhdGFWaWV3VGFnID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBmbG9hdDMyVGFnID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwgZmxvYXQ2NFRhZyA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIGludDhUYWcgPSBcIltvYmplY3QgSW50OEFycmF5XVwiLCBpbnQxNlRhZyA9IFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCBpbnQzMlRhZyA9IFwiW29iamVjdCBJbnQzMkFycmF5XVwiLCB1aW50OFRhZyA9IFwiW29iamVjdCBVaW50OEFycmF5XVwiLCB1aW50OENsYW1wZWRUYWcgPSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIHVpbnQxNlRhZyA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgdWludDMyVGFnID0gXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiO1xuICAgICAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLCByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG4gICAgICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZywgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLCByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG4gICAgICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZywgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcbiAgICAgIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLCByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG4gICAgICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLCByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG4gICAgICB2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuICAgICAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuICAgICAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLCByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLCByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG4gICAgICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG4gICAgICB2YXIgcmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMgPSAvWygpPSx7fVxcW1xcXVxcL1xcc10vO1xuICAgICAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuICAgICAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcbiAgICAgIHZhciByZUZsYWdzID0gL1xcdyokLztcbiAgICAgIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG4gICAgICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcbiAgICAgIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuICAgICAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG4gICAgICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuICAgICAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcbiAgICAgIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG4gICAgICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG4gICAgICB2YXIgcnNBc3RyYWxSYW5nZSA9IFwiXFxcXHVkODAwLVxcXFx1ZGZmZlwiLCByc0NvbWJvTWFya3NSYW5nZSA9IFwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLCByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSBcIlxcXFx1ZmUyMC1cXFxcdWZlMmZcIiwgcnNDb21ib1N5bWJvbHNSYW5nZSA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmZlwiLCByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsIHJzRGluZ2JhdFJhbmdlID0gXCJcXFxcdTI3MDAtXFxcXHUyN2JmXCIsIHJzTG93ZXJSYW5nZSA9IFwiYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmXCIsIHJzTWF0aE9wUmFuZ2UgPSBcIlxcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjdcIiwgcnNOb25DaGFyUmFuZ2UgPSBcIlxcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZlwiLCByc1B1bmN0dWF0aW9uUmFuZ2UgPSBcIlxcXFx1MjAwMC1cXFxcdTIwNmZcIiwgcnNTcGFjZVJhbmdlID0gXCIgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMFwiLCByc1VwcGVyUmFuZ2UgPSBcIkEtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZVwiLCByc1ZhclJhbmdlID0gXCJcXFxcdWZlMGVcXFxcdWZlMGZcIiwgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuICAgICAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLCByc0FzdHJhbCA9IFwiW1wiICsgcnNBc3RyYWxSYW5nZSArIFwiXVwiLCByc0JyZWFrID0gXCJbXCIgKyByc0JyZWFrUmFuZ2UgKyBcIl1cIiwgcnNDb21ibyA9IFwiW1wiICsgcnNDb21ib1JhbmdlICsgXCJdXCIsIHJzRGlnaXRzID0gXCJcXFxcZCtcIiwgcnNEaW5nYmF0ID0gXCJbXCIgKyByc0RpbmdiYXRSYW5nZSArIFwiXVwiLCByc0xvd2VyID0gXCJbXCIgKyByc0xvd2VyUmFuZ2UgKyBcIl1cIiwgcnNNaXNjID0gXCJbXlwiICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyBcIl1cIiwgcnNGaXR6ID0gXCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIiwgcnNNb2RpZmllciA9IFwiKD86XCIgKyByc0NvbWJvICsgXCJ8XCIgKyByc0ZpdHogKyBcIilcIiwgcnNOb25Bc3RyYWwgPSBcIlteXCIgKyByc0FzdHJhbFJhbmdlICsgXCJdXCIsIHJzUmVnaW9uYWwgPSBcIig/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn1cIiwgcnNTdXJyUGFpciA9IFwiW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdXCIsIHJzVXBwZXIgPSBcIltcIiArIHJzVXBwZXJSYW5nZSArIFwiXVwiLCByc1pXSiA9IFwiXFxcXHUyMDBkXCI7XG4gICAgICB2YXIgcnNNaXNjTG93ZXIgPSBcIig/OlwiICsgcnNMb3dlciArIFwifFwiICsgcnNNaXNjICsgXCIpXCIsIHJzTWlzY1VwcGVyID0gXCIoPzpcIiArIHJzVXBwZXIgKyBcInxcIiArIHJzTWlzYyArIFwiKVwiLCByc09wdENvbnRyTG93ZXIgPSBcIig/OlwiICsgcnNBcG9zICsgXCIoPzpkfGxsfG18cmV8c3x0fHZlKSk/XCIsIHJzT3B0Q29udHJVcHBlciA9IFwiKD86XCIgKyByc0Fwb3MgKyBcIig/OkR8TEx8TXxSRXxTfFR8VkUpKT9cIiwgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgXCI/XCIsIHJzT3B0VmFyID0gXCJbXCIgKyByc1ZhclJhbmdlICsgXCJdP1wiLCByc09wdEpvaW4gPSBcIig/OlwiICsgcnNaV0ogKyBcIig/OlwiICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKFwifFwiKSArIFwiKVwiICsgcnNPcHRWYXIgKyByZU9wdE1vZCArIFwiKSpcIiwgcnNPcmRMb3dlciA9IFwiXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pXCIsIHJzT3JkVXBwZXIgPSBcIlxcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKVwiLCByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sIHJzRW1vamkgPSBcIig/OlwiICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbihcInxcIikgKyBcIilcIiArIHJzU2VxLCByc1N5bWJvbCA9IFwiKD86XCIgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgXCI/XCIsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKFwifFwiKSArIFwiKVwiO1xuICAgICAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsIFwiZ1wiKTtcbiAgICAgIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCBcImdcIik7XG4gICAgICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArIFwiKD89XCIgKyByc0ZpdHogKyBcIil8XCIgKyByc1N5bWJvbCArIHJzU2VxLCBcImdcIik7XG4gICAgICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgICAgIHJzVXBwZXIgKyBcIj9cIiArIHJzTG93ZXIgKyBcIitcIiArIHJzT3B0Q29udHJMb3dlciArIFwiKD89XCIgKyBbcnNCcmVhaywgcnNVcHBlciwgXCIkXCJdLmpvaW4oXCJ8XCIpICsgXCIpXCIsXG4gICAgICAgIHJzTWlzY1VwcGVyICsgXCIrXCIgKyByc09wdENvbnRyVXBwZXIgKyBcIig/PVwiICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgXCIkXCJdLmpvaW4oXCJ8XCIpICsgXCIpXCIsXG4gICAgICAgIHJzVXBwZXIgKyBcIj9cIiArIHJzTWlzY0xvd2VyICsgXCIrXCIgKyByc09wdENvbnRyTG93ZXIsXG4gICAgICAgIHJzVXBwZXIgKyBcIitcIiArIHJzT3B0Q29udHJVcHBlcixcbiAgICAgICAgcnNPcmRVcHBlcixcbiAgICAgICAgcnNPcmRMb3dlcixcbiAgICAgICAgcnNEaWdpdHMsXG4gICAgICAgIHJzRW1vamlcbiAgICAgIF0uam9pbihcInxcIiksIFwiZ1wiKTtcbiAgICAgIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoXCJbXCIgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgXCJdXCIpO1xuICAgICAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcbiAgICAgIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgICAgIFwiQXJyYXlcIixcbiAgICAgICAgXCJCdWZmZXJcIixcbiAgICAgICAgXCJEYXRhVmlld1wiLFxuICAgICAgICBcIkRhdGVcIixcbiAgICAgICAgXCJFcnJvclwiLFxuICAgICAgICBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgICBcIkZsb2F0NjRBcnJheVwiLFxuICAgICAgICBcIkZ1bmN0aW9uXCIsXG4gICAgICAgIFwiSW50OEFycmF5XCIsXG4gICAgICAgIFwiSW50MTZBcnJheVwiLFxuICAgICAgICBcIkludDMyQXJyYXlcIixcbiAgICAgICAgXCJNYXBcIixcbiAgICAgICAgXCJNYXRoXCIsXG4gICAgICAgIFwiT2JqZWN0XCIsXG4gICAgICAgIFwiUHJvbWlzZVwiLFxuICAgICAgICBcIlJlZ0V4cFwiLFxuICAgICAgICBcIlNldFwiLFxuICAgICAgICBcIlN0cmluZ1wiLFxuICAgICAgICBcIlN5bWJvbFwiLFxuICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICAgICAgXCJVaW50OENsYW1wZWRBcnJheVwiLFxuICAgICAgICBcIlVpbnQxNkFycmF5XCIsXG4gICAgICAgIFwiVWludDMyQXJyYXlcIixcbiAgICAgICAgXCJXZWFrTWFwXCIsXG4gICAgICAgIFwiX1wiLFxuICAgICAgICBcImNsZWFyVGltZW91dFwiLFxuICAgICAgICBcImlzRmluaXRlXCIsXG4gICAgICAgIFwicGFyc2VJbnRcIixcbiAgICAgICAgXCJzZXRUaW1lb3V0XCJcbiAgICAgIF07XG4gICAgICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG4gICAgICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgICAgIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gICAgICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG4gICAgICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICAgICAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9IGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9IGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgICAgIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9IGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcbiAgICAgIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAgICAgXCJcXHhDMFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDMVwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDMlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDM1wiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDNFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDNVwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhFMFwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFMVwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFMlwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHhFNFwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFNVwiOiBcImFcIixcbiAgICAgICAgXCJcXHhDN1wiOiBcIkNcIixcbiAgICAgICAgXCJcXHhFN1wiOiBcImNcIixcbiAgICAgICAgXCJcXHhEMFwiOiBcIkRcIixcbiAgICAgICAgXCJcXHhGMFwiOiBcImRcIixcbiAgICAgICAgXCJcXHhDOFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDOVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDQVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDQlwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhFOFwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFOVwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQVwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQlwiOiBcImVcIixcbiAgICAgICAgXCJcXHhDQ1wiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRFwiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRVwiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRlwiOiBcIklcIixcbiAgICAgICAgXCJcXHhFQ1wiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRFwiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRVwiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRlwiOiBcImlcIixcbiAgICAgICAgXCJcXHhEMVwiOiBcIk5cIixcbiAgICAgICAgXCJcXHhGMVwiOiBcIm5cIixcbiAgICAgICAgXCJcXHhEMlwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhEM1wiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENFwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENVwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENlwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhEOFwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhGMlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGM1wiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGOFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhEOVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQlwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQ1wiOiBcIlVcIixcbiAgICAgICAgXCJcXHhGOVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQlwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQ1wiOiBcInVcIixcbiAgICAgICAgXCJcXHhERFwiOiBcIllcIixcbiAgICAgICAgXCJcXHhGRFwiOiBcInlcIixcbiAgICAgICAgXCJcXHhGRlwiOiBcInlcIixcbiAgICAgICAgXCJcXHhDNlwiOiBcIkFlXCIsXG4gICAgICAgIFwiXFx4RTZcIjogXCJhZVwiLFxuICAgICAgICBcIlxceERFXCI6IFwiVGhcIixcbiAgICAgICAgXCJcXHhGRVwiOiBcInRoXCIsXG4gICAgICAgIFwiXFx4REZcIjogXCJzc1wiLFxuICAgICAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICAgICBcIlxcdTAxMDBcIjogXCJBXCIsXG4gICAgICAgIFwiXFx1MDEwMlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHUwMTA0XCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTAxMDFcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MDEwM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHUwMTA1XCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTAxMDZcIjogXCJDXCIsXG4gICAgICAgIFwiXFx1MDEwOFwiOiBcIkNcIixcbiAgICAgICAgXCJcXHUwMTBBXCI6IFwiQ1wiLFxuICAgICAgICBcIlxcdTAxMENcIjogXCJDXCIsXG4gICAgICAgIFwiXFx1MDEwN1wiOiBcImNcIixcbiAgICAgICAgXCJcXHUwMTA5XCI6IFwiY1wiLFxuICAgICAgICBcIlxcdTAxMEJcIjogXCJjXCIsXG4gICAgICAgIFwiXFx1MDEwRFwiOiBcImNcIixcbiAgICAgICAgXCJcXHUwMTBFXCI6IFwiRFwiLFxuICAgICAgICBcIlxcdTAxMTBcIjogXCJEXCIsXG4gICAgICAgIFwiXFx1MDEwRlwiOiBcImRcIixcbiAgICAgICAgXCJcXHUwMTExXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTAxMTJcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDExNFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUwMTE2XCI6IFwiRVwiLFxuICAgICAgICBcIlxcdTAxMThcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDExQVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUwMTEzXCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTAxMTVcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDExN1wiOiBcImVcIixcbiAgICAgICAgXCJcXHUwMTE5XCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTAxMUJcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDExQ1wiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwMTFFXCI6IFwiR1wiLFxuICAgICAgICBcIlxcdTAxMjBcIjogXCJHXCIsXG4gICAgICAgIFwiXFx1MDEyMlwiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwMTFEXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTAxMUZcIjogXCJnXCIsXG4gICAgICAgIFwiXFx1MDEyMVwiOiBcImdcIixcbiAgICAgICAgXCJcXHUwMTIzXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTAxMjRcIjogXCJIXCIsXG4gICAgICAgIFwiXFx1MDEyNlwiOiBcIkhcIixcbiAgICAgICAgXCJcXHUwMTI1XCI6IFwiaFwiLFxuICAgICAgICBcIlxcdTAxMjdcIjogXCJoXCIsXG4gICAgICAgIFwiXFx1MDEyOFwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwMTJBXCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTAxMkNcIjogXCJJXCIsXG4gICAgICAgIFwiXFx1MDEyRVwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwMTMwXCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTAxMjlcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDEyQlwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMTJEXCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTAxMkZcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDEzMVwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMTM0XCI6IFwiSlwiLFxuICAgICAgICBcIlxcdTAxMzVcIjogXCJqXCIsXG4gICAgICAgIFwiXFx1MDEzNlwiOiBcIktcIixcbiAgICAgICAgXCJcXHUwMTM3XCI6IFwia1wiLFxuICAgICAgICBcIlxcdTAxMzhcIjogXCJrXCIsXG4gICAgICAgIFwiXFx1MDEzOVwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTNCXCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTAxM0RcIjogXCJMXCIsXG4gICAgICAgIFwiXFx1MDEzRlwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTQxXCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTAxM0FcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MDEzQ1wiOiBcImxcIixcbiAgICAgICAgXCJcXHUwMTNFXCI6IFwibFwiLFxuICAgICAgICBcIlxcdTAxNDBcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MDE0MlwiOiBcImxcIixcbiAgICAgICAgXCJcXHUwMTQzXCI6IFwiTlwiLFxuICAgICAgICBcIlxcdTAxNDVcIjogXCJOXCIsXG4gICAgICAgIFwiXFx1MDE0N1wiOiBcIk5cIixcbiAgICAgICAgXCJcXHUwMTRBXCI6IFwiTlwiLFxuICAgICAgICBcIlxcdTAxNDRcIjogXCJuXCIsXG4gICAgICAgIFwiXFx1MDE0NlwiOiBcIm5cIixcbiAgICAgICAgXCJcXHUwMTQ4XCI6IFwiblwiLFxuICAgICAgICBcIlxcdTAxNEJcIjogXCJuXCIsXG4gICAgICAgIFwiXFx1MDE0Q1wiOiBcIk9cIixcbiAgICAgICAgXCJcXHUwMTRFXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTAxNTBcIjogXCJPXCIsXG4gICAgICAgIFwiXFx1MDE0RFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUwMTRGXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTAxNTFcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MDE1NFwiOiBcIlJcIixcbiAgICAgICAgXCJcXHUwMTU2XCI6IFwiUlwiLFxuICAgICAgICBcIlxcdTAxNThcIjogXCJSXCIsXG4gICAgICAgIFwiXFx1MDE1NVwiOiBcInJcIixcbiAgICAgICAgXCJcXHUwMTU3XCI6IFwiclwiLFxuICAgICAgICBcIlxcdTAxNTlcIjogXCJyXCIsXG4gICAgICAgIFwiXFx1MDE1QVwiOiBcIlNcIixcbiAgICAgICAgXCJcXHUwMTVDXCI6IFwiU1wiLFxuICAgICAgICBcIlxcdTAxNUVcIjogXCJTXCIsXG4gICAgICAgIFwiXFx1MDE2MFwiOiBcIlNcIixcbiAgICAgICAgXCJcXHUwMTVCXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTAxNURcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MDE1RlwiOiBcInNcIixcbiAgICAgICAgXCJcXHUwMTYxXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTAxNjJcIjogXCJUXCIsXG4gICAgICAgIFwiXFx1MDE2NFwiOiBcIlRcIixcbiAgICAgICAgXCJcXHUwMTY2XCI6IFwiVFwiLFxuICAgICAgICBcIlxcdTAxNjNcIjogXCJ0XCIsXG4gICAgICAgIFwiXFx1MDE2NVwiOiBcInRcIixcbiAgICAgICAgXCJcXHUwMTY3XCI6IFwidFwiLFxuICAgICAgICBcIlxcdTAxNjhcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MDE2QVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHUwMTZDXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTAxNkVcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MDE3MFwiOiBcIlVcIixcbiAgICAgICAgXCJcXHUwMTcyXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTAxNjlcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDE2QlwiOiBcInVcIixcbiAgICAgICAgXCJcXHUwMTZEXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTAxNkZcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDE3MVwiOiBcInVcIixcbiAgICAgICAgXCJcXHUwMTczXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTAxNzRcIjogXCJXXCIsXG4gICAgICAgIFwiXFx1MDE3NVwiOiBcIndcIixcbiAgICAgICAgXCJcXHUwMTc2XCI6IFwiWVwiLFxuICAgICAgICBcIlxcdTAxNzdcIjogXCJ5XCIsXG4gICAgICAgIFwiXFx1MDE3OFwiOiBcIllcIixcbiAgICAgICAgXCJcXHUwMTc5XCI6IFwiWlwiLFxuICAgICAgICBcIlxcdTAxN0JcIjogXCJaXCIsXG4gICAgICAgIFwiXFx1MDE3RFwiOiBcIlpcIixcbiAgICAgICAgXCJcXHUwMTdBXCI6IFwielwiLFxuICAgICAgICBcIlxcdTAxN0NcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MDE3RVwiOiBcInpcIixcbiAgICAgICAgXCJcXHUwMTMyXCI6IFwiSUpcIixcbiAgICAgICAgXCJcXHUwMTMzXCI6IFwiaWpcIixcbiAgICAgICAgXCJcXHUwMTUyXCI6IFwiT2VcIixcbiAgICAgICAgXCJcXHUwMTUzXCI6IFwib2VcIixcbiAgICAgICAgXCJcXHUwMTQ5XCI6IFwiJ25cIixcbiAgICAgICAgXCJcXHUwMTdGXCI6IFwic1wiXG4gICAgICB9O1xuICAgICAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgICBcIjxcIjogXCImbHQ7XCIsXG4gICAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICAgICAgXCInXCI6IFwiJiMzOTtcIlxuICAgICAgfTtcbiAgICAgIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICAgICBcIiZhbXA7XCI6IFwiJlwiLFxuICAgICAgICBcIiZsdDtcIjogXCI8XCIsXG4gICAgICAgIFwiJmd0O1wiOiBcIj5cIixcbiAgICAgICAgXCImcXVvdDtcIjogJ1wiJyxcbiAgICAgICAgXCImIzM5O1wiOiBcIidcIlxuICAgICAgfTtcbiAgICAgIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICAgICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gICAgICAgIFwiJ1wiOiBcIidcIixcbiAgICAgICAgXCJcXG5cIjogXCJuXCIsXG4gICAgICAgIFwiXFxyXCI6IFwiclwiLFxuICAgICAgICBcIlxcdTIwMjhcIjogXCJ1MjAyOFwiLFxuICAgICAgICBcIlxcdTIwMjlcIjogXCJ1MjAyOVwiXG4gICAgICB9O1xuICAgICAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCwgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcbiAgICAgIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG4gICAgICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuICAgICAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG4gICAgICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG4gICAgICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcbiAgICAgIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuICAgICAgdmFyIG5vZGVVdGlsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKFwidXRpbFwiKS50eXBlcztcbiAgICAgICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZyhcInV0aWxcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgICAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlciwgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSwgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLCBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCwgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcbiAgICAgIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzSW5kZXggPSAwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCwgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KFwibGVuZ3RoXCIpO1xuICAgICAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KFwiXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuICAgICAgICB3aGlsZSAoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCA6IE5BTjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBvYmplY3Rba2V5XTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkMiA6IG9iamVjdFtrZXldO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSkgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uMik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQyID8gY3VycmVudCA6IHJlc3VsdCArIGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG4pO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsIFwiXCIpIDogc3RyaW5nO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgICAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc3VsdCA9IDA7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgKytyZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcbiAgICAgIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcbiAgICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgICAgIHJldHVybiBcIlxcXFxcIiArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgICAgICB2YXIgZGF0YSwgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcbiAgICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc0luZGV4ID0gMCwgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcbiAgICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuICAgICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKSA/IHVuaWNvZGVTaXplKHN0cmluZykgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZykgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG4gICAgICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICAgICsrcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIHJ1bkluQ29udGV4dDIoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuICAgICAgICB2YXIgQXJyYXkyID0gY29udGV4dC5BcnJheSwgRGF0ZTIgPSBjb250ZXh0LkRhdGUsIEVycm9yMiA9IGNvbnRleHQuRXJyb3IsIEZ1bmN0aW9uMiA9IGNvbnRleHQuRnVuY3Rpb24sIE1hdGgyID0gY29udGV4dC5NYXRoLCBPYmplY3QyID0gY29udGV4dC5PYmplY3QsIFJlZ0V4cDIgPSBjb250ZXh0LlJlZ0V4cCwgU3RyaW5nMiA9IGNvbnRleHQuU3RyaW5nLCBUeXBlRXJyb3IyID0gY29udGV4dC5UeXBlRXJyb3I7XG4gICAgICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkyLnByb3RvdHlwZSwgZnVuY1Byb3RvID0gRnVuY3Rpb24yLnByb3RvdHlwZSwgb2JqZWN0UHJvdG8gPSBPYmplY3QyLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0W1wiX19jb3JlLWpzX3NoYXJlZF9fXCJdO1xuICAgICAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgdmFyIGlkQ291bnRlciA9IDA7XG4gICAgICAgIHZhciBtYXNrU3JjS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8IFwiXCIpO1xuICAgICAgICAgIHJldHVybiB1aWQgPyBcIlN5bWJvbChzcmMpXzEuXCIgKyB1aWQgOiBcIlwiO1xuICAgICAgICB9KCk7XG4gICAgICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuICAgICAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdDIpO1xuICAgICAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcbiAgICAgICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAyKFxuICAgICAgICAgIFwiXlwiICsgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCBcIiQxLio/XCIpICsgXCIkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIEJ1ZmZlcjIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQyLCBTeW1ib2wyID0gY29udGV4dC5TeW1ib2wsIFVpbnQ4QXJyYXkyID0gY29udGV4dC5VaW50OEFycmF5LCBhbGxvY1Vuc2FmZSA9IEJ1ZmZlcjIgPyBCdWZmZXIyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkMiwgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QyLmdldFByb3RvdHlwZU9mLCBPYmplY3QyKSwgb2JqZWN0Q3JlYXRlID0gT2JqZWN0Mi5jcmVhdGUsIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLCBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sMiA/IFN5bWJvbDIuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkMiwgc3ltSXRlcmF0b3IgPSBTeW1ib2wyID8gU3ltYm9sMi5pdGVyYXRvciA6IHVuZGVmaW5lZDIsIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sMiA/IFN5bWJvbDIudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQyO1xuICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0MiwgXCJkZWZpbmVQcm9wZXJ0eVwiKTtcbiAgICAgICAgICAgIGZ1bmMoe30sIFwiXCIsIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCwgY3R4Tm93ID0gRGF0ZTIgJiYgRGF0ZTIubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUyLm5vdywgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcbiAgICAgICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoMi5jZWlsLCBuYXRpdmVGbG9vciA9IE1hdGgyLmZsb29yLCBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0Mi5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyMiA/IEJ1ZmZlcjIuaXNCdWZmZXIgOiB1bmRlZmluZWQyLCBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdDIua2V5cywgT2JqZWN0MiksIG5hdGl2ZU1heCA9IE1hdGgyLm1heCwgbmF0aXZlTWluID0gTWF0aDIubWluLCBuYXRpdmVOb3cgPSBEYXRlMi5ub3csIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCwgbmF0aXZlUmFuZG9tID0gTWF0aDIucmFuZG9tLCBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuICAgICAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgXCJEYXRhVmlld1wiKSwgTWFwMiA9IGdldE5hdGl2ZShjb250ZXh0LCBcIk1hcFwiKSwgUHJvbWlzZTIgPSBnZXROYXRpdmUoY29udGV4dCwgXCJQcm9taXNlXCIpLCBTZXQyID0gZ2V0TmF0aXZlKGNvbnRleHQsIFwiU2V0XCIpLCBXZWFrTWFwMiA9IGdldE5hdGl2ZShjb250ZXh0LCBcIldlYWtNYXBcIiksIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QyLCBcImNyZWF0ZVwiKTtcbiAgICAgICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwMiAmJiBuZXcgV2Vha01hcDIoKTtcbiAgICAgICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuICAgICAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLCBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwMiksIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZTIpLCBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0MiksIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcDIpO1xuICAgICAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wyID8gU3ltYm9sMi5wcm90b3R5cGUgOiB1bmRlZmluZWQyLCBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkMiwgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkMjtcbiAgICAgICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwiX193cmFwcGVkX19cIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jdGlvbiBvYmplY3QoKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IG9iamVjdCgpO1xuICAgICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIFwiZXNjYXBlXCI6IHJlRXNjYXBlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAgICovXG4gICAgICAgICAgXCJldmFsdWF0ZVwiOiByZUV2YWx1YXRlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAgICovXG4gICAgICAgICAgXCJpbnRlcnBvbGF0ZVwiOiByZUludGVycG9sYXRlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIFwidmFyaWFibGVcIjogXCJcIixcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBcImltcG9ydHNcIjoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiX1wiOiBsb2Rhc2hcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcbiAgICAgICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICAgICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuICAgICAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgICAgICByZXN1bHQyLl9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICAgICAgcmVzdWx0Mi5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgICAgICByZXN1bHQyLl9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgICAgICByZXN1bHQyLl9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICAgICAgcmVzdWx0Mi5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICByZXN1bHQyLl9fZGlyX18gPSAtMTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19kaXJfXyAqPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSwgZGlyID0gdGhpcy5fX2Rpcl9fLCBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLCBpc1JpZ2h0ID0gZGlyIDwgMCwgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLCB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSwgc3RhcnQgPSB2aWV3LnN0YXJ0LCBlbmQgPSB2aWV3LmVuZCwgbGVuZ3RoID0gZW5kIC0gc3RhcnQsIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IHN0YXJ0IC0gMSwgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLCBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCwgcmVzSW5kZXggPSAwLCB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuICAgICAgICAgIGlmICghaXNBcnIgfHwgIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSwgaXRlcmF0ZWUyID0gZGF0YS5pdGVyYXRlZSwgdHlwZSA9IGRhdGEudHlwZSwgY29tcHV0ZWQgPSBpdGVyYXRlZTIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcbiAgICAgICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICAgICAgdGhpcy5zaXplIC09IHJlc3VsdDIgPyAxIDogMDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZDIgOiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQyIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgICAgIGRhdGFba2V5XSA9IG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkMiA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgICAgIEhhc2gucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gaGFzaERlbGV0ZTtcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcbiAgICAgICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLCBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZDIgOiBkYXRhW2luZGV4XVsxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gbGlzdENhY2hlRGVsZXRlO1xuICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICAgICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuICAgICAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICAgICBcImhhc2hcIjogbmV3IEhhc2goKSxcbiAgICAgICAgICAgIFwibWFwXCI6IG5ldyAoTWFwMiB8fCBMaXN0Q2FjaGUpKCksXG4gICAgICAgICAgICBcInN0cmluZ1wiOiBuZXcgSGFzaCgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGdldE1hcERhdGEodGhpcywga2V5KVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQyID8gMSA6IDA7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSwgc2l6ZTIgPSBkYXRhLnNpemU7XG4gICAgICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplMiA/IDAgOiAxO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgICAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICAgICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuICAgICAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHZhbHVlczIgPT0gbnVsbCA/IDAgOiB2YWx1ZXMyLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlczJbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICAgICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuICAgICAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLCByZXN1bHQyID0gZGF0YVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICAgICAgaWYgKCFNYXAyIHx8IHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSB7XG4gICAgICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICAgICAgU3RhY2sucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gc3RhY2tEZWxldGU7XG4gICAgICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICAgICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgICAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLCBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLCBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSwgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLCByZXN1bHQyID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcyKSA6IFtdLCBsZW5ndGggPSByZXN1bHQyLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmICEoc2tpcEluZGV4ZXMgJiYgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgKGtleSA9PSBcImxlbmd0aFwiIHx8IC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgaXNCdWZmICYmIChrZXkgPT0gXCJvZmZzZXRcIiB8fCBrZXkgPT0gXCJwYXJlbnRcIikgfHwgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgaXNUeXBlICYmIChrZXkgPT0gXCJidWZmZXJcIiB8fCBrZXkgPT0gXCJieXRlTGVuZ3RoXCIgfHwga2V5ID09IFwiYnl0ZU9mZnNldFwiKSB8fCAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkMiAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkMiAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlMiwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUyKHZhbHVlKSwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoa2V5ID09IFwiX19wcm90b19fXCIgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgICAgIFwiY29uZmlndXJhYmxlXCI6IHRydWUsXG4gICAgICAgICAgICAgIFwiZW51bWVyYWJsZVwiOiB0cnVlLFxuICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLFxuICAgICAgICAgICAgICBcIndyaXRhYmxlXCI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBwYXRocy5sZW5ndGgsIHJlc3VsdDIgPSBBcnJheTIobGVuZ3RoKSwgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQyIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiwgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRywgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRywgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG4gICAgICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IGlzRnVuYyAmJiAhb2JqZWN0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBpc0ZsYXQgfHwgaXNGdW5jID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0ZsYXQgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0MiwgdmFsdWUpKSA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdDIsIHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdDIpO1xuICAgICAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5Mikge1xuICAgICAgICAgICAgICByZXN1bHQyLnNldChrZXkyLCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleTIsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrZXlzRnVuYyA9IGlzRnVsbCA/IGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMgOiBpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkMiA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgICAgICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkyKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAga2V5MiA9IHN1YlZhbHVlO1xuICAgICAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0Miwga2V5MiwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXkyLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBPYmplY3QyKG9iamVjdCk7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSwgcHJlZGljYXRlID0gc291cmNlW2tleV0sIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgIShrZXkgaW4gb2JqZWN0KSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVuZGVmaW5lZDIsIGFyZ3MpO1xuICAgICAgICAgIH0sIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlcywgaXNDb21tb24gPSB0cnVlLCBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc3VsdDIgPSBbXSwgdmFsdWVzTGVuZ3RoID0gdmFsdWVzMi5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICB2YWx1ZXMyID0gYXJyYXlNYXAodmFsdWVzMiwgYmFzZVVuYXJ5KGl0ZXJhdGVlMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVzMi5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gY2FjaGVIYXM7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFsdWVzMiA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sIGNvbXB1dGVkID0gaXRlcmF0ZWUyID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlMih2YWx1ZSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCA/IHZhbHVlIDogMDtcbiAgICAgICAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlczJbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5jbHVkZXMyKHZhbHVlczIsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcbiAgICAgICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0cnVlO1xuICAgICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLCBjdXJyZW50ID0gaXRlcmF0ZWUyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWQyID8gY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKSkpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCwgcmVzdWx0MiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiBsZW5ndGggKyBzdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQyIHx8IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgICAgIHJlc3VsdDIgfHwgKHJlc3VsdDIgPSBbXSk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0Mik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdDIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXN1bHQyLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG4gICAgICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUyLCBrZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlMiwga2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICAgIHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCA/IG9iamVjdCA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdDIgOiBhcnJheVB1c2gocmVzdWx0Miwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDIgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0Mih2YWx1ZSkgPyBnZXRSYXdUYWcodmFsdWUpIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGluY2x1ZGVzMiA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsIG90aEluZGV4ID0gb3RoTGVuZ3RoLCBjYWNoZXMgPSBBcnJheTIob3RoTGVuZ3RoKSwgbWF4TGVuZ3RoID0gSW5maW5pdHksIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUyIHx8IGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIHNlZW4gPSBjYWNoZXNbMF07XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQyLmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sIGNvbXB1dGVkID0gaXRlcmF0ZWUyID8gaXRlcmF0ZWUyKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgICAgICAgIGlmICghKHNlZW4gPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZCkgOiBpbmNsdWRlczIocmVzdWx0MiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSkge1xuICAgICAgICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY2FjaGUgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpIDogaW5jbHVkZXMyKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQyLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZTIsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgaXRlcmF0ZWUyKHZhbHVlKSwga2V5LCBvYmplY3QyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkMiA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAhaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLCBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLCBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuICAgICAgICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgICAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICAgICAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZywgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcbiAgICAgICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBcIl9fd3JhcHBlZF9fXCIpLCBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBcIl9fd3JhcHBlZF9fXCIpO1xuICAgICAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LCBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG4gICAgICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCwgbGVuZ3RoID0gaW5kZXgsIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IE9iamVjdDIob2JqZWN0KTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dIDogIShkYXRhWzBdIGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgICAgICB2YXIga2V5ID0gZGF0YVswXSwgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSwgc3JjVmFsdWUgPSBkYXRhWzFdO1xuICAgICAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkMiAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEocmVzdWx0MiA9PT0gdW5kZWZpbmVkMiA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaykgOiByZXN1bHQyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKSA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdDIob2JqZWN0KSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSwgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghKGtleSA9PSBcImNvbnN0cnVjdG9yXCIgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheTIoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG4gICAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbjIpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbKytpbmRleF0gPSBpdGVyYXRlZTIodmFsdWUsIGtleSwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqVmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlID8gaGFzSW4ob2JqZWN0LCBwYXRoKSA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCBrZXkgKyBcIlwiLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwga2V5c0luKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkgKyBcIlwiLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkMjtcbiAgICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLCBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLCBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZTIubGVuZ3RoID09PSAxID8gaXRlcmF0ZWUyWzBdIDogaXRlcmF0ZWUyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZTI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICAgIHZhciByZXN1bHQyID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlMih2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IFwiY3JpdGVyaWFcIjogY3JpdGVyaWEsIFwiaW5kZXhcIjogKytpbmRleCwgXCJ2YWx1ZVwiOiB2YWx1ZSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdDIsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCwgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSwgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgICAgICBiYXNlU2V0KHJlc3VsdDIsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXhPZjIgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsIGluZGV4ID0gLTEsIGxlbmd0aCA9IHZhbHVlczIubGVuZ3RoLCBzZWVuID0gYXJyYXk7XG4gICAgICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMyKSB7XG4gICAgICAgICAgICB2YWx1ZXMyID0gY29weUFycmF5KHZhbHVlczIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZTIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmcm9tSW5kZXggPSAwLCB2YWx1ZSA9IHZhbHVlczJbaW5kZXhdLCBjb21wdXRlZCA9IGl0ZXJhdGVlMiA/IGl0ZXJhdGVlMih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZjIoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLCByZXN1bHQyID0gQXJyYXkyKGxlbmd0aCk7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICByZXN1bHQyW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgICAgICByZXN1bHQyICs9IHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKG4pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGgubGVuZ3RoLCBsYXN0SW5kZXggPSBsZW5ndGggLSAxLCBuZXN0ZWQgPSBvYmplY3Q7XG4gICAgICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiIHx8IGtleSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGtleSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSkgPyBvYmpWYWx1ZSA6IGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgXCJ0b1N0cmluZ1wiLCB7XG4gICAgICAgICAgICBcImNvbmZpZ3VyYWJsZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJlbnVtZXJhYmxlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAgICAgXCJ3cml0YWJsZVwiOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IGxlbmd0aCArIHN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6IGVuZCAtIHN0YXJ0ID4+PiAwO1xuICAgICAgICAgIHN0YXJ0ID4+Pj0gMDtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IEFycmF5MihsZW5ndGgpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MjtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgICAgcmV0dXJuICFyZXN1bHQyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAhIXJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgICB2YXIgbWlkID0gbG93ICsgaGlnaCA+Pj4gMSwgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuICAgICAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJiAocmV0SGlnaGVzdCA/IGNvbXB1dGVkIDw9IHZhbHVlIDogY29tcHV0ZWQgPCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZTIsIHJldEhpZ2hlc3QpIHtcbiAgICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBpdGVyYXRlZTIodmFsdWUpO1xuICAgICAgICAgIHZhciB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSwgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLCB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQyO1xuICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksIGNvbXB1dGVkID0gaXRlcmF0ZWUyKGFycmF5W21pZF0pLCBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkMiwgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLCBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcbiAgICAgICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IGNvbXB1dGVkIDw9IHZhbHVlIDogY29tcHV0ZWQgPCB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgcmVzSW5kZXggPSAwLCByZXN1bHQyID0gW107XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSwgY29tcHV0ZWQgPSBpdGVyYXRlZTIgPyBpdGVyYXRlZTIodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gdmFsdWUgKyBcIlwiO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09IFwiMFwiICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyBcIi0wXCIgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlcywgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBpc0NvbW1vbiA9IHRydWUsIHJlc3VsdDIgPSBbXSwgc2VlbiA9IHJlc3VsdDI7XG4gICAgICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBpbmNsdWRlczIgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgICAgICB2YXIgc2V0MiA9IGl0ZXJhdGVlMiA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICAgICAgaWYgKHNldDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gY2FjaGVIYXM7XG4gICAgICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW4gPSBpdGVyYXRlZTIgPyBbXSA6IHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dGVyOlxuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLCBjb21wdXRlZCA9IGl0ZXJhdGVlMiA/IGl0ZXJhdGVlMih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwID8gdmFsdWUgOiAwO1xuICAgICAgICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluY2x1ZGVzMihzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0Mikge1xuICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcbiAgICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJiBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0Ryb3AgPyBiYXNlU2xpY2UoYXJyYXksIGZyb21SaWdodCA/IDAgOiBpbmRleCwgZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSA6IGJhc2VTbGljZShhcnJheSwgZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCwgZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHZhbHVlO1xuICAgICAgICAgIGlmIChyZXN1bHQyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQzLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHQzXSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgICAgICB9LCByZXN1bHQyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gQXJyYXkyKGxlbmd0aCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sIG90aEluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdDJbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQyLCAxKSwgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMyLCBhc3NpZ25GdW5jKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgdmFsc0xlbmd0aCA9IHZhbHVlczIubGVuZ3RoLCByZXN1bHQyID0ge307XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlczJbaW5kZXhdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0MiwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG4gICAgICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogZW5kO1xuICAgICAgICAgIHJldHVybiAhc3RhcnQgJiYgZW5kID49IGxlbmd0aCA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLCByZXN1bHQyID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuICAgICAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdDIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICBuZXcgVWludDhBcnJheTIocmVzdWx0Mikuc2V0KG5ldyBVaW50OEFycmF5MihhcnJheUJ1ZmZlcikpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICAgICAgcmVzdWx0Mi5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0MihzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZDIsIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLCB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSwgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZDIsIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLCBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlciwgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG4gICAgICAgICAgICBpZiAoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIgfHwgdmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sIHx8IHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgfHwgIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSB8fCAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIgfHwgb3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sIHx8IG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgfHwgIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSB8fCAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLCBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLCBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKiAob3JkZXIgPT0gXCJkZXNjXCIgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLCBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsIGxlZnRJbmRleCA9IC0xLCBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksIHJlc3VsdDIgPSBBcnJheTIobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSwgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuICAgICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDJbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdDJbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLCBob2xkZXJzSW5kZXggPSAtMSwgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLCByaWdodEluZGV4ID0gLTEsIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksIHJlc3VsdDIgPSBBcnJheTIocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcbiAgICAgICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0MlthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0MltvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bHQyW29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheTIobGVuZ3RoKSk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLCBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQyLCBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IChsZW5ndGgtLSwgY3VzdG9taXplcikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZDIgOiBjdXN0b21pemVyO1xuICAgICAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsIGl0ZXJhYmxlID0gT2JqZWN0Mihjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIHdoaWxlIChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoaXRlcmF0ZWUyKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlMiwga2V5c0Z1bmMpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpdGVyYWJsZSA9IE9iamVjdDIob2JqZWN0KSwgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLCBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoaXRlcmF0ZWUyKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRywgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlciA/IEN0b3IgOiBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKSA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9scyA/IHN0clN5bWJvbHNbMF0gOiBzdHJpbmcuY2hhckF0KDApO1xuICAgICAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9scyA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKFwiXCIpIDogc3RyaW5nLnNsaWNlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCBcIlwiKSksIGNhbGxiYWNrLCBcIlwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCk7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSwgcmVzdWx0MiA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdDIpID8gcmVzdWx0MiA6IHRoaXNCaW5kaW5nO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlbmd0aCksIGluZGV4ID0gbGVuZ3RoLCBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBob2xkZXJzID0gbGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlciA/IFtdIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgICAgICBjcmVhdGVIeWJyaWQsXG4gICAgICAgICAgICAgICAgd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQyLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgaG9sZGVycyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQyLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDIsXG4gICAgICAgICAgICAgICAgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlciA/IEN0b3IgOiBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QyKGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgaXRlcmF0ZWUyID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZTIoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUyID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQyO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsIGluZGV4ID0gbGVuZ3RoLCBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuICAgICAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSBcIndyYXBwZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLCBkYXRhID0gZnVuY05hbWUgPT0gXCJ3cmFwcGVyXCIgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJiBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDEpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSA/IHdyYXBwZXJbZnVuY05hbWVdKCkgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIHZhbHVlID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleDIgPSAwLCByZXN1bHQyID0gbGVuZ3RoID8gZnVuY3NbaW5kZXgyXS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuICAgICAgICAgICAgICB3aGlsZSAoKytpbmRleDIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gZnVuY3NbaW5kZXgyXS5jYWxsKHRoaXMsIHJlc3VsdDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnkyLCBhcml0eSkge1xuICAgICAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLCBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSwgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLCBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkMiA6IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlbmd0aCksIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgICAgICBjcmVhdGVIeWJyaWQsXG4gICAgICAgICAgICAgICAgd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgbmV3SG9sZGVycyxcbiAgICAgICAgICAgICAgICBhcmdQb3MsXG4gICAgICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgICAgICBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeTIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJncy5sZW5ndGggPSBhcnkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUyKSwge30pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgb3RoZXIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICByZXN1bHQyID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBvdGhlciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZTIsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZDIgPyBcIiBcIiA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG4gICAgICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0MiksIDAsIGxlbmd0aCkuam9pbihcIlwiKSA6IHJlc3VsdDIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRywgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGxlZnRJbmRleCA9IC0xLCBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSwgZm4gPSB0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIgPyBDdG9yIDogZnVuYztcbiAgICAgICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSBcIm51bWJlclwiICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZDIgPyBzdGFydCA8IGVuZCA/IDEgOiAtMSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvdGhlciA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnkyLCBhcml0eSkge1xuICAgICAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRywgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkMiwgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZDIgOiBob2xkZXJzLCBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZDIsIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkMiA6IHBhcnRpYWxzO1xuICAgICAgICAgIGJpdG1hc2sgfD0gaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUc7XG4gICAgICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcbiAgICAgICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBuZXdQYXJ0aWFscyxcbiAgICAgICAgICAgIG5ld0hvbGRlcnMsXG4gICAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LFxuICAgICAgICAgICAgYXJnUG9zLFxuICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgIGFyaXR5XG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZDIsIG5ld0RhdGEpO1xuICAgICAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgICAgICBzZXREYXRhKHJlc3VsdDIsIG5ld0RhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQyLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQyLCBmdW5jLCBiaXRtYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBNYXRoMlttZXRob2ROYW1lXTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArIFwiZVwiKS5zcGxpdChcImVcIiksIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgXCJlXCIgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyBcImVcIikuc3BsaXQoXCJlXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgXCJlXCIgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQyICYmIDEgLyBzZXRUb0FycmF5KG5ldyBTZXQyKFssIC0wXSkpWzFdID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQyKHZhbHVlczIpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5MiwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyeTIgPSBhcnkyID09PSB1bmRlZmluZWQyID8gYXJ5MiA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5MiksIDApO1xuICAgICAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZDIgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscywgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcbiAgICAgICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkMiA6IGdldERhdGEoZnVuYyk7XG4gICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnMsXG4gICAgICAgICAgICBwYXJ0aWFsc1JpZ2h0LFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0LFxuICAgICAgICAgICAgYXJnUG9zLFxuICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgIGFyaXR5XG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkMiA/IGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aCA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcbiAgICAgICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQyLCBuZXdEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0MiwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkMiB8fCBlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQyLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQyIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRywgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gdHJ1ZSwgc2VlbiA9IGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHID8gbmV3IFNldENhY2hlKCkgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKSA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZTIsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiYgKGFyclZhbHVlID09PSBvdGhWYWx1ZTIgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZTIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShhcnJheSk7XG4gICAgICAgICAgc3RhY2tbXCJkZWxldGVcIl0ob3RoZXIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICAgIGlmIChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoIHx8IG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG4gICAgICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgICAgICBpZiAob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCB8fCAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5MihvYmplY3QpLCBuZXcgVWludDhBcnJheTIob3RoZXIpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcbiAgICAgICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG4gICAgICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG90aGVyICsgXCJcIjtcbiAgICAgICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG4gICAgICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuICAgICAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuICAgICAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQyID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgICAgIHN0YWNrW1wiZGVsZXRlXCJdKG9iamVjdCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRywgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCwgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSwgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgICAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0cnVlO1xuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSwgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZDIgPyBvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIDogY29tcGFyZWQpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDIgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3Rvciwgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJiAoXCJjb25zdHJ1Y3RvclwiIGluIG9iamVjdCAmJiBcImNvbnN0cnVjdG9yXCIgaW4gb3RoZXIpICYmICEodHlwZW9mIG9iakN0b3IgPT0gXCJmdW5jdGlvblwiICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmIHR5cGVvZiBvdGhDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShvYmplY3QpO1xuICAgICAgICAgIHN0YWNrW1wiZGVsZXRlXCJdKG90aGVyKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZDIsIGZsYXR0ZW4pLCBmdW5jICsgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5uYW1lICsgXCJcIiwgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0Ml0sIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQyKSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgXCJwbGFjZWhvbGRlclwiKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgICAgICByZXN1bHQyID0gcmVzdWx0MiA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQyO1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0Mihhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwMiwga2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBtYXAyLl9fZGF0YV9fO1xuICAgICAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KSA/IGRhdGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwiaGFzaFwiXSA6IGRhdGEubWFwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGtleXMob2JqZWN0KSwgbGVuZ3RoID0gcmVzdWx0Mi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcmVzdWx0MltsZW5ndGhdLCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgcmVzdWx0MltsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLCB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IE9iamVjdDIob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0MiwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG4gICAgICAgIGlmIChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnIHx8IE1hcDIgJiYgZ2V0VGFnKG5ldyBNYXAyKCkpICE9IG1hcFRhZyB8fCBQcm9taXNlMiAmJiBnZXRUYWcoUHJvbWlzZTIucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnIHx8IFNldDIgJiYgZ2V0VGFnKG5ldyBTZXQyKCkpICE9IHNldFRhZyB8fCBXZWFrTWFwMiAmJiBnZXRUYWcobmV3IFdlYWtNYXAyKCkpICE9IHdlYWtNYXBUYWcpIHtcbiAgICAgICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlR2V0VGFnKHZhbHVlKSwgQ3RvciA9IHJlc3VsdDIgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQyLCBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSwgc2l6ZTIgPSBkYXRhLnNpemU7XG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZHJvcFwiOlxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHNpemUyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZHJvcFJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgZW5kIC09IHNpemUyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGFrZVwiOlxuICAgICAgICAgICAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZTIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGFrZVJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgXCJzdGFydFwiOiBzdGFydCwgXCJlbmRcIjogZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGgubGVuZ3RoLCByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAoIShyZXN1bHQyID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQyIHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJiAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgcmVzdWx0MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuICAgICAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09IFwic3RyaW5nXCIgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgXCJpbmRleFwiKSkge1xuICAgICAgICAgICAgcmVzdWx0Mi5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICAgICAgcmVzdWx0Mi5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gXCJmdW5jdGlvblwiICYmICFpc1Byb3RvdHlwZShvYmplY3QpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG4gICAgICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcbiAgICAgICAgICAgIGNhc2UgZmxvYXQzMlRhZzpcbiAgICAgICAgICAgIGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgICAgIGNhc2UgaW50OFRhZzpcbiAgICAgICAgICAgIGNhc2UgaW50MTZUYWc6XG4gICAgICAgICAgICBjYXNlIGludDMyVGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50OFRhZzpcbiAgICAgICAgICAgIGNhc2UgdWludDhDbGFtcGVkVGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50MTZUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG4gICAgICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCk7XG4gICAgICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoKTtcbiAgICAgICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/IFwiJiBcIiA6IFwiXCIpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/IFwiLCBcIiA6IFwiIFwiKTtcbiAgICAgICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgXCJ7XFxuLyogW3dyYXBwZWQgd2l0aCBcIiArIGRldGFpbHMgKyBcIl0gKi9cXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHwgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiAhIWxlbmd0aCAmJiAodHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgIT0gXCJzeW1ib2xcIiAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgICAgIGlmICh0eXBlID09IFwibnVtYmVyXCIgPyBpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpIDogdHlwZSA9PSBcInN0cmluZ1wiICYmIGluZGV4IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gXCJudW1iZXJcIiB8fCB0eXBlID09IFwic3ltYm9sXCIgfHwgdHlwZSA9PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHwgb2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0eXBlID09IFwic3RyaW5nXCIgfHwgdHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgPT0gXCJzeW1ib2xcIiB8fCB0eXBlID09IFwiYm9vbGVhblwiID8gdmFsdWUgIT09IFwiX19wcm90b19fXCIgOiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSwgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gXCJmdW5jdGlvblwiIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiBtYXNrU3JjS2V5IGluIGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLCBwcm90byA9IHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBDdG9yLnByb3RvdHlwZSB8fCBvYmplY3RQcm90bztcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiYgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQyIHx8IGtleSBpbiBPYmplY3QyKG9iamVjdCkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBtZW1vaXplMihmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjYWNoZSA9IHJlc3VsdDIuY2FjaGU7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSwgc3JjQml0bWFzayA9IHNvdXJjZVsxXSwgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLCBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcbiAgICAgICAgICB2YXIgaXNDb21ibyA9IHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRyAmJiBiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcgJiYgZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdIHx8IHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmIHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdICYmIGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHO1xuICAgICAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3QyKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0yKSB7XG4gICAgICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZDIgPyBmdW5jLmxlbmd0aCAtIDEgOiBzdGFydCwgMCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGluZGV4ID0gLTEsIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSwgYXJyYXkgPSBBcnJheTIobGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5MihzdGFydCArIDEpO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtMihhcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcbiAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSBcImNvbnN0cnVjdG9yXCIgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSA9PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcbiAgICAgICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuICAgICAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHJlZmVyZW5jZSArIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMCwgbGFzdENhbGxlZCA9IDA7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQyLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICBzaXplMiA9IHNpemUyID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogc2l6ZTI7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplMikge1xuICAgICAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLCB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuICAgICAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTI7XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0Nikge1xuICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQyLnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsIFwiJDFcIikgOiBudW1iZXIgfHwgbWF0Y2gpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gdmFsdWUgKyBcIlwiO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09IFwiMFwiICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyBcIi0wXCIgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYyArIFwiXCI7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBcIl8uXCIgKyBwYWlyWzBdO1xuICAgICAgICAgICAgaWYgKGJpdG1hc2sgJiBwYWlyWzFdICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgICAgIHJlc3VsdDIuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2luZGV4X18gPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgICAgICByZXN1bHQyLl9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUyLCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplMiwgZ3VhcmQpIDogc2l6ZTIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHNpemUyID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZTIgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUyKSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCB8fCBzaXplMiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCwgcmVzSW5kZXggPSAwLCByZXN1bHQyID0gQXJyYXkyKG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZTIpKTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCBpbmRleCArPSBzaXplMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsIHJlc0luZGV4ID0gMCwgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheTIobGVuZ3RoIC0gMSksIGFycmF5ID0gYXJndW1lbnRzWzBdLCBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSkgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzMiwgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlMiA9IGxhc3QodmFsdWVzMik7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSkgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzMiwgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlczIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzMik7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KSA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMyLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZDIsIGNvbXBhcmF0b3IpIDogW107XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBndWFyZCB8fCBuID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSkgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSBcIm51bWJlclwiICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLCByZXN1bHQyID0ge307XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0MltwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYXJyYXlbMF0gOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0gPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCkgOiBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyksIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlMiA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgICAgICBpdGVyYXRlZTIgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMikpIDogW107XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLCBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSBcImZ1bmN0aW9uXCIgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBcIlwiIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KSA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuICAgICAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMyICYmIHZhbHVlczIubGVuZ3RoID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlczIpIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlczIgJiYgdmFsdWVzMi5sZW5ndGggPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzMiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSkgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzMiwgY29tcGFyYXRvcikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzMiAmJiB2YWx1ZXMyLmxlbmd0aCA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMyLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKSA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0MiA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpbmRleGVzID0gW10sIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gXCJudW1iZXJcIiAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZDIgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkMiwgY29tcGFyYXRvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkMiwgY29tcGFyYXRvcikgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHVuemlwKGFycmF5KTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0MiwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZTIsIHVuZGVmaW5lZDIsIGdyb3VwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KSA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMyKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG4gICAgICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMyIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMyIHx8IFtdLCBiYXNlU2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLCBpdGVyYXRlZTIgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICBpdGVyYXRlZTIgPSB0eXBlb2YgaXRlcmF0ZWUyID09IFwiZnVuY3Rpb25cIiA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlMikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZTIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLCBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCwgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLCBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8ICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgICBcImZ1bmNcIjogdGhydSxcbiAgICAgICAgICAgIFwiYXJnc1wiOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAgICAgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZDIgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG4gICAgICAgICAgcmV0dXJuIHsgXCJkb25lXCI6IGRvbmUsIFwidmFsdWVcIjogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiwgcGFyZW50MiA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKHBhcmVudDIgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUyID0gd3JhcHBlckNsb25lKHBhcmVudDIpO1xuICAgICAgICAgICAgY2xvbmUyLl9faW5kZXhfXyA9IDA7XG4gICAgICAgICAgICBjbG9uZTIuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBjbG9uZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTI7XG4gICAgICAgICAgICBwYXJlbnQyID0gcGFyZW50Mi5fX3dyYXBwZWRfXztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICAgICBcImZ1bmNcIjogdGhydSxcbiAgICAgICAgICAgICAgXCJhcmdzXCI6IFtyZXZlcnNlXSxcbiAgICAgICAgICAgICAgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdDIsIHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQyLCBrZXkpKSB7XG4gICAgICAgICAgICArK3Jlc3VsdDJba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdDIsIGtleSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuICAgICAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuICAgICAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpLCBJTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMiwgZGVwdGgpIHtcbiAgICAgICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Miwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0MltrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0Miwga2V5LCBbdmFsdWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4ICYmICFndWFyZCA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xIDogISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSBcImZ1bmN0aW9uXCIsIHJlc3VsdDIgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5Mihjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0MlsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdDIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQyIDogb3JkZXJzO1xuICAgICAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0MiwgdmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdDJba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUyLCBhY2N1bXVsYXRvcikge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSwgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlMiwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSwgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICBuID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQyIDogbjtcbiAgICAgICAgICBuID0gZnVuYyAmJiBuID09IG51bGwgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MjtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZDIgOiBhcml0eTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCBhcml0eSk7XG4gICAgICAgICAgcmVzdWx0Mi5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZDIgOiBhcml0eTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCBhcml0eSk7XG4gICAgICAgICAgcmVzdWx0Mi5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBsYXN0QXJncywgbGFzdFRoaXMsIG1heFdhaXQsIHJlc3VsdDIsIHRpbWVySWQsIGxhc3RDYWxsVGltZSwgbGFzdEludm9rZVRpbWUgPSAwLCBsZWFkaW5nID0gZmFsc2UsIG1heGluZyA9IGZhbHNlLCB0cmFpbGluZyA9IHRydWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgICAgICBtYXhpbmcgPSBcIm1heFdhaXRcIiBpbiBvcHRpb25zO1xuICAgICAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgICAgIHRyYWlsaW5nID0gXCJ0cmFpbGluZ1wiIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLCB0aGlzQXJnID0gbGFzdFRoaXM7XG4gICAgICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogdGltZVdhaXRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLCB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkMiB8fCB0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0IHx8IHRpbWVTaW5jZUxhc3RDYWxsIDwgMCB8fCBtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQyID8gcmVzdWx0MiA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gbm93KCksIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG4gICAgICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG4gICAgICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1lbW9pemUyKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIiB8fCByZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLCBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuICAgICAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0MikgfHwgY2FjaGU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplMi5DYWNoZSB8fCBNYXBDYWNoZSkoKTtcbiAgICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbWVtb2l6ZTIuQ2FjaGUgPSBNYXBDYWNoZTtcbiAgICAgICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zID0gdHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKSA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZDIsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkMiwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgaW5kZXhlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkMiA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLCBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGxlYWRpbmcgPSBcImxlYWRpbmdcIiBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICAgICAgdHJhaWxpbmcgPSBcInRyYWlsaW5nXCIgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAgICAgXCJsZWFkaW5nXCI6IGxlYWRpbmcsXG4gICAgICAgICAgICBcIm1heFdhaXRcIjogd2FpdCxcbiAgICAgICAgICAgIFwidHJhaWxpbmdcIjogdHJhaWxpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gXCJmdW5jdGlvblwiID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gXCJmdW5jdGlvblwiID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG4gICAgICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgICAgICB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBcImNhbGxlZVwiKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgXCJjYWxsZWVcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkyLmlzQXJyYXk7XG4gICAgICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG4gICAgICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuICAgICAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09IFwiZnVuY3Rpb25cIiB8fCBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSBcImZ1bmN0aW9uXCIgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09PSB1bmRlZmluZWQyID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQyLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSBcInN0cmluZ1wiICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Zpbml0ZTIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSBcIm9iamVjdFwiIHx8IHR5cGUgPT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcbiAgICAgICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTmFOMih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IyKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiIHx8IGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcbiAgICAgICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8ICFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJzeW1ib2xcIiB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG4gICAgICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcbiAgICAgICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLCBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiB0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcztcbiAgICAgICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gdG9GaW5pdGUodmFsdWUpLCByZW1haW5kZXIgPSByZXN1bHQyICUgMTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiA9PT0gcmVzdWx0MiA/IHJlbWFpbmRlciA/IHJlc3VsdDIgLSByZW1haW5kZXIgOiByZXN1bHQyIDogMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gXCJmdW5jdGlvblwiID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IG90aGVyICsgXCJcIiA6IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgICAgICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpIDogcmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpIDogdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0MiA6IGJhc2VBc3NpZ24ocmVzdWx0MiwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgICAgb2JqZWN0ID0gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgfHwgZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZDIsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZDIsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpLCBrZXlzSW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpLCBrZXlzSW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgPT09IHVuZGVmaW5lZDIgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0MiwgdmFsdWUsIGtleSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdDJbdmFsdWVdID0ga2V5O1xuICAgICAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuICAgICAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0MiwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHQyW3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDJbdmFsdWVdID0gW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9LCBnZXRJdGVyYXRlZSk7XG4gICAgICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcbiAgICAgICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyk7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQyLCBpdGVyYXRlZTIodmFsdWUsIGtleSwgb2JqZWN0MiksIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyk7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQyLCBrZXksIGl0ZXJhdGVlMih2YWx1ZSwga2V5LCBvYmplY3QyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0Mik7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGJhc2VDbG9uZShyZXN1bHQyLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQocmVzdWx0MiwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQyIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuICAgICAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZTIsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLCBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgNCk7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yKCkgOiBbXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QyKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSBcImJvb2xlYW5cIiAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkMiAmJiB1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyByYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdChcIjFlLVwiICsgKChyYW5kICsgXCJcIikubGVuZ3RoIC0gMSkpKSwgdXBwZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG4gICAgICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKSA6IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsIFwiXFxcXCQmXCIpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKyAoaW5kZXggPyBcIi1cIiA6IFwiXCIpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0Miwgd29yZCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IFwiIFwiIDogXCJcIikgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdChcInRvTG93ZXJDYXNlXCIpO1xuICAgICAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcbiAgICAgICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArIHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG4gICAgICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGggPyBzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG4gICAgICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGggPyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlSW50MihzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICByYWRpeCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsIFwiXCIpLCByYWRpeCB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgbiA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQyLCB3b3JkLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQyICsgKGluZGV4ID8gXCJfXCIgOiBcIlwiKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gXCJudW1iZXJcIiAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZDIgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIGlmIChzdHJpbmcgJiYgKHR5cGVvZiBzZXBhcmF0b3IgPT0gXCJzdHJpbmdcIiB8fCBzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSkpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0Miwgd29yZCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IFwiIFwiIDogXCJcIikgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbCA/IDAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuICAgICAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLCBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcbiAgICAgICAgICB2YXIgaXNFc2NhcGluZywgaXNFdmFsdWF0aW5nLCBpbmRleCA9IDAsIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcbiAgICAgICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwMihcbiAgICAgICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArIFwifFwiICsgaW50ZXJwb2xhdGUuc291cmNlICsgXCJ8XCIgKyAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArIFwifFwiICsgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyBcInwkXCIsXG4gICAgICAgICAgICBcImdcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIHNvdXJjZVVSTCA9IFwiLy8jIHNvdXJjZVVSTD1cIiArIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic291cmNlVVJMXCIpID8gKG9wdGlvbnMuc291cmNlVVJMICsgXCJcIikucmVwbGFjZSgvXFxzL2csIFwiIFwiKSA6IFwibG9kYXNoLnRlbXBsYXRlU291cmNlc1tcIiArICsrdGVtcGxhdGVDb3VudGVyICsgXCJdXCIpICsgXCJcXG5cIjtcbiAgICAgICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuICAgICAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcbiAgICAgICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcbiAgICAgICAgICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwidmFyaWFibGVcIikgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBcIndpdGggKG9iaikge1xcblwiICsgc291cmNlICsgXCJcXG59XFxuXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycy50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yMihJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCBcIlwiKSA6IHNvdXJjZSkucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCBcIiQxXCIpLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCBcIiQxO1wiKTtcbiAgICAgICAgICBzb3VyY2UgPSBcImZ1bmN0aW9uKFwiICsgKHZhcmlhYmxlIHx8IFwib2JqXCIpICsgXCIpIHtcXG5cIiArICh2YXJpYWJsZSA/IFwiXCIgOiBcIm9iaiB8fCAob2JqID0ge30pO1xcblwiKSArIFwidmFyIF9fdCwgX19wID0gJydcIiArIChpc0VzY2FwaW5nID8gXCIsIF9fZSA9IF8uZXNjYXBlXCIgOiBcIlwiKSArIChpc0V2YWx1YXRpbmcgPyBcIiwgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCIgOiBcIjtcXG5cIikgKyBzb3VyY2UgKyBcInJldHVybiBfX3BcXG59XCI7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uMihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgXCJyZXR1cm4gXCIgKyBzb3VyY2UpLmFwcGx5KHVuZGVmaW5lZDIsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc3VsdDIuc291cmNlID0gc291cmNlO1xuICAgICAgICAgIGlmIChpc0Vycm9yKHJlc3VsdDIpKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVRyaW0oc3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLCBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSwgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLCBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkMikpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCwgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwic2VwYXJhdG9yXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICAgICAgbGVuZ3RoID0gXCJsZW5ndGhcIiBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgICAgIG9taXNzaW9uID0gXCJvbWlzc2lvblwiIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gc3RyU3ltYm9scyA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oXCJcIikgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIG9taXNzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICAgICAgZW5kICs9IHJlc3VsdDIubGVuZ3RoIC0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICAgIHZhciBtYXRjaCwgc3Vic3RyaW5nID0gcmVzdWx0MjtcbiAgICAgICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwMihzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyBcImdcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQyID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Mi5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIG9taXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKyAoaW5kZXggPyBcIiBcIiA6IFwiXCIpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoXCJ0b1VwcGVyQ2FzZVwiKTtcbiAgICAgICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkMiA6IHBhdHRlcm47XG4gICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQyLCBhcmdzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IyKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCwgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG4gICAgICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG4gICAgICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSBcImZ1bmN0aW9uXCIgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hhaW4yID0gIShpc09iamVjdChvcHRpb25zKSAmJiBcImNoYWluXCIgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLCBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG4gICAgICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW4yIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSwgYWN0aW9ucyA9IHJlc3VsdDIuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyBcImZ1bmNcIjogZnVuYywgXCJhcmdzXCI6IGFyZ3VtZW50cywgXCJ0aGlzQXJnXCI6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDIuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcbiAgICAgICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG4gICAgICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcbiAgICAgICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuICAgICAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILCBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgICAgICAgaXRlcmF0ZWUyID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyKTtcbiAgICAgICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZTIpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICAgICAgaXRlcmF0ZWUyKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZChcImNlaWxcIik7XG4gICAgICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKFwiZmxvb3JcIik7XG4gICAgICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSwgYmFzZUd0KSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMiksIGJhc2VMdCkgOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgICAgIH0sIDEpO1xuICAgICAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZChcInJvdW5kXCIpO1xuICAgICAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMikpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICAgICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICAgICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICAgICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICAgICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICAgICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgICAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgICAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICAgICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgICAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgICAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgICAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICAgICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgICAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICAgICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgICAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICAgICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgICAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICAgICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgICAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgICAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICAgICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgICAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgICAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICAgICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICAgICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgICAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgICAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgICAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgICAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgICAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICAgICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICAgICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICAgICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICAgICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICAgICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgICAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgICAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICAgICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgICAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgICAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICAgICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICAgICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgICAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICAgICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICAgICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgICAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgICAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemUyO1xuICAgICAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICAgICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICAgICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgICAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgICAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgICAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICAgICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgICAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgICAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgICAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICAgICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgICAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgICAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgICAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICAgICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgICAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgICAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICAgICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICAgICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICAgICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICAgICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgICAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICAgICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgICAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICAgICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICAgICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgICAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgICAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICAgICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICAgICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgICAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgICAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgICAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgICAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICAgICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgICAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICAgICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICAgICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICAgICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgICAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICAgICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICAgICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICAgICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgICAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgICAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICAgICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgICAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgICAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgICAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgICAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgICAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgICAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICAgICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuICAgICAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICAgICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcbiAgICAgICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICAgICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgICAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgICAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICAgICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgICAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgICAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICAgICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICAgICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICAgICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICAgICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgICAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgICAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgICAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICAgICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgICAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgICAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgICAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgICAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICAgICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgICAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgICAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICAgICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgICAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgICAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICAgICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICAgICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgICAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgICAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICAgICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgICAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgICAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICAgICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgICAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgICAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICAgICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICAgICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICAgICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgICAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgICAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlMjtcbiAgICAgICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgICAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgICAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICAgICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICAgICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOMjtcbiAgICAgICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgICAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgICAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICAgICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICAgICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICAgICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgICAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICAgICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICAgICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICAgICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICAgICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgICAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICAgICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICAgICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgICAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICAgICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICAgICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICAgICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICAgICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICAgICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICAgICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICAgICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgICAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICAgICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICAgICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgICAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgICAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgICAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgICAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICAgICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQyO1xuICAgICAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgICAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgICAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICAgICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgICAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICAgICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDI7XG4gICAgICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICAgICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICAgICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgICAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICAgICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgICAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgICAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICAgICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICAgICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgICAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICAgICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICAgICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICAgICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgICAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgICAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICAgICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgICAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgICAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICAgICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgICAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgICAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG4gICAgICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICAgICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICAgICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcbiAgICAgICAgbWl4aW4obG9kYXNoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0ge307XG4gICAgICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH0oKSwgeyBcImNoYWluXCI6IGZhbHNlIH0pO1xuICAgICAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG4gICAgICAgIGFycmF5RWFjaChbXCJiaW5kXCIsIFwiYmluZEtleVwiLCBcImN1cnJ5XCIsIFwiY3VycnlSaWdodFwiLCBcInBhcnRpYWxcIiwgXCJwYXJ0aWFsUmlnaHRcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wiZHJvcFwiLCBcInRha2VcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZDIgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleCA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyLl9fZmlsdGVyZWRfXykge1xuICAgICAgICAgICAgICByZXN1bHQyLl9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Mi5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IG1ldGhvZE5hbWUgKyAocmVzdWx0Mi5fX2Rpcl9fIDwgMCA/IFwiUmlnaHRcIiA6IFwiXCIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArIFwiUmlnaHRcIl0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wiZmlsdGVyXCIsIFwibWFwXCIsIFwidGFrZVdoaWxlXCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLCBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcbiAgICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgcmVzdWx0Mi5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICAgICBcIml0ZXJhdGVlXCI6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyksXG4gICAgICAgICAgICAgIFwidHlwZVwiOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19maWx0ZXJlZF9fID0gcmVzdWx0Mi5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyYXlFYWNoKFtcImhlYWRcIiwgXCJsYXN0XCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciB0YWtlTmFtZSA9IFwidGFrZVwiICsgKGluZGV4ID8gXCJSaWdodFwiIDogXCJcIik7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyYXlFYWNoKFtcImluaXRpYWxcIiwgXCJ0YWlsXCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciBkcm9wTmFtZSA9IFwiZHJvcFwiICsgKGluZGV4ID8gXCJcIiA6IFwiUmlnaHRcIik7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgICAgICB9O1xuICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXM7XG4gICAgICAgICAgaWYgKHJlc3VsdDIuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLmRyb3Aoc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBlbmQgPCAwID8gcmVzdWx0Mi5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQyLnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgICAgICB9O1xuICAgICAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLCBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyBcInRha2VcIiArIChtZXRob2ROYW1lID09IFwibGFzdFwiID8gXCJSaWdodFwiIDogXCJcIikgOiBtZXRob2ROYW1lXSwgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG4gICAgICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLCBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLCBpdGVyYXRlZTIgPSBhcmdzWzBdLCB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQzID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWUyXSwgYXJncykpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNUYWtlciAmJiBjaGFpbkFsbCA/IHJlc3VsdDNbMF0gOiByZXN1bHQzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlMiA9PSBcImZ1bmN0aW9uXCIgJiYgaXRlcmF0ZWUyLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLCBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCwgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuICAgICAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICAgIHJlc3VsdDIuX19hY3Rpb25zX18ucHVzaCh7IFwiZnVuY1wiOiB0aHJ1LCBcImFyZ3NcIjogW2ludGVyY2VwdG9yXSwgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDIgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQyLCBjaGFpbkFsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQyID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IGlzVGFrZXIgPyByZXN1bHQyLnZhbHVlKClbMF0gOiByZXN1bHQyLnZhbHVlKCkgOiByZXN1bHQyO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wicG9wXCIsIFwicHVzaFwiLCBcInNoaWZ0XCIsIFwic29ydFwiLCBcInNwbGljZVwiLCBcInVuc2hpZnRcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/IFwidGFwXCIgOiBcInRocnVcIiwgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcbiAgICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUyKSA/IHZhbHVlMiA6IFtdLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgXCJcIjtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyBcIm5hbWVcIjogbWV0aG9kTmFtZSwgXCJmdW5jXCI6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQyLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICAgICBcIm5hbWVcIjogXCJ3cmFwcGVyXCIsXG4gICAgICAgICAgXCJmdW5jXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgfV07XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuICAgICAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2Rhc2g7XG4gICAgICB9O1xuICAgICAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcbiAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgcm9vdC5fID0gXztcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5fID0gXztcbiAgICAgIH1cbiAgICB9KS5jYWxsKGV4cG9ydHMpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qc1xudmFyIHJlcXVpcmVfaW90YSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBpb3RhKG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICByZXN1bHRbaV0gPSBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpb3RhO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNfYnVmZmVyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgICAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTbG93QnVmZmVyKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSBcImZ1bmN0aW9uXCIgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzXG52YXIgcmVxdWlyZV9uZGFycmF5ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBpb3RhID0gcmVxdWlyZV9pb3RhKCk7XG4gICAgdmFyIGlzQnVmZmVyID0gcmVxdWlyZV9pc19idWZmZXIoKTtcbiAgICB2YXIgaGFzVHlwZWRBcnJheXMgPSB0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIGZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcmRlcigpIHtcbiAgICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAgIHZhciB0ZXJtcyA9IG5ldyBBcnJheShzdHJpZGUubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRlcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldO1xuICAgICAgfVxuICAgICAgdGVybXMuc29ydChjb21wYXJlMXN0KTtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodGVybXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGRpbWVuc2lvbikge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIik7XG4gICAgICBpZiAoZGltZW5zaW9uIDwgMCkge1xuICAgICAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZTtcbiAgICAgIH1cbiAgICAgIHZhciB1c2VHZXR0ZXJzID0gZHR5cGUgPT09IFwiZ2VuZXJpY1wiO1xuICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBcImZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCIoYSl7dGhpcy5kYXRhPWE7fTt2YXIgcHJvdG89XCIgKyBjbGFzc05hbWUgKyBcIi5wcm90b3R5cGU7cHJvdG8uZHR5cGU9J1wiICsgZHR5cGUgKyBcIic7cHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O3Byb3RvLnNpemU9MDtwcm90by5kaW1lbnNpb249LTE7cHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO3Byb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKHRoaXMuZGF0YSk7fTtwcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtwcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIgKyBjbGFzc05hbWUgKyBcIihhKXtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIoYSk7fVwiO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpO1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlKCk7XG4gICAgICB9IGVsc2UgaWYgKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgICAgICB2YXIgY29kZSA9IFwiZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIihhLGQpIHt0aGlzLmRhdGEgPSBhO3RoaXMub2Zmc2V0ID0gZH07dmFyIHByb3RvPVwiICsgY2xhc3NOYW1lICsgXCIucHJvdG90eXBlO3Byb3RvLmR0eXBlPSdcIiArIGR0eXBlICsgXCInO3Byb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtwcm90by5kaW1lbnNpb249MDtwcm90by5zaXplPTE7cHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO3Byb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfY29weSgpIHtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLHRoaXMub2Zmc2V0KX07cHJvdG8ucGljaz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3BpY2soKXtyZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7fTtwcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2dldCgpe3JldHVybiBcIiArICh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpICsgXCJ9O3Byb3RvLnNldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NldCh2KXtyZXR1cm4gXCIgKyAodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikgKyBcIn07cmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIiArIGNsYXNzTmFtZSArIFwiKGEsYixjLGQpe3JldHVybiBuZXcgXCIgKyBjbGFzc05hbWUgKyBcIihhLGQpfVwiO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiVHJpdmlhbEFycmF5XCIsIGNvZGUpO1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdO1xuICAgICAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbik7XG4gICAgICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImlcIiArIGkyO1xuICAgICAgfSk7XG4gICAgICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaTIgKyBcIl0qaVwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiK1wiKTtcbiAgICAgIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImJcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICB2YXIgc3RyaWRlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiY1wiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICAgIGNvZGUucHVzaChcbiAgICAgICAgXCJmdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgICAgXCJ0aGlzLnNoYXBlPVtcIiArIHNoYXBlQXJnICsgXCJdXCIsXG4gICAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgICAgICBcInZhciBwcm90bz1cIiArIGNsYXNzTmFtZSArIFwiLnByb3RvdHlwZVwiLFxuICAgICAgICBcInByb3RvLmR0eXBlPSdcIiArIGR0eXBlICsgXCInXCIsXG4gICAgICAgIFwicHJvdG8uZGltZW5zaW9uPVwiICsgZGltZW5zaW9uXG4gICAgICApO1xuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NpemUoKXtyZXR1cm4gXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgIHJldHVybiBcInRoaXMuc2hhcGVbXCIgKyBpMiArIFwiXVwiO1xuICAgICAgICB9KS5qb2luKFwiKlwiKSxcbiAgICAgICAgXCJ9fSlcIlxuICAgICAgKTtcbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDEpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIik7XG4gICAgICAgIGlmIChkaW1lbnNpb24gPCA0KSB7XG4gICAgICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIl9vcmRlcigpe1wiKTtcbiAgICAgICAgICBpZiAoZGltZW5zaW9uID09PSAyKSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goXG4gICAgICAgICAgICAgIFwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO2lmKHMwPnMxKXtpZihzMT5zMil7cmV0dXJuIFsyLDEsMF07fWVsc2UgaWYoczA+czIpe3JldHVybiBbMSwyLDBdO31lbHNle3JldHVybiBbMSwwLDJdO319ZWxzZSBpZihzMD5zMil7cmV0dXJuIFsyLDAsMV07fWVsc2UgaWYoczI+czEpe3JldHVybiBbMCwxLDJdO31lbHNle3JldHVybiBbMCwyLDFdO319fSlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcInByb3RvLnNldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NldChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIix2KXtcIlxuICAgICAgKTtcbiAgICAgIGlmICh1c2VHZXR0ZXJzKSB7XG4gICAgICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiICsgaW5kZXhfc3RyICsgXCIsdil9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIiArIGluZGV4X3N0ciArIFwiXT12fVwiKTtcbiAgICAgIH1cbiAgICAgIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2dldChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIil7XCIpO1xuICAgICAgaWYgKHVzZUdldHRlcnMpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIgKyBpbmRleF9zdHIgKyBcIil9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIiArIGluZGV4X3N0ciArIFwiXX1cIik7XG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goXG4gICAgICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIl9pbmRleChcIixcbiAgICAgICAgYXJncy5qb2luKCksXG4gICAgICAgIFwiKXtyZXR1cm4gXCIgKyBpbmRleF9zdHIgKyBcIn1cIlxuICAgICAgKTtcbiAgICAgIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfaGkoXCIgKyBhcmdzLmpvaW4oXCIsXCIpICsgXCIpe3JldHVybiBuZXcgXCIgKyBjbGFzc05hbWUgKyBcIih0aGlzLmRhdGEsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsIGkyLCBcIiE9PSdudW1iZXInfHxpXCIsIGkyLCBcIjwwKT90aGlzLnNoYXBlW1wiLCBpMiwgXCJdOmlcIiwgaTIsIFwifDBcIl0uam9pbihcIlwiKTtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIiArIGkyICsgXCJdXCI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLHRoaXMub2Zmc2V0KX1cIik7XG4gICAgICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTIgKyBcIj10aGlzLnNoYXBlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImNcIiArIGkyICsgXCI9dGhpcy5zdHJpZGVbXCIgKyBpMiArIFwiXVwiO1xuICAgICAgfSk7XG4gICAgICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2xvKFwiICsgYXJncy5qb2luKFwiLFwiKSArIFwiKXt2YXIgYj10aGlzLm9mZnNldCxkPTAsXCIgKyBhX3ZhcnMuam9pbihcIixcIikgKyBcIixcIiArIGNfdmFycy5qb2luKFwiLFwiKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIGNvZGUucHVzaChcbiAgICAgICAgICBcImlmKHR5cGVvZiBpXCIgKyBpICsgXCI9PT0nbnVtYmVyJyYmaVwiICsgaSArIFwiPj0wKXtkPWlcIiArIGkgKyBcInwwO2IrPWNcIiArIGkgKyBcIipkO2FcIiArIGkgKyBcIi09ZH1cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKHRoaXMuZGF0YSxcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImFcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIikgKyBcIixcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImNcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIikgKyBcIixiKX1cIik7XG4gICAgICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfc3RlcChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIil7dmFyIFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTIgKyBcIj10aGlzLnNoYXBlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJiXCIgKyBpMiArIFwiPXRoaXMuc3RyaWRlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIGNvZGUucHVzaChcbiAgICAgICAgICBcImlmKHR5cGVvZiBpXCIgKyBpICsgXCI9PT0nbnVtYmVyJyl7ZD1pXCIgKyBpICsgXCJ8MDtpZihkPDApe2MrPWJcIiArIGkgKyBcIiooYVwiICsgaSArIFwiLTEpO2FcIiArIGkgKyBcIj1jZWlsKC1hXCIgKyBpICsgXCIvZCl9ZWxzZXthXCIgKyBpICsgXCI9Y2VpbChhXCIgKyBpICsgXCIvZCl9YlwiICsgaSArIFwiKj1kfVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYlwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLGMpfVwiKTtcbiAgICAgIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKTtcbiAgICAgIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiICsgaSArIFwiXVwiO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3RyYW5zcG9zZShcIiArIGFyZ3MgKyBcIil7XCIgKyBhcmdzLm1hcChmdW5jdGlvbihuLCBpZHgpIHtcbiAgICAgICAgICByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCI7XG4gICAgICAgIH0pLmpvaW4oXCI7XCIpLFxuICAgICAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLFwiICsgdFNoYXBlLmpvaW4oXCIsXCIpICsgXCIsXCIgKyB0U3RyaWRlLmpvaW4oXCIsXCIpICsgXCIsdGhpcy5vZmZzZXQpfVwiXG4gICAgICApO1xuICAgICAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3BpY2soXCIgKyBhcmdzICsgXCIpe3ZhciBhPVtdLGI9W10sYz10aGlzLm9mZnNldFwiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyArK2kpIHtcbiAgICAgICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIiArIGkgKyBcIj09PSdudW1iZXInJiZpXCIgKyBpICsgXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGkgKyBcIil8MH1lbHNle2EucHVzaCh0aGlzLnNoYXBlW1wiICsgaSArIFwiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSl9XCIpO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpO1xuICAgICAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIiArIGNsYXNzTmFtZSArIFwiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKGRhdGEsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJzaGFwZVtcIiArIGkyICsgXCJdXCI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaWRlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsb2Zmc2V0KX1cIik7XG4gICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKTtcbiAgICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gICAgICBpZiAoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYnVmZmVyXCI7XG4gICAgICB9XG4gICAgICBpZiAoaGFzVHlwZWRBcnJheXMpIHtcbiAgICAgICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiO1xuICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImludDhcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaW50MTZcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaW50MzJcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwidWludDhcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcInVpbnQxNlwiO1xuICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwidWludDMyXCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgQmlnSW50NjRBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImJpZ2ludDY0XCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgQmlnVWludDY0QXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiaWd1aW50NjRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImdlbmVyaWNcIjtcbiAgICB9XG4gICAgdmFyIENBQ0hFRF9DT05TVFJVQ1RPUlMgPSB7XG4gICAgICBcImZsb2F0MzJcIjogW10sXG4gICAgICBcImZsb2F0NjRcIjogW10sXG4gICAgICBcImludDhcIjogW10sXG4gICAgICBcImludDE2XCI6IFtdLFxuICAgICAgXCJpbnQzMlwiOiBbXSxcbiAgICAgIFwidWludDhcIjogW10sXG4gICAgICBcInVpbnQxNlwiOiBbXSxcbiAgICAgIFwidWludDMyXCI6IFtdLFxuICAgICAgXCJhcnJheVwiOiBbXSxcbiAgICAgIFwidWludDhfY2xhbXBlZFwiOiBbXSxcbiAgICAgIFwiYmlnaW50NjRcIjogW10sXG4gICAgICBcImJpZ3VpbnQ2NFwiOiBbXSxcbiAgICAgIFwiYnVmZmVyXCI6IFtdLFxuICAgICAgXCJnZW5lcmljXCI6IFtdXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXTtcbiAgICAgICAgcmV0dXJuIGN0b3IoW10pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hhcGUgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgfVxuICAgICAgdmFyIGQgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RyaWRlID0gbmV3IEFycmF5KGQpO1xuICAgICAgICBmb3IgKHZhciBpID0gZCAtIDEsIHN6ID0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBzdHJpZGVbaV0gPSBzejtcbiAgICAgICAgICBzeiAqPSBzaGFwZVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZDsgKytpKSB7XG4gICAgICAgICAgaWYgKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0gLSAxKSAqIHN0cmlkZVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSk7XG4gICAgICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV07XG4gICAgICB3aGlsZSAoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkICsgMSkge1xuICAgICAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGggLSAxKSk7XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkICsgMV07XG4gICAgICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvcjtcbiAgfVxufSk7XG5cbi8vIHNyYy9hcGkvdjEudHNcbnZhciBpbXBvcnRfbG9kYXNoID0gX190b0VTTShyZXF1aXJlX2xvZGFzaCgpKTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgaW1wb3J0X25kYXJyYXkyID0gX190b0VTTShyZXF1aXJlX25kYXJyYXkoKSk7XG5cbi8vIHNyYy9NaW1lVHlwZS50c1xudmFyIE1pbWVUeXBlID0gY2xhc3MgX01pbWVUeXBlIHtcbiAgY29uc3RydWN0b3IodHlwZSwgcGFyYW1zKSB7XG4gICAgdGhpcy50eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgcGFyYW1zU3RyID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJhbXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJhbXNba2V5XTtcbiAgICAgIHBhcmFtc1N0ci5wdXNoKGAke2tleX09JHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aGlzLnR5cGUsIC4uLnBhcmFtc1N0cl0uam9pbihcIjtcIik7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZSh0eXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IF9NaW1lVHlwZSh0eXBlLCBwYXJhbXMpO1xuICB9XG4gIGlzSWRlbnRpY2FsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gb3RoZXIudHlwZSAmJiB0aGlzLnBhcmFtcyA9PT0gb3RoZXIucGFyYW1zO1xuICB9XG4gIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBvdGhlci50eXBlO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RyaW5nKG1pbWVUeXBlKSB7XG4gICAgY29uc3QgW3R5cGUsIC4uLnBhcmFtc0Fycl0gPSBtaW1lVHlwZS5zcGxpdChcIjtcIik7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXNBcnIpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhcmFtLnNwbGl0KFwiPVwiKTtcbiAgICAgIHBhcmFtc1trZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTWltZVR5cGUodHlwZSwgcGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvZGVjcy50c1xudmFyIGltcG9ydF9uZGFycmF5ID0gX190b0VTTShyZXF1aXJlX25kYXJyYXkoKSk7XG5hc3luYyBmdW5jdGlvbiBpbWFnZURlY29kZShibG9iKSB7XG4gIGNvbnN0IG1pbWUgPSBNaW1lVHlwZS5mcm9tU3RyaW5nKGJsb2IudHlwZSk7XG4gIHN3aXRjaCAobWltZS50eXBlKSB7XG4gICAgY2FzZSBcImltYWdlL3gtYWxwaGE4XCI6IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWltZS5wYXJhbXNbXCJ3aWR0aFwiXSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChtaW1lLnBhcmFtc1tcImhlaWdodFwiXSk7XG4gICAgICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5LmRlZmF1bHQpKG5ldyBVaW50OEFycmF5KGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksIFtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgMVxuICAgICAgXSk7XG4gICAgfVxuICAgIGNhc2UgXCJpbWFnZS94LXJnYmE4XCI6IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWltZS5wYXJhbXNbXCJ3aWR0aFwiXSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChtaW1lLnBhcmFtc1tcImhlaWdodFwiXSk7XG4gICAgICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5LmRlZmF1bHQpKG5ldyBVaW50OEFycmF5KGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksIFtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgNFxuICAgICAgXSk7XG4gICAgfVxuICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjpcbiAgICBjYXNlIGBpbWFnZS9wbmdgOlxuICAgIGNhc2UgYGltYWdlL2pwZWdgOlxuICAgIGNhc2UgYGltYWdlL2pwZ2A6XG4gICAgY2FzZSBgaW1hZ2Uvd2VicGA6IHtcbiAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZUJpdG1hcFRvSW1hZ2VEYXRhKGltYWdlQml0bWFwKTtcbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X25kYXJyYXkuZGVmYXVsdCkobmV3IFVpbnQ4QXJyYXkoaW1hZ2VEYXRhLmRhdGEpLCBbXG4gICAgICAgIGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgIGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgNFxuICAgICAgXSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGZvcm1hdDogJHttaW1lLnR5cGV9IHdpdGggcGFyYW1zOiAke21pbWUucGFyYW1zfWBcbiAgICAgICk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGltYWdlRW5jb2RlKGltYWdlVGVuc29yLCBxdWFsaXR5ID0gMC44LCBmb3JtYXQgPSBcImltYWdlL3BuZ1wiKSB7XG4gIGNvbnN0IFtoZWlnaHQsIHdpZHRoLCBjaGFubmVsc10gPSBpbWFnZVRlbnNvci5zaGFwZTtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIFwiaW1hZ2UveC1hbHBoYThcIjpcbiAgICBjYXNlIFwiaW1hZ2UveC1yZ2JhOFwiOiB7XG4gICAgICBjb25zdCBtaW1lID0gTWltZVR5cGUuY3JlYXRlKGZvcm1hdCwge1xuICAgICAgICB3aWR0aDogd2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQudG9TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEJsb2IoW2ltYWdlVGVuc29yLmRhdGFdLCB7IHR5cGU6IG1pbWUudG9TdHJpbmcoKSB9KTtcbiAgICB9XG4gICAgY2FzZSBgaW1hZ2UvcG5nYDpcbiAgICBjYXNlIGBpbWFnZS9qcGVnYDpcbiAgICBjYXNlIGBpbWFnZS93ZWJwYDoge1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShcbiAgICAgICAgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGltYWdlVGVuc29yLmRhdGEpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuICAgICAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyhpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLmNvbnZlcnRUb0Jsb2IoeyBxdWFsaXR5LCB0eXBlOiBmb3JtYXQgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9ybWF0OiAke2Zvcm1hdH1gKTtcbiAgfVxufVxuXG4vLyBzcmMvdXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVVJJKHVybCkge1xuICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXig/OlthLXorXSs6KT8vL1wiLCBcImlcIik7XG4gIHJldHVybiByZWdFeHAudGVzdCh1cmwpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWJzb2x1dGVVUkkodXJsLCBiYXNlVXJsKSB7XG4gIGlmIChpc0Fic29sdXRlVVJJKHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVVJMKHVybCwgYmFzZVVybCkuaHJlZjtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIGltYWdlQml0bWFwVG9JbWFnZURhdGEoaW1hZ2VCaXRtYXApIHtcbiAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyhpbWFnZUJpdG1hcC53aWR0aCwgaW1hZ2VCaXRtYXAuaGVpZ2h0KTtcbiAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGN0eC5kcmF3SW1hZ2UoaW1hZ2VCaXRtYXAsIDAsIDApO1xuICByZXR1cm4gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZUFycmF5KGxlbmd0aCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShsZW5ndGgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZEFycmF5IG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHRlbnNvclJlc2l6ZUJpbGluZWFyKGltYWdlVGVuc29yLCBuZXdXaWR0aCwgbmV3SGVpZ2h0LCBwcm9wb3J0aW9uYWwgPSBmYWxzZSkge1xuICBjb25zdCBbc3JjSGVpZ2h0LCBzcmNXaWR0aCwgc3JjQ2hhbm5lbHNdID0gaW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGxldCBzY2FsZVggPSBzcmNXaWR0aCAvIG5ld1dpZHRoO1xuICBsZXQgc2NhbGVZID0gc3JjSGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICBpZiAocHJvcG9ydGlvbmFsKSB7XG4gICAgY29uc3QgZG93bnNjYWxpbmcgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSkgPiAxO1xuICAgIHNjYWxlWCA9IHNjYWxlWSA9IGRvd25zY2FsaW5nID8gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpIDogTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICB9XG4gIGNvbnN0IHJlc2l6ZWRJbWFnZURhdGEgPSAoMCwgaW1wb3J0X25kYXJyYXkyLmRlZmF1bHQpKFxuICAgIGNyZWF0ZVR5cGVBcnJheShzcmNDaGFubmVscyAqIG5ld1dpZHRoICogbmV3SGVpZ2h0KSxcbiAgICBbbmV3SGVpZ2h0LCBuZXdXaWR0aCwgc3JjQ2hhbm5lbHNdXG4gICk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgbmV3SGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5ld1dpZHRoOyB4KyspIHtcbiAgICAgIGNvbnN0IHNyY1ggPSB4ICogc2NhbGVYO1xuICAgICAgY29uc3Qgc3JjWSA9IHkgKiBzY2FsZVk7XG4gICAgICBjb25zdCB4MSA9IE1hdGgubWF4KE1hdGguZmxvb3Ioc3JjWCksIDApO1xuICAgICAgY29uc3QgeDIgPSBNYXRoLm1pbihNYXRoLmNlaWwoc3JjWCksIHNyY1dpZHRoIC0gMSk7XG4gICAgICBjb25zdCB5MSA9IE1hdGgubWF4KE1hdGguZmxvb3Ioc3JjWSksIDApO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLm1pbihNYXRoLmNlaWwoc3JjWSksIHNyY0hlaWdodCAtIDEpO1xuICAgICAgY29uc3QgZHggPSBzcmNYIC0geDE7XG4gICAgICBjb25zdCBkeSA9IHNyY1kgLSB5MTtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgc3JjQ2hhbm5lbHM7IGMrKykge1xuICAgICAgICBjb25zdCBwMSA9IGltYWdlVGVuc29yLmdldCh5MSwgeDEsIGMpO1xuICAgICAgICBjb25zdCBwMiA9IGltYWdlVGVuc29yLmdldCh5MSwgeDIsIGMpO1xuICAgICAgICBjb25zdCBwMyA9IGltYWdlVGVuc29yLmdldCh5MiwgeDEsIGMpO1xuICAgICAgICBjb25zdCBwNCA9IGltYWdlVGVuc29yLmdldCh5MiwgeDIsIGMpO1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRWYWx1ZSA9ICgxIC0gZHgpICogKDEgLSBkeSkgKiBwMSArIGR4ICogKDEgLSBkeSkgKiBwMiArICgxIC0gZHgpICogZHkgKiBwMyArIGR4ICogZHkgKiBwNDtcbiAgICAgICAgcmVzaXplZEltYWdlRGF0YS5zZXQoeSwgeCwgYywgaW50ZXJwb2xhdGVkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzaXplZEltYWdlRGF0YTtcbn1cbmZ1bmN0aW9uIHRlbnNvckhXQ3RvQkNIVyhpbWFnZVRlbnNvciwgbWVhbiA9IFsxMjgsIDEyOCwgMTI4XSwgc3RkID0gWzI1NiwgMjU2LCAyNTZdKSB7XG4gIHZhciBpbWFnZUJ1ZmZlckRhdGEgPSBpbWFnZVRlbnNvci5kYXRhO1xuICBjb25zdCBbc3JjSGVpZ2h0LCBzcmNXaWR0aCwgc3JjQ2hhbm5lbHNdID0gaW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGNvbnN0IHN0cmlkZSA9IHNyY0hlaWdodCAqIHNyY1dpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIHN0cmlkZSk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGltYWdlQnVmZmVyRGF0YS5sZW5ndGg7IGkgKz0gNCwgaiArPSAxKSB7XG4gICAgZmxvYXQzMkRhdGFbal0gPSAoaW1hZ2VCdWZmZXJEYXRhW2ldIC0gbWVhblswXSkgLyBzdGRbMF07XG4gICAgZmxvYXQzMkRhdGFbaiArIHN0cmlkZV0gPSAoaW1hZ2VCdWZmZXJEYXRhW2kgKyAxXSAtIG1lYW5bMV0pIC8gc3RkWzFdO1xuICAgIGZsb2F0MzJEYXRhW2ogKyBzdHJpZGUgKyBzdHJpZGVdID0gKGltYWdlQnVmZmVyRGF0YVtpICsgMl0gLSBtZWFuWzJdKSAvIHN0ZFsyXTtcbiAgfVxuICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5Mi5kZWZhdWx0KShmbG9hdDMyRGF0YSwgWzEsIDMsIHNyY0hlaWdodCwgc3JjV2lkdGhdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGltYWdlU291cmNlVG9JbWFnZURhdGEoaW1hZ2UsIGNvbmZpZykge1xuICBpZiAodHlwZW9mIGltYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaW1hZ2UgPSBlbnN1cmVBYnNvbHV0ZVVSSShpbWFnZSwgY29uZmlnLnB1YmxpY1BhdGgpO1xuICAgIGltYWdlID0gbmV3IFVSTChpbWFnZSk7XG4gIH1cbiAgaWYgKGltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbWFnZSwge30pO1xuICAgIGltYWdlID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICB9XG4gIGlmIChpbWFnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhpbWFnZSkpIHtcbiAgICBpbWFnZSA9IG5ldyBCbG9iKFtpbWFnZV0pO1xuICB9XG4gIGlmIChpbWFnZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICBpbWFnZSA9IGF3YWl0IGltYWdlRGVjb2RlKGltYWdlKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59XG5mdW5jdGlvbiBjb252ZXJ0RmxvYXQzMlRvVWludDgoZmxvYXQzMkFycmF5KSB7XG4gIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShmbG9hdDMyQXJyYXkuZGF0YS5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJBcnJheS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdWludDhBcnJheVtpXSA9IGZsb2F0MzJBcnJheS5kYXRhW2ldICogMjU1O1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X25kYXJyYXkyLmRlZmF1bHQpKHVpbnQ4QXJyYXksIGZsb2F0MzJBcnJheS5zaGFwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICBsZXQgY2FudmFzID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgfVxuICBpZiAoIWNhbnZhcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW52YXMgbm9yIE9mZnNjcmVlbkNhbnZhcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuLy8gc3JjL29ubngudHNcbnZhciBpbXBvcnRfbmRhcnJheTMgPSBfX3RvRVNNKHJlcXVpcmVfbmRhcnJheSgpKTtcblxuLy8gc3JjL2NhcGFiaWxpdGllcy5qc1xudmFyIHdlYmdwdSA9IGFzeW5jICgpID0+IHtcbiAgaWYgKG5hdmlnYXRvci5ncHUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7XG4gIHJldHVybiBhZGFwdGVyICE9PSBudWxsO1xufTtcbnZhciBtYXhOdW1UaHJlYWRzID0gKCkgPT4gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgPz8gNDtcblxuLy8gc3JjL3Jlc291cmNlLnRzXG5hc3luYyBmdW5jdGlvbiBsb2FkQXNVcmwodXJsLCBjb25maWcpIHtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYXdhaXQgbG9hZEFzQmxvYih1cmwsIGNvbmZpZykpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEFzQmxvYihrZXksIGNvbmZpZykge1xuICBjb25zdCByZXNvdXJjZVVybCA9IG5ldyBVUkwoXCJyZXNvdXJjZXMuanNvblwiLCBjb25maWcucHVibGljUGF0aCk7XG4gIGNvbnN0IHJlc291cmNlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXNvdXJjZVVybCk7XG4gIGlmICghcmVzb3VyY2VSZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZXNvdXJjZSBtZXRhZGF0YSBub3QgZm91bmQuIEVuc3VyZSB0aGF0IHRoZSBjb25maWcucHVibGljUGF0aCBpcyBjb25maWd1cmVkIGNvcnJlY3RseS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXNvdXJjZU1hcCA9IGF3YWl0IHJlc291cmNlUmVzcG9uc2UuanNvbigpO1xuICBjb25zdCBlbnRyeSA9IHJlc291cmNlTWFwW2tleV07XG4gIGlmICghZW50cnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVzb3VyY2UgJHtrZXl9IG5vdCBmb3VuZC4gRW5zdXJlIHRoYXQgdGhlIGNvbmZpZy5wdWJsaWNQYXRoIGlzIGNvbmZpZ3VyZWQgY29ycmVjdGx5LmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGNodW5rcyA9IGVudHJ5LmNodW5rcztcbiAgbGV0IGRvd25sb2FkZWRTaXplID0gMDtcbiAgY29uc3QgcmVzcG9uc2VzID0gY2h1bmtzLm1hcChhc3luYyAoY2h1bmspID0+IHtcbiAgICBjb25zdCBjaHVua1NpemUgPSBjaHVuay5vZmZzZXRzWzFdIC0gY2h1bmsub2Zmc2V0c1swXTtcbiAgICBjb25zdCB1cmwgPSBjb25maWcucHVibGljUGF0aCA/IG5ldyBVUkwoY2h1bmsubmFtZSwgY29uZmlnLnB1YmxpY1BhdGgpLnRvU3RyaW5nKCkgOiBjaHVuay5uYW1lO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBjb25maWcuZmV0Y2hBcmdzKTtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgIGlmIChjaHVua1NpemUgIT09IGJsb2Iuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoICR7a2V5fSB3aXRoIHNpemUgJHtjaHVua1NpemV9IGJ1dCBnb3QgJHtibG9iLnNpemV9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wcm9ncmVzcykge1xuICAgICAgZG93bmxvYWRlZFNpemUgKz0gY2h1bmtTaXplO1xuICAgICAgY29uZmlnLnByb2dyZXNzKGBmZXRjaDoke2tleX1gLCBkb3dubG9hZGVkU2l6ZSwgZW50cnkuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBibG9iO1xuICB9KTtcbiAgY29uc3QgYWxsQ2h1bmtEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzcG9uc2VzKTtcbiAgY29uc3QgZGF0YSA9IG5ldyBCbG9iKGFsbENodW5rRGF0YSwgeyB0eXBlOiBlbnRyeS5taW1lIH0pO1xuICBpZiAoZGF0YS5zaXplICE9PSBlbnRyeS5zaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZhaWxlZCB0byBmZXRjaCAke2tleX0gd2l0aCBzaXplICR7ZW50cnkuc2l6ZX0gYnV0IGdvdCAke2RhdGEuc2l6ZX1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gc3JjL29ubngudHNcbnZhciBvcnQgPSBudWxsO1xudmFyIGdldE9ydCA9IGFzeW5jICh1c2VXZWJHUFUpID0+IHtcbiAgaWYgKG9ydCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBvcnQ7XG4gIH1cbiAgaWYgKHVzZVdlYkdQVSkge1xuICAgIG9ydCA9IChhd2FpdCBpbXBvcnQoXCJvbm54cnVudGltZS13ZWIvd2ViZ3B1XCIpKS5kZWZhdWx0O1xuICB9IGVsc2Uge1xuICAgIG9ydCA9IChhd2FpdCBpbXBvcnQoXCJvbm54cnVudGltZS13ZWJcIikpLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIG9ydDtcbn07XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVPbm54U2Vzc2lvbihtb2RlbCwgY29uZmlnKSB7XG4gIGNvbnN0IHVzZVdlYkdQVSA9IGNvbmZpZy5kZXZpY2UgPT09IFwiZ3B1XCIgJiYgYXdhaXQgd2ViZ3B1KCk7XG4gIGNvbnN0IHByb3h5VG9Xb3JrZXIgPSB1c2VXZWJHUFUgJiYgY29uZmlnLnByb3h5VG9Xb3JrZXI7XG4gIGNvbnN0IGV4ZWN1dGlvblByb3ZpZGVycyA9IFt1c2VXZWJHUFUgPyBcIndlYmdwdVwiIDogXCJ3YXNtXCJdO1xuICBjb25zdCBvcnQyID0gYXdhaXQgZ2V0T3J0KHVzZVdlYkdQVSk7XG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiXHRVc2luZyBXZWJHUFU6XCIsIHVzZVdlYkdQVSk7XG4gICAgY29uc29sZS5kZWJ1ZyhcIlx0UHJveHkgdG8gV29ya2VyOlwiLCBwcm94eVRvV29ya2VyKTtcbiAgICBvcnQyLmVudi5kZWJ1ZyA9IHRydWU7XG4gICAgb3J0Mi5lbnYubG9nTGV2ZWwgPSBcInZlcmJvc2VcIjtcbiAgfVxuICBvcnQyLmVudi53YXNtLm51bVRocmVhZHMgPSBtYXhOdW1UaHJlYWRzKCk7XG4gIG9ydDIuZW52Lndhc20ucHJveHkgPSBwcm94eVRvV29ya2VyO1xuICBjb25zdCBiYXNlRmlsZVBhdGggPSB1c2VXZWJHUFUgPyBcIi9vbm54cnVudGltZS13ZWIvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwXCIgOiBcIi9vbm54cnVudGltZS13ZWIvb3J0LXdhc20tc2ltZC10aHJlYWRlZFwiO1xuICBjb25zdCB3YXNtUGF0aCA9IGF3YWl0IGxvYWRBc1VybChgJHtiYXNlRmlsZVBhdGh9Lndhc21gLCBjb25maWcpO1xuICBjb25zdCBtanNQYXRoID0gYXdhaXQgbG9hZEFzVXJsKGAke2Jhc2VGaWxlUGF0aH0ubWpzYCwgY29uZmlnKTtcbiAgb3J0Mi5lbnYud2FzbS53YXNtUGF0aHMgPSB7XG4gICAgbWpzOiBtanNQYXRoLFxuICAgIHdhc206IHdhc21QYXRoXG4gIH07XG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwib3J0LmVudi53YXNtOlwiLCBvcnQyLmVudi53YXNtKTtcbiAgfVxuICBjb25zdCBvcnRDb25maWcgPSB7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJzLFxuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IFwiYWxsXCIsXG4gICAgZXhlY3V0aW9uTW9kZTogXCJwYXJhbGxlbFwiLFxuICAgIGVuYWJsZUNwdU1lbUFyZW5hOiB0cnVlXG4gIH07XG4gIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBvcnQyLkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKG1vZGVsLCBvcnRDb25maWcpLmNhdGNoKFxuICAgIChlKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb246IFwiJHtlfVwiLiBQbGVhc2UgY2hlY2sgaWYgdGhlIHB1YmxpY1BhdGggaXMgc2V0IGNvcnJlY3RseS5gXG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHNlc3Npb247XG59XG5hc3luYyBmdW5jdGlvbiBydW5Pbm54U2Vzc2lvbihzZXNzaW9uLCBpbnB1dHMsIG91dHB1dHMsIGNvbmZpZykge1xuICBjb25zdCB1c2VXZWJHUFUgPSBjb25maWcuZGV2aWNlID09PSBcImdwdVwiICYmIGF3YWl0IHdlYmdwdSgpO1xuICBjb25zdCBvcnQyID0gYXdhaXQgZ2V0T3J0KHVzZVdlYkdQVSk7XG4gIGNvbnN0IGZlZWRzID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdGVuc29yXSBvZiBpbnB1dHMpIHtcbiAgICBmZWVkc1trZXldID0gbmV3IG9ydDIuVGVuc29yKFxuICAgICAgXCJmbG9hdDMyXCIsXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KHRlbnNvci5kYXRhKSxcbiAgICAgIHRlbnNvci5zaGFwZVxuICAgICk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0RGF0YSA9IGF3YWl0IHNlc3Npb24ucnVuKGZlZWRzLCB7fSk7XG4gIGNvbnN0IG91dHB1dEtWUGFpcnMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygb3V0cHV0cykge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dERhdGFba2V5XTtcbiAgICBjb25zdCBzaGFwZSA9IG91dHB1dC5kaW1zO1xuICAgIGNvbnN0IGRhdGEgPSBvdXRwdXQuZGF0YTtcbiAgICBjb25zdCB0ZW5zb3IgPSAoMCwgaW1wb3J0X25kYXJyYXkzLmRlZmF1bHQpKGRhdGEsIHNoYXBlKTtcbiAgICBvdXRwdXRLVlBhaXJzLnB1c2godGVuc29yKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0S1ZQYWlycztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3pvZC9saWIvaW5kZXgubWpzXG52YXIgdXRpbDtcbihmdW5jdGlvbih1dGlsMikge1xuICB1dGlsMi5hc3NlcnRFcXVhbCA9ICh2YWwpID0+IHZhbDtcbiAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykge1xuICB9XG4gIHV0aWwyLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgdXRpbDIuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgdXRpbDIuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIHV0aWwyLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsMi5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgfVxuICAgIHJldHVybiB1dGlsMi5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICB9O1xuICB1dGlsMi5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHV0aWwyLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICB9KTtcbiAgfTtcbiAgdXRpbDIub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSA6IChvYmplY3QpID0+IHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG4gIHV0aWwyLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9O1xuICB1dGlsMi5pc0ludGVnZXIgPSB0eXBlb2YgTnVtYmVyLmlzSW50ZWdlciA9PT0gXCJmdW5jdGlvblwiID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkuam9pbihzZXBhcmF0b3IpO1xuICB9XG4gIHV0aWwyLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICB1dGlsMi5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbihvYmplY3RVdGlsMikge1xuICBvYmplY3RVdGlsMi5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpcnN0LFxuICAgICAgLi4uc2Vjb25kXG4gICAgICAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxuICAgIH07XG4gIH07XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbnZhciBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gIFwic3RyaW5nXCIsXG4gIFwibmFuXCIsXG4gIFwibnVtYmVyXCIsXG4gIFwiaW50ZWdlclwiLFxuICBcImZsb2F0XCIsXG4gIFwiYm9vbGVhblwiLFxuICBcImRhdGVcIixcbiAgXCJiaWdpbnRcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcInVuZGVmaW5lZFwiLFxuICBcIm51bGxcIixcbiAgXCJhcnJheVwiLFxuICBcIm9iamVjdFwiLFxuICBcInVua25vd25cIixcbiAgXCJwcm9taXNlXCIsXG4gIFwidm9pZFwiLFxuICBcIm5ldmVyXCIsXG4gIFwibWFwXCIsXG4gIFwic2V0XCJcbl0pO1xudmFyIGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIGlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gIH1cbn07XG52YXIgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gIFwiaW52YWxpZF90eXBlXCIsXG4gIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gIFwiY3VzdG9tXCIsXG4gIFwiaW52YWxpZF91bmlvblwiLFxuICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gIFwiaW52YWxpZF9kYXRlXCIsXG4gIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgXCJ0b29fc21hbGxcIixcbiAgXCJ0b29fYmlnXCIsXG4gIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgXCJub3RfZmluaXRlXCJcbl0pO1xudmFyIHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbnZhciBab2RFcnJvciA9IGNsYXNzIF9ab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICB9O1xuICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgIH07XG4gICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gIH1cbiAgZ2V0IGVycm9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gIH1cbiAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8IGZ1bmN0aW9uKGlzc3VlKSB7XG4gICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICB9O1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICB9XG4gIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9ab2RFcnJvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gIH1cbiAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICB9XG59O1xuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICByZXR1cm4gZXJyb3I7XG59O1xudmFyIGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gIGxldCBtZXNzYWdlO1xuICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xuICAgICAgZWxzZVxuICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fYmlnOlxuICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYCA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgIGVsc2VcbiAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgfVxuICByZXR1cm4geyBtZXNzYWdlIH07XG59O1xudmFyIG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxudmFyIG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi5pc3N1ZURhdGEucGF0aCB8fCBbXV07XG4gIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAuLi5pc3N1ZURhdGEsXG4gICAgcGF0aDogZnVsbFBhdGhcbiAgfTtcbiAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZVxuICAgIH07XG4gIH1cbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gIGNvbnN0IG1hcHMgPSBlcnJvck1hcHMuZmlsdGVyKChtKSA9PiAhIW0pLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uaXNzdWVEYXRhLFxuICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZVxuICB9O1xufTtcbnZhciBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICBjb25zdCBvdmVycmlkZU1hcCA9IGdldEVycm9yTWFwKCk7XG4gIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICBpc3N1ZURhdGEsXG4gICAgZGF0YTogY3R4LmRhdGEsXG4gICAgcGF0aDogY3R4LnBhdGgsXG4gICAgZXJyb3JNYXBzOiBbXG4gICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgIG92ZXJyaWRlTWFwLFxuICAgICAgb3ZlcnJpZGVNYXAgPT09IGVycm9yTWFwID8gdm9pZCAwIDogZXJyb3JNYXBcbiAgICAgIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgXS5maWx0ZXIoKHgpID0+ICEheClcbiAgfSk7XG4gIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxudmFyIFBhcnNlU3RhdHVzID0gY2xhc3MgX1BhcnNlU3RhdHVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgfVxuICBkaXJ0eSgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XG4gICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX1BhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gIH1cbiAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICB9XG59O1xudmFyIElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdHVzOiBcImFib3J0ZWRcIlxufSk7XG52YXIgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbnZhciBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xudmFyIGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG52YXIgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xudmFyIGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbnZhciBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59XG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwibVwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpLCB2YWx1ZTtcbn1cbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24oZXJyb3JVdGlsMikge1xuICBlcnJvclV0aWwyLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICBlcnJvclV0aWwyLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5tZXNzYWdlO1xufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xudmFyIF9ab2RFbnVtX2NhY2hlO1xudmFyIF9ab2ROYXRpdmVFbnVtX2NhY2hlO1xudmFyIFBhcnNlSW5wdXRMYXp5UGF0aCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgIHRoaXMuX2tleSA9IGtleTtcbiAgfVxuICBnZXQgcGF0aCgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XG4gIH1cbn07XG52YXIgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gIGlmICghcGFyYW1zKVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgeyBlcnJvck1hcDogZXJyb3JNYXAyLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICBpZiAoZXJyb3JNYXAyICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICB9XG4gIGlmIChlcnJvck1hcDIpXG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwMiwgZGVzY3JpcHRpb24gfTtcbiAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogKF9hID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogcmVxdWlyZWRfZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9XG4gICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYiA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGludmFsaWRfdHlwZV9lcnJvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICB9O1xuICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxudmFyIFpvZFR5cGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlZikge1xuICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gIH1cbiAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgfVxuICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgIHJldHVybiBjdHggfHwge1xuICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgIHBhcmVudDogaW5wdXQucGFyZW50XG4gICAgfTtcbiAgfVxuICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICBjdHg6IHtcbiAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICB9XG4gIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcFxuICAgICAgfSxcbiAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgfVxuICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICB9XG4gIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgIGNvbW1vbjoge1xuICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgIH0sXG4gICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpXG4gICAgfTtcbiAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgfVxuICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbClcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH1cbiAgICB9KTtcbiAgfVxuICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsaXNoKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgfVxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gIH1cbiAgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBvcihvcHRpb24pIHtcbiAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICB9XG4gIGFuZChpbmNvbWluZykge1xuICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICB9XG4gIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHRcbiAgICB9KTtcbiAgfVxuICBicmFuZCgpIHtcbiAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgdHlwZTogdGhpcyxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKVxuICAgIH0pO1xuICB9XG4gIGNhdGNoKGRlZikge1xuICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoXG4gICAgfSk7XG4gIH1cbiAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxuICBwaXBlKHRhcmdldCkge1xuICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgfVxuICByZWFkb25seSgpIHtcbiAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICB9XG4gIGlzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHZvaWQgMCkuc3VjY2VzcztcbiAgfVxuICBpc051bGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICB9XG59O1xudmFyIGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xudmFyIGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xudmFyIHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvO1xudmFyIHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xudmFyIG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbnZhciBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbnZhciBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbnZhciBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG52YXIgZW1vamlSZWdleDtcbnZhciBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xudmFyIGlwdjZSZWdleCA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xudmFyIGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xudmFyIGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xudmFyIGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICBsZXQgcmVnZXggPSBgKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQ6WzAtNV1cXFxcZGA7XG4gIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgIHJlZ2V4ID0gYCR7cmVnZXh9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICB9IGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICByZWdleCA9IGAke3JlZ2V4fShcXFxcLlxcXFxkKyk/YDtcbiAgfVxuICByZXR1cm4gcmVnZXg7XG59XG5mdW5jdGlvbiB0aW1lUmVnZXgoYXJncykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbmZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICBsZXQgcmVnZXggPSBgJHtkYXRlUmVnZXhTb3VyY2V9VCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfWA7XG4gIGNvbnN0IG9wdHMgPSBbXTtcbiAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBab2RTdHJpbmcgPSBjbGFzcyBfWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgyLnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgIGxldCBjdHggPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwicmVnZXhcIikge1xuICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgaWYgKCF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IHsgaW5jbHVkZXM6IGNoZWNrLnZhbHVlLCBwb3NpdGlvbjogY2hlY2sucG9zaXRpb24gfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvTG93ZXJDYXNlXCIpIHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiKSB7XG4gICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiKSB7XG4gICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICBpZiAoIWlucHV0LmRhdGEuZW5kc1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICB2YWxpZGF0aW9uLFxuICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICB1cmwobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBlbW9qaShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgdXVpZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBuYW5vaWQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBjdWlkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICB1bGlkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJiYXNlNjRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGlwKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgfVxuICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICBvZmZzZXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgbG9jYWw6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZGF0ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XG4gIH1cbiAgdGltZShvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICBtZXNzYWdlOiBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZHVyYXRpb25cIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgIHJlZ2V4LFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgdmFsdWUsXG4gICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgIHZhbHVlLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICB2YWx1ZTogbGVuLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB6LnN0cmluZygpLm1pbigxKSBpbnN0ZWFkLlxuICAgKiBAc2VlIHtAbGluayBab2RTdHJpbmcubWlufVxuICAgKi9cbiAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICB9XG4gIHRyaW0oKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b0xvd2VyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICB9XG4gIGdldCBpc0RhdGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICB9XG4gIGdldCBpc1RpbWUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIGdldCBpc0R1cmF0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gIH1cbiAgZ2V0IGlzRW1haWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgfVxuICBnZXQgaXNVUkwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1cmxcIik7XG4gIH1cbiAgZ2V0IGlzRW1vamkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgfVxuICBnZXQgaXNVVUlEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgfVxuICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgfVxuICBnZXQgaXNVTElEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgfVxuICBnZXQgaXNJUCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICB9XG4gIGdldCBpc0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgfVxuICBnZXQgbWluTGVuZ3RoKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgIGxldCBtYXggPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxufTtcblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgIGNoZWNrczogW10sXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgY29lcmNlOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICByZXR1cm4gdmFsSW50ICUgc3RlcEludCAvIE1hdGgucG93KDEwLCBkZWNDb3VudCk7XG59XG52YXIgWm9kTnVtYmVyID0gY2xhc3MgX1pvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgbGV0IGN0eCA9IHZvaWQgMDtcbiAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICB9XG4gIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IF9ab2ROdW1iZXIoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbXG4gICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhjaGVjaykge1xuICAgIHJldHVybiBuZXcgX1pvZE51bWJlcih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja11cbiAgICB9KTtcbiAgfVxuICBpbnQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImludFwiLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBzYWZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IG1heCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGdldCBpc0ludCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSk7XG4gIH1cbiAgZ2V0IGlzRmluaXRlKCkge1xuICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHwgY2gua2luZCA9PT0gXCJpbnRcIiB8fCBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgfVxufTtcblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICBjaGVja3M6IFtdLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQmlnSW50ID0gY2xhc3MgX1pvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBsZXQgY3R4ID0gdm9pZCAwO1xuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kQmlnSW50KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2RCaWdJbnQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgIHZhbHVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IG1heCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG59O1xuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcbiAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQm9vbGVhbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZERhdGUgPSBjbGFzcyBfWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgbGV0IGN0eCA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJkYXRlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpXG4gICAgfTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2REYXRlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgfVxuICBnZXQgbWF4RGF0ZSgpIHtcbiAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsO1xuICB9XG59O1xuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RTeW1ib2wgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN5bWJvbCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFVuZGVmaW5lZCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5kZWZpbmVkLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTnVsbCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gIH1cbn07XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RBbnkgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2FueSA9IHRydWU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kVW5rbm93biA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTmV2ZXIgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICB9KTtcbiAgICByZXR1cm4gSU5WQUxJRDtcbiAgfVxufTtcblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFZvaWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gIH1cbn07XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RBcnJheSA9IGNsYXNzIF9ab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAoZGVmLmV4YWN0TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0b29CaWcgPSBjdHguZGF0YS5sZW5ndGggPiBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgIG1pbmltdW06IHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdm9pZCAwLFxuICAgICAgICAgIG1heGltdW06IHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHZvaWQgMCxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogZGVmLm1heExlbmd0aC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgIH0pKS50aGVuKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0Mik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZEFycmF5KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RBcnJheSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kQXJyYXkoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59O1xuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgIHR5cGU6IHNjaGVtYSxcbiAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBudWxsLFxuICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICB9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgIHJldHVybiBab2RUdXBsZS5jcmVhdGUoc2NoZW1hLml0ZW1zLm1hcCgoaXRlbSkgPT4gZGVlcFBhcnRpYWxpZnkoaXRlbSkpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG59XG52YXIgWm9kT2JqZWN0ID0gY2xhc3MgX1pvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgIHRoaXMuYXVnbWVudCA9IHRoaXMuZXh0ZW5kO1xuICB9XG4gIF9nZXRDYWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkID0geyBzaGFwZSwga2V5cyB9O1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgIGNvbnN0IGV4dHJhS2V5cyA9IFtdO1xuICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICAgIGtleXM6IGV4dHJhS2V5c1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmlwXCIpXG4gICAgICAgIDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKFxuICAgICAgICAgICAgbmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KVxuICAgICAgICAgICAgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICB9KS50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNoYXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgfVxuICBzdHJpY3QobWVzc2FnZSkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAuLi5tZXNzYWdlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSA6IHt9XG4gICAgfSk7XG4gIH1cbiAgc3RyaXAoKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCJcbiAgICB9KTtcbiAgfVxuICBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIlxuICAgIH0pO1xuICB9XG4gIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgLy8gICApOiBab2RPYmplY3Q8XG4gIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgLy8gICA+ID0+IHtcbiAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgICAgLi4uZGVmLFxuICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gIC8vICAgICAgIH0pLFxuICAvLyAgICAgfSkgYXMgYW55O1xuICAvLyAgIH07XG4gIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5hdWdtZW50YXRpb25cbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAqL1xuICBtZXJnZShtZXJnaW5nKSB7XG4gICAgY29uc3QgbWVyZ2VkID0gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgICB9KSxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuICAvLyBtZXJnZTxcbiAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAvLyAgICAgICA6IG5ldmVyO1xuICAvLyAgIH0sXG4gIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAvLyAgICAgICA6IG5ldmVyO1xuICAvLyAgIH1cbiAgLy8gPihcbiAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAvLyApOiBab2RPYmplY3Q8XG4gIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAvLyAgIE5ld091dHB1dCxcbiAgLy8gICBOZXdJbnB1dFxuICAvLyA+IHtcbiAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gIC8vICAgICBzaGFwZTogKCkgPT5cbiAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC8vICAgfSkgYXMgYW55O1xuICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gIC8vIH1cbiAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gIH1cbiAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XG4gIC8vIFpvZE9iamVjdDxcbiAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgLy8gPiB7XG4gIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAvLyAgIC8vICk7XG4gIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAvLyAgICAgc2hhcGU6ICgpID0+XG4gIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAvLyAgIH0pIGFzIGFueTtcbiAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAvLyB9XG4gIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNhdGNoYWxsOiBpbmRleFxuICAgIH0pO1xuICB9XG4gIHBpY2sobWFzaykge1xuICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgdXRpbC5vYmplY3RLZXlzKG1hc2spLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHNoYXBlXG4gICAgfSk7XG4gIH1cbiAgb21pdChtYXNrKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gc2hhcGVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgfVxuICBwYXJ0aWFsKG1hc2spIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH1cbiAgcmVxdWlyZWQobWFzaykge1xuICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGVcbiAgICB9KTtcbiAgfVxuICBrZXlvZigpIHtcbiAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICB9XG59O1xuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGUsXG4gICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RVbmlvbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgIGlzc3VlczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3R4OiBjaGlsZEN0eFxuICAgICAgICB9O1xuICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXJ0eSA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlczIpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMyKSk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbn07XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICBvcHRpb25zOiB0eXBlcyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICByZXR1cm4gW3ZvaWQgMF07XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgIHJldHVybiBbdm9pZCAwLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RCcmFuZGVkKSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xudmFyIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiA9IGNsYXNzIF9ab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGN0eC5kYXRhW2Rpc2NyaW1pbmF0b3JdO1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICBpZiAoIW9wdGlvbikge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgIG9wdGlvbnM6IEFycmF5LmZyb20odGhpcy5vcHRpb25zTWFwLmtleXMoKSksXG4gICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIHBhcmVudDogY3R4XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbiAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgY29uc3Qgb3B0aW9uc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZXMgPSBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2hhcGVbZGlzY3JpbWluYXRvcl0pO1xuICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNNYXAuc2V0KHZhbHVlLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvcHRpb25zTWFwLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0UGFyc2VkVHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH0gZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpO1xuICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsLm9iamVjdEtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICB9IGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgfSBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgfVxufVxudmFyIFpvZEludGVyc2VjdGlvbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgfTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pLFxuICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pXG4gICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufTtcblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFR1cGxlID0gY2xhc3MgX1pvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCByZXN0ID0gdGhpcy5fZGVmLnJlc3Q7XG4gICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIlxuICAgICAgfSk7XG4gICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgfSkuZmlsdGVyKCh4KSA9PiAhIXgpO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gIH1cbiAgcmVzdChyZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kVHVwbGUoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgcmVzdFxuICAgIH0pO1xuICB9XG59O1xuWm9kVHVwbGUuY3JlYXRlID0gKHNjaGVtYXMsIHBhcmFtcykgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICBpdGVtczogc2NoZW1hcyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgIHJlc3Q6IG51bGwsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RSZWNvcmQgPSBjbGFzcyBfWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICB9XG4gIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgY3R4LmRhdGFba2V5XSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICByZXR1cm4gbmV3IF9ab2RSZWNvcmQoe1xuICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1pvZFJlY29yZCh7XG4gICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZClcbiAgICB9KTtcbiAgfVxufTtcbnZhciBab2RNYXAgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBnZXQga2V5U2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgfVxuICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICBjb25zdCBmaW5hbE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbmFsTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgfVxuICB9XG59O1xuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgdmFsdWVUeXBlLFxuICAgIGtleVR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RTZXQgPSBjbGFzcyBfWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnNldCkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzMikge1xuICAgICAgY29uc3QgcGFyc2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50czIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50czIpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgIH1cbiAgfVxuICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZFNldCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU2V0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9XG4gICAgfSk7XG4gIH1cbiAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59O1xuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgdmFsdWVUeXBlLFxuICAgIG1pblNpemU6IG51bGwsXG4gICAgbWF4U2l6ZTogbnVsbCxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFNldCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZEZ1bmN0aW9uID0gY2xhc3MgX1pvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgZXJyb3JNYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcbiAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgZXJyb3JNYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgY29uc3QgZm4gPSBjdHguZGF0YTtcbiAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZUFyZ3NJc3N1ZShhcmdzLCBlKSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGUucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICB9XG4gIHJldHVyblR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICB9XG4gIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICByZXR1cm5zOiByZXR1cm5UeXBlXG4gICAgfSk7XG4gIH1cbiAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgfVxuICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kRnVuY3Rpb24oe1xuICAgICAgYXJnczogYXJncyA/IGFyZ3MgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gICAgfSk7XG4gIH1cbn07XG52YXIgWm9kTGF6eSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gIH1cbn07XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgIGdldHRlcixcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RMaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gIH1cbn07XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgdmFsdWUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG52YXIgWm9kRW51bSA9IGNsYXNzIF9ab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICB9XG4gIGdldCBWYWx1ZXMoKSB7XG4gICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gIH1cbiAgZ2V0IEVudW0oKSB7XG4gICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gIH1cbiAgZXh0cmFjdCh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgIHJldHVybiBfWm9kRW51bS5jcmVhdGUodmFsdWVzLCB7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAuLi5uZXdEZWZcbiAgICB9KTtcbiAgfVxuICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIF9ab2RFbnVtLmNyZWF0ZSh0aGlzLm9wdGlvbnMuZmlsdGVyKChvcHQpID0+ICF2YWx1ZXMuaW5jbHVkZXMob3B0KSksIHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIC4uLm5ld0RlZlxuICAgIH0pO1xuICB9XG59O1xuX1pvZEVudW1fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbnZhciBab2ROYXRpdmVFbnVtID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfWm9kTmF0aXZlRW51bV9jYWNoZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiYgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpO1xuICAgIH1cbiAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG59O1xuX1pvZE5hdGl2ZUVudW1fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFByb21pc2UgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2UgPyBjdHguZGF0YSA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcFxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG59O1xuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICB0eXBlOiBzY2hlbWEsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kRWZmZWN0cyA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGlubmVyVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgfVxuICBzb3VyY2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKCkgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkMikgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQyLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfTtcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGlubmVyKSA9PiB7XG4gICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICB9XG59O1xuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgIHNjaGVtYSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgZWZmZWN0LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgc2NoZW1hLFxuICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kT3B0aW9uYWwgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gT0sodm9pZCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn07XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTnVsbGFibGUgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2REZWZhdWx0ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YSxcbiAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgcGFyZW50OiBjdHhcbiAgICB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZENhdGNoID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgbmV3Q3R4ID0ge1xuICAgICAgLi4uY3R4LFxuICAgICAgY29tbW9uOiB7XG4gICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgLi4ubmV3Q3R4XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgdmFsdWU6IHJlc3VsdDIuc3RhdHVzID09PSBcInZhbGlkXCIgPyByZXN1bHQyLnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGFcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gcmVzdWx0LnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZW1vdmVDYXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTmFOID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxufTtcblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmFOKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xudmFyIFpvZEJyYW5kZWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICBkYXRhLFxuICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IGN0eFxuICAgIH0pO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbn07XG52YXIgWm9kUGlwZWxpbmUgPSBjbGFzcyBfWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgIH0pO1xuICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgIHZhbHVlOiBpblJlc3VsdC52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgIHJldHVybiBuZXcgX1pvZFBpcGVsaW5lKHtcbiAgICAgIGluOiBhLFxuICAgICAgb3V0OiBiLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZVxuICAgIH0pO1xuICB9XG59O1xudmFyIFpvZFJlYWRvbmx5ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpIDogZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBwYXJhbXMgPSB7fSwgZmF0YWwpIHtcbiAgaWYgKGNoZWNrKVxuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICghY2hlY2soZGF0YSkpIHtcbiAgICAgICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucDIsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG52YXIgbGF0ZSA9IHtcbiAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZVxufTtcbnZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24oWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMikge1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xudmFyIGluc3RhbmNlT2ZUeXBlID0gKGNscywgcGFyYW1zID0ge1xuICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xudmFyIHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xudmFyIG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xudmFyIG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xudmFyIGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xudmFyIGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG52YXIgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbnZhciBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbnZhciB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbnZhciBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xudmFyIGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xudmFyIHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG52YXIgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xudmFyIHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG52YXIgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xudmFyIG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xudmFyIHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xudmFyIHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbnZhciBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbnZhciBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbnZhciB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG52YXIgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XG52YXIgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG52YXIgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG52YXIgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xudmFyIGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG52YXIgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbnZhciBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xudmFyIG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG52YXIgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbnZhciBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xudmFyIG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbnZhciBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG52YXIgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xudmFyIHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbnZhciBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG52YXIgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xudmFyIG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xudmFyIGNvZXJjZSA9IHtcbiAgc3RyaW5nOiAoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIG51bWJlcjogKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pLFxuICBib29sZWFuOiAoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgLi4uYXJnLFxuICAgIGNvZXJjZTogdHJ1ZVxuICB9KSxcbiAgYmlnaW50OiAoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIGRhdGU6IChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSlcbn07XG52YXIgTkVWRVIgPSBJTlZBTElEO1xudmFyIHogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdEVycm9yTWFwOiBlcnJvck1hcCxcbiAgc2V0RXJyb3JNYXAsXG4gIGdldEVycm9yTWFwLFxuICBtYWtlSXNzdWUsXG4gIEVNUFRZX1BBVEgsXG4gIGFkZElzc3VlVG9Db250ZXh0LFxuICBQYXJzZVN0YXR1cyxcbiAgSU5WQUxJRCxcbiAgRElSVFksXG4gIE9LLFxuICBpc0Fib3J0ZWQsXG4gIGlzRGlydHksXG4gIGlzVmFsaWQsXG4gIGlzQXN5bmMsXG4gIGdldCB1dGlsKCkge1xuICAgIHJldHVybiB1dGlsO1xuICB9LFxuICBnZXQgb2JqZWN0VXRpbCgpIHtcbiAgICByZXR1cm4gb2JqZWN0VXRpbDtcbiAgfSxcbiAgWm9kUGFyc2VkVHlwZSxcbiAgZ2V0UGFyc2VkVHlwZSxcbiAgWm9kVHlwZSxcbiAgZGF0ZXRpbWVSZWdleCxcbiAgWm9kU3RyaW5nLFxuICBab2ROdW1iZXIsXG4gIFpvZEJpZ0ludCxcbiAgWm9kQm9vbGVhbixcbiAgWm9kRGF0ZSxcbiAgWm9kU3ltYm9sLFxuICBab2RVbmRlZmluZWQsXG4gIFpvZE51bGwsXG4gIFpvZEFueSxcbiAgWm9kVW5rbm93bixcbiAgWm9kTmV2ZXIsXG4gIFpvZFZvaWQsXG4gIFpvZEFycmF5LFxuICBab2RPYmplY3QsXG4gIFpvZFVuaW9uLFxuICBab2REaXNjcmltaW5hdGVkVW5pb24sXG4gIFpvZEludGVyc2VjdGlvbixcbiAgWm9kVHVwbGUsXG4gIFpvZFJlY29yZCxcbiAgWm9kTWFwLFxuICBab2RTZXQsXG4gIFpvZEZ1bmN0aW9uLFxuICBab2RMYXp5LFxuICBab2RMaXRlcmFsLFxuICBab2RFbnVtLFxuICBab2ROYXRpdmVFbnVtLFxuICBab2RQcm9taXNlLFxuICBab2RFZmZlY3RzLFxuICBab2RUcmFuc2Zvcm1lcjogWm9kRWZmZWN0cyxcbiAgWm9kT3B0aW9uYWwsXG4gIFpvZE51bGxhYmxlLFxuICBab2REZWZhdWx0LFxuICBab2RDYXRjaCxcbiAgWm9kTmFOLFxuICBCUkFORCxcbiAgWm9kQnJhbmRlZCxcbiAgWm9kUGlwZWxpbmUsXG4gIFpvZFJlYWRvbmx5LFxuICBjdXN0b20sXG4gIFNjaGVtYTogWm9kVHlwZSxcbiAgWm9kU2NoZW1hOiBab2RUeXBlLFxuICBsYXRlLFxuICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKCkge1xuICAgIHJldHVybiBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4gIH0sXG4gIGNvZXJjZSxcbiAgYW55OiBhbnlUeXBlLFxuICBhcnJheTogYXJyYXlUeXBlLFxuICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gIGJvb2xlYW46IGJvb2xlYW5UeXBlLFxuICBkYXRlOiBkYXRlVHlwZSxcbiAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICBlZmZlY3Q6IGVmZmVjdHNUeXBlLFxuICBcImVudW1cIjogZW51bVR5cGUsXG4gIFwiZnVuY3Rpb25cIjogZnVuY3Rpb25UeXBlLFxuICBcImluc3RhbmNlb2ZcIjogaW5zdGFuY2VPZlR5cGUsXG4gIGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uVHlwZSxcbiAgbGF6eTogbGF6eVR5cGUsXG4gIGxpdGVyYWw6IGxpdGVyYWxUeXBlLFxuICBtYXA6IG1hcFR5cGUsXG4gIG5hbjogbmFuVHlwZSxcbiAgbmF0aXZlRW51bTogbmF0aXZlRW51bVR5cGUsXG4gIG5ldmVyOiBuZXZlclR5cGUsXG4gIFwibnVsbFwiOiBudWxsVHlwZSxcbiAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgbnVtYmVyOiBudW1iZXJUeXBlLFxuICBvYmplY3Q6IG9iamVjdFR5cGUsXG4gIG9ib29sZWFuLFxuICBvbnVtYmVyLFxuICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxuICBvc3RyaW5nLFxuICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcbiAgcHJvbWlzZTogcHJvbWlzZVR5cGUsXG4gIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgc2V0OiBzZXRUeXBlLFxuICBzdHJpY3RPYmplY3Q6IHN0cmljdE9iamVjdFR5cGUsXG4gIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgc3ltYm9sOiBzeW1ib2xUeXBlLFxuICB0cmFuc2Zvcm1lcjogZWZmZWN0c1R5cGUsXG4gIHR1cGxlOiB0dXBsZVR5cGUsXG4gIFwidW5kZWZpbmVkXCI6IHVuZGVmaW5lZFR5cGUsXG4gIHVuaW9uOiB1bmlvblR5cGUsXG4gIHVua25vd246IHVua25vd25UeXBlLFxuICBcInZvaWRcIjogdm9pZFR5cGUsXG4gIE5FVkVSLFxuICBab2RJc3N1ZUNvZGUsXG4gIHF1b3RlbGVzc0pzb24sXG4gIFpvZEVycm9yXG59KTtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgcGFja2FnZV9kZWZhdWx0ID0ge1xuICBuYW1lOiBcIkBpbWdseS9iYWNrZ3JvdW5kLXJlbW92YWxcIixcbiAgdmVyc2lvbjogXCIxLjUuOFwiLFxuICBkZXNjcmlwdGlvbjogXCJCYWNrZ3JvdW5kIFJlbW92YWwgaW4gdGhlIEJyb3dzZXJcIixcbiAga2V5d29yZHM6IFtcbiAgICBcImJhY2tncm91bmQtcmVtb3ZhbFwiLFxuICAgIFwiY2xpZW50LXNpZGVcIixcbiAgICBcImRhdGEtcHJpdmFjeVwiLFxuICAgIFwiaW1hZ2Utc2VnbWVudGF0aW9uXCIsXG4gICAgXCJpbWFnZS1tYXR0aW5nXCIsXG4gICAgXCJvbm54XCJcbiAgXSxcbiAgcmVwb3NpdG9yeToge1xuICAgIHR5cGU6IFwiZ2l0XCIsXG4gICAgdXJsOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vaW1nbHkvYmFja2dyb3VuZC1yZW1vdmFsLWpzLmdpdFwiXG4gIH0sXG4gIGxpY2Vuc2U6IFwiU0VFIExJQ0VOU0UgSU4gTElDRU5TRS5tZFwiLFxuICBhdXRob3I6IHtcbiAgICBuYW1lOiBcIklNRy5MWSBHbWJIXCIsXG4gICAgZW1haWw6IFwic3VwcG9ydEBpbWcubHlcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9pbWcubHlcIlxuICB9LFxuICBidWdzOiB7XG4gICAgZW1haWw6IFwic3VwcG9ydEBpbWcubHlcIlxuICB9LFxuICBzb3VyY2U6IFwiLi9zcmMvaW5kZXgudHNcIixcbiAgbWFpbjogXCIuL2Rpc3QvaW5kZXguY2pzXCIsXG4gIG1vZHVsZTogXCIuL2Rpc3QvaW5kZXgubWpzXCIsXG4gIHR5cGVzOiBcIi4vZGlzdC9zcmMvaW5kZXguZC50c1wiLFxuICBleHBvcnRzOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIHJlcXVpcmU6IFwiLi9kaXN0L2luZGV4LmNqc1wiLFxuICAgICAgaW1wb3J0OiBcIi4vZGlzdC9pbmRleC5tanNcIixcbiAgICAgIHR5cGVzOiBcIi4vZGlzdC9zcmMvaW5kZXguZC50c1wiXG4gICAgfVxuICB9LFxuICBob21lcGFnZTogXCJodHRwczovL2ltZy5seS9zaG93Y2FzZXMvY2VzZGsvd2ViL2JhY2tncm91bmQtcmVtb3ZhbFwiLFxuICBmaWxlczogW1xuICAgIFwiTElDRU5TRS5tZFwiLFxuICAgIFwiUkVBRE1FLm1kXCIsXG4gICAgXCJDSEFOR0VMT0cubWRcIixcbiAgICBcIlRoaXJkUGFydHlMaWNlbnNlcy5qc29uXCIsXG4gICAgXCJkaXN0L1wiLFxuICAgIFwiYmluL1wiXG4gIF0sXG4gIHNjcmlwdHM6IHtcbiAgICBzdGFydDogXCJucG0gcnVuIHdhdGNoXCIsXG4gICAgY2xlYW46IFwibnB4IHJpbXJhZiBkaXN0XCIsXG4gICAgdGVzdDogXCJ0cnVlXCIsXG4gICAgcmVzb3VyY2VzOiBcIm5vZGUgLi4vLi4vc2NyaXB0cy9wYWNrYWdlLXJlc291cmNlcy5tanNcIixcbiAgICBcImNoYW5nZWxvZzpjcmVhdGVcIjogXCJub2RlIC4uLy4uL3NjcmlwdHMvY2hhbmdlbG9nL2NoYW5nZWxvZy1jcmVhdGUubWpzXCIsXG4gICAgXCJjaGFuZ2Vsb2c6Z2VuZXJhdGVcIjogXCJub2RlIC4uLy4uL3NjcmlwdHMvY2hhbmdlbG9nL2NoYW5nZWxvZy1nZW5lcmF0ZS5tanNcIixcbiAgICBidWlsZDogXCJucG0gcnVuIGNsZWFuICYmIG5wbSBydW4gdHlwZXMgJiYgbnBtIHJ1biByZXNvdXJjZXMgJiYgbnBtIHJ1biBjaGFuZ2Vsb2c6Z2VuZXJhdGUgJiYgbm9kZSBzY3JpcHRzL2J1aWxkLm1qc1wiLFxuICAgIHR5cGVzOiBcIiBucHggdHNjIC0tZGVjbGFyYXRpb24gLS1lbWl0RGVjbGFyYXRpb25Pbmx5IC0tZGVjbGFyYXRpb25EaXIgZGlzdCAtLWRlY2xhcmF0aW9uTWFwXCIsXG4gICAgd2F0Y2g6IFwibnBtIHJ1biBjbGVhbiAmJiBucG0gcnVuIHJlc291cmNlcyAmJiBucG0gcnVuIGNoYW5nZWxvZzpnZW5lcmF0ZSAmJiBub2RlIHNjcmlwdHMvd2F0Y2gubWpzXCIsXG4gICAgXCJwdWJsaXNoOmxhdGVzdFwiOiBcIm5wbSBwdWJsaXNoIC0tdGFnIGxhdGVzdCAtLWFjY2VzcyBwdWJsaWNcIixcbiAgICBcInB1Ymxpc2g6bmV4dFwiOiBcIm5wbSBwdWJsaXNoIC0tdGFnIG5leHQgLS1hY2Nlc3MgcHVibGljXCIsXG4gICAgXCJwYWNrYWdlOnBhY2tcIjogXCJucG0gcGFjayAuIC0tcGFjay1kZXN0aW5hdGlvbiAuLi8uLi9yZWxlYXNlc1wiLFxuICAgIGxpbnQ6IFwibnB4IHByZXR0aWVyIC0td3JpdGUgLlwiXG4gIH0sXG4gIGRlcGVuZGVuY2llczoge1xuICAgIFwibG9kYXNoLWVzXCI6IFwiXjQuMTcuMjFcIixcbiAgICBuZGFycmF5OiBcIn4xLjAuMFwiLFxuICAgIHpvZDogXCJeMy4yMy44XCJcbiAgfSxcbiAgcGVlckRlcGVuZGVuY2llczoge1xuICAgIFwib25ueHJ1bnRpbWUtd2ViXCI6IFwiMS4yMS4wLWRldi4yMDI1MDExNC0yMjhkZDE2ODkzXCJcbiAgfSxcbiAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAdHlwZXMvbG9kYXNoLWVzXCI6IFwiXjQuMTcuMTJcIixcbiAgICBcIkB0eXBlcy9uZGFycmF5XCI6IFwifjEuMC4xNFwiLFxuICAgIFwiQHR5cGVzL25vZGVcIjogXCJ+MjAuMy4wXCIsXG4gICAgYXNzZXJ0OiBcIn4yLjAuMFwiLFxuICAgIGVzYnVpbGQ6IFwifjAuMTguMFwiLFxuICAgIGdsb2I6IFwifjEwLjMuMFwiLFxuICAgIFwibnBtLWR0c1wiOiBcIn4xLjMuMFwiLFxuICAgIHByb2Nlc3M6IFwifjAuMTEuMFwiLFxuICAgIFwidHMtbG9hZGVyXCI6IFwifjkuNC4wXCIsXG4gICAgdHNsaWI6IFwifjIuNS4wXCIsXG4gICAgdHlwZXNjcmlwdDogXCJ+NS4xLjBcIixcbiAgICB1dGlsOiBcIn4wLjEyLjBcIixcbiAgICB3ZWJwYWNrOiBcIn41Ljg1LjBcIixcbiAgICBcIndlYnBhY2stY2xpXCI6IFwifjUuMS4wXCJcbiAgfSxcbiAgYnVuZGxlRGVwZW5kZW5jaWVzOiBbXVxufTtcblxuLy8gc3JjL3NjaGVtYS50c1xudmFyIENvbmZpZ1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgcHVibGljUGF0aDogei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIHB1YmxpYyBwYXRoIHRvIHRoZSB3YXNtIGZpbGVzIGFuZCB0aGUgb25ueCBtb2RlbC5cIikuZGVmYXVsdChcbiAgICBcImh0dHBzOi8vc3RhdGljaW1nbHkuY29tL0BpbWdseS9iYWNrZ3JvdW5kLXJlbW92YWwtZGF0YS8ke1BBQ0tBR0VfVkVSU0lPTn0vZGlzdC9cIlxuICApLnRyYW5zZm9ybSgodmFsKSA9PiB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKFwiJHtQQUNLQUdFX05BTUV9XCIsIHBhY2thZ2VfZGVmYXVsdC5uYW1lKS5yZXBsYWNlKFwiJHtQQUNLQUdFX1ZFUlNJT059XCIsIHBhY2thZ2VfZGVmYXVsdC52ZXJzaW9uKTtcbiAgfSksXG4gIGRlYnVnOiB6LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKS5kZXNjcmliZShcIldoZXRoZXIgdG8gZW5hYmxlIGRlYnVnIGxvZ2dpbmcuXCIpLFxuICByZXNjYWxlOiB6LmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLmRlc2NyaWJlKFwiV2hldGhlciB0byByZXNjYWxlIHRoZSBpbWFnZS5cIiksXG4gIGRldmljZTogei5lbnVtKFtcImNwdVwiLCBcImdwdVwiXSkuZGVmYXVsdChcImNwdVwiKS5kZXNjcmliZShcIlRoZSBkZXZpY2UgdG8gcnVuIHRoZSBtb2RlbCBvbi5cIiksXG4gIHByb3h5VG9Xb3JrZXI6IHouYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLmRlc2NyaWJlKFwiV2hldGhlciB0byBwcm94eSBpbmZlcmVuY2UgdG8gYSB3ZWIgd29ya2VyLlwiKSxcbiAgZmV0Y2hBcmdzOiB6LmFueSgpLmRlZmF1bHQoe30pLmRlc2NyaWJlKFwiQXJndW1lbnRzIHRvIHBhc3MgdG8gZmV0Y2ggd2hlbiBsb2FkaW5nIHRoZSBtb2RlbC5cIiksXG4gIHByb2dyZXNzOiB6LmZ1bmN0aW9uKCkuYXJncyh6LnN0cmluZygpLCB6Lm51bWJlcigpLCB6Lm51bWJlcigpKS5yZXR1cm5zKHoudm9pZCgpKS5kZXNjcmliZShcIlByb2dyZXNzIGNhbGxiYWNrLlwiKS5vcHRpb25hbCgpLFxuICBtb2RlbDogei5wcmVwcm9jZXNzKFxuICAgICh2YWwpID0+IHtcbiAgICAgIHN3aXRjaCAodmFsKSB7XG4gICAgICAgIGNhc2UgXCJsYXJnZVwiOlxuICAgICAgICAgIHJldHVybiBcImlzbmV0XCI7XG4gICAgICAgIGNhc2UgXCJzbWFsbFwiOlxuICAgICAgICAgIHJldHVybiBcImlzbmV0X3F1aW50OFwiO1xuICAgICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgICAgcmV0dXJuIFwiaXNuZXRfZnAxNlwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICB6LmVudW0oW1wiaXNuZXRcIiwgXCJpc25ldF9mcDE2XCIsIFwiaXNuZXRfcXVpbnQ4XCJdKVxuICApLmRlZmF1bHQoXCJtZWRpdW1cIiksXG4gIG91dHB1dDogei5vYmplY3Qoe1xuICAgIGZvcm1hdDogei5lbnVtKFtcbiAgICAgIFwiaW1hZ2UvcG5nXCIsXG4gICAgICBcImltYWdlL2pwZWdcIixcbiAgICAgIFwiaW1hZ2Uvd2VicFwiLFxuICAgICAgXCJpbWFnZS94LXJnYmE4XCIsXG4gICAgICBcImltYWdlL3gtYWxwaGE4XCJcbiAgICBdKS5kZWZhdWx0KFwiaW1hZ2UvcG5nXCIpLFxuICAgIHF1YWxpdHk6IHoubnVtYmVyKCkuZGVmYXVsdCgwLjgpXG4gIH0pLmRlZmF1bHQoe30pXG59KS5kZWZhdWx0KHt9KS50cmFuc2Zvcm0oKGNvbmZpZykgPT4ge1xuICBpZiAoY29uZmlnLmRlYnVnKVxuICAgIGNvbnNvbGUubG9nKFwiQ29uZmlnOlwiLCBjb25maWcpO1xuICBpZiAoY29uZmlnLmRlYnVnICYmICFjb25maWcucHJvZ3Jlc3MpIHtcbiAgICBjb25maWcucHJvZ3Jlc3MgPSBjb25maWcucHJvZ3Jlc3MgPz8gKChrZXksIGN1cnJlbnQsIHRvdGFsKSA9PiB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBEb3dubG9hZGluZyAke2tleX06ICR7Y3VycmVudH0gb2YgJHt0b3RhbH1gKTtcbiAgICB9KTtcbiAgICBpZiAoIWNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcbiAgICAgIGlmIChjb25maWcuZGVidWcpXG4gICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgXCJDcm9zcy1PcmlnaW4tSXNvbGF0ZWQgaXMgbm90IGVuYWJsZWQuIFBlcmZvcm1hbmNlIHdpbGwgYmUgZGVncmFkZWQuIFBsZWFzZSBzZWUgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NoYXJlZEFycmF5QnVmZmVyLlwiXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWc7XG59KTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlnKGNvbmZpZ3VyYXRpb24pIHtcbiAgcmV0dXJuIENvbmZpZ1NjaGVtYS5wYXJzZShjb25maWd1cmF0aW9uID8/IHt9KTtcbn1cblxuLy8gc3JjL2luZmVyZW5jZS50c1xudmFyIGltcG9ydF9uZGFycmF5NCA9IF9fdG9FU00ocmVxdWlyZV9uZGFycmF5KCkpO1xuYXN5bmMgZnVuY3Rpb24gaW5pdEJhc2UoY29uZmlnKSB7XG4gIGlmIChjb25maWcuZGVidWcpXG4gICAgY29uc29sZS5kZWJ1ZyhcIkxvYWRpbmcgbW9kZWwuLi5cIiwgY29uZmlnLm1vZGVsKTtcbiAgY29uc3QgbW9kZWwgPSBjb25maWcubW9kZWw7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCBsb2FkQXNCbG9iKGAvbW9kZWxzLyR7bW9kZWx9YCwgY29uZmlnKTtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7XG4gIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjcmVhdGVPbm54U2Vzc2lvbihhcnJheUJ1ZmZlciwgY29uZmlnKTtcbiAgcmV0dXJuIHNlc3Npb247XG59XG5hc3luYyBmdW5jdGlvbiBpbml0SW5mZXJlbmNlKGNvbmZpZykge1xuICBjb25maWcgPSB2YWxpZGF0ZUNvbmZpZyhjb25maWcpO1xuICBjb25zdCBiYXNlID0gYXdhaXQgaW5pdEJhc2UoY29uZmlnKTtcbiAgcmV0dXJuIHsgY29uZmlnLCBzZXNzaW9uOiB7IGJhc2UgfSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcnVuSW5mZXJlbmNlKGltYWdlVGVuc29yLCBjb25maWcsIHNlc3Npb24pIHtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IDEwMjQ7XG4gIGNvbnN0IFtzcmNIZWlnaHQsIHNyY1dpZHRoLCBzcmNDaGFubmVsc10gPSBpbWFnZVRlbnNvci5zaGFwZTtcbiAgY29uc3Qga2VlcEFzcGVjdCA9IGZhbHNlO1xuICBsZXQgcmVzaXplZEltYWdlVGVuc29yID0gdGVuc29yUmVzaXplQmlsaW5lYXIoXG4gICAgaW1hZ2VUZW5zb3IsXG4gICAgcmVzb2x1dGlvbixcbiAgICByZXNvbHV0aW9uLFxuICAgIGtlZXBBc3BlY3RcbiAgKTtcbiAgY29uc3QgaW5wdXRUZW5zb3IgPSB0ZW5zb3JIV0N0b0JDSFcocmVzaXplZEltYWdlVGVuc29yKTtcbiAgbGV0IHByZWRpY3Rpb25zRGljdCA9IGF3YWl0IHJ1bk9ubnhTZXNzaW9uKFxuICAgIHNlc3Npb24uYmFzZSxcbiAgICBbW1wiaW5wdXRcIiwgaW5wdXRUZW5zb3JdXSxcbiAgICBbXCJvdXRwdXRcIl0sXG4gICAgY29uZmlnXG4gICk7XG4gIGxldCBhbHBoYW1hc2syID0gKDAsIGltcG9ydF9uZGFycmF5NC5kZWZhdWx0KShwcmVkaWN0aW9uc0RpY3RbMF0uZGF0YSwgW3Jlc29sdXRpb24sIHJlc29sdXRpb24sIDFdKTtcbiAgbGV0IGFscGhhbWFza1U4ID0gY29udmVydEZsb2F0MzJUb1VpbnQ4KGFscGhhbWFzazIpO1xuICBpZiAoY29uZmlnLnJlc2NhbGUpIHtcbiAgICBhbHBoYW1hc2tVOCA9IHRlbnNvclJlc2l6ZUJpbGluZWFyKFxuICAgICAgYWxwaGFtYXNrVTgsXG4gICAgICBzcmNXaWR0aCxcbiAgICAgIHNyY0hlaWdodCxcbiAgICAgIGtlZXBBc3BlY3RcbiAgICApO1xuICAgIHJldHVybiBbYWxwaGFtYXNrVTgsIGltYWdlVGVuc29yXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2FscGhhbWFza1U4LCByZXNpemVkSW1hZ2VUZW5zb3JdO1xuICB9XG59XG5cbi8vIHNyYy9hcGkvdjEudHNcbnZhciBpbml0ID0gKDAsIGltcG9ydF9sb2Rhc2gubWVtb2l6ZSkoaW5pdEluZmVyZW5jZSwgKGNvbmZpZykgPT4gSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XG5hc3luYyBmdW5jdGlvbiBwcmVsb2FkKGNvbmZpZ3VyYXRpb24pIHtcbiAgYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgcmV0dXJuO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlQmFja2dyb3VuZChpbWFnZSwgY29uZmlndXJhdGlvbikge1xuICBjb25zdCB7IGNvbmZpZywgc2Vzc2lvbiB9ID0gYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgaWYgKGNvbmZpZy5wcm9ncmVzcylcbiAgICBjb25maWcucHJvZ3Jlc3MoXCJjb21wdXRlOmRlY29kZVwiLCAwLCA0KTtcbiAgY29uc3QgaW5wdXRJbWFnZVRlbnNvciA9IGF3YWl0IGltYWdlU291cmNlVG9JbWFnZURhdGEoaW1hZ2UsIGNvbmZpZyk7XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTppbmZlcmVuY2VcIiwgMSwgNCk7XG4gIGNvbnN0IFthbHBoYW1hc2syLCBpbWFnZVRlbnNvcl0gPSBhd2FpdCBydW5JbmZlcmVuY2UoXG4gICAgaW5wdXRJbWFnZVRlbnNvcixcbiAgICBjb25maWcsXG4gICAgc2Vzc2lvblxuICApO1xuICBjb25maWcucHJvZ3Jlc3M/LihcImNvbXB1dGU6bWFza1wiLCAyLCA0KTtcbiAgY29uc3Qgb3V0SW1hZ2VUZW5zb3IgPSBpbWFnZVRlbnNvcjtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gb3V0SW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGNvbnN0IHN0cmlkZSA9IHdpZHRoICogaGVpZ2h0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgaSArPSAxKSB7XG4gICAgb3V0SW1hZ2VUZW5zb3IuZGF0YVs0ICogaSArIDNdID0gYWxwaGFtYXNrMi5kYXRhW2ldO1xuICB9XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTplbmNvZGVcIiwgMywgNCk7XG4gIGNvbnN0IG91dEltYWdlID0gYXdhaXQgaW1hZ2VFbmNvZGUoXG4gICAgb3V0SW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLm91dHB1dC5xdWFsaXR5LFxuICAgIGNvbmZpZy5vdXRwdXQuZm9ybWF0XG4gICk7XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTplbmNvZGVcIiwgNCwgNCk7XG4gIHJldHVybiBvdXRJbWFnZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZUZvcmVncm91bmQoaW1hZ2UsIGNvbmZpZ3VyYXRpb24pIHtcbiAgY29uc3QgeyBjb25maWcsIHNlc3Npb24gfSA9IGF3YWl0IGluaXQoY29uZmlndXJhdGlvbik7XG4gIGNvbnN0IGltYWdlVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShpbWFnZSwgY29uZmlnKTtcbiAgY29uc3QgW2FscGhhbWFzazIsIGltYWdlSW5wdXRdID0gYXdhaXQgcnVuSW5mZXJlbmNlKFxuICAgIGltYWdlVGVuc29yLFxuICAgIGNvbmZpZyxcbiAgICBzZXNzaW9uXG4gICk7XG4gIGNvbnN0IG91dEltYWdlVGVuc29yID0gaW1hZ2VJbnB1dDtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHQsIGNoYW5uZWxzXSA9IG91dEltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBzdHJpZGUgPSB3aWR0aCAqIGhlaWdodDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7IGkgKz0gMSkge1xuICAgIG91dEltYWdlVGVuc29yLmRhdGFbNCAqIGkgKyAzXSA9IDI1NSAtIGFscGhhbWFzazIuZGF0YVtpXTtcbiAgfVxuICBjb25zdCBvdXRJbWFnZSA9IGF3YWl0IGltYWdlRW5jb2RlKFxuICAgIG91dEltYWdlVGVuc29yLFxuICAgIGNvbmZpZy5vdXRwdXQucXVhbGl0eSxcbiAgICBjb25maWcub3V0cHV0LmZvcm1hdFxuICApO1xuICByZXR1cm4gb3V0SW1hZ2U7XG59XG52YXIgYWxwaGFtYXNrID0gc2VnbWVudEZvcmVncm91bmQ7XG5hc3luYyBmdW5jdGlvbiBzZWdtZW50Rm9yZWdyb3VuZChpbWFnZSwgY29uZmlndXJhdGlvbikge1xuICBjb25zdCB7IGNvbmZpZywgc2Vzc2lvbiB9ID0gYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgY29uc3QgaW1hZ2VUZW5zb3IgPSBhd2FpdCBpbWFnZVNvdXJjZVRvSW1hZ2VEYXRhKGltYWdlLCBjb25maWcpO1xuICBsZXQgW2hlaWdodCwgd2lkdGgsIGNoYW5uZWxzXSA9IGltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBbYWxwaGFtYXNrMiwgaW1hZ2VJbnB1dF0gPSBhd2FpdCBydW5JbmZlcmVuY2UoXG4gICAgaW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLFxuICAgIHNlc3Npb25cbiAgKTtcbiAgY29uc3Qgc3RyaWRlID0gd2lkdGggKiBoZWlnaHQ7XG4gIGNvbnN0IG91dEltYWdlVGVuc29yID0gaW1hZ2VUZW5zb3I7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyBpICs9IDEpIHtcbiAgICBjb25zdCBpbmRleCA9IDQgKiBpO1xuICAgIGxldCBhbHBoYSA9IGFscGhhbWFzazIuZGF0YVtpXTtcbiAgICBvdXRJbWFnZVRlbnNvci5kYXRhW2luZGV4XSA9IDI1NTtcbiAgICBvdXRJbWFnZVRlbnNvci5kYXRhW2luZGV4ICsgMV0gPSAyNTU7XG4gICAgb3V0SW1hZ2VUZW5zb3IuZGF0YVtpbmRleCArIDJdID0gMjU1O1xuICAgIG91dEltYWdlVGVuc29yLmRhdGFbaW5kZXggKyAzXSA9IGFscGhhO1xuICB9XG4gIGNvbnN0IG91dEltYWdlID0gYXdhaXQgaW1hZ2VFbmNvZGUoXG4gICAgb3V0SW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLm91dHB1dC5xdWFsaXR5LFxuICAgIGNvbmZpZy5vdXRwdXQuZm9ybWF0XG4gICk7XG4gIHJldHVybiBvdXRJbWFnZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5U2VnbWVudGF0aW9uTWFzayhpbWFnZSwgbWFzaywgY29uZmlnKSB7XG4gIGNvbmZpZyA9IHZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XG4gIGNvbnN0IGltYWdlVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShpbWFnZSwgY29uZmlnKTtcbiAgY29uc3QgW2ltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoLCBpbWFnZUNoYW5uZWxzXSA9IGltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBtYXNrVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShtYXNrLCBjb25maWcpO1xuICBjb25zdCBbbWFza0hlaWdodCwgbWFza1dpZHRoLCBtYXNrQ2hhbm5lbHNdID0gbWFza1RlbnNvci5zaGFwZTtcbiAgY29uc3QgYWxwaGFNYXNrID0gbWFza0hlaWdodCAhPT0gaW1hZ2VIZWlnaHQgfHwgbWFza1dpZHRoICE9PSBpbWFnZVdpZHRoID8gdGVuc29yUmVzaXplQmlsaW5lYXIobWFza1RlbnNvciwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpIDogbWFza1RlbnNvcjtcbiAgY29uc3Qgc3RyaWRlID0gaW1hZ2VXaWR0aCAqIGltYWdlSGVpZ2h0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgaSArPSAxKSB7XG4gICAgY29uc3QgaWR4SW1hZ2UgPSBpbWFnZUNoYW5uZWxzICogaTtcbiAgICBjb25zdCBpZHhNYXNrID0gbWFza0NoYW5uZWxzICogaTtcbiAgICBpbWFnZVRlbnNvci5kYXRhW2lkeEltYWdlICsgM10gPSBhbHBoYU1hc2suZGF0YVtpZHhNYXNrICsgM107XG4gIH1cbiAgY29uc3Qgb3V0SW1hZ2UgPSBhd2FpdCBpbWFnZUVuY29kZShcbiAgICBpbWFnZVRlbnNvcixcbiAgICBjb25maWcub3V0cHV0LnF1YWxpdHksXG4gICAgY29uZmlnLm91dHB1dC5mb3JtYXRcbiAgKTtcbiAgcmV0dXJuIG91dEltYWdlO1xufVxuZXhwb3J0IHtcbiAgYWxwaGFtYXNrLFxuICBhcHBseVNlZ21lbnRhdGlvbk1hc2ssXG4gIHByZWxvYWQsXG4gIHJlbW92ZUJhY2tncm91bmQsXG4gIHJlbW92ZUZvcmVncm91bmQsXG4gIHNlZ21lbnRGb3JlZ3JvdW5kXG59O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxubG9kYXNoL2xvZGFzaC5qczpcbiAgKCoqXG4gICAqIEBsaWNlbnNlXG4gICAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAgICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICAgKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gICAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gICAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICAgKilcblxuaXMtYnVmZmVyL2luZGV4LmpzOlxuICAoKiFcbiAgICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICAgKlxuICAgKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICAgKiBAbGljZW5zZSAgTUlUXG4gICAqKVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@imgly/background-removal/dist/index.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".main.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "webpacktemplate:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkwebpacktemplate"] = self["webpackChunkwebpacktemplate"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;