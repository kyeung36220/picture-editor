"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwebpacktemplate"] = self["webpackChunkwebpacktemplate"] || []).push([["vendors-node_modules_onnxruntime-web_dist_ort_webgpu_bundle_min_mjs"],{

/***/ "./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "21c580b4d212f4539f52.wasm";

/***/ }),

/***/ "./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?3e05":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "cb0349dc8ace28f7867d.mjs";

/***/ }),

/***/ "./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?79d7":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ Fp),\n/* harmony export */   TRACE: () => (/* binding */ wr),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* binding */ Ue),\n/* harmony export */   TRACE_FUNC_END: () => (/* binding */ De),\n/* harmony export */   Tensor: () => (/* binding */ He),\n/* harmony export */   \"default\": () => (/* binding */ $1),\n/* harmony export */   env: () => (/* binding */ ve),\n/* harmony export */   registerBackend: () => (/* binding */ St)\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0-dev.20250114-228dd16893\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Un=Object.defineProperty;var Vp=Object.getOwnPropertyDescriptor;var Wp=Object.getOwnPropertyNames;var Lp=Object.prototype.hasOwnProperty;var Nn=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,r)=>(typeof require<\"u\"?require:t)[r]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var U=(e,t)=>()=>(e&&(t=e(e=0)),t);var Ft=(e,t)=>{for(var r in t)Un(e,r,{get:t[r],enumerable:!0})},Gp=(e,t,r,n)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of Wp(t))!Lp.call(e,o)&&o!==r&&Un(e,o,{get:()=>t[o],enumerable:!(n=Vp(t,o))||n.enumerable});return e};var br=e=>Gp(Un({},\"__esModule\",{value:!0}),e);var yr,xt,St,Hp,Ji,Vn=U(()=>{\"use strict\";yr=new Map,xt=[],St=(e,t,r)=>{if(t&&typeof t.init==\"function\"&&typeof t.createInferenceSessionHandler==\"function\"){let n=yr.get(e);if(n===void 0)yr.set(e,{backend:t,priority:r});else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${r}`)}if(r>=0){let o=xt.indexOf(e);o!==-1&&xt.splice(o,1);for(let i=0;i<xt.length;i++)if(yr.get(xt[i]).priority<=r){xt.splice(i,0,e);return}xt.push(e)}return}throw new TypeError(\"not a valid backend\")},Hp=async e=>{let t=yr.get(e);if(!t)return\"backend not found.\";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(n){return r||(t.error=`${n}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Ji=async e=>{let t=e.executionProviders||[],r=t.map(l=>typeof l==\"string\"?l:l.name),n=r.length===0?xt:r,o,i=[],a=new Set;for(let l of n){let p=await Hp(l);typeof p==\"string\"?i.push({name:l,err:p}):(o||(o=p),o===p&&a.add(l))}if(!o)throw new Error(`no available backend found. ERR: ${i.map(l=>`[${l.name}] ${l.err}`).join(\", \")}`);for(let{name:l,err:p}of i)r.includes(l)&&console.warn(`removing requested execution provider \"${l}\" from session options because it is not available: ${p}`);let d=t.filter(l=>a.has(typeof l==\"string\"?l:l.name));return[o,new Proxy(e,{get:(l,p)=>p===\"executionProviders\"?d:Reflect.get(l,p)})]}});var ea=U(()=>{\"use strict\";Vn()});var ta,ra=U(()=>{\"use strict\";ta=\"1.21.0-dev.20241212-1f88284f96\"});var na,Re,Wn=U(()=>{\"use strict\";ra();na=\"warning\",Re={wasm:{},webgl:{},webgpu:{},versions:{common:ta},set logLevel(e){if(e!==void 0){if(typeof e!=\"string\"||[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);na=e}},get logLevel(){return na}};Object.defineProperty(Re,\"logLevel\",{enumerable:!0})});var ve,oa=U(()=>{\"use strict\";Wn();ve=Re});var ia,aa,sa=U(()=>{\"use strict\";ia=(e,t)=>{let r=typeof document<\"u\"?document.createElement(\"canvas\"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext(\"2d\");if(n!=null){let o,i;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],i=e.dims[3]):(o=e.dims[3],i=e.dims[2]);let a=t?.format!==void 0?t.format:\"RGB\",d=t?.norm,l,p;d===void 0||d.mean===void 0?l=[255,255,255,255]:typeof d.mean==\"number\"?l=[d.mean,d.mean,d.mean,d.mean]:(l=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(l[3]=d.mean[3])),d===void 0||d.bias===void 0?p=[0,0,0,0]:typeof d.bias==\"number\"?p=[d.bias,d.bias,d.bias,d.bias]:(p=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(p[3]=d.bias[3]));let m=i*o,u=0,h=m,_=m*2,y=-1;a===\"RGBA\"?(u=0,h=m,_=m*2,y=m*3):a===\"RGB\"?(u=0,h=m,_=m*2):a===\"RBG\"&&(u=0,_=m,h=m*2);for(let g=0;g<i;g++)for(let x=0;x<o;x++){let $=(e.data[u++]-p[0])*l[0],v=(e.data[h++]-p[1])*l[1],S=(e.data[_++]-p[2])*l[2],T=y===-1?255:(e.data[y++]-p[3])*l[3];n.fillStyle=\"rgba(\"+$+\",\"+v+\",\"+S+\",\"+T+\")\",n.fillRect(x,g,1,1)}if(\"toDataURL\"in r)return r.toDataURL();throw new Error(\"toDataURL is not supported\")}else throw new Error(\"Can not access image data\")},aa=(e,t)=>{let r=typeof document<\"u\"?document.createElement(\"canvas\").getContext(\"2d\"):new OffscreenCanvas(1,1).getContext(\"2d\"),n;if(r!=null){let o,i,a;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],i=e.dims[1],a=e.dims[3]):(o=e.dims[3],i=e.dims[2],a=e.dims[1]);let d=t!==void 0&&t.format!==void 0?t.format:\"RGB\",l=t?.norm,p,m;l===void 0||l.mean===void 0?p=[255,255,255,255]:typeof l.mean==\"number\"?p=[l.mean,l.mean,l.mean,l.mean]:(p=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(p[3]=l.mean[3])),l===void 0||l.bias===void 0?m=[0,0,0,0]:typeof l.bias==\"number\"?m=[l.bias,l.bias,l.bias,l.bias]:(m=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(m[3]=l.bias[3]));let u=i*o;if(t!==void 0&&(t.format!==void 0&&a===4&&t.format!==\"RGBA\"||a===3&&t.format!==\"RGB\"&&t.format!==\"BGR\"))throw new Error(\"Tensor format doesn't match input tensor dims\");let h=4,_=0,y=1,g=2,x=3,$=0,v=u,S=u*2,T=-1;d===\"RGBA\"?($=0,v=u,S=u*2,T=u*3):d===\"RGB\"?($=0,v=u,S=u*2):d===\"RBG\"&&($=0,S=u,v=u*2),n=r.createImageData(o,i);for(let A=0;A<i*o;_+=h,y+=h,g+=h,x+=h,A++)n.data[_]=(e.data[$++]-m[0])*p[0],n.data[y]=(e.data[v++]-m[1])*p[1],n.data[g]=(e.data[S++]-m[2])*p[2],n.data[x]=T===-1?255:(e.data[T++]-m[3])*p[3]}else throw new Error(\"Can not access image data\");return n}});var Ln,ua,da,la,ca,pa,ma=U(()=>{\"use strict\";_r();Ln=(e,t)=>{if(e===void 0)throw new Error(\"Image buffer must be defined\");if(t.height===void 0||t.width===void 0)throw new Error(\"Image height and width must be defined\");if(t.tensorLayout===\"NHWC\")throw new Error(\"NHWC Tensor layout is not supported yet\");let{height:r,width:n}=t,o=t.norm??{mean:255,bias:0},i,a;typeof o.mean==\"number\"?i=[o.mean,o.mean,o.mean,o.mean]:i=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias==\"number\"?a=[o.bias,o.bias,o.bias,o.bias]:a=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let d=t.format!==void 0?t.format:\"RGBA\",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:\"RGB\",p=r*n,m=l===\"RGBA\"?new Float32Array(p*4):new Float32Array(p*3),u=4,h=0,_=1,y=2,g=3,x=0,$=p,v=p*2,S=-1;d===\"RGB\"&&(u=3,h=0,_=1,y=2,g=-1),l===\"RGBA\"?S=p*3:l===\"RBG\"?(x=0,v=p,$=p*2):l===\"BGR\"&&(v=0,$=p,x=p*2);for(let A=0;A<p;A++,h+=u,y+=u,_+=u,g+=u)m[x++]=(e[h]+a[0])/i[0],m[$++]=(e[_]+a[1])/i[1],m[v++]=(e[y]+a[2])/i[2],S!==-1&&g!==-1&&(m[S++]=(e[g]+a[3])/i[3]);return l===\"RGBA\"?new ze(\"float32\",m,[1,4,r,n]):new ze(\"float32\",m,[1,3,r,n])},ua=async(e,t)=>{let r=typeof HTMLImageElement<\"u\"&&e instanceof HTMLImageElement,n=typeof ImageData<\"u\"&&e instanceof ImageData,o=typeof ImageBitmap<\"u\"&&e instanceof ImageBitmap,i=typeof e==\"string\",a,d=t??{},l=()=>{if(typeof document<\"u\")return document.createElement(\"canvas\");if(typeof OffscreenCanvas<\"u\")return new OffscreenCanvas(1,1);throw new Error(\"Canvas is not supported\")},p=m=>typeof HTMLCanvasElement<\"u\"&&m instanceof HTMLCanvasElement||m instanceof OffscreenCanvas?m.getContext(\"2d\"):null;if(r){let m=l();m.width=e.width,m.height=e.height;let u=p(m);if(u!=null){let h=e.height,_=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(h=t.resizedHeight,_=t.resizedWidth),t!==void 0){if(d=t,t.tensorFormat!==void 0)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");d.tensorFormat=\"RGBA\",d.height=h,d.width=_}else d.tensorFormat=\"RGBA\",d.height=h,d.width=_;u.drawImage(e,0,0),a=u.getImageData(0,0,_,h).data}else throw new Error(\"Can not access image data\")}else if(n){let m,u;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(m=t.resizedHeight,u=t.resizedWidth):(m=e.height,u=e.width),t!==void 0&&(d=t),d.format=\"RGBA\",d.height=m,d.width=u,t!==void 0){let h=l();h.width=u,h.height=m;let _=p(h);if(_!=null)_.putImageData(e,0,0),a=_.getImageData(0,0,u,m).data;else throw new Error(\"Can not access image data\")}else a=e.data}else if(o){if(t===void 0)throw new Error(\"Please provide image config with format for Imagebitmap\");let m=l();m.width=e.width,m.height=e.height;let u=p(m);if(u!=null){let h=e.height,_=e.width;return u.drawImage(e,0,0,_,h),a=u.getImageData(0,0,_,h).data,d.height=h,d.width=_,Ln(a,d)}else throw new Error(\"Can not access image data\")}else{if(i)return new Promise((m,u)=>{let h=l(),_=p(h);if(!e||!_)return u();let y=new Image;y.crossOrigin=\"Anonymous\",y.src=e,y.onload=()=>{h.width=y.width,h.height=y.height,_.drawImage(y,0,0,h.width,h.height);let g=_.getImageData(0,0,h.width,h.height);d.height=h.height,d.width=h.width,m(Ln(g.data,d))}});throw new Error(\"Input data provided is not supported - aborted tensor creation\")}if(a!==void 0)return Ln(a,d);throw new Error(\"Input data provided is not supported - aborted tensor creation\")},da=(e,t)=>{let{width:r,height:n,download:o,dispose:i}=t,a=[1,n,r,4];return new ze({location:\"texture\",type:\"float32\",texture:e,dims:a,download:o,dispose:i})},la=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:i}=t;return new ze({location:\"gpu-buffer\",type:r??\"float32\",gpuBuffer:e,dims:n,download:o,dispose:i})},ca=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:i}=t;return new ze({location:\"ml-tensor\",type:r??\"float32\",mlTensor:e,dims:n,download:o,dispose:i})},pa=(e,t,r)=>new ze({location:\"cpu-pinned\",type:e,data:t,dims:r??[t.length]})});var Tt,qt,fa,ha,ga=U(()=>{\"use strict\";Tt=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array],[\"int4\",Uint8Array],[\"uint4\",Uint8Array]]),qt=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]),fa=!1,ha=()=>{if(!fa){fa=!0;let e=typeof BigInt64Array<\"u\"&&BigInt64Array.from,t=typeof BigUint64Array<\"u\"&&BigUint64Array.from,r=typeof Float16Array<\"u\"&&Float16Array.from;e&&(Tt.set(\"int64\",BigInt64Array),qt.set(BigInt64Array,\"int64\")),t&&(Tt.set(\"uint64\",BigUint64Array),qt.set(BigUint64Array,\"uint64\")),r?(Tt.set(\"float16\",Float16Array),qt.set(Float16Array,\"float16\")):Tt.set(\"float16\",Uint16Array)}}});var ba,ya,_a=U(()=>{\"use strict\";_r();ba=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if(typeof n!=\"number\"||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},ya=(e,t)=>{switch(e.location){case\"cpu\":return new ze(e.type,e.data,t);case\"cpu-pinned\":return new ze({location:\"cpu-pinned\",data:e.data,type:e.type,dims:t});case\"texture\":return new ze({location:\"texture\",texture:e.texture,type:e.type,dims:t});case\"gpu-buffer\":return new ze({location:\"gpu-buffer\",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case\"ml-tensor\":return new ze({location:\"ml-tensor\",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var ze,_r=U(()=>{\"use strict\";sa();ma();ga();_a();ze=class{constructor(t,r,n){ha();let o,i;if(typeof t==\"object\"&&\"location\"in t)switch(this.dataLocation=t.location,o=t.type,i=t.dims,t.location){case\"cpu-pinned\":{let d=Tt.get(o);if(!d)throw new TypeError(`unsupported type \"${o}\" to create tensor from pinned buffer`);if(!(t.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=t.data;break}case\"texture\":{if(o!==\"float32\")throw new TypeError(`unsupported type \"${o}\" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case\"gpu-buffer\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case\"ml-tensor\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint64\"&&o!==\"int8\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,l;if(typeof t==\"string\")if(o=t,l=n,t===\"string\"){if(!Array.isArray(r))throw new TypeError(\"A string tensor's data must be a string array.\");d=r}else{let p=Tt.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t===\"float16\"&&p===Uint16Array||t===\"uint4\"||t===\"int4\")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${p.name} as data.`);t===\"uint64\"||t===\"int64\"?d=p.from(r,BigInt):d=p.from(r)}else if(r instanceof p)d=r;else if(r instanceof Uint8ClampedArray)if(t===\"uint8\")d=Uint8Array.from(r);else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");else throw new TypeError(`A ${o} tensor's data must be type of ${p}`)}else if(l=r,Array.isArray(t)){if(t.length===0)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");let p=typeof t[0];if(p===\"string\")o=\"string\",d=t;else if(p===\"boolean\")o=\"bool\",d=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else if(t instanceof Uint8ClampedArray)o=\"uint8\",d=Uint8Array.from(t);else{let p=qt.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=p,d=t}if(l===void 0)l=[d.length];else if(!Array.isArray(l))throw new TypeError(\"A tensor's dims must be a number array\");i=l,this.cpuData=d,this.dataLocation=\"cpu\"}let a=ba(i);if(this.cpuData&&a!==this.cpuData.length&&!((o===\"uint4\"||o===\"int4\")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=i,this.size=a}static async fromImage(t,r){return ua(t,r)}static fromTexture(t,r){return da(t,r)}static fromGpuBuffer(t,r){return la(t,r)}static fromMLTensor(t,r){return ca(t,r)}static fromPinnedBuffer(t,r,n){return pa(t,r,n)}toDataURL(t){return ia(this,t)}toImageData(t){return aa(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error(\"The data is not stored as a WebGL texture.\");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error(\"The data is not stored as a WebGPU buffer.\");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error(\"The data is not stored as a WebNN MLTensor.\");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case\"cpu\":case\"cpu-pinned\":return this.data;case\"texture\":case\"gpu-buffer\":case\"ml-tensor\":{if(!this.downloader)throw new Error(\"The current tensor is not created with a specified data downloader.\");if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation=\"cpu\",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation=\"none\"}ensureValid(){if(this.dataLocation===\"none\")throw new Error(\"The tensor is disposed.\")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");return ya(this,t)}}});var He,Gn=U(()=>{\"use strict\";_r();He=ze});var wr,wa,Ue,De,Hn=U(()=>{\"use strict\";Wn();wr=(e,t)=>{(typeof Re.trace>\"u\"?!Re.wasm.trace:!Re.trace)||console.timeStamp(`${e}::ORT::${t}`)},wa=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],n=!1;for(let o=0;o<r.length;o++){if(n&&!r[o].includes(\"TRACE_FUNC\")){let i=`FUNC_${e}::${r[o].trim().split(\" \")[1]}`;t&&(i+=`::${t}`),wr(\"CPU\",i);return}r[o].includes(\"TRACE_FUNC\")&&(n=!0)}},Ue=e=>{(typeof Re.trace>\"u\"?!Re.wasm.trace:!Re.trace)||wa(\"BEGIN\",e)},De=e=>{(typeof Re.trace>\"u\"?!Re.wasm.trace:!Re.trace)||wa(\"END\",e)}});var vr,va=U(()=>{\"use strict\";Vn();Gn();Hn();vr=class e{constructor(t){this.handler=t}async run(t,r,n){Ue();let o={},i={};if(typeof t!=\"object\"||t===null||t instanceof He||Array.isArray(t))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let a=!0;if(typeof r==\"object\"){if(r===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(r instanceof He)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(r)){if(r.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");a=!1;for(let p of r){if(typeof p!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);o[p]=null}if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let p=!1,m=Object.getOwnPropertyNames(r);for(let u of this.outputNames)if(m.indexOf(u)!==-1){let h=r[u];(h===null||h instanceof He)&&(p=!0,a=!1,o[u]=h)}if(p){if(typeof n==\"object\"&&n!==null)i=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else i=r}}else if(typeof r<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let p of this.inputNames)if(typeof t[p]>\"u\")throw new Error(`input '${p}' is missing in 'feeds'.`);if(a)for(let p of this.outputNames)o[p]=null;let d=await this.handler.run(t,o,i),l={};for(let p in d)if(Object.hasOwnProperty.call(d,p)){let m=d[p];m instanceof He?l[p]=m:l[p]=new He(m.type,m.data,m.dims)}return De(),l}async release(){return this.handler.dispose()}static async create(t,r,n,o){Ue();let i,a={};if(typeof t==\"string\"){if(i=t,typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof Uint8Array){if(i=t,typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&t instanceof SharedArrayBuffer){let m=t,u=0,h=t.byteLength;if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r==\"number\"){if(u=r,!Number.isSafeInteger(u))throw new RangeError(\"'byteOffset' must be an integer.\");if(u<0||u>=m.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${m.byteLength}).`);if(h=t.byteLength-u,typeof n==\"number\"){if(h=n,!Number.isSafeInteger(h))throw new RangeError(\"'byteLength' must be an integer.\");if(h<=0||u+h>m.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${m.byteLength-u}].`);if(typeof o==\"object\"&&o!==null)a=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(typeof n<\"u\")throw new TypeError(\"'byteLength' must be a number.\")}else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\");i=new Uint8Array(m,u,h)}else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");let[d,l]=await Ji(a),p=await d.createInferenceSessionHandler(i,l);return De(),new e(p)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Fp,$a=U(()=>{\"use strict\";va();Fp=vr});var xa=U(()=>{\"use strict\"});var Sa=U(()=>{\"use strict\"});var Ta=U(()=>{\"use strict\"});var Ia=U(()=>{\"use strict\"});var Fn={};Ft(Fn,{InferenceSession:()=>Fp,TRACE:()=>wr,TRACE_FUNC_BEGIN:()=>Ue,TRACE_FUNC_END:()=>De,Tensor:()=>He,env:()=>ve,registerBackend:()=>St});var We=U(()=>{\"use strict\";ea();oa();$a();Gn();xa();Sa();Hn();Ta();Ia()});var $r=U(()=>{\"use strict\"});var Ea={};Ft(Ea,{default:()=>qp});var Aa,ka,qp,Pa=U(()=>{\"use strict\";qn();gt();xr();Aa=\"ort-wasm-proxy-worker\",ka=globalThis.self?.name===Aa;ka&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case\"init-wasm\":Sr(r.wasm).then(()=>{Tr(r).then(()=>{postMessage({type:t})},n=>{postMessage({type:t,err:n})})},n=>{postMessage({type:t,err:n})});break;case\"init-ep\":{let{epName:n,env:o}=r;Ir(o,n).then(()=>{postMessage({type:t})},i=>{postMessage({type:t,err:i})});break}case\"copy-from\":{let{buffer:n}=r,o=Kt(n);postMessage({type:t,out:o});break}case\"create\":{let{model:n,options:o}=r;Cr(n,o).then(i=>{postMessage({type:t,out:i})},i=>{postMessage({type:t,err:i})});break}case\"release\":Ar(r),postMessage({type:t});break;case\"run\":{let{sessionId:n,inputIndices:o,inputs:i,outputIndices:a,options:d}=r;kr(n,o,i,a,new Array(a.length).fill(null),d).then(l=>{l.some(p=>p[3]!==\"cpu\")?postMessage({type:t,err:\"Proxy does not support non-cpu tensor location.\"}):postMessage({type:t,out:l},Pr([...i,...l]))},l=>{postMessage({type:t,err:l})});break}case\"end-profiling\":Er(r),postMessage({type:t});break;default:}}catch(n){postMessage({type:t,err:n})}});qp=ka?null:e=>new Worker(e??Ne,{type:\"module\",name:Aa})});var Oa={};Ft(Oa,{default:()=>Kp});var Kn,za,Kp,Da=U(()=>{\"use strict\";za=(Kn=\"file:///home/kyeung/repos/personal/picture-editor/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\",async function(e={}){function t(){return se.buffer!=J.buffer&&ye(),J}function r(){return se.buffer!=J.buffer&&ye(),ne}function n(){return se.buffer!=J.buffer&&ye(),be}function o(){return se.buffer!=J.buffer&&ye(),Oe}function i(){return se.buffer!=J.buffer&&ye(),$e}function a(){return se.buffer!=J.buffer&&ye(),le}function d(){return se.buffer!=J.buffer&&ye(),W}function l(){return se.buffer!=J.buffer&&ye(),Ge}var p,m,u=Object.assign({},e),h=new Promise((s,c)=>{p=s,m=c}),_=typeof window==\"object\",y=typeof importScripts==\"function\",g=y&&self.name==\"em-pthread\";u.mountExternalData=(s,c)=>{s.startsWith(\"./\")&&(s=s.substring(2)),(u.Fb||(u.Fb=new Map)).set(s,c)},u.unmountExternalData=()=>{delete u.Fb};var x=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let $=()=>{let s=(f,b,w)=>(...I)=>{let O=Xe,B=b?.();I=f(...I);let L=b?.();return B!==L&&(f=L,w(B),b=w=null),Xe!=O?new Promise((H,X)=>{En={resolve:H,reject:X}}):I},c=f=>async(...b)=>{try{if(u.Gb)throw Error(\"Session already started\");let w=u.Gb={hc:b[0],errors:[]},I=await f(...b);if(u.Gb!==w)throw Error(\"Session mismatch\");u.Hb?.flush();let O=w.errors;if(0<O.length){let B=await Promise.all(O);if(B=B.filter(L=>L),0<B.length)throw Error(B.join(`\n`))}return I}finally{u.Gb=null}};u._OrtCreateSession=s(u._OrtCreateSession,()=>u._OrtCreateSession,f=>u._OrtCreateSession=f),u._OrtRun=c(s(u._OrtRun,()=>u._OrtRun,f=>u._OrtRun=f)),u._OrtRunWithBinding=c(s(u._OrtRunWithBinding,()=>u._OrtRunWithBinding,f=>u._OrtRunWithBinding=f)),u._OrtBindInput=s(u._OrtBindInput,()=>u._OrtBindInput,f=>u._OrtBindInput=f),$=void 0};u.jsepInit=(s,c)=>{if($?.(),s===\"webgpu\"){[u.Hb,u.Vb,u.Zb,u.Ob,u.Yb,u.kb,u.$b,u.cc,u.Wb,u.Xb,u.ac]=c;let f=u.Hb;u.jsepRegisterBuffer=(b,w,I,O)=>f.registerBuffer(b,w,I,O),u.jsepGetBuffer=b=>f.getBuffer(b),u.jsepCreateDownloader=(b,w,I)=>f.createDownloader(b,w,I),u.jsepOnCreateSession=b=>{f.onCreateSession(b)},u.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},u.jsepOnRunStart=b=>f.onRunStart(b),u.dc=(b,w)=>{f.upload(b,w)}}else if(s===\"webnn\"){[u.Hb,u.bc,u.Pb,u.jsepEnsureTensor,u.ec,u.jsepDownloadTensor]=c,u.jsepReleaseTensorId=u.Pb;let f=u.Hb;u.jsepOnRunStart=b=>f.onRunStart(b),u.jsepRegisterMLContext=(b,w)=>{f.registerMLContext(b,w)},u.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},u.jsepCreateMLTensorDownloader=(b,w)=>f.createMLTensorDownloader(b,w),u.jsepRegisterMLTensor=(b,w,I)=>f.registerMLTensor(b,w,I),u.jsepCreateMLContext=b=>f.createMLContext(b),u.jsepRegisterMLConstant=(b,w,I,O,B)=>f.registerMLConstant(b,w,I,O,B,u.Fb)}};var v,S,T=Object.assign({},u),A=\"./this.program\",k=(s,c)=>{throw c},P=\"\";(_||y)&&(y?P=self.location.href:typeof document<\"u\"&&document.currentScript&&(P=document.currentScript.src),Kn&&(P=Kn),P=P.startsWith(\"blob:\")?\"\":P.substr(0,P.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1),y&&(S=s=>{var c=new XMLHttpRequest;return c.open(\"GET\",s,!1),c.responseType=\"arraybuffer\",c.send(null),new Uint8Array(c.response)}),v=(s,c,f)=>{var b=new XMLHttpRequest;b.open(\"GET\",s,!0),b.responseType=\"arraybuffer\",b.onload=()=>{b.status==200||b.status==0&&b.response?c(b.response):f()},b.onerror=f,b.send(null)});var D,R=console.log.bind(console),G=console.error.bind(console),K=R,j=G;if(Object.assign(u,T),T=null,g){let s=function(c){try{var f=c.data,b=f.cmd;if(b===\"load\"){let w=[];self.onmessage=I=>w.push(I),self.startWorker=()=>{postMessage({cmd:\"loaded\"});for(let I of w)s(I);self.onmessage=s};for(let I of f.handlers)u[I]&&!u[I].proxy||(u[I]=(...O)=>{postMessage({Nb:\"callHandler\",pc:I,args:O})},I==\"print\"&&(K=u[I]),I==\"printErr\"&&(j=u[I]));se=f.wasmMemory,ye(),V(f.wasmModule)}else if(b===\"run\"){Dn(f.pthread_ptr,0,0,1,0,0),An(f.pthread_ptr),xc(),Ho(),Q||(Wi(),Q=!0);try{Sc(f.start_routine,f.arg)}catch(w){if(w!=\"unwind\")throw w}}else b===\"cancel\"?Mt()&&hr(-1):f.target!==\"setimmediate\"&&(b===\"checkMailbox\"?Q&&ir():b&&(j(`worker: received unknown command ${b}`),j(f)))}catch(w){throw Li(),w}};var wg=s,V,Q=!1;j=function(...c){c=c.join(\" \"),console.error(c)},self.alert=function(...c){postMessage({Nb:\"alert\",text:c.join(\" \"),rc:Mt()})},u.instantiateWasm=(c,f)=>new Promise(b=>{V=w=>{w=new WebAssembly.Instance(w,No()),f(w),b()}}),self.onunhandledrejection=c=>{throw c.reason||c},self.onmessage=s}u.wasmBinary&&(D=u.wasmBinary);var se,Y,ee,J,ne,be,Oe,$e,le,W,q,he,Ge,we=!1;function ye(){var s=se.buffer;u.HEAP8=J=new Int8Array(s),u.HEAP16=be=new Int16Array(s),u.HEAPU8=ne=new Uint8Array(s),u.HEAPU16=Oe=new Uint16Array(s),u.HEAP32=$e=new Int32Array(s),u.HEAPU32=le=new Uint32Array(s),u.HEAPF32=W=new Float32Array(s),u.HEAPF64=Ge=new Float64Array(s),u.HEAP64=q=new BigInt64Array(s),u.HEAPU64=he=new BigUint64Array(s)}if(!g){if(!((se=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof x))throw j(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),Error(\"bad memory\");ye()}var Ye=[],Lt=[],fn=[],Gt=0,hn=null,Ht=null;function Do(){if(--Gt==0&&(hn!==null&&(clearInterval(hn),hn=null),Ht)){var s=Ht;Ht=null,s()}}function ct(s){throw j(s=\"Aborted(\"+s+\")\"),we=!0,ee=1,s=new WebAssembly.RuntimeError(s+\". Build with -sASSERTIONS for more info.\"),m(s),s}var gn,Bo=s=>s.startsWith(\"data:application/octet-stream;base64,\"),Mo=s=>s.startsWith(\"file://\");function Ro(s){if(s==gn&&D)return new Uint8Array(D);if(S)return S(s);throw\"both async and sync fetching of the wasm failed\"}function Uo(s,c,f){return function(b){if(!D&&(_||y)){if(typeof fetch==\"function\"&&!Mo(b))return fetch(b,{credentials:\"same-origin\"}).then(w=>{if(!w.ok)throw`failed to load wasm binary file at '${b}'`;return w.arrayBuffer()}).catch(()=>Ro(b));if(v)return new Promise((w,I)=>{v(b,O=>w(new Uint8Array(O)),I)})}return Promise.resolve().then(()=>Ro(b))}(s).then(b=>WebAssembly.instantiate(b,c)).then(f,b=>{j(`failed to asynchronously prepare wasm: ${b}`),ct(b)})}function No(){return{a:{O:$c,Aa:vc,b:Ic,aa:jo,B:Qo,qa:Xo,Y:ei,_:ti,ra:ri,oa:ni,ha:oi,na:ii,L:ai,Z:si,W:ui,pa:di,X:li,va:Cc,F:kc,Q:Ec,P:zc,E:Dc,u:Bc,q:Mc,G:Rc,A:Hc,R:Fc,ua:qc,ka:Kc,U:jc,ba:Yc,H:Zc,ja:An,ta:Qc,t:Xc,Ba:Jc,x:rp,n:np,l:ip,c:In,o:ap,j:dp,w:lp,p:cp,f:pp,s:mp,m:fp,e:hp,k:gp,i:bp,h:yp,d:_p,ea:wp,fa:vp,ga:$p,ca:Si,da:Ti,T:xp,g:Sp,D:Tp,I:Ip,M:Cp,y:Ap,sa:kp,V:Ep,v:Ci,z:Pp,N:zp,S:Op,za:Dp,ya:Bp,la:Ei,ma:Pi,$:vn,C:zi,K:Oi,ia:Di,J:Bi,a:se,xa:wn,wa:Ui,r:Up}}}var bn={913700:(s,c,f,b,w)=>{if(u===void 0||!u.Fb)return 1;if((s=Ce(Number(s>>>0))).startsWith(\"./\")&&(s=s.substring(2)),!(s=u.Fb.get(s)))return 2;if(c=Number(c>>>0),f=Number(f>>>0),b=Number(b>>>0),c+f>s.byteLength)return 3;try{let I=s.subarray(c,c+f);switch(w){case 0:r().set(I,b>>>0);break;case 1:u.dc(b,I);break;default:return 4}return 0}catch{return 4}},914415:(s,c,f)=>{u.ec(s,r().subarray(c>>>0,c+f>>>0))},914478:()=>u.bc(),914519:s=>{u.Pb(s)},914555:()=>{u.Wb()},914586:()=>{u.Xb()},914615:()=>{u.ac()},914640:s=>u.Vb(s),914673:s=>u.Zb(s),914705:(s,c,f)=>{u.Ob(Number(s),Number(c),Number(f),!0)},914768:(s,c,f)=>{u.Ob(Number(s),Number(c),Number(f))},914825:()=>typeof wasmOffsetConverter<\"u\",914882:s=>{u.kb(\"Abs\",s,void 0)},914933:s=>{u.kb(\"Neg\",s,void 0)},914984:s=>{u.kb(\"Floor\",s,void 0)},915037:s=>{u.kb(\"Ceil\",s,void 0)},915089:s=>{u.kb(\"Reciprocal\",s,void 0)},915147:s=>{u.kb(\"Sqrt\",s,void 0)},915199:s=>{u.kb(\"Exp\",s,void 0)},915250:s=>{u.kb(\"Erf\",s,void 0)},915301:s=>{u.kb(\"Sigmoid\",s,void 0)},915356:(s,c,f)=>{u.kb(\"HardSigmoid\",s,{alpha:c,beta:f})},915435:s=>{u.kb(\"Log\",s,void 0)},915486:s=>{u.kb(\"Sin\",s,void 0)},915537:s=>{u.kb(\"Cos\",s,void 0)},915588:s=>{u.kb(\"Tan\",s,void 0)},915639:s=>{u.kb(\"Asin\",s,void 0)},915691:s=>{u.kb(\"Acos\",s,void 0)},915743:s=>{u.kb(\"Atan\",s,void 0)},915795:s=>{u.kb(\"Sinh\",s,void 0)},915847:s=>{u.kb(\"Cosh\",s,void 0)},915899:s=>{u.kb(\"Asinh\",s,void 0)},915952:s=>{u.kb(\"Acosh\",s,void 0)},916005:s=>{u.kb(\"Atanh\",s,void 0)},916058:s=>{u.kb(\"Tanh\",s,void 0)},916110:s=>{u.kb(\"Not\",s,void 0)},916161:(s,c,f)=>{u.kb(\"Clip\",s,{min:c,max:f})},916230:s=>{u.kb(\"Clip\",s,void 0)},916282:(s,c)=>{u.kb(\"Elu\",s,{alpha:c})},916340:s=>{u.kb(\"Gelu\",s,void 0)},916392:s=>{u.kb(\"Relu\",s,void 0)},916444:(s,c)=>{u.kb(\"LeakyRelu\",s,{alpha:c})},916508:(s,c)=>{u.kb(\"ThresholdedRelu\",s,{alpha:c})},916578:(s,c)=>{u.kb(\"Cast\",s,{to:c})},916636:s=>{u.kb(\"Add\",s,void 0)},916687:s=>{u.kb(\"Sub\",s,void 0)},916738:s=>{u.kb(\"Mul\",s,void 0)},916789:s=>{u.kb(\"Div\",s,void 0)},916840:s=>{u.kb(\"Pow\",s,void 0)},916891:s=>{u.kb(\"Equal\",s,void 0)},916944:s=>{u.kb(\"Greater\",s,void 0)},916999:s=>{u.kb(\"GreaterOrEqual\",s,void 0)},917061:s=>{u.kb(\"Less\",s,void 0)},917113:s=>{u.kb(\"LessOrEqual\",s,void 0)},917172:(s,c,f,b,w)=>{u.kb(\"ReduceMean\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},917347:(s,c,f,b,w)=>{u.kb(\"ReduceMax\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},917521:(s,c,f,b,w)=>{u.kb(\"ReduceMin\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},917695:(s,c,f,b,w)=>{u.kb(\"ReduceProd\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},917870:(s,c,f,b,w)=>{u.kb(\"ReduceSum\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},918044:(s,c,f,b,w)=>{u.kb(\"ReduceL1\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},918217:(s,c,f,b,w)=>{u.kb(\"ReduceL2\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},918390:(s,c,f,b,w)=>{u.kb(\"ReduceLogSum\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},918567:(s,c,f,b,w)=>{u.kb(\"ReduceSumSquare\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},918747:(s,c,f,b,w)=>{u.kb(\"ReduceLogSumExp\",s,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},918927:s=>{u.kb(\"Where\",s,void 0)},918980:(s,c,f)=>{u.kb(\"Transpose\",s,{perm:c?Array.from(i().subarray(Number(c)>>>0,Number(f)>>>0)):[]})},919104:(s,c,f,b)=>{u.kb(\"DepthToSpace\",s,{blocksize:c,mode:Ce(f),format:b?\"NHWC\":\"NCHW\"})},919237:(s,c,f,b)=>{u.kb(\"DepthToSpace\",s,{blocksize:c,mode:Ce(f),format:b?\"NHWC\":\"NCHW\"})},919370:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z,de)=>{u.kb(\"ConvTranspose\",s,{format:L?\"NHWC\":\"NCHW\",autoPad:c,dilations:[f],group:b,kernelShape:[w],pads:[I,O],strides:[B],wIsConst:()=>!!t()[H>>>0],outputPadding:X?Array.from(i().subarray(Number(X)>>>0,Number(ce)>>>0)):[],outputShape:ge?Array.from(i().subarray(Number(ge)>>>0,Number(z)>>>0)):[],activation:Ce(de)})},919803:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z)=>{u.kb(\"ConvTranspose\",s,{format:B?\"NHWC\":\"NCHW\",autoPad:c,dilations:Array.from(i().subarray(Number(f)>>>0,2+(Number(f)>>>0)>>>0)),group:b,kernelShape:Array.from(i().subarray(Number(w)>>>0,2+(Number(w)>>>0)>>>0)),pads:Array.from(i().subarray(Number(I)>>>0,4+(Number(I)>>>0)>>>0)),strides:Array.from(i().subarray(Number(O)>>>0,2+(Number(O)>>>0)>>>0)),wIsConst:()=>!!t()[L>>>0],outputPadding:H?Array.from(i().subarray(Number(H)>>>0,Number(X)>>>0)):[],outputShape:ce?Array.from(i().subarray(Number(ce)>>>0,Number(ge)>>>0)):[],activation:Ce(z)})},920464:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z,de)=>{u.kb(\"ConvTranspose\",s,{format:L?\"NHWC\":\"NCHW\",autoPad:c,dilations:[f],group:b,kernelShape:[w],pads:[I,O],strides:[B],wIsConst:()=>!!t()[H>>>0],outputPadding:X?Array.from(i().subarray(Number(X)>>>0,Number(ce)>>>0)):[],outputShape:ge?Array.from(i().subarray(Number(ge)>>>0,Number(z)>>>0)):[],activation:Ce(de)})},920897:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z)=>{u.kb(\"ConvTranspose\",s,{format:B?\"NHWC\":\"NCHW\",autoPad:c,dilations:Array.from(i().subarray(Number(f)>>>0,2+(Number(f)>>>0)>>>0)),group:b,kernelShape:Array.from(i().subarray(Number(w)>>>0,2+(Number(w)>>>0)>>>0)),pads:Array.from(i().subarray(Number(I)>>>0,4+(Number(I)>>>0)>>>0)),strides:Array.from(i().subarray(Number(O)>>>0,2+(Number(O)>>>0)>>>0)),wIsConst:()=>!!t()[L>>>0],outputPadding:H?Array.from(i().subarray(Number(H)>>>0,Number(X)>>>0)):[],outputShape:ce?Array.from(i().subarray(Number(ce)>>>0,Number(ge)>>>0)):[],activation:Ce(z)})},921558:(s,c)=>{u.kb(\"GlobalAveragePool\",s,{format:c?\"NHWC\":\"NCHW\"})},921649:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z)=>{u.kb(\"AveragePool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(L)>>>0)):[],pads:H?Array.from(i().subarray(Number(H)>>>0,Number(X)>>>0)):[],strides:ce?Array.from(i().subarray(Number(ce)>>>0,Number(ge)>>>0)):[]})},922128:(s,c)=>{u.kb(\"GlobalAveragePool\",s,{format:c?\"NHWC\":\"NCHW\"})},922219:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z)=>{u.kb(\"AveragePool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(L)>>>0)):[],pads:H?Array.from(i().subarray(Number(H)>>>0,Number(X)>>>0)):[],strides:ce?Array.from(i().subarray(Number(ce)>>>0,Number(ge)>>>0)):[]})},922698:(s,c)=>{u.kb(\"GlobalMaxPool\",s,{format:c?\"NHWC\":\"NCHW\"})},922785:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z)=>{u.kb(\"MaxPool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(L)>>>0)):[],pads:H?Array.from(i().subarray(Number(H)>>>0,Number(X)>>>0)):[],strides:ce?Array.from(i().subarray(Number(ce)>>>0,Number(ge)>>>0)):[]})},923260:(s,c)=>{u.kb(\"GlobalMaxPool\",s,{format:c?\"NHWC\":\"NCHW\"})},923347:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z)=>{u.kb(\"MaxPool\",s,{format:z?\"NHWC\":\"NCHW\",auto_pad:c,ceil_mode:f,count_include_pad:b,storage_order:w,dilations:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],kernel_shape:B?Array.from(i().subarray(Number(B)>>>0,Number(L)>>>0)):[],pads:H?Array.from(i().subarray(Number(H)>>>0,Number(X)>>>0)):[],strides:ce?Array.from(i().subarray(Number(ce)>>>0,Number(ge)>>>0)):[]})},923822:(s,c,f,b,w)=>{u.kb(\"Gemm\",s,{alpha:c,beta:f,transA:b,transB:w})},923926:s=>{u.kb(\"MatMul\",s,void 0)},923980:(s,c,f,b)=>{u.kb(\"ArgMax\",s,{keepDims:!!c,selectLastIndex:!!f,axis:b})},924088:(s,c,f,b)=>{u.kb(\"ArgMin\",s,{keepDims:!!c,selectLastIndex:!!f,axis:b})},924196:(s,c)=>{u.kb(\"Softmax\",s,{axis:c})},924259:(s,c)=>{u.kb(\"Concat\",s,{axis:c})},924319:(s,c,f,b,w)=>{u.kb(\"Split\",s,{axis:c,numOutputs:f,splitSizes:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},924475:s=>{u.kb(\"Expand\",s,void 0)},924529:(s,c)=>{u.kb(\"Gather\",s,{axis:Number(c)})},924600:(s,c)=>{u.kb(\"GatherElements\",s,{axis:Number(c)})},924679:(s,c)=>{u.kb(\"GatherND\",s,{batch_dims:Number(c)})},924758:(s,c,f,b,w,I,O,B,L,H,X)=>{u.kb(\"Resize\",s,{antialias:c,axes:f?Array.from(i().subarray(Number(f)>>>0,Number(b)>>>0)):[],coordinateTransformMode:Ce(w),cubicCoeffA:I,excludeOutside:O,extrapolationValue:B,keepAspectRatioPolicy:Ce(L),mode:Ce(H),nearestMode:Ce(X)})},925120:(s,c,f,b,w,I,O)=>{u.kb(\"Slice\",s,{starts:c?Array.from(i().subarray(Number(c)>>>0,Number(f)>>>0)):[],ends:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[],axes:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[]})},925384:s=>{u.kb(\"Tile\",s,void 0)},925436:(s,c,f)=>{u.kb(\"InstanceNormalization\",s,{epsilon:c,format:f?\"NHWC\":\"NCHW\"})},925550:(s,c,f)=>{u.kb(\"InstanceNormalization\",s,{epsilon:c,format:f?\"NHWC\":\"NCHW\"})},925664:s=>{u.kb(\"Range\",s,void 0)},925717:(s,c)=>{u.kb(\"Einsum\",s,{equation:Ce(c)})},925798:(s,c,f,b,w)=>{u.kb(\"Pad\",s,{mode:c,value:f,pads:b?Array.from(i().subarray(Number(b)>>>0,Number(w)>>>0)):[]})},925941:(s,c,f,b,w,I)=>{u.kb(\"BatchNormalization\",s,{epsilon:c,momentum:f,spatial:!!w,trainingMode:!!b,format:I?\"NHWC\":\"NCHW\"})},926110:(s,c,f,b,w,I)=>{u.kb(\"BatchNormalization\",s,{epsilon:c,momentum:f,spatial:!!w,trainingMode:!!b,format:I?\"NHWC\":\"NCHW\"})},926279:(s,c,f)=>{u.kb(\"CumSum\",s,{exclusive:Number(c),reverse:Number(f)})},926376:(s,c,f)=>{u.kb(\"DequantizeLinear\",s,{axis:c,blockSize:f})},926466:(s,c,f,b,w)=>{u.kb(\"GridSample\",s,{align_corners:c,mode:Ce(f),padding_mode:Ce(b),format:w?\"NHWC\":\"NCHW\"})},926636:(s,c,f,b,w)=>{u.kb(\"GridSample\",s,{align_corners:c,mode:Ce(f),padding_mode:Ce(b),format:w?\"NHWC\":\"NCHW\"})},926806:(s,c,f,b,w,I,O,B,L)=>{u.kb(\"Attention\",s,{numHeads:c,isUnidirectional:f,maskFilterValue:b,scale:w,doRotary:I,qkvHiddenSizes:O?Array.from(i().subarray(Number(B)>>>0,Number(B)+O>>>0)):[],pastPresentShareBuffer:!!L})},927078:s=>{u.kb(\"BiasAdd\",s,void 0)},927133:s=>{u.kb(\"BiasSplitGelu\",s,void 0)},927194:s=>{u.kb(\"FastGelu\",s,void 0)},927250:(s,c,f,b,w,I,O,B,L,H,X,ce,ge,z,de,Te)=>{u.kb(\"Conv\",s,{format:ce?\"NHWC\":\"NCHW\",auto_pad:c,dilations:f?Array.from(i().subarray(Number(f)>>>0,Number(b)>>>0)):[],group:w,kernel_shape:I?Array.from(i().subarray(Number(I)>>>0,Number(O)>>>0)):[],pads:B?Array.from(i().subarray(Number(B)>>>0,Number(L)>>>0)):[],strides:H?Array.from(i().subarray(Number(H)>>>0,Number(X)>>>0)):[],w_is_const:()=>!!t()[Number(ge)>>>0],activation:Ce(z),activation_params:de?Array.from(d().subarray(Number(de)>>>0,Number(Te)>>>0)):[]})},927834:s=>{u.kb(\"Gelu\",s,void 0)},927886:(s,c,f,b,w,I,O,B,L)=>{u.kb(\"GroupQueryAttention\",s,{numHeads:c,kvNumHeads:f,scale:b,softcap:w,doRotary:I,rotaryInterleaved:O,smoothSoftmax:B,localWindowSize:L})},928103:(s,c,f,b)=>{u.kb(\"LayerNormalization\",s,{axis:c,epsilon:f,simplified:!!b})},928214:(s,c,f,b)=>{u.kb(\"LayerNormalization\",s,{axis:c,epsilon:f,simplified:!!b})},928325:(s,c,f,b,w,I)=>{u.kb(\"MatMulNBits\",s,{k:c,n:f,accuracyLevel:b,bits:w,blockSize:I})},928452:(s,c,f,b,w,I)=>{u.kb(\"MultiHeadAttention\",s,{numHeads:c,isUnidirectional:f,maskFilterValue:b,scale:w,doRotary:I})},928611:(s,c)=>{u.kb(\"QuickGelu\",s,{alpha:c})},928675:(s,c,f,b,w)=>{u.kb(\"RotaryEmbedding\",s,{interleaved:!!c,numHeads:f,rotaryEmbeddingDim:b,scale:w})},928814:(s,c,f)=>{u.kb(\"SkipLayerNormalization\",s,{epsilon:c,simplified:!!f})},928916:(s,c,f)=>{u.kb(\"SkipLayerNormalization\",s,{epsilon:c,simplified:!!f})},929018:(s,c,f,b)=>{u.kb(\"GatherBlockQuantized\",s,{gatherAxis:c,quantizeAxis:f,blockSize:b})},929139:s=>{u.$b(s)},929173:(s,c)=>u.cc(Number(s),Number(c),u.Gb.hc,u.Gb.errors)};function vc(s,c,f){return _i(async()=>{await u.Yb(Number(s),Number(c),Number(f))})}function $c(){return typeof wasmOffsetConverter<\"u\"}function yn(s){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${s})`,this.status=s}var _n=s=>{s.terminate(),s.onmessage=()=>{}},Vo=s=>{pt.length==0&&(qo(),Fo(pt[0]));var c=pt.pop();if(!c)return 6;vt.push(c),Ze[s.Bb]=c,c.Bb=s.Bb;var f={cmd:\"run\",start_routine:s.ic,arg:s.Rb,pthread_ptr:s.Bb};return c.postMessage(f,s.nc),0},wt=0,xe=(s,c,...f)=>{for(var b=2*f.length,w=Rn(),I=Mn(8*b),O=I>>>3,B=0;B<f.length;B++){var L=f[B];typeof L==\"bigint\"?(q[O+2*B]=1n,q[O+2*B+1]=L):(q[O+2*B]=0n,l()[O+2*B+1>>>0]=L)}return s=Gi(s,0,b,I,c),gr(w),s};function wn(s){if(g)return xe(0,1,s);if(ee=s,!(0<wt)){for(var c of vt)_n(c);for(c of pt)_n(c);pt=[],vt=[],Ze=[],we=!0}k(s,new yn(s))}function Wo(s){if(g)return xe(1,0,s);vn(s)}var vn=s=>{if(ee=s,g)throw Wo(s),\"unwind\";wn(s)},pt=[],vt=[],Lo=[],Ze={},Go=s=>{var c=s.Bb;delete Ze[c],pt.push(s),vt.splice(vt.indexOf(s),1),s.Bb=0,Bn(c)};function Ho(){Lo.forEach(s=>s())}var Fo=s=>new Promise(c=>{s.onmessage=w=>{var I=(w=w.data).cmd;if(w.targetThread&&w.targetThread!=Mt()){var O=Ze[w.targetThread];O?O.postMessage(w,w.transferList):j(`Internal error! Worker sent a message \"${I}\" to target pthread ${w.targetThread}, but that thread no longer exists!`)}else I===\"checkMailbox\"?ir():I===\"spawnThread\"?Vo(w):I===\"cleanupThread\"?Go(Ze[w.thread]):I===\"killThread\"?(w=w.thread,I=Ze[w],delete Ze[w],_n(I),Bn(w),vt.splice(vt.indexOf(I),1),I.Bb=0):I===\"cancelThread\"?Ze[w.thread].postMessage({cmd:\"cancel\"}):I===\"loaded\"?(s.loaded=!0,c(s)):I===\"alert\"?alert(`Thread ${w.threadId}: ${w.text}`):w.target===\"setimmediate\"?s.postMessage(w):I===\"callHandler\"?u[w.handler](...w.args):I&&j(`worker sent an unknown command ${I}`)},s.onerror=w=>{throw j(`worker sent an error! ${w.filename}:${w.lineno}: ${w.message}`),w};var f,b=[];for(f of[])u.hasOwnProperty(f)&&b.push(f);s.postMessage({cmd:\"load\",handlers:b,wasmMemory:se,wasmModule:Y})});function qo(){var s=new Worker(\"file:///home/kyeung/repos/personal/picture-editor/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\".startsWith(\"file:\")?new URL(/* asset import */ __webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?3e05\"), __webpack_require__.b):new URL(\"file:///home/kyeung/repos/personal/picture-editor/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"),{type:\"module\",workerData:\"em-pthread\",name:\"em-pthread\"});pt.push(s)}var or=s=>{for(;0<s.length;)s.shift()(u)},xc=()=>{var s=Mt(),c=a()[s+52>>>2>>>0];s=a()[s+56>>>2>>>0],Fi(c,c-s),gr(c)},Sc=(s,c)=>{wt=0,s=qi(s,c),0<wt?ee=s:hr(s)};class Tc{constructor(c){this.Kb=c-24}}function Ic(s,c,f){var b=new Tc(s>>>=0);throw c>>>=0,f>>>=0,a()[b.Kb+16>>>2>>>0]=0,a()[b.Kb+4>>>2>>>0]=c,a()[b.Kb+8>>>2>>>0]=f,s}function Ko(s,c,f,b){return g?xe(2,1,s,c,f,b):jo(s,c,f,b)}function jo(s,c,f,b){if(s>>>=0,c>>>=0,f>>>=0,b>>>=0,x===void 0)return j(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var w=[];return g&&w.length===0?Ko(s,c,f,b):(s={ic:f,Bb:s,Rb:b,nc:w},g?(s.Nb=\"spawnThread\",postMessage(s,w),0):Vo(s))}var Yo=typeof TextDecoder<\"u\"?new TextDecoder(\"utf8\"):void 0,Zo=(s,c,f)=>{var b=(c>>>=0)+f;for(f=c;s[f]&&!(f>=b);)++f;if(16<f-c&&s.buffer&&Yo)return Yo.decode(s.buffer instanceof x?s.slice(c,f):s.subarray(c,f));for(b=\"\";c<f;){var w=s[c++];if(128&w){var I=63&s[c++];if((224&w)==192)b+=String.fromCharCode((31&w)<<6|I);else{var O=63&s[c++];65536>(w=(240&w)==224?(15&w)<<12|I<<6|O:(7&w)<<18|I<<12|O<<6|63&s[c++])?b+=String.fromCharCode(w):(w-=65536,b+=String.fromCharCode(55296|w>>10,56320|1023&w))}}else b+=String.fromCharCode(w)}return b},Ce=(s,c)=>(s>>>=0)?Zo(r(),s,c):\"\";function Qo(s,c,f){return g?xe(3,1,s,c,f):0}function Xo(s,c){if(g)return xe(4,1,s,c)}var $n=s=>{for(var c=0,f=0;f<s.length;++f){var b=s.charCodeAt(f);127>=b?c++:2047>=b?c+=2:55296<=b&&57343>=b?(c+=4,++f):c+=3}return c},Jo=(s,c,f,b)=>{if(!(0<b))return 0;var w=f>>>=0;b=f+b-1;for(var I=0;I<s.length;++I){var O=s.charCodeAt(I);if(55296<=O&&57343>=O&&(O=65536+((1023&O)<<10)|1023&s.charCodeAt(++I)),127>=O){if(f>=b)break;c[f++>>>0]=O}else{if(2047>=O){if(f+1>=b)break;c[f++>>>0]=192|O>>6}else{if(65535>=O){if(f+2>=b)break;c[f++>>>0]=224|O>>12}else{if(f+3>=b)break;c[f++>>>0]=240|O>>18,c[f++>>>0]=128|O>>12&63}c[f++>>>0]=128|O>>6&63}c[f++>>>0]=128|63&O}}return c[f>>>0]=0,f-w},Ot=(s,c,f)=>Jo(s,r(),c,f);function ei(s,c){if(g)return xe(5,1,s,c)}function ti(s,c,f){if(g)return xe(6,1,s,c,f)}function ri(s,c,f){return g?xe(7,1,s,c,f):0}function ni(s,c){if(g)return xe(8,1,s,c)}function oi(s,c,f){if(g)return xe(9,1,s,c,f)}function ii(s,c,f,b){if(g)return xe(10,1,s,c,f,b)}function ai(s,c,f,b){if(g)return xe(11,1,s,c,f,b)}function si(s,c,f,b){if(g)return xe(12,1,s,c,f,b)}function ui(s){if(g)return xe(13,1,s)}function di(s,c){if(g)return xe(14,1,s,c)}function li(s,c,f){if(g)return xe(15,1,s,c,f)}var ci,mt,Cc=()=>{ct(\"\")},Qe=s=>{for(var c=\"\";r()[s>>>0];)c+=ci[r()[s++>>>0]];return c},xn={},Sn={},Ac={};function st(s,c,f={}){if(!(\"argPackAdvance\"in c))throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");return function(b,w,I={}){var O=w.name;if(!b)throw new mt(`type \"${O}\" must have a positive integer typeid pointer`);if(Sn.hasOwnProperty(b)){if(I.Tb)return;throw new mt(`Cannot register type '${O}' twice`)}Sn[b]=w,delete Ac[b],xn.hasOwnProperty(b)&&(w=xn[b],delete xn[b],w.forEach(B=>B()))}(s,c,f)}var pi=(s,c,f)=>{switch(c){case 1:return f?b=>t()[b>>>0]:b=>r()[b>>>0];case 2:return f?b=>n()[b>>>1>>>0]:b=>o()[b>>>1>>>0];case 4:return f?b=>i()[b>>>2>>>0]:b=>a()[b>>>2>>>0];case 8:return f?b=>q[b>>>3]:b=>he[b>>>3];default:throw new TypeError(`invalid integer width (${c}): ${s}`)}};function kc(s,c,f){f>>>=0,st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:b=>b,toWireType:function(b,w){if(typeof w!=\"bigint\"&&typeof w!=\"number\")throw w=w===null?\"null\":(b=typeof w)==\"object\"||b===\"array\"||b===\"function\"?w.toString():\"\"+w,new TypeError(`Cannot convert \"${w}\" to ${this.name}`);return typeof w==\"number\"&&(w=BigInt(w)),w},argPackAdvance:ft,readValueFromPointer:pi(c,f,c.indexOf(\"u\")==-1),Eb:null})}var ft=8;function Ec(s,c,f,b){st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:function(w){return!!w},toWireType:function(w,I){return I?f:b},argPackAdvance:ft,readValueFromPointer:function(w){return this.fromWireType(r()[w>>>0])},Eb:null})}var Tn=[],ut=[];function In(s){9<(s>>>=0)&&--ut[s+1]==0&&(ut[s]=void 0,Tn.push(s))}var Me=s=>{if(!s)throw new mt(\"Cannot use deleted val. handle = \"+s);return ut[s]},Ve=s=>{switch(s){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let c=Tn.pop()||ut.length;return ut[c]=s,ut[c+1]=1,c}};function Cn(s){return this.fromWireType(a()[s>>>2>>>0])}var Pc={name:\"emscripten::val\",fromWireType:s=>{var c=Me(s);return In(s),c},toWireType:(s,c)=>Ve(c),argPackAdvance:ft,readValueFromPointer:Cn,Eb:null};function zc(s){return st(s>>>0,Pc)}var Oc=(s,c)=>{switch(c){case 4:return function(f){return this.fromWireType(d()[f>>>2>>>0])};case 8:return function(f){return this.fromWireType(l()[f>>>3>>>0])};default:throw new TypeError(`invalid float width (${c}): ${s}`)}};function Dc(s,c,f){f>>>=0,st(s>>>=0,{name:c=Qe(c>>>0),fromWireType:b=>b,toWireType:(b,w)=>w,argPackAdvance:ft,readValueFromPointer:Oc(c,f),Eb:null})}function Bc(s,c,f,b,w){if(s>>>=0,f>>>=0,c=Qe(c>>>0),w===-1&&(w=4294967295),w=B=>B,b===0){var I=32-8*f;w=B=>B<<I>>>I}var O=c.includes(\"unsigned\")?function(B,L){return L>>>0}:function(B,L){return L};st(s,{name:c,fromWireType:w,toWireType:O,argPackAdvance:ft,readValueFromPointer:pi(c,f,b!==0),Eb:null})}function Mc(s,c,f){function b(I){var O=a()[I>>>2>>>0];return I=a()[I+4>>>2>>>0],new w(t().buffer,I,O)}var w=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][c];st(s>>>=0,{name:f=Qe(f>>>0),fromWireType:b,argPackAdvance:ft,readValueFromPointer:b},{Tb:!0})}function Rc(s,c){s>>>=0;var f=(c=Qe(c>>>0))===\"std::string\";st(s,{name:c,fromWireType:function(b){var w=a()[b>>>2>>>0],I=b+4;if(f)for(var O=I,B=0;B<=w;++B){var L=I+B;if(B==w||r()[L>>>0]==0){if(O=Ce(O,L-O),H===void 0)var H=O;else H+=String.fromCharCode(0),H+=O;O=L+1}}else{for(H=Array(w),B=0;B<w;++B)H[B]=String.fromCharCode(r()[I+B>>>0]);H=H.join(\"\")}return Je(b),H},toWireType:function(b,w){w instanceof ArrayBuffer&&(w=new Uint8Array(w));var I=typeof w==\"string\";if(!(I||w instanceof Uint8Array||w instanceof Uint8ClampedArray||w instanceof Int8Array))throw new mt(\"Cannot pass non-string to std::string\");var O=f&&I?$n(w):w.length,B=fr(4+O+1),L=B+4;if(a()[B>>>2>>>0]=O,f&&I)Ot(w,L,O+1);else if(I)for(I=0;I<O;++I){var H=w.charCodeAt(I);if(255<H)throw Je(L),new mt(\"String has UTF-16 code units that do not fit in 8 bits\");r()[L+I>>>0]=H}else for(I=0;I<O;++I)r()[L+I>>>0]=w[I];return b!==null&&b.push(Je,B),B},argPackAdvance:ft,readValueFromPointer:Cn,Eb(b){Je(b)}})}var mi=typeof TextDecoder<\"u\"?new TextDecoder(\"utf-16le\"):void 0,Uc=(s,c)=>{for(var f=s>>1,b=f+c/2;!(f>=b)&&o()[f>>>0];)++f;if(32<(f<<=1)-s&&mi)return mi.decode(r().slice(s,f));for(f=\"\",b=0;!(b>=c/2);++b){var w=n()[s+2*b>>>1>>>0];if(w==0)break;f+=String.fromCharCode(w)}return f},Nc=(s,c,f)=>{if(f??=2147483647,2>f)return 0;var b=c;f=(f-=2)<2*s.length?f/2:s.length;for(var w=0;w<f;++w){var I=s.charCodeAt(w);n()[c>>>1>>>0]=I,c+=2}return n()[c>>>1>>>0]=0,c-b},Vc=s=>2*s.length,Wc=(s,c)=>{for(var f=0,b=\"\";!(f>=c/4);){var w=i()[s+4*f>>>2>>>0];if(w==0)break;++f,65536<=w?(w-=65536,b+=String.fromCharCode(55296|w>>10,56320|1023&w)):b+=String.fromCharCode(w)}return b},Lc=(s,c,f)=>{if(c>>>=0,f??=2147483647,4>f)return 0;var b=c;f=b+f-4;for(var w=0;w<s.length;++w){var I=s.charCodeAt(w);if(55296<=I&&57343>=I&&(I=65536+((1023&I)<<10)|1023&s.charCodeAt(++w)),i()[c>>>2>>>0]=I,(c+=4)+4>f)break}return i()[c>>>2>>>0]=0,c-b},Gc=s=>{for(var c=0,f=0;f<s.length;++f){var b=s.charCodeAt(f);55296<=b&&57343>=b&&++f,c+=4}return c};function Hc(s,c,f){if(s>>>=0,c>>>=0,f=Qe(f>>>=0),c===2)var b=Uc,w=Nc,I=Vc,O=B=>o()[B>>>1>>>0];else c===4&&(b=Wc,w=Lc,I=Gc,O=B=>a()[B>>>2>>>0]);st(s,{name:f,fromWireType:B=>{for(var L,H=a()[B>>>2>>>0],X=B+4,ce=0;ce<=H;++ce){var ge=B+4+ce*c;ce!=H&&O(ge)!=0||(X=b(X,ge-X),L===void 0?L=X:(L+=String.fromCharCode(0),L+=X),X=ge+c)}return Je(B),L},toWireType:(B,L)=>{if(typeof L!=\"string\")throw new mt(`Cannot pass non-string to C++ string type ${f}`);var H=I(L),X=fr(4+H+c);return a()[X>>>2>>>0]=H/c,w(L,X+4,H+c),B!==null&&B.push(Je,X),X},argPackAdvance:ft,readValueFromPointer:Cn,Eb(B){Je(B)}})}function Fc(s,c){st(s>>>=0,{Ub:!0,name:c=Qe(c>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var qc=()=>1;function Kc(s){Dn(s>>>0,!y,1,!_,131072,!1),Ho()}var fi=s=>{if(!we)try{if(s(),!(0<wt))try{g?hr(ee):vn(ee)}catch(c){c instanceof yn||c==\"unwind\"||k(1,c)}}catch(c){c instanceof yn||c==\"unwind\"||k(1,c)}};function An(s){s>>>=0,typeof Atomics.oc==\"function\"&&(Atomics.oc(i(),s>>>2,s).value.then(ir),s+=128,Atomics.store(i(),s>>>2,1))}var ir=()=>{var s=Mt();s&&(An(s),fi(Hi))};function jc(s,c){(s>>>=0)==c>>>0?setTimeout(ir):g?postMessage({targetThread:s,cmd:\"checkMailbox\"}):(s=Ze[s])&&s.postMessage({cmd:\"checkMailbox\"})}var kn=[];function Yc(s,c,f,b,w){for(c>>>=0,b/=2,kn.length=b,f=w>>>0>>>3,w=0;w<b;w++)kn[w]=q[f+2*w]?q[f+2*w+1]:l()[f+2*w+1>>>0];return(c?bn[c]:Np[s])(...kn)}function Zc(s){s>>>=0,g?postMessage({cmd:\"cleanupThread\",thread:s}):Go(Ze[s])}function Qc(s){}var ar=(s,c)=>{var f=Sn[s];if(f===void 0)throw s=Vi(s),f=Qe(s),Je(s),new mt(`${c} has unknown type ${f}`);return f},hi=(s,c,f)=>{var b=[];return s=s.toWireType(b,f),b.length&&(a()[c>>>2>>>0]=Ve(b)),s};function Xc(s,c,f){return c>>>=0,f>>>=0,s=Me(s>>>0),c=ar(c,\"emval::as\"),hi(c,f,s)}function Jc(s,c){return c>>>=0,s=Me(s>>>0),(c=ar(c,\"emval::as\")).toWireType(null,s)}var sr=s=>{try{s()}catch(c){ct(c)}},ht=0,Xe=null,gi=0,ur=[],bi={},yi={},ep=0,En=null,tp=[];function _i(s){return function(c){if(!we){if(ht===0){var f=!1,b=!1;c((w=0)=>{if(!we&&(gi=w,f=!0,b)){ht=2,sr(()=>Yi(Xe)),typeof Browser<\"u\"&&Browser.Lb.Sb&&Browser.Lb.resume(),w=!1;try{var I=function(){var L=i()[Xe+8>>>2>>>0];return L=Z[yi[L]],--wt,L()}()}catch(L){I=L,w=!0}var O=!1;if(!Xe){var B=En;B&&(En=null,(w?B.reject:B.resolve)(I),O=!0)}if(w&&!O)throw I}}),b=!0,f||(ht=1,Xe=function(){var w=fr(65548),I=w+12;a()[w>>>2>>>0]=I,a()[w+4>>>2>>>0]=I+65536,I=ur[0];var O=bi[I];return O===void 0&&(O=ep++,bi[I]=O,yi[O]=I),I=O,i()[w+8>>>2>>>0]=I,w}(),typeof Browser<\"u\"&&Browser.Lb.Sb&&Browser.Lb.pause(),sr(()=>Ki(Xe)))}else ht===2?(ht=0,sr(Zi),Je(Xe),Xe=null,tp.forEach(fi)):ct(`invalid state: ${ht}`);return gi}}(c=>{s().then(c)})}function rp(s){return s>>>=0,_i(()=>(s=Me(s)).then(Ve))}var dr=[];function np(s,c,f,b){return f>>>=0,b>>>=0,(s=dr[s>>>0])(null,c=Me(c>>>0),f,b)}var op={},lr=s=>{var c=op[s];return c===void 0?Qe(s):c};function ip(s,c,f,b,w){return f>>>=0,b>>>=0,w>>>=0,(s=dr[s>>>0])(c=Me(c>>>0),c[f=lr(f)],b,w)}var wi=()=>typeof globalThis==\"object\"?globalThis:Function(\"return this\")();function ap(s){return(s>>>=0)==0?Ve(wi()):(s=lr(s),Ve(wi()[s]))}var sp=s=>{var c=dr.length;return dr.push(s),c},up=(s,c)=>{for(var f=Array(s),b=0;b<s;++b)f[b]=ar(a()[c+4*b>>>2>>>0],\"parameter \"+b);return f},vi=(s,c)=>Object.defineProperty(c,\"name\",{value:s});function dp(s,c,f){var b=(c=up(s,c>>>0)).shift();s--;var w=`return function (obj, func, destructorsRef, args) {\n`,I=0,O=[];f===0&&O.push(\"obj\");for(var B=[\"retType\"],L=[b],H=0;H<s;++H)O.push(\"arg\"+H),B.push(\"argType\"+H),L.push(c[H]),w+=`  var arg${H} = argType${H}.readValueFromPointer(args${I?\"+\"+I:\"\"});\n`,I+=c[H].argPackAdvance;return w+=`  var rv = ${f===1?\"new func\":\"func.call\"}(${O.join(\", \")});\n`,b.Ub||(B.push(\"emval_returnValue\"),L.push(hi),w+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),B.push(w+`};\n`),s=function(X){var ce=Function;if(!(ce instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof ce} which is not a function`);var ge=vi(ce.name||\"unknownFunctionName\",function(){});return ge.prototype=ce.prototype,ge=new ge,(X=ce.apply(ge,X))instanceof Object?X:ge}(B)(...L),f=`methodCaller<(${c.map(X=>X.name).join(\", \")}) => ${b.name}>`,sp(vi(f,s))}function lp(s){return s=lr(s>>>0),Ve(u[s])}function cp(s,c){return c>>>=0,s=Me(s>>>0),c=Me(c),Ve(s[c])}function pp(s){9<(s>>>=0)&&(ut[s+1]+=1)}function mp(){return Ve([])}function fp(s){s=Me(s>>>0);for(var c=Array(s.length),f=0;f<s.length;f++)c[f]=s[f];return Ve(c)}function hp(s){return Ve(lr(s>>>0))}function gp(){return Ve({})}function bp(s){for(var c=Me(s>>>=0);c.length;){var f=c.pop();c.pop()(f)}In(s)}function yp(s,c,f){c>>>=0,f>>>=0,s=Me(s>>>0),c=Me(c),f=Me(f),s[c]=f}function _p(s,c){return c>>>=0,s=(s=ar(s>>>0,\"_emval_take_value\")).readValueFromPointer(c),Ve(s)}function wp(s,c){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),c>>>=0,s=new Date(1e3*s),i()[c>>>2>>>0]=s.getUTCSeconds(),i()[c+4>>>2>>>0]=s.getUTCMinutes(),i()[c+8>>>2>>>0]=s.getUTCHours(),i()[c+12>>>2>>>0]=s.getUTCDate(),i()[c+16>>>2>>>0]=s.getUTCMonth(),i()[c+20>>>2>>>0]=s.getUTCFullYear()-1900,i()[c+24>>>2>>>0]=s.getUTCDay(),s=(s.getTime()-Date.UTC(s.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[c+28>>>2>>>0]=s}var Dt=s=>s%4==0&&(s%100!=0||s%400==0),$i=[0,31,60,91,121,152,182,213,244,274,305,335],xi=[0,31,59,90,120,151,181,212,243,273,304,334];function vp(s,c){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),c>>>=0,s=new Date(1e3*s),i()[c>>>2>>>0]=s.getSeconds(),i()[c+4>>>2>>>0]=s.getMinutes(),i()[c+8>>>2>>>0]=s.getHours(),i()[c+12>>>2>>>0]=s.getDate(),i()[c+16>>>2>>>0]=s.getMonth(),i()[c+20>>>2>>>0]=s.getFullYear()-1900,i()[c+24>>>2>>>0]=s.getDay();var f=(Dt(s.getFullYear())?$i:xi)[s.getMonth()]+s.getDate()-1|0;i()[c+28>>>2>>>0]=f,i()[c+36>>>2>>>0]=-60*s.getTimezoneOffset(),f=new Date(s.getFullYear(),6,1).getTimezoneOffset();var b=new Date(s.getFullYear(),0,1).getTimezoneOffset();s=0|(f!=b&&s.getTimezoneOffset()==Math.min(b,f)),i()[c+32>>>2>>>0]=s}function $p(s){s>>>=0;var c=new Date(i()[s+20>>>2>>>0]+1900,i()[s+16>>>2>>>0],i()[s+12>>>2>>>0],i()[s+8>>>2>>>0],i()[s+4>>>2>>>0],i()[s>>>2>>>0],0),f=i()[s+32>>>2>>>0],b=c.getTimezoneOffset(),w=new Date(c.getFullYear(),6,1).getTimezoneOffset(),I=new Date(c.getFullYear(),0,1).getTimezoneOffset(),O=Math.min(I,w);return 0>f?i()[s+32>>>2>>>0]=+(w!=I&&O==b):0<f!=(O==b)&&(w=Math.max(I,w),c.setTime(c.getTime()+6e4*((0<f?O:w)-b))),i()[s+24>>>2>>>0]=c.getDay(),f=(Dt(c.getFullYear())?$i:xi)[c.getMonth()]+c.getDate()-1|0,i()[s+28>>>2>>>0]=f,i()[s>>>2>>>0]=c.getSeconds(),i()[s+4>>>2>>>0]=c.getMinutes(),i()[s+8>>>2>>>0]=c.getHours(),i()[s+12>>>2>>>0]=c.getDate(),i()[s+16>>>2>>>0]=c.getMonth(),i()[s+20>>>2>>>0]=c.getYear(),s=c.getTime(),BigInt(isNaN(s)?-1:s/1e3)}function Si(s,c,f,b,w,I,O){return g?xe(16,1,s,c,f,b,w,I,O):-52}function Ti(s,c,f,b,w,I){if(g)return xe(17,1,s,c,f,b,w,I)}function xp(s,c,f,b){s>>>=0,c>>>=0,f>>>=0,b>>>=0;var w=new Date().getFullYear(),I=new Date(w,0,1),O=new Date(w,6,1);w=I.getTimezoneOffset();var B=O.getTimezoneOffset(),L=Math.max(w,B);a()[s>>>2>>>0]=60*L,i()[c>>>2>>>0]=+(w!=B),I=(s=H=>H.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:\"short\"}).split(\" \")[1])(I),O=s(O),B<w?(Ot(I,f,17),Ot(O,b,17)):(Ot(I,b,17),Ot(O,f,17))}var Pn=[],Ii=(s,c)=>{Pn.length=0;for(var f;f=r()[s++>>>0];){var b=f!=105;c+=(b&=f!=112)&&c%8?4:0,Pn.push(f==112?a()[c>>>2>>>0]:f==106?q[c>>>3]:f==105?i()[c>>>2>>>0]:l()[c>>>3>>>0]),c+=b?8:4}return Pn};function Sp(s,c,f){return s>>>=0,c=Ii(c>>>0,f>>>0),bn[s](...c)}function Tp(s,c,f){return s>>>=0,c=Ii(c>>>0,f>>>0),bn[s](...c)}var Ip=()=>{},Cp=()=>Date.now();function Ap(s,c){return j(Ce(s>>>0,c>>>0))}var Ci,kp=()=>{throw wt+=1,\"unwind\"};function Ep(){return 4294901760}Ci=()=>performance.timeOrigin+performance.now();var Pp=()=>navigator.hardwareConcurrency;function zp(){return ct(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"),0}function Op(s){s>>>=0;var c=r().length;if(s<=c||4294901760<s)return!1;for(var f=1;4>=f;f*=2){var b=c*(1+.2/f);b=Math.min(b,s+100663296);var w=Math;b=Math.max(s,b);e:{w=(w.min.call(w,4294901760,b+(65536-b%65536)%65536)-se.buffer.byteLength+65535)/65536;try{se.grow(w),ye();var I=1;break e}catch{}I=void 0}if(I)return!0}return!1}var cr=()=>(ct(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"),0),Bt={},Ai=s=>{s.forEach(c=>{var f=cr();f&&(Bt[f]=c)})};function Dp(){var s=Error().stack.toString().split(`\n`);return s[0]==\"Error\"&&s.shift(),Ai(s),Bt.Qb=cr(),Bt.fc=s,Bt.Qb}function Bp(s,c,f){if(s>>>=0,c>>>=0,Bt.Qb==s)var b=Bt.fc;else(b=Error().stack.toString().split(`\n`))[0]==\"Error\"&&b.shift(),Ai(b);for(var w=3;b[w]&&cr()!=s;)++w;for(s=0;s<f&&b[s+w];++s)i()[c+4*s>>>2>>>0]=cr();return s}var zn,On={},ki=()=>{if(!zn){var s,c={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:A||\"./this.program\"};for(s in On)On[s]===void 0?delete c[s]:c[s]=On[s];var f=[];for(s in c)f.push(`${s}=${c[s]}`);zn=f}return zn};function Ei(s,c){if(g)return xe(18,1,s,c);s>>>=0,c>>>=0;var f=0;return ki().forEach((b,w)=>{var I=c+f;for(w=a()[s+4*w>>>2>>>0]=I,I=0;I<b.length;++I)t()[w++>>>0]=b.charCodeAt(I);t()[w>>>0]=0,f+=b.length+1}),0}function Pi(s,c){if(g)return xe(19,1,s,c);s>>>=0,c>>>=0;var f=ki();a()[s>>>2>>>0]=f.length;var b=0;return f.forEach(w=>b+=w.length+1),a()[c>>>2>>>0]=b,0}function zi(s){return g?xe(20,1,s):52}function Oi(s,c,f,b){return g?xe(21,1,s,c,f,b):52}function Di(s,c,f,b){return g?xe(22,1,s,c,f,b):70}var Mp=[null,[],[]];function Bi(s,c,f,b){if(g)return xe(23,1,s,c,f,b);c>>>=0,f>>>=0,b>>>=0;for(var w=0,I=0;I<f;I++){var O=a()[c>>>2>>>0],B=a()[c+4>>>2>>>0];c+=8;for(var L=0;L<B;L++){var H=r()[O+L>>>0],X=Mp[s];H===0||H===10?((s===1?K:j)(Zo(X,0)),X.length=0):X.push(H)}w+=B}return a()[b>>>2>>>0]=w,0}var Mi=[31,29,31,30,31,30,31,31,30,31,30,31],Ri=[31,28,31,30,31,30,31,31,30,31,30,31],Rp=(s,c)=>{t().set(s,c>>>0)};function Ui(s,c,f,b){function w(z,de,Te){for(z=typeof z==\"number\"?z.toString():z||\"\";z.length<de;)z=Te[0]+z;return z}function I(z,de){return w(z,de,\"0\")}function O(z,de){function Te(Xi){return 0>Xi?-1:0<Xi?1:0}var $t;return($t=Te(z.getFullYear()-de.getFullYear()))===0&&($t=Te(z.getMonth()-de.getMonth()))===0&&($t=Te(z.getDate()-de.getDate())),$t}function B(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function L(z){var de=z.Cb;for(z=new Date(new Date(z.Db+1900,0,1).getTime());0<de;){var Te=z.getMonth(),$t=(Dt(z.getFullYear())?Mi:Ri)[Te];if(!(de>$t-z.getDate())){z.setDate(z.getDate()+de);break}de-=$t-z.getDate()+1,z.setDate(1),11>Te?z.setMonth(Te+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1))}return Te=new Date(z.getFullYear()+1,0,4),de=B(new Date(z.getFullYear(),0,4)),Te=B(Te),0>=O(de,z)?0>=O(Te,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}s>>>=0,c>>>=0,f>>>=0,b>>>=0;var H=a()[b+40>>>2>>>0];for(var X in b={lc:i()[b>>>2>>>0],kc:i()[b+4>>>2>>>0],Ib:i()[b+8>>>2>>>0],Mb:i()[b+12>>>2>>>0],Jb:i()[b+16>>>2>>>0],Db:i()[b+20>>>2>>>0],vb:i()[b+24>>>2>>>0],Cb:i()[b+28>>>2>>>0],sc:i()[b+32>>>2>>>0],jc:i()[b+36>>>2>>>0],mc:H?Ce(H):\"\"},f=Ce(f),H={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})f=f.replace(new RegExp(X,\"g\"),H[X]);var ce=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),ge=\"January February March April May June July August September October November December\".split(\" \");for(X in H={\"%a\":z=>ce[z.vb].substring(0,3),\"%A\":z=>ce[z.vb],\"%b\":z=>ge[z.Jb].substring(0,3),\"%B\":z=>ge[z.Jb],\"%C\":z=>I((z.Db+1900)/100|0,2),\"%d\":z=>I(z.Mb,2),\"%e\":z=>w(z.Mb,2,\" \"),\"%g\":z=>L(z).toString().substring(2),\"%G\":L,\"%H\":z=>I(z.Ib,2),\"%I\":z=>((z=z.Ib)==0?z=12:12<z&&(z-=12),I(z,2)),\"%j\":z=>{for(var de=0,Te=0;Te<=z.Jb-1;de+=(Dt(z.Db+1900)?Mi:Ri)[Te++]);return I(z.Mb+de,3)},\"%m\":z=>I(z.Jb+1,2),\"%M\":z=>I(z.kc,2),\"%n\":()=>`\n`,\"%p\":z=>0<=z.Ib&&12>z.Ib?\"AM\":\"PM\",\"%S\":z=>I(z.lc,2),\"%t\":()=>\"\t\",\"%u\":z=>z.vb||7,\"%U\":z=>I(Math.floor((z.Cb+7-z.vb)/7),2),\"%V\":z=>{var de=Math.floor((z.Cb+7-(z.vb+6)%7)/7);if(2>=(z.vb+371-z.Cb-2)%7&&de++,de)de==53&&((Te=(z.vb+371-z.Cb)%7)==4||Te==3&&Dt(z.Db)||(de=1));else{de=52;var Te=(z.vb+7-z.Cb-1)%7;(Te==4||Te==5&&Dt(z.Db%400-1))&&de++}return I(de,2)},\"%w\":z=>z.vb,\"%W\":z=>I(Math.floor((z.Cb+7-(z.vb+6)%7)/7),2),\"%y\":z=>(z.Db+1900).toString().substring(2),\"%Y\":z=>z.Db+1900,\"%z\":z=>{var de=0<=(z=z.jc);return z=Math.abs(z)/60,(de?\"+\":\"-\")+(\"0000\"+(z/60*100+z%60)).slice(-4)},\"%Z\":z=>z.mc,\"%%\":()=>\"%\"},f=f.replace(/%%/g,\"\\0\\0\"),H)f.includes(X)&&(f=f.replace(new RegExp(X,\"g\"),H[X](b)));return X=function(z){var de=Array($n(z)+1);return Jo(z,de,0,de.length),de}(f=f.replace(/\\0\\0/g,\"%\")),X.length>c?0:(Rp(X,s),X.length-1)}function Up(s,c,f,b){return Ui(s>>>0,c>>>0,f>>>0,b>>>0)}g||function(){for(var s=u.numThreads-1;s--;)qo();Ye.unshift(()=>{Gt++,function(c){g?c():Promise.all(pt.map(Fo)).then(c)}(()=>Do())})}();for(var Ni=Array(256),pr=0;256>pr;++pr)Ni[pr]=String.fromCharCode(pr);ci=Ni,mt=u.BindingError=class extends Error{constructor(s){super(s),this.name=\"BindingError\"}},u.InternalError=class extends Error{constructor(s){super(s),this.name=\"InternalError\"}},ut.push(0,1,void 0,1,null,1,!0,1,!1,1),u.count_emval_handles=()=>ut.length/2-5-Tn.length;var Np=[wn,Wo,Ko,Qo,Xo,ei,ti,ri,ni,oi,ii,ai,si,ui,di,li,Si,Ti,Ei,Pi,zi,Oi,Di,Bi],Z=function(){function s(f,b){return Z=f.exports,Z=function(){var w=Z,I={};for(let[O,B]of Object.entries(w))I[O]=typeof B==\"function\"?(...L)=>{ur.push(O);try{return B(...L)}finally{we||(ur.pop(),Xe&&ht===1&&ur.length===0&&(ht=0,wt+=1,sr(ji),typeof Fibers<\"u\"&&Fibers.tc()))}}:B;return I}(),Z=function(){var w=Z,I=B=>L=>B(L)>>>0,O=B=>()=>B()>>>0;return(w=Object.assign({},w)).Da=I(w.Da),w.gb=O(w.gb),w.ib=I(w.ib),w.emscripten_main_runtime_thread_id=O(w.emscripten_main_runtime_thread_id),w.tb=I(w.tb),w.ub=O(w.ub),w}(),Lo.push(Z.jb),Lt.unshift(Z.Ca),Y=b,Do(),Z}var c=No();if(Gt++,u.instantiateWasm)try{return u.instantiateWasm(c,s)}catch(f){j(`Module.instantiateWasm callback failed with error: ${f}`),m(f)}return gn||=u.locateFile?Bo(\"ort-wasm-simd-threaded.jsep.wasm\")?\"ort-wasm-simd-threaded.jsep.wasm\":u.locateFile?u.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\",P):P+\"ort-wasm-simd-threaded.jsep.wasm\":new URL(/* asset import */ __webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\"), __webpack_require__.b).href,function(f,b){var w=gn;return D||typeof WebAssembly.instantiateStreaming!=\"function\"||Bo(w)||Mo(w)||typeof fetch!=\"function\"?Uo(w,f,b):fetch(w,{credentials:\"same-origin\"}).then(I=>WebAssembly.instantiateStreaming(I,f).then(b,function(O){return j(`wasm streaming compile failed: ${O}`),j(\"falling back to ArrayBuffer instantiation\"),Uo(w,f,b)}))}(c,function(f){s(f.instance,f.module)}).catch(m),{}}(),Vi=s=>(Vi=Z.Da)(s),Wi=()=>(Wi=Z.Ea)();u._OrtInit=(s,c)=>(u._OrtInit=Z.Fa)(s,c),u._OrtGetLastError=(s,c)=>(u._OrtGetLastError=Z.Ga)(s,c),u._OrtCreateSessionOptions=(s,c,f,b,w,I,O,B,L,H)=>(u._OrtCreateSessionOptions=Z.Ha)(s,c,f,b,w,I,O,B,L,H),u._OrtAppendExecutionProvider=(s,c)=>(u._OrtAppendExecutionProvider=Z.Ia)(s,c),u._OrtAddFreeDimensionOverride=(s,c,f)=>(u._OrtAddFreeDimensionOverride=Z.Ja)(s,c,f),u._OrtAddSessionConfigEntry=(s,c,f)=>(u._OrtAddSessionConfigEntry=Z.Ka)(s,c,f),u._OrtReleaseSessionOptions=s=>(u._OrtReleaseSessionOptions=Z.La)(s),u._OrtCreateSession=(s,c,f)=>(u._OrtCreateSession=Z.Ma)(s,c,f),u._OrtReleaseSession=s=>(u._OrtReleaseSession=Z.Na)(s),u._OrtGetInputOutputCount=(s,c,f)=>(u._OrtGetInputOutputCount=Z.Oa)(s,c,f),u._OrtGetInputName=(s,c)=>(u._OrtGetInputName=Z.Pa)(s,c),u._OrtGetOutputName=(s,c)=>(u._OrtGetOutputName=Z.Qa)(s,c),u._OrtFree=s=>(u._OrtFree=Z.Ra)(s),u._OrtCreateTensor=(s,c,f,b,w,I)=>(u._OrtCreateTensor=Z.Sa)(s,c,f,b,w,I),u._OrtGetTensorData=(s,c,f,b,w)=>(u._OrtGetTensorData=Z.Ta)(s,c,f,b,w),u._OrtReleaseTensor=s=>(u._OrtReleaseTensor=Z.Ua)(s),u._OrtCreateRunOptions=(s,c,f,b)=>(u._OrtCreateRunOptions=Z.Va)(s,c,f,b),u._OrtAddRunConfigEntry=(s,c,f)=>(u._OrtAddRunConfigEntry=Z.Wa)(s,c,f),u._OrtReleaseRunOptions=s=>(u._OrtReleaseRunOptions=Z.Xa)(s),u._OrtCreateBinding=s=>(u._OrtCreateBinding=Z.Ya)(s),u._OrtBindInput=(s,c,f)=>(u._OrtBindInput=Z.Za)(s,c,f),u._OrtBindOutput=(s,c,f,b)=>(u._OrtBindOutput=Z._a)(s,c,f,b),u._OrtClearBoundOutputs=s=>(u._OrtClearBoundOutputs=Z.$a)(s),u._OrtReleaseBinding=s=>(u._OrtReleaseBinding=Z.ab)(s),u._OrtRunWithBinding=(s,c,f,b,w)=>(u._OrtRunWithBinding=Z.bb)(s,c,f,b,w),u._OrtRun=(s,c,f,b,w,I,O,B)=>(u._OrtRun=Z.cb)(s,c,f,b,w,I,O,B),u._OrtEndProfiling=s=>(u._OrtEndProfiling=Z.db)(s),u._JsepOutput=(s,c,f)=>(u._JsepOutput=Z.eb)(s,c,f),u._JsepGetNodeName=s=>(u._JsepGetNodeName=Z.fb)(s);var mr,Mt=()=>(Mt=Z.gb)(),Je=u._free=s=>(Je=u._free=Z.hb)(s),fr=u._malloc=s=>(fr=u._malloc=Z.ib)(s),Dn=(s,c,f,b,w,I)=>(Dn=Z.lb)(s,c,f,b,w,I),Li=()=>(Li=Z.mb)(),Gi=(s,c,f,b,w)=>(Gi=Z.nb)(s,c,f,b,w),Bn=s=>(Bn=Z.ob)(s),hr=s=>(hr=Z.pb)(s),Hi=()=>(Hi=Z.qb)(),Fi=(s,c)=>(Fi=Z.rb)(s,c),gr=s=>(gr=Z.sb)(s),Mn=s=>(Mn=Z.tb)(s),Rn=()=>(Rn=Z.ub)(),qi=u.dynCall_ii=(s,c)=>(qi=u.dynCall_ii=Z.wb)(s,c),Ki=s=>(Ki=Z.xb)(s),ji=()=>(ji=Z.yb)(),Yi=s=>(Yi=Z.zb)(s),Zi=()=>(Zi=Z.Ab)();function Qi(){0<Gt||(g?(p(u),g||or(Lt),startWorker(u)):(or(Ye),0<Gt||mr||(mr=!0,u.calledRun=!0,we||(g||or(Lt),p(u),g||or(fn)))))}return u.___start_em_js=929301,u.___stop_em_js=929547,u.stackSave=()=>Rn(),u.stackRestore=s=>gr(s),u.stackAlloc=s=>Mn(s),u.setValue=function(s,c,f=\"i8\"){switch(f.endsWith(\"*\")&&(f=\"*\"),f){case\"i1\":case\"i8\":t()[s>>>0]=c;break;case\"i16\":n()[s>>>1>>>0]=c;break;case\"i32\":i()[s>>>2>>>0]=c;break;case\"i64\":q[s>>>3]=BigInt(c);break;case\"float\":d()[s>>>2>>>0]=c;break;case\"double\":l()[s>>>3>>>0]=c;break;case\"*\":a()[s>>>2>>>0]=c;break;default:ct(`invalid type for setValue: ${f}`)}},u.getValue=function(s,c=\"i8\"){switch(c.endsWith(\"*\")&&(c=\"*\"),c){case\"i1\":case\"i8\":return t()[s>>>0];case\"i16\":return n()[s>>>1>>>0];case\"i32\":return i()[s>>>2>>>0];case\"i64\":return q[s>>>3];case\"float\":return d()[s>>>2>>>0];case\"double\":return l()[s>>>3>>>0];case\"*\":return a()[s>>>2>>>0];default:ct(`invalid type for getValue: ${c}`)}},u.UTF8ToString=Ce,u.stringToUTF8=Ot,u.lengthBytesUTF8=$n,Ht=function s(){mr||Qi(),mr||(Ht=s)},Qi(),u.PTR_SIZE=4,h}),Kp=za;globalThis.self?.name===\"em-pthread\"&&za()});var Ra,jp,Ne,Ua,jn,Yp,Zp,Na,Qp,Ba,Va,Ma,Wa,xr=U(()=>{\"use strict\";$r();Ra= false||typeof location>\"u\"?void 0:location.origin,jp=()=>{if(true)return \"file:///home/kyeung/repos/personal/picture-editor/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\")?new URL(new URL(/* asset import */ __webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?3e05\"), __webpack_require__.b).href,Ra).href:\"file:///home/kyeung/repos/personal/picture-editor/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"},Ne=jp(),Ua=()=>{if(Ne&&!Ne.startsWith(\"blob:\"))return Ne.substring(0,Ne.lastIndexOf(\"/\")+1)},jn=(e,t)=>{try{let r=t??Ne;return(r?new URL(e,r):new URL(e)).origin===Ra}catch{return!1}},Yp=(e,t)=>{let r=t??Ne;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},Zp=(e,t)=>`${t??\"./\"}${e}`,Na=async e=>{let r=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(r)},Qp=async e=>(await import(/*webpackIgnore:true*/e)).default,Ba=(Pa(),br(Ea)).default,Va=async()=>{if(!Ne)throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");if(jn(Ne))return[void 0,Ba()];let e=await Na(Ne);return[e,Ba(e)]},Ma=(Da(),br(Oa)).default,Wa=async(e,t,r)=>{if(!e&&!t&&Ma&&Ne&&jn(Ne))return[void 0,Ma];{let n=\"ort-wasm-simd-threaded.jsep.mjs\",o=e??Yp(n,t),i= true&&r&&o&&!jn(o,t),a=i?await Na(o):o??Zp(n,t);return[i?a:void 0,await Qp(a)]}}});var Yn,Zn,zr,La,Xp,Jp,Sr,Ie,gt=U(()=>{\"use strict\";xr();Zn=!1,zr=!1,La=!1,Xp=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Jp=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Sr=async e=>{if(Zn)return Promise.resolve();if(zr)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(La)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");zr=!0;let t=e.initTimeout,r=e.numThreads;if(!Jp())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let n=Xp();r>1&&!n&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+r+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=r=1);let o=e.wasmPaths,i=typeof o==\"string\"?o:void 0,a=o?.mjs,d=a?.href??a,l=o?.wasm,p=l?.href??l,m=e.wasmBinary,[u,h]=await Wa(d,i,r>1),_=!1,y=[];if(t>0&&y.push(new Promise(g=>{setTimeout(()=>{_=!0,g()},t)})),y.push(new Promise((g,x)=>{let $={numThreads:r};if(m)$.wasmBinary=m;else if(p||i)$.locateFile=v=>p??i+v;else if(d&&d.indexOf(\"blob:\")!==0)$.locateFile=v=>new URL(v,d).href;else if(u){let v=Ua();v&&($.locateFile=S=>v+S)}h($).then(v=>{zr=!1,Zn=!0,Yn=v,g(),u&&URL.revokeObjectURL(u)},v=>{zr=!1,La=!0,x(v)})})),await Promise.race(y),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ie=()=>{if(Zn&&Yn)return Yn;throw new Error(\"WebAssembly is not initialized yet.\")}});var ke,jt,pe,Or=U(()=>{\"use strict\";gt();ke=(e,t)=>{let r=Ie(),n=r.lengthBytesUTF8(e)+1,o=r._malloc(n);return r.stringToUTF8(e,o,n),t.push(o),o},jt=(e,t,r,n)=>{if(typeof e==\"object\"&&e!==null){if(r.has(e))throw new Error(\"Circular reference in options\");r.add(e)}Object.entries(e).forEach(([o,i])=>{let a=t?t+o:o;if(typeof i==\"object\")jt(i,a+\".\",r,n);else if(typeof i==\"string\"||typeof i==\"number\")n(a,i.toString());else if(typeof i==\"boolean\")n(a,i?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},pe=e=>{let t=Ie(),r=t.stackSave();try{let n=t.PTR_SIZE,o=t.stackAlloc(2*n);t._OrtGetLastError(o,o+n);let i=Number(t.getValue(o,n===4?\"i32\":\"i64\")),a=t.getValue(o+n,\"*\"),d=a?t.UTF8ToString(a):\"\";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${d}`)}finally{t.stackRestore(r)}}});var Ga,Ha=U(()=>{\"use strict\";gt();Or();Ga=e=>{let t=Ie(),r=0,n=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let i=0;return e?.tag!==void 0&&(i=ke(e.tag,n)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,i),r===0&&pe(\"Can't create run options.\"),e?.extra!==void 0&&jt(e.extra,\"\",new WeakSet,(a,d)=>{let l=ke(a,n),p=ke(d,n);t._OrtAddRunConfigEntry(r,l,p)!==0&&pe(`Can't set a run config entry: ${a} - ${d}.`)}),[r,n]}catch(i){throw r!==0&&t._OrtReleaseRunOptions(r),n.forEach(a=>t._free(a)),i}}});var em,tm,rm,nm,Fa,qa=U(()=>{\"use strict\";gt();Or();em=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},tm=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},rm=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(r=>(typeof r==\"string\"?r:r.name)===\"webgpu\")&&(e.enableMemPattern=!1)},nm=(e,t,r)=>{for(let n of t){let o=typeof n==\"string\"?n:n.name;switch(o){case\"webnn\":if(o=\"WEBNN\",typeof n!=\"string\"){let d=n?.deviceType;if(d){let l=ke(\"deviceType\",r),p=ke(d,r);Ie()._OrtAddSessionConfigEntry(e,l,p)!==0&&pe(`Can't set a session config entry: 'deviceType' - ${d}.`)}}break;case\"webgpu\":if(o=\"JS\",typeof n!=\"string\"){let a=n;if(a?.preferredLayout){if(a.preferredLayout!==\"NCHW\"&&a.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${a.preferredLayout}`);let d=ke(\"preferredLayout\",r),l=ke(a.preferredLayout,r);Ie()._OrtAddSessionConfigEntry(e,d,l)!==0&&pe(`Can't set a session config entry: 'preferredLayout' - ${a.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${o}`)}let i=ke(o,r);Ie()._OrtAppendExecutionProvider(e,i)!==0&&pe(`Can't append execution provider: ${o}.`)}},Fa=e=>{let t=Ie(),r=0,n=[],o=e||{};rm(o);try{let i=em(o.graphOptimizationLevel??\"all\"),a=tm(o.executionMode??\"sequential\"),d=typeof o.logId==\"string\"?ke(o.logId,n):0,l=o.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let p=o.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let m=typeof o.optimizedModelFilePath==\"string\"?ke(o.optimizedModelFilePath,n):0;if(r=t._OrtCreateSessionOptions(i,!!o.enableCpuMemArena,!!o.enableMemPattern,a,!!o.enableProfiling,0,d,l,p,m),r===0&&pe(\"Can't create session options.\"),o.executionProviders&&nm(r,o.executionProviders,n),o.enableGraphCapture!==void 0){if(typeof o.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);let u=ke(\"enableGraphCapture\",n),h=ke(o.enableGraphCapture.toString(),n);t._OrtAddSessionConfigEntry(r,u,h)!==0&&pe(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(let[u,h]of Object.entries(o.freeDimensionOverrides)){if(typeof u!=\"string\")throw new Error(`free dimension override name must be a string: ${u}`);if(typeof h!=\"number\"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let _=ke(u,n);t._OrtAddFreeDimensionOverride(r,_,h)!==0&&pe(`Can't set a free dimension override: ${u} - ${h}.`)}return o.extra!==void 0&&jt(o.extra,\"\",new WeakSet,(u,h)=>{let _=ke(u,n),y=ke(h,n);t._OrtAddSessionConfigEntry(r,_,y)!==0&&pe(`Can't set a session config entry: ${u} - ${h}.`)}),[r,n]}catch(i){throw r!==0&&t._OrtReleaseSessionOptions(r)!==0&&pe(\"Can't release session options.\"),n.forEach(a=>t._free(a)),i}}});var Yt,bt,Ct,Dr,Zt,Br,Mr,Qn,te=U(()=>{\"use strict\";Yt=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;case\"int4\":return 22;case\"uint4\":return 21;default:throw new Error(`unsupported data type: ${e}`)}},bt=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";case 22:return\"int4\";case 21:return\"uint4\";default:throw new Error(`unsupported data type: ${e}`)}},Ct=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n=typeof t==\"number\"?t:t.reduce((o,i)=>o*i,1);return r>0?Math.ceil(n*r):void 0},Dr=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Zt=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Br=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Mr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint64\"||e===\"int8\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Qn=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;case\"ml-tensor\":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var Qt,Xn=U(()=>{\"use strict\";$r();Qt=async e=>{if(typeof e==\"string\")if(false){}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get(\"Content-Length\"),n=r?parseInt(r,10):0;if(n<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let o=t.body.getReader(),i;try{i=new ArrayBuffer(n)}catch(d){if(d instanceof RangeError){let l=Math.ceil(n/65536);i=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw d}let a=0;for(;;){let{done:d,value:l}=await o.read();if(d)break;let p=l.byteLength;new Uint8Array(i,a,p).set(l),a+=p}return new Uint8Array(i,0,n)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var om,im,Ka,ja,Rr,am,ue,et=U(()=>{\"use strict\";te();om=[\"V\",\"I\",\"W\",\"E\",\"F\"],im=(e,t)=>{console.log(`[${om[e]},${new Date().toISOString()}]${t}`)},Rr=(e,t)=>{Ka=e,ja=t},am=(e,t)=>{let r=Zt(e),n=Zt(Ka);r>=n&&im(r,typeof t==\"function\"?t():t)},ue=(...e)=>{ja&&am(...e)}});var Ur,Jn=U(()=>{\"use strict\";te();Ur=(e,t)=>new(Dr(t))(e)});var Nr=U(()=>{\"use strict\"});var Ya,eo,to,sm,um,Za,no,ro,Xa,Ja=U(()=>{\"use strict\";et();Nr();Ya=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),eo=[],to=e=>Math.ceil(Number(e)/16)*16,sm=e=>{for(let t=0;t<eo.length;t++){let r=eo[t];if(e<=r)return r}return Math.ceil(e/16)*16},um=1,Za=()=>um++,no=async(e,t,r,n)=>{let o=to(r),i=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,i,0,o),e.flush(),await i.mapAsync(GPUMapMode.READ);let d=i.getMappedRange();if(n){let l=n();return l.set(new Uint8Array(d,0,r)),l}else return new Uint8Array(d.slice(0,r))}finally{i.destroy()}},ro=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[r]of Ya)eo.push(r),this.freeBuffers.set(r,[]),this.freeUniformBuffers.set(r,[]);this.sessionCount=0}upload(t,r){let n=r.buffer,o=r.byteOffset,i=r.byteLength,a=to(i),d=this.storageCache.get(t);if(!d)throw new Error(\"gpu data for uploading does not exist\");if(Number(d.originalSize)!==i)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${i}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=l.getMappedRange();new Uint8Array(p).set(new Uint8Array(n,o,i)),l.unmap();let m=this.backend.device.createCommandEncoder();m.copyBufferToBuffer(l,0,d.gpuData.buffer,0,a),this.backend.device.queue.submit([m.finish()]),l.destroy(),ue(\"verbose\",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,r){let n=this.storageCache.get(t);if(!n)throw new Error(\"source gpu data for memcpy does not exist\");let o=this.storageCache.get(r);if(!o)throw new Error(\"destination gpu data for memcpy does not exist\");if(n.originalSize!==o.originalSize)throw new Error(\"inconsistent source and destination gpu data size\");let i=to(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,o.gpuData.buffer,0,i)}registerExternalBuffer(t,r,n){let o;if(n){if(o=n[0],t===n[1])return ue(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`),o;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`)}else o=Za();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:r}),ue(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),ue(\"verbose\",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=sm(t),o,i=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||a){let p=(i?this.freeBuffers:this.freeUniformBuffers).get(n);p?p.length>0?o=p.pop():o=this.backend.device.createBuffer({size:n,usage:r}):o=this.backend.device.createBuffer({size:n,usage:r})}else o=this.backend.device.createBuffer({size:n,usage:r});let d={id:Za(),type:0,buffer:o};return this.storageCache.set(d.id,{gpuData:d,originalSize:Number(t)}),ue(\"verbose\",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=typeof t==\"bigint\"?Number(t):t,n=this.storageCache.get(r);if(!n){if(this.storageCache.size===0)return 0;throw new Error(\"releasing data does not exist\")}return ue(\"verbose\",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(t,r){let n=this.storageCache.get(Number(t));if(!n)throw new Error(\"data does not exist\");await no(this.backend,n.gpuData.buffer,n.originalSize,r)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus===\"default\"){for(let t of this.buffersPending){let r=Ya.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(t.size)||[];r===void 0||n.length>=r?t.destroy():n.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(t.size)||[];r===void 0||n.length>=r?t.destroy():n.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let r of this.buffersPending)t.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let r=this.capturedPendingBuffers.get(t);r&&(r.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(ue(\"warning\",()=>\"[WebGPU] Clearing webgpu buffer cache\"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Xa=(...e)=>new ro(...e)});var oo,re,Se=U(()=>{\"use strict\";oo=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(\";\")),this.key}},re=e=>new oo(e)});var io,tt,C,At,Vr,es,ts,oe=U(()=>{\"use strict\";io=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},tt=class{static calcShape(t,r,n=!1){let o=t.length,i=r.length;if(o===0)return r;if(i===0)return t;let a=Math.max(t.length,r.length),d=new Array(a);if(n){if(o<2||i<2)return;let l=io.calcMatMulShape([t[o-2],t[o-1]],[r[i-2],r[i-1]]);if(l===void 0)return;[d[a-2],d[a-1]]=l}for(let l=n?3:1;l<=a;l++){let p=o-l<0?1:t[o-l],m=i-l<0?1:r[i-l];if(p!==m&&p>1&&m>1)return;let u=Math.max(p,m);if(p&&m)d[a-l]=Math.max(p,m);else{if(u>1)return;d[a-l]=0}}return d}static isValidBroadcast(t,r){let n=t.length,o=r.length;if(n>o)return!1;for(let i=1;i<=n;i++)if(t[n-i]!==1&&t[n-i]!==r[o-i])return!1;return!0}},C=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let n=t.length;if(n===0)return[];let o=new Array(n),i=n-1;for(;i>=0;){if(t[i]%r===0){o[i]=t[i]/r;break}if(r%t[i]!==0)throw new Error(\"cannot convert shape\");o[i]=1,r/=t[i],i--}for(i--;i>=0;i--)o[i]=t[i];return o}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,n){let o=1;for(let i=r;i<n;i++){if(t[i]<0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");o*=Number(t[i])}return o}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let n=new Array(r);n[r-1]=1,n[r-2]=t[r-1];for(let o=r-3;o>=0;--o)n[o]=n[o+1]*t[o+1];return n}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error(\"unsupported axis for this operation.\");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(n=>this.normalizeAxis(n,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(n=>t[n]):t.slice().reverse()}static padShape(t,r){let n=t.length;return t.map((o,i)=>o+r[i]+r[i+n])}static areEqual(t,r){return t.length!==r.length?!1:t.every((n,o)=>n===r[o])}},At=class e{static adjustPoolAttributes(t,r,n,o,i,a){if(!t&&n.length!==r.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let d=0;d<r.length-2;d++)d>=n.length?n.push(r[d+2]):n[d]=r[d+2];for(let d=0;d<n.length;d++)if(d<o.length){if(o[d]<0)throw new Error(\"strides should be greater than or equal to 1\")}else o.push(1);for(let d=0;d<n.length;d++)if(d<i.length){if(i[d]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else i.push(1);for(let d=0;d<n.length*2;d++)if(d<a.length){if(a[d]<0)throw new Error(\"pad should be greater than or equal to 1\")}else a.push(0);for(let d=0;d<n.length;d++){if(n[d]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(a[d]>=n[d]||a[d+n.length]>=n[d])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,r,n,o,i,a,d){if(d){if(i.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(r.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(o.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(a?1:2)],r[l],n[l],o[l],i,l,l+t.length-2,d)}}static computePoolOutputShape(t,r,n,o,i,a,d){if(r.length<=0)throw new Error(\"input shape must be of size greater than 0\");let l=[r[0],r[1]];return e.computeShapeHelper(t,r,l,n,o,i,a,d),l}static computeConvOutputShape(t,r,n,o,i,a,d){if(t.length<=0||r.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");let l=[t[0],r[0]];return e.computeShapeHelper(!1,t,l,n,o,i,a,d),l}static computeShapeHelper(t,r,n,o,i,a,d,l){if(t)for(let p=0;p<r.length-2;p++)n.push(1);else for(let p=0;p<r.length-2;p++)n.push(e.adjustPadAndReturnShape(r[p+2],o[p],i[p],a[p],d,p,p+r.length-2,l))}static adjustPadAndReturnShape(t,r,n,o,i,a,d,l){let p=n*(o-1)+1;if(l&&l!==\"NOTSET\")switch(l){case\"VALID\":return i[a]=0,i[d]=0,Math.floor((t-p)/r+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(n!==1)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{let u=((t+r-1)/r-1)*r+o-t;return i[a]=Math.floor(l===\"SAME_LOWER\"?(u+1)/2:u/2),i[d]=u-i[a],Math.floor((t+u-o)/r+1)}default:throw new Error(\"Unsupported AutoPad type\")}else return Math.floor((t+i[a]+i[d]-p)/r+1)}},Vr=class{static getShapeOfGemmResult(t,r,n,o,i){if(t.length!==2||n.length!==2)throw new Error(\"shape need to be of size 2\");let a,d,l;r?(a=t[1],d=t[0]):(a=t[0],d=t[1]);let p=-1;if(o?(l=n[0],p=1):(l=n[1],p=0),n[p]!==d)throw new Error(\"dimension mismatch\");if(a<=0||l<=0||d<=0)throw new Error(\"invalid shape specified\");if(i&&!tt.isValidBroadcast(i,[a,l]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[a,l,d]}},es=-34028234663852886e22,ts=34028234663852886e22});var kt,so,_e,Ee,N,me,uo,Et,Fe,F,Wr,E,M,rs,Lr,ao,ns,ae=U(()=>{\"use strict\";te();oe();kt=64,so=(e,t)=>{if(t===3)throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:\"f16\";case 1:return t>1?`vec${t}<f32>`:\"f32\";case 6:return t>1?`vec${t}<i32>`:\"i32\";case 12:return t>1?`vec${t}<u32>`:\"u32\";case 7:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"i32\"];case 13:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"u32\"];case 9:if(t!==4)throw new Error(\"bool must be vec4\");return[\"u32\",\"vec4<bool>\"];case 22:return\"i32\";case 21:return\"u32\";default:throw new Error(`Unknown data type: ${e}`)}},_e=(e,t=1)=>{let r=so(e,t);return typeof r==\"string\"?r:r[0]},Ee=(e,t=1)=>{let r=so(e,t);return typeof r==\"string\"?r:r[1]},N=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:C.computeStrides(r)})}),t},me=e=>e%4===0?4:e%2===0?2:1,uo=(e=\"f32\",t,r=\"0\")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Et=(e,t,r)=>e===\"f32\"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,Fe=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,F=(e,t,r,n)=>e.startsWith(\"uniforms.\")&&r>4?typeof t==\"string\"?n===\"f16\"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:n===\"f16\"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Wr=(e,t,r,n,o)=>{let i=typeof r==\"number\",a=i?r:r.length,d=[...new Array(a).keys()],l=a<2?\"u32\":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,p=so(t,o),m=typeof p==\"string\"?p:p[1],u=typeof p==\"string\"?p:p[0],h={indices:l,value:m,storage:u,tensor:t},_=W=>typeof W==\"string\"?W:`${W}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},g=i?\"uniforms.\":\"\",x=`${g}${e}_shape`,$=`${g}${e}_strides`,v=\"\";for(let W=0;W<a-1;W++)v+=`\n    let dim${W} = current / ${F($,W,a)};\n    let rest${W} = current % ${F($,W,a)};\n    indices[${W}] = dim${W};\n    current = rest${W};\n    `;v+=`indices[${a-1}] = current;`;let S=a<2?\"\":`\n  fn o2i_${e}(offset: u32) -> ${h.indices} {\n    var indices: ${h.indices};\n    var current = offset;\n    ${v}\n    return indices;\n  }`,T=W=>(y.offsetToIndices=!0,a<2?W:`o2i_${e}(${W})`),A=[];if(a>=2)for(let W=a-1;W>=0;W--)A.push(`${F($,W,a)} * (indices[${W}])`);let k=a<2?\"\":`\n  fn i2o_${e}(indices: ${h.indices}) -> u32 {\n    return ${A.join(\"+\")};\n  }`,P=W=>(y.indicesToOffset=!0,a<2?W:`i2o_${e}(${W})`),D=(...W)=>a===0?\"0u\":`${h.indices}(${W.map(_).join(\",\")})`,R=(W,q)=>a<2?`${W}`:`${F(W,q,a)}`,G=(W,q,he)=>a<2?`${W}=${he};`:`${F(W,q,a)}=${he};`,K={},j=(W,q)=>{y.broadcastedIndicesToOffset=!0;let he=`${q.name}broadcastedIndicesTo${e}Offset`;if(he in K)return`${he}(${W})`;let Ge=[];for(let we=a-1;we>=0;we--){let ye=q.indicesGet(\"outputIndices\",we+q.rank-a);Ge.push(`${R($,we)} * (${ye} % ${R(x,we)})`)}return K[he]=`fn ${he}(outputIndices: ${q.type.indices}) -> u32 {\n             return ${Ge.length>0?Ge.join(\"+\"):\"0u\"};\n           }`,`${he}(${W})`},V=(W,q)=>(()=>{if(h.storage===h.value)return`${e}[${W}]=${q};`;if(h.storage===\"vec2<u32>\"&&h.value===\"i32\")return`${e}[${W}]=vec2<u32>(u32(${q}), select(0u, 0xFFFFFFFFu, ${q} < 0));`;if(h.storage===\"vec2<u32>\"&&h.value===\"u32\")return`${e}[${W}]=vec2<u32>(u32(${q}), 0u);`;if(h.storage===\"u32\"&&h.value===\"vec4<bool>\")return`${e}[${W}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${q}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),Q=W=>(()=>{if(h.storage===h.value)return`${e}[${W}]`;if(h.storage===\"vec2<u32>\"&&h.value===\"i32\")return`i32(${e}[${W}].x)`;if(h.storage===\"vec2<u32>\"&&h.value===\"u32\")return`u32(${e}[${W}].x)`;if(h.storage===\"u32\"&&h.value===\"vec4<bool>\")return`vec4<bool>(bool(${e}[${W}] & 0xFFu), bool(${e}[${W}] & 0xFF00u), bool(${e}[${W}] & 0xFF0000u), bool(${e}[${W}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),se=a<2?\"\":`\n  fn get_${e}ByIndices(indices: ${h.indices}) -> ${m} {\n    return ${Q(`i2o_${e}(indices)`)};\n  }`,Y=a<2?\"\":(()=>{let W=d.map(he=>`d${he}: u32`).join(\", \"),q=d.map(he=>`d${he}`).join(\", \");return`\n  fn get_${e}(${W}) -> ${m} {\n    return get_${e}ByIndices(${D(q)});\n  }`})(),ee=(...W)=>{if(W.length!==a)throw new Error(`indices length must be ${a}`);let q=W.map(_).join(\",\");return a===0?Q(\"0u\"):a===1?Q(q[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}(${q})`)},J=W=>a<2?Q(W):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}ByIndices(${W})`),ne=a<2?\"\":`\n  fn set_${e}ByIndices(indices: ${h.indices}, value: ${m}) {\n    ${V(`i2o_${e}(indices)`,\"value\")}\n  }`,be=a<2?\"\":(()=>{let W=d.map(he=>`d${he}: u32`).join(\", \"),q=d.map(he=>`d${he}`).join(\", \");return`\n  fn set_${e}(${W}, value: ${m}) {\n    set_${e}ByIndices(${D(q)}, value);\n  }`})();return{impl:()=>{let W=[],q=!1;return y.offsetToIndices&&(W.push(S),q=!0),y.indicesToOffset&&(W.push(k),q=!0),y.broadcastedIndicesToOffset&&(Object.values(K).forEach(he=>W.push(he)),q=!0),y.set&&(W.push(be),q=!0),y.setByIndices&&(W.push(ne),q=!0),y.get&&(W.push(Y),q=!0),y.getByIndices&&(W.push(se),q=!0),!i&&q&&W.unshift(`const ${x} = ${h.indices}(${r.join(\",\")});`,`const ${$} = ${h.indices}(${C.computeStrides(r).join(\",\")});`),W.join(`\n`)},type:h,offsetToIndices:T,indicesToOffset:P,broadcastedIndicesToOffset:j,indices:D,indicesGet:R,indicesSet:G,set:(...W)=>{if(W.length!==a+1)throw new Error(`indices length must be ${a}`);let q=W[a];if(typeof q!=\"string\")throw new Error(\"value must be string\");let he=W.slice(0,a).map(_).join(\",\");return a===0?V(\"0u\",q):a===1?V(he[0],q):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}(${he}, ${q})`)},setByOffset:V,setByIndices:(W,q)=>a<2?V(W,q):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}ByIndices(${W}, ${q});`),get:ee,getByOffset:Q,getByIndices:J,usage:n,name:e,strides:$,shape:x,rank:a}},E=(e,t,r,n=1)=>Wr(e,t,r,\"input\",n),M=(e,t,r,n=1)=>Wr(e,t,r,\"output\",n),rs=(e,t,r)=>Wr(e,t,r,\"atomicOutput\",1),Lr=(e,t,r,n=1)=>Wr(e,t,r,\"internal\",n),ao=class{constructor(t,r){this.normalizedDispatchGroup=t;this.limits=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t==\"number\"?`${t}u`:t}) { return; }`}mainStart(t=kt){let r=typeof t==\"number\"?t:t[0],n=typeof t==\"number\"?1:t[1],o=typeof t==\"number\"?1:t[2];if(r>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||o>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(r*n*o>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=i?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=i?`let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${r*n*o}u + local_idx;`;return`@compute @workgroup_size(${r}, ${n}, ${o})\n  fn main(${a}) {\n    ${d}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.shape.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}),t.strides.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.strides.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}))}declareVariable(t,r){if(t.usage===\"internal\")throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage===\"input\"?\"read\":\"read_write\",o=t.usage===\"atomicOutput\"?\"atomic<i32>\":t.type.storage;return`@group(0) @binding(${r}) var<storage, ${n}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!==\"internal\")throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,n=1){return this.uniforms.push({name:t,type:r,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return\"\";let t=[];for(let{name:r,type:n,length:o}of this.uniforms)if(o&&o>4)n===\"f16\"?t.push(`@align(16) ${r}:array<mat2x4<${n}>, ${Math.ceil(o/8)}>`):t.push(`${r}:array<vec4<${n}>, ${Math.ceil(o/4)}>`);else{let i=o==null||o===1?n:`vec${o}<${n}>`;t.push(`${r}:${i}`)}return`\n      struct Uniforms { ${t.join(\", \")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=r=>[12,10,1,6][[\"u32\",\"f16\",\"f32\",\"i32\"].indexOf(r)];return this.uniforms.map(r=>[t(r.type),r.length??1])}},ns=(e,t)=>new ao(e,t)});var dm,os,lm,cm,pm,mm,Pe,is,as,dt=U(()=>{\"use strict\";te();oe();Se();ae();dm=(e,t)=>{if(!e||e.length!==1)throw new Error(\"Transpose requires 1 input.\");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},os=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),lm=(e,t)=>C.sortBasedOnPerm(e,os(e.length,t)),cm=(e,t,r,n)=>{let o=`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`;for(let i=0;i<t;++i)o+=`a[${e[i]}]=i[${i}];`;return o+=\"return a;}\"},pm=(e,t)=>{let r=[],n=[];for(let o=0;o<e.length;++o)e[o]!==1&&r.push(e[o]),e[t[o]]!==1&&n.push(t[o]);return{newShape:r,newPerm:n}},mm=(e,t)=>{let r=0;for(let n=0;n<e.length;++n)if(t[e[n]]!==1){if(e[n]<r)return!1;r=e[n]}return!0},Pe=(e,t)=>{let r=e.dataType,n=e.dims.length,o=os(n,t),i=lm(e.dims,o),a=e.dims,d=i,l=n<2||mm(o,e.dims),p;if(l)return p=g=>{let x=E(\"input\",r,a,4),$=M(\"output\",r,d,4);return`\n  ${g.registerUniform(\"output_size\",\"u32\").declareVariables(x,$)}\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    output[global_idx] = input[global_idx];\n  }`},{name:\"TransposeCopy\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let g=C.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64/4)},programUniforms:[{type:12,data:Math.ceil(g/4)}]}},getShaderSource:p};let{newShape:m,newPerm:u}=pm(e.dims,o),h=C.areEqual(u,[2,3,1]),_=C.areEqual(u,[3,1,2]);if(m.length===2||h||_){a=h?[m[0],m[1]*m[2]]:_?[m[0]*m[1],m[2]]:m,d=[a[1],a[0]];let g=16;return p=x=>{let $=E(\"a\",r,a.length),v=M(\"output\",r,d.length);return`\n  ${x.registerUniform(\"output_size\",\"u32\").declareVariables($,v)}\n  var<workgroup> tile : array<array<${v.type.value}, ${g+1}>, ${g}>;\n  ${x.mainStart([g,g,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${g} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${g}u + local_id.x;\n    let input_row = workgroup_id_x * ${g}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${$.getByIndices(`${$.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${g}u + local_id.x;\n    let output_row = workgroup_id_y * ${g}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${v.setByIndices(`${v.type.indices}(output_row, output_col)`,\"tile[local_id.x][local_id.y]\")}\n    }\n  }`},{name:\"TransposeShared\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let x=C.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d[1]/g),y:Math.ceil(d[0]/g)},programUniforms:[{type:12,data:x},...N(a,d)]}},getShaderSource:p}}return p=g=>{let x=E(\"a\",r,a.length),$=M(\"output\",r,d.length);return`\n  ${g.registerUniform(\"output_size\",\"u32\").declareVariables(x,$)}\n\n  ${cm(o,n,x,$)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${$.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${$.setByOffset(\"global_idx\",x.getByIndices(\"aIndices\"))}\n  }`},{name:\"Transpose\",shaderCache:{hint:`${t}`,inputDependencies:[\"rank\"]},getRunData:()=>{let g=C.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:12,data:g},...N(a,d)]}},getShaderSource:p}},is=(e,t)=>{dm(e.inputs,t.perm),e.compute(Pe(e.inputs[0],t.perm))},as=e=>re({perm:e.perm})});var fm,hm,gm,bm,ym,_m,wm,vm,$m,xm,rt,ss,us,ds,ls,cs,ps,ms,fs,hs,gs,bs=U(()=>{\"use strict\";te();oe();ae();Gr();dt();fm={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate * candidate\",logSumExp:\"bestValue + exp(candidate)\",l1:\"bestValue + abs(candidate)\",l2:\"bestValue + candidate * candidate\",logSum:\"bestValue + candidate\"},hm={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate\",logSumExp:\"bestValue + candidate\",l1:\"bestValue + candidate\",l2:\"bestValue + candidate\",logSum:\"bestValue + candidate\"},gm={max:\"_A[offset]\",min:\"_A[offset]\",mean:\"0\",sum:\"0\",prod:\"1\",sumSquare:\"0\",logSumExp:\"0\",l1:\"0\",l2:\"0\",logSum:\"0\"},bm={max:\"bestValue\",min:\"bestValue\",sum:\"bestValue\",prod:\"bestValue\",sumSquare:\"bestValue\",logSumExp:\"log(bestValue)\",l1:\"bestValue\",l2:\"sqrt(bestValue)\",logSum:\"log(bestValue)\"},ym=(e,t)=>{let r=[];for(let n=t-e;n<t;++n)r.push(n);return r},_m=(e,t)=>{let r=[],n=e.length;for(let i=0;i<n;i++)t.indexOf(i)===-1&&r.push(e[i]);let o=t.map(i=>e[i]);return[r,o]},wm=(e,t)=>{let r=e.length+t.length,n=[],o=0;for(let i=0;i<r;i++)t.indexOf(i)===-1?n.push(e[o++]):n.push(1);return n},vm=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},$m=(e,t)=>{let r=[];if(!vm(e,t)){for(let n=0;n<t;++n)e.indexOf(n)===-1&&r.push(n);e.forEach(n=>r.push(n))}return r},xm=(e,t,r,n,o,i,a)=>{let d=r[0].dims,l=C.size(i),p=C.size(a),m=E(\"_A\",r[0].dataType,d),u=M(\"output\",o,i),h=64;l===1&&(h=256);let _=`\n          var<workgroup> aBestValues : array<f32, ${h}>;\n       `,y=g=>`\n        ${g.registerUniform(\"reduceSize\",\"u32\").declareVariables(m,u)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${g.mainStart(h)}\n\n          let outputIndex = global_idx / ${h};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${gm[n]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${h}) {\n           let candidate = f32(${m.getByOffset(\"offset + k\")});\n           bestValue = ${fm[n]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${h}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${hm[n]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${u.setByOffset(\"outputIndex\",`${n===\"mean\"?`${u.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${u.type.storage}(${bm[n]})`}`)};\n         }\n        }`;return{name:e,shaderCache:{hint:`${t};${h}`,inputDependencies:[\"type\"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:l},programUniforms:[{type:12,data:p}]})}},rt=(e,t,r,n)=>{let o=e.inputs.length===1?r:lo(e.inputs,r),i=o.axes;i.length===0&&!o.noopWithEmptyAxes&&(i=e.inputs[0].dims.map((_,y)=>y));let a=C.normalizeAxes(i,e.inputs[0].dims.length),d=a,l=e.inputs[0],p=$m(d,e.inputs[0].dims.length);p.length>0&&(l=e.compute(Pe(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=ym(d.length,l.dims.length));let[m,u]=_m(l.dims,d),h=m;o.keepDims&&(h=wm(m,a)),e.compute(xm(t,o.cacheKey,[l],n,e.inputs[0].dataType,h,u),{inputs:[l]})},ss=(e,t)=>{rt(e,\"ReduceMeanShared\",t,\"mean\")},us=(e,t)=>{rt(e,\"ReduceL1Shared\",t,\"l1\")},ds=(e,t)=>{rt(e,\"ReduceL2Shared\",t,\"l2\")},ls=(e,t)=>{rt(e,\"ReduceLogSumExpShared\",t,\"logSumExp\")},cs=(e,t)=>{rt(e,\"ReduceMaxShared\",t,\"max\")},ps=(e,t)=>{rt(e,\"ReduceMinShared\",t,\"min\")},ms=(e,t)=>{rt(e,\"ReduceProdShared\",t,\"prod\")},fs=(e,t)=>{rt(e,\"ReduceSumShared\",t,\"sum\")},hs=(e,t)=>{rt(e,\"ReduceSumSquareShared\",t,\"sumSquare\")},gs=(e,t)=>{rt(e,\"ReduceLogSumShared\",t,\"logSum\")}});var nt,Sm,Hr,lo,ot,Tm,Im,Cm,Am,km,Em,Pm,zm,Om,Dm,it,ys,_s,ws,vs,$s,xs,Ss,Ts,Is,Cs,Gr=U(()=>{\"use strict\";te();oe();Se();ae();bs();nt=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"Reduce op requires 1 or 2 inputs.\");if(e.length===2&&e[1].dims.length!==1)throw new Error(\"Invalid axes input dims.\")},Sm=e=>[\"\",\"\",`var value = ${e.getByIndices(\"input_indices\")};`,\"\"],Hr=(e,t,r,n,o,i,a=!1,d=!1)=>{let l=[],p=r[0].dims,m=p.length,u=C.normalizeAxes(o,m),h=!d&&u.length===0;p.forEach((x,$)=>{h||u.indexOf($)>=0?a&&l.push(1):l.push(x)});let _=l.length,y=C.size(l);return{name:e,shaderCache:t,getShaderSource:x=>{let $=[],v=E(\"_A\",r[0].dataType,m),S=M(\"output\",i,_),T=n(v,S,u),A=T[2];for(let k=0,P=0;k<m;k++)h||u.indexOf(k)>=0?(a&&P++,A=`for(var j${k}: u32 = 0; j${k} < ${p[k]}; j${k}++) {\n                  ${T[2].includes(\"last_index\")?`let last_index = j${k};`:\"\"}\n                  ${v.indicesSet(\"input_indices\",k,`j${k}`)}\n                  ${A}\n                }`):($.push(`${v.indicesSet(\"input_indices\",k,S.indicesGet(\"output_indices\",P))};`),P++);return`\n\n        ${x.registerUniform(\"output_size\",\"u32\").declareVariables(v,S)}\n\n        ${x.mainStart()}\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var input_indices: ${v.type.indices};\n          let output_indices = ${S.offsetToIndices(\"global_idx\")};\n\n          ${$.join(`\n`)}\n          ${T[0]}       // init ops for reduce max/min\n          ${T[1]}\n          ${A}\n          ${T[3]}\n          ${T.length===4?S.setByOffset(\"global_idx\",\"value\"):T.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...N(p,l)]})}},lo=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),re({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ot=(e,t,r,n)=>{let o=e.inputs,i=o.length===1?r:lo(o,r);e.compute(Hr(t,{hint:i.cacheKey,inputDependencies:[\"rank\"]},[o[0]],i.noopWithEmptyAxes&&i.axes.length===0?Sm:n,i.axes,o[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Tm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceLogSum\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${n.getByIndices(\"input_indices\")};`,\"value = log(value);\"])},Im=(e,t)=>{nt(e.inputs),ot(e,\"ReduceL1\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += abs(${n.getByIndices(\"input_indices\")});`,\"\"])},Cm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceL2\",t,(n,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${n.getByIndices(\"input_indices\")}; value += (t * t);`,\"value = sqrt(value);\"])},Am=(e,t)=>{nt(e.inputs),ot(e,\"ReduceLogSumExp\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += exp(${n.getByIndices(\"input_indices\")});`,\"value = log(value);\"])},km=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMax\",t,(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(n.indicesSet(\"input_indices\",d,0));return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};`,`value = max(value, ${n.getByIndices(\"input_indices\")});`,\"\"]})},Em=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMean\",t,(n,o,i)=>{let a=1;for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&(a*=e.inputs[0].dims[d]);return[\"var sum = f32(0);\",\"\",`sum += f32(${n.getByIndices(\"input_indices\")});`,`let value = ${o.type.value}(sum / ${a});`]})},Pm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceMin\",t,(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};`,`value = min(value, ${n.getByIndices(\"input_indices\")});`,\"\"]})},zm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceProd\",t,(n,o)=>[`var value = ${o.type.storage}(1);`,\"\",`value *= ${n.getByIndices(\"input_indices\")};`,\"\"])},Om=(e,t)=>{nt(e.inputs),ot(e,\"ReduceSum\",t,(n,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${n.getByIndices(\"input_indices\")};`,\"\"])},Dm=(e,t)=>{nt(e.inputs),ot(e,\"ReduceSumSquare\",t,(n,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${n.getByIndices(\"input_indices\")}; value += t * t;`,\"\"])},it=(e,t,r)=>{if(t.length===0)return r;let n=1,o=1;for(let i=0;i<t.length;i++)t.indexOf(i)===-1?n*=e[i]:o*=e[i];return o<32&&n>1024},ys=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Em(e,t):ss(e,t)},_s=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Im(e,t):us(e,t)},ws=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cm(e,t):ds(e,t)},vs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Am(e,t):ls(e,t)},$s=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?km(e,t):cs(e,t)},xs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Pm(e,t):ps(e,t)},Ss=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?zm(e,t):ms(e,t)},Ts=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Om(e,t):fs(e,t)},Is=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Dm(e,t):hs(e,t)},Cs=(e,t)=>{it(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Tm(e,t):gs(e,t)}});var As,ks,Es,co,Ps=U(()=>{\"use strict\";te();Se();Gr();As=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");if(e[0].dataType!==1)throw new Error(\"Invalid input type.\")},ks=(e,t)=>{As(e.inputs);let r=(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\"<=\":\"<\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Hr(\"ArgMin\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Es=(e,t)=>{As(e.inputs);let r=(n,o,i)=>{let a=[];for(let d=0;d<n.rank;d++)(i.indexOf(d)>=0||i.length===0)&&a.push(`input_indices[${d}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\">=\":\">\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Hr(\"argMax\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},co=e=>re(e)});var Bm,po,Mm,Rm,Um,Rt,Nm,zs,Fr=U(()=>{\"use strict\";te();oe();Nr();ae();Bm=(e,t)=>{let r=e[0],n=e[1],o=e[2],i=e[3],a=e[4],d=e[5];if(a&&d)throw new Error(\"Attention cannot have both past and attention_bias\");if(r.dims.length!==3)throw new Error('Input \"input\" must have 3 dimensions');let l=r.dims[0],p=r.dims[1],m=r.dims[2];if(o.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimensions');if(n.dims.length!==2)throw new Error('Input \"weights\" is expected to have 2 dimensions');if(n.dims[0]!==m)throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");if(o.dims[0]!==n.dims[1])throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');let u=o.dims[0]/3,h=u,_=h;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");for(let S of t.qkvHiddenSizes)if(S%t.numHeads!==0)throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");u=t.qkvHiddenSizes[0],h=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let y=p;if(u!==h)throw new Error(\"qkv_hidden_sizes first element should be same as the second\");if(o.dims[0]!==u+h+_)throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');let g=0;if(a){if(h!==_)throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');if(a.dims.length!==5)throw new Error('Input \"past\" must have 5 dimensions');if(a.dims[0]!==2)throw new Error('Input \"past\" first dimension must be 2');if(a.dims[1]!==l)throw new Error('Input \"past\" second dimension must be batch_size');if(a.dims[2]!==t.numHeads)throw new Error('Input \"past\" third dimension must be num_heads');if(a.dims[4]!==h/t.numHeads)throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(g=a.dims[3])}let x=y+g,$=-1,v=0;if(i)throw new Error(\"Mask not supported\");if(a)throw new Error(\"past is not supported\");if(d){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" must have 4 dimensions');if(d.dims[0]!==l||d.dims[1]!==t.numHeads||d.dims[2]!==p||d.dims[3]!==x)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:p,pastSequenceLength:g,kvSequenceLength:y,totalSequenceLength:x,maxSequenceLength:$,inputHiddenSize:m,hiddenSize:u,vHiddenSize:_,headSize:Math.floor(u/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:v,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},po=(e,t,r)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset(\"0\")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset(\"batchIdx\")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${r?\"let past_sequence_length = uniforms.past_sequence_length\":\"\"};\n    let present_sequence_length = total_sequence_length;\n    `,Mm=(e,t,r,n,o,i,a,d)=>{let l=me(a?1:i),p=64,m=i/l;m<p&&(p=32);let u=Math.ceil(i/l/p),h=[{type:12,data:t},{type:12,data:r},{type:12,data:n},{type:12,data:o},{type:12,data:m},{type:12,data:u}],_=_e(e.dataType,l),y=Ee(1,l),g=[\"type\"];a&&g.push(\"type\"),d&&g.push(\"type\");let x=$=>{let v=M(\"x\",e.dataType,e.dims,l),S=[v],T=a?E(\"seq_lens\",a.dataType,a.dims):void 0;T&&S.push(T);let A=d?E(\"total_sequence_length_input\",d.dataType,d.dims):void 0;A&&S.push(A);let k=Ee(e.dataType),P=[{name:\"batch_size\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"sequence_length\",type:\"u32\"},{name:\"total_sequence_length\",type:\"u32\"},{name:\"elements_per_thread\",type:\"u32\"}];return`\n  var<workgroup> thread_max: array<f32, ${p}>;\n  var<workgroup> thread_sum: array<f32, ${p}>;\n  ${$.registerUniforms(P).declareVariables(...S)}\n  ${$.mainStart([p,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${po(T,A,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${p}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${a?\"u32(past_sequence_length + workgroup_id.y + 1)\":\"total_sequence_length\"};\n    var thread_max_vector = ${y}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${y}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return\"thread_max_vector\";case 2:return\"max(thread_max_vector.x, thread_max_vector.y)\";case 4:return\"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${p}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${y}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${y}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return\"sum_vector\";case 2:return\"sum_vector.x + sum_vector.y\";case 4:return\"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${p}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${v.type.value}(${k}(1.0) / ${k}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${y}(x[offset + i]);\n        x[offset + i] = ${v.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${a?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${v.type.value}(${k}(0));\n        }`:\"\"};\n  }`};return{name:\"AttentionProbsSoftmax\",shaderCache:{hint:`${p};${_};${l}`,inputDependencies:g},getShaderSource:x,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(i/p),y:o,z:t*r},programUniforms:h})}},Rm=(e,t,r,n,o,i,a,d,l)=>{let p=a+i.kvSequenceLength,m=[i.batchSize,i.numHeads,i.sequenceLength,p],u=e>1&&n,h=i.kvNumHeads?i.kvNumHeads:i.numHeads,_=u?[i.batchSize,h,p,i.headSize]:void 0,y=i.nReps?i.nReps:1,g=i.scale===0?1/Math.sqrt(i.headSize):i.scale,x=me(i.headSize),$=i.headSize/x,v=12,S={x:Math.ceil(p/v),y:Math.ceil(i.sequenceLength/v),z:i.batchSize*i.numHeads},T=[{type:12,data:i.sequenceLength},{type:12,data:$},{type:12,data:p},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:1,data:g},{type:12,data:a},{type:12,data:i.kvSequenceLength},{type:12,data:y}],A=u&&n&&C.size(n.dims)>0,k=[\"type\",\"type\"];A&&k.push(\"type\"),o&&k.push(\"type\"),d&&k.push(\"type\"),l&&k.push(\"type\");let P=[{dims:m,dataType:t.dataType,gpuDataType:0}];u&&P.push({dims:_,dataType:t.dataType,gpuDataType:0});let D=R=>{let G=E(\"q\",t.dataType,t.dims,x),K=E(\"key\",r.dataType,r.dims,x),j=[G,K];if(A){let ne=E(\"past_key\",n.dataType,n.dims,x);j.push(ne)}o&&j.push(E(\"attention_bias\",o.dataType,o.dims));let V=d?E(\"seq_lens\",d.dataType,d.dims):void 0;V&&j.push(V);let Q=l?E(\"total_sequence_length_input\",l.dataType,l.dims):void 0;Q&&j.push(Q);let se=M(\"output\",t.dataType,m),Y=[se];u&&Y.push(M(\"present_key\",t.dataType,_,x));let ee=Ee(1,x),J=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${v}u;\n\n  var<workgroup> tileQ: array<${G.type.storage}, ${v*v}>;\n  var<workgroup> tileK: array<${G.type.storage}, ${v*v}>;\n  ${R.registerUniforms(J).declareVariables(...j,...Y)}\n  ${R.mainStart([v,v,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${y===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n    let kv_num_heads = ${y===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${po(V,Q,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${A&&u?\"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\":\"\"};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${u?\"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\":\"\"}\n    var value = ${ee}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${(()=>A&&u?`\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }`:`\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }`)()}\n      ${u?`if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }`:\"\"}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${ee}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(x){case 1:return\"value\";case 2:return\"value.x + value.y\";case 4:return\"value.x + value.y + value.z + value.w\";default:throw new Error(`Unsupported components: ${x}`)}})()};\n        output[outputIdx] = ${se.type.value} (sum * uniforms.alpha) + ${o?\"attention_bias[outputIdx]\":\"0.0\"};\n    }\n  }`};return{name:\"AttentionProbs\",shaderCache:{hint:`${x};${o!==void 0};${n!==void 0};${e}`,inputDependencies:k},getRunData:()=>({outputs:P,dispatchGroup:S,programUniforms:T}),getShaderSource:D}},Um=(e,t,r,n,o,i,a=void 0,d=void 0)=>{let l=i+o.kvSequenceLength,p=o.nReps?o.nReps:1,m=o.vHiddenSize*p,u=e>1&&n,h=o.kvNumHeads?o.kvNumHeads:o.numHeads,_=u?[o.batchSize,h,l,o.headSize]:void 0,y=[o.batchSize,o.sequenceLength,m],g=12,x={x:Math.ceil(o.vHeadSize/g),y:Math.ceil(o.sequenceLength/g),z:o.batchSize*o.numHeads},$=[{type:12,data:o.sequenceLength},{type:12,data:l},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:12,data:m},{type:12,data:i},{type:12,data:o.kvSequenceLength},{type:12,data:p}],v=u&&n&&C.size(n.dims)>0,S=[\"type\",\"type\"];v&&S.push(\"type\"),a&&S.push(\"type\"),d&&S.push(\"type\");let T=[{dims:y,dataType:t.dataType,gpuDataType:0}];u&&T.push({dims:_,dataType:t.dataType,gpuDataType:0});let A=k=>{let P=E(\"probs\",t.dataType,t.dims),D=E(\"v\",r.dataType,r.dims),R=[P,D];v&&R.push(E(\"past_value\",n.dataType,n.dims));let G=a?E(\"seq_lens\",a.dataType,a.dims):void 0;a&&R.push(G);let K=d?E(\"total_sequence_length_input\",d.dataType,d.dims):void 0;d&&R.push(K);let V=[M(\"output\",t.dataType,y)];u&&V.push(M(\"present_value\",t.dataType,_));let Q=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"v_hidden_size\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${g}u;\n  var<workgroup> tileQ: array<${P.type.value}, ${g*g}>;\n  var<workgroup> tileV: array<${P.type.value}, ${g*g}>;\n  ${k.registerUniforms(Q).declareVariables(...R,...V)}\n  ${k.mainStart([g,g,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${p===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n   let kv_num_heads = ${p===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${po(G,K,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${v&&u?\"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\":\"\"};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${u?\"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\":\"\"}\n   var value = ${P.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${(()=>v&&u?`\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      `:`\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }`)()}\n        ${u?`\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }`:\"\"}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return{name:\"AttentionScore\",shaderCache:{hint:`${n!==void 0};${e}`,inputDependencies:S},getRunData:()=>({outputs:T,dispatchGroup:x,programUniforms:$}),getShaderSource:A}},Rt=(e,t,r,n,o,i,a,d,l,p,m=void 0,u=void 0)=>{let h=Math.min(e.outputCount,1+(a?1:0)+(d?1:0)),_=h>1?p.pastSequenceLength:0,y=_+p.kvSequenceLength,g=l&&C.size(l.dims)>0?l:void 0,x=[t,r];h>1&&a&&C.size(a.dims)>0&&x.push(a),g&&x.push(g),m&&x.push(m),u&&x.push(u);let $=e.compute(Rm(h,t,r,a,g,p,_,m,u),{inputs:x,outputs:h>1?[-1,1]:[-1]})[0];e.compute(Mm($,p.batchSize,p.numHeads,_,p.sequenceLength,y,m,u),{inputs:m&&u?[$,m,u]:[$],outputs:[]});let v=[$,n];h>1&&d&&C.size(d.dims)>0&&v.push(d),m&&v.push(m),u&&v.push(u),e.compute(Um(h,$,n,d,p,_,m,u),{inputs:v,outputs:h>1?[0,2]:[0]})},Nm=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],n=t.sequenceLength,o=t.inputHiddenSize,i=t.headSize,a=12,d={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],p=[{type:12,data:n},{type:12,data:o},{type:12,data:i},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],m=u=>{let h=M(\"output_q\",l[0].dataType,r),_=M(\"output_k\",l[0].dataType,r),y=M(\"output_v\",l[0].dataType,r),g=E(\"input\",l[0].dataType,l[0].dims),x=E(\"weight\",l[1].dataType,l[1].dims),$=E(\"bias\",l[2].dataType,l[2].dims),v=g.type.storage,S=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"ldb\",type:\"u32\"}];return`\n  const TILE_SIZE = ${a}u;\n  var<workgroup> tileInput: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightQ: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightK: array<${v}, ${a*a}>;\n  var<workgroup> tileWeightV: array<${v}, ${a*a}>;\n  ${u.registerUniforms(S).declareVariables(g,x,$,h,_,y)}\n  ${u.mainStart([a,a,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${v}(0);\n    var valueK = ${v}(0);\n    var valueV = ${v}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:\"AttentionPrepare\",shaderCache:{inputDependencies:[\"type\",\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:d,programUniforms:p}),getShaderSource:m},{inputs:l,outputs:[-1,-1,-1]})},zs=(e,t)=>{let r=Bm(e.inputs,t),[n,o,i]=Nm(e,r);return Rt(e,n,o,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r)}});var Vm,Wm,Lm,Os,Ds=U(()=>{\"use strict\";We();te();oe();Se();ae();Vm=(e,t)=>{if(!e||e.length!==5)throw new Error(\"BatchNormalization requires 5 inputs\");let r=(n,o,i)=>{let a=o.length;if(a!==n.length)throw new Error(`${i}: num dimensions != ${a}`);o.forEach((d,l)=>{if(d!==n[l])throw new Error(`${i}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let n=t.format===\"NHWC\"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,n,\"Invalid input scale\"),r(e[2].dims,n,\"Invalid input B\"),r(e[3].dims,n,\"Invalid input mean\"),r(e[4].dims,n,\"Invalid input var\")}else r(e[1].dims,[1],\"Invalid input scale\"),r(e[2].dims,[1],\"Invalid input B\"),r(e[3].dims,[1],\"Invalid input mean\"),r(e[4].dims,[1],\"Invalid input var\")},Wm=(e,t)=>{let{epsilon:r,spatial:n,format:o}=t,i=e[0].dims,a=n?me(i[i.length-1]):1,d=o===\"NHWC\"&&i.length>1?a:1,l=C.size(i)/a,p=n,m=p?i.length:i,u=E(\"x\",e[0].dataType,e[0].dims,a),h=E(\"scale\",e[1].dataType,e[1].dims,d),_=E(\"bias\",e[2].dataType,e[2].dims,d),y=E(\"inputMean\",e[3].dataType,e[3].dims,d),g=E(\"inputVar\",e[4].dataType,e[4].dims,d),x=M(\"y\",e[0].dataType,m,a),$=()=>{let S=\"\";if(n)S=`let cOffset = ${i.length===1?\"0u\":o===\"NHWC\"?`outputIndices[${i.length-1}] / ${a}`:\"outputIndices[1]\"};`;else if(o===\"NCHW\")S=`\n            ${x.indicesSet(\"outputIndices\",\"0\",\"0\")}\n            let cOffset = ${x.indicesToOffset(\"outputIndices\")};`;else{S=`var cIndices = ${h.type.indices}(0);\n                       cIndices[0] = outputIndices[${i.length-1}];`;for(let T=1;T<h.rank;T++)S+=`cIndices[${T}] = outputIndices[${T}];`;S+=`let cOffset = ${h.indicesToOffset(\"cIndices\")};`}return S},v=S=>`\n  const epsilon = ${r};\n  ${S.registerUniform(\"outputSize\",\"u32\").declareVariables(u,h,_,y,g,x)}\n  ${S.mainStart()}\n  ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n    var outputIndices = ${x.offsetToIndices(`global_idx * ${a}`)};\n    ${$()}\n    let scale = ${h.getByOffset(\"cOffset\")};\n    let bias = ${_.getByOffset(\"cOffset\")};\n    let inputMean = ${y.getByOffset(\"cOffset\")};\n    let inputVar = ${g.getByOffset(\"cOffset\")};\n    let x = ${u.getByOffset(\"global_idx\")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${x.setByOffset(\"global_idx\",\"value\")}\n  }`;return{name:\"BatchNormalization\",shaderCache:{hint:`${t.epsilon}_${t.format}_${n}_${a}`,inputDependencies:p?[\"rank\",\"type\",\"type\",\"type\",\"type\"]:void 0},getShaderSource:v,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p?[{type:12,data:l},...N(i)]:[{type:12,data:l}]})}},Lm=e=>re(e),Os=(e,t)=>{let{inputs:r,outputCount:n}=e,o=Lm({...t,outputCount:n});if(ve.webgpu.validateInputContent&&Vm(r,o),t.trainingMode)throw new Error(\"BatchNormalization trainingMode is not supported yet.\");e.compute(Wm(r,o))}});var Gm,Hm,Bs,Ms=U(()=>{\"use strict\";oe();ae();Gm=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![320,640,1280].includes(e[0].dims[2]))throw new Error(\"number of channels should be 320, 640 or 1280\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Hm=e=>{let t=e[0].dims,r=e[0].dims[2],n=C.size(t)/4,o=e[0].dataType,i=E(\"input\",o,t,4),a=E(\"bias\",o,[r],4),d=E(\"residual\",o,t,4),l=M(\"output\",o,t,4);return{name:\"BiasAdd\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:m=>`\n  const channels = ${r}u / 4;\n  ${m.declareVariables(i,a,d,l)}\n\n  ${m.mainStart()}\n    ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let value = ${i.getByOffset(\"global_idx\")}\n      + ${a.getByOffset(\"global_idx % channels\")} + ${d.getByOffset(\"global_idx\")};\n    ${l.setByOffset(\"global_idx\",\"value\")}\n  }`}},Bs=e=>{Gm(e.inputs),e.compute(Hm(e.inputs))}});var Fm,fe,Rs,Us,Ns,Vs,Ws,Ls,Gs,Hs,Fs,qm,qs,Ks,js,Ys,Xt,Zs,qr,Qs,Xs,Js,eu,tu,ru,nu,ou,iu,au,su,uu,du,lu,cu,pu,mu,fu,mo,fo,hu,gu,bu,Km,jm,yu,Kr=U(()=>{\"use strict\";te();oe();Se();ae();Fm=(e,t,r,n,o,i,a)=>{let d=Math.ceil(t/4),l=\"\";typeof o==\"string\"?l=`${o}(a)`:l=o(\"a\");let p=E(\"inputData\",r,[d],4),m=M(\"outputData\",n,[d],4),u=[{name:\"vec_size\",type:\"u32\"}];return a&&u.push(...a),`\n      ${e.registerUniforms(u).declareVariables(p,m)}\n\n  ${i??\"\"}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n\n    let a = ${p.getByOffset(\"global_idx\")};\n    ${m.setByOffset(\"global_idx\",l)}\n  }`},fe=(e,t,r,n,o,i=e.dataType,a,d)=>{let l=[{type:12,data:Math.ceil(C.size(e.dims)/4)}];return a&&l.push(...a),{name:t,shaderCache:{hint:o,inputDependencies:[\"type\"]},getShaderSource:p=>Fm(p,C.size(e.dims),e.dataType,i,r,n,d),getRunData:p=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(C.size(p[0].dims)/64/4)},programUniforms:l})}},Rs=e=>{e.compute(fe(e.inputs[0],\"Abs\",\"abs\"))},Us=e=>{e.compute(fe(e.inputs[0],\"Acos\",\"acos\"))},Ns=e=>{e.compute(fe(e.inputs[0],\"Acosh\",\"acosh\"))},Vs=e=>{e.compute(fe(e.inputs[0],\"Asin\",\"asin\"))},Ws=e=>{e.compute(fe(e.inputs[0],\"Asinh\",\"asinh\"))},Ls=e=>{e.compute(fe(e.inputs[0],\"Atan\",\"atan\"))},Gs=e=>{e.compute(fe(e.inputs[0],\"Atanh\",\"atanh\"))},Hs=e=>re(e),Fs=(e,t)=>{let r;switch(t.to){case 10:r=\"vec4<f16>\";break;case 1:r=\"vec4<f32>\";break;case 12:r=\"vec4<u32>\";break;case 6:r=\"vec4<i32>\";break;case 9:r=\"vec4<bool>\";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(fe(e.inputs[0],\"Cast\",r,void 0,t.cacheKey,t.to))},qm=e=>{let t,r,n=e.length>=2&&e[1].data!==0,o=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=n?e[1].getFloat32Array()[0]:-34028234663852886e22,r=o?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=n?e[1].getUint16Array()[0]:64511,r=o?e[2].getUint16Array()[0]:31743;break;default:throw new Error(\"Unsupport data type\")}return re({min:t,max:r})},qs=(e,t)=>{let r=t||qm(e.inputs),n=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Clip\",o=>`clamp(${o}, vec4<${n}>(uniforms.min), vec4<${n}>(uniforms.max))`,void 0,r.cacheKey,void 0,[{type:e.inputs[0].dataType,data:r.min},{type:e.inputs[0].dataType,data:r.max}],[{name:\"min\",type:n},{name:\"max\",type:n}]),{inputs:[0]})},Ks=e=>{e.compute(fe(e.inputs[0],\"Ceil\",\"ceil\"))},js=e=>{e.compute(fe(e.inputs[0],\"Cos\",\"cos\"))},Ys=e=>{e.compute(fe(e.inputs[0],\"Cosh\",\"cosh\"))},Xt=e=>re(e),Zs=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Elu\",n=>`elu_vf32(${n})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},qr=(e=\"f32\")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Qs=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Erf\",r=>`erf_vf32(${r})`,qr(t)))},Xs=e=>{e.compute(fe(e.inputs[0],\"Exp\",\"exp\"))},Js=e=>{e.compute(fe(e.inputs[0],\"Floor\",\"floor\"))},eu=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Gelu\",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,qr(t)))},tu=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"LeakyRelu\",n=>`select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},ru=e=>{e.compute(fe(e.inputs[0],\"Not\",t=>`!${t}`))},nu=e=>{e.compute(fe(e.inputs[0],\"Neg\",t=>`-${t}`))},ou=e=>{e.compute(fe(e.inputs[0],\"Reciprocal\",t=>`1.0/${t}`))},iu=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"Relu\",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},au=e=>{e.compute(fe(e.inputs[0],\"Sigmoid\",t=>`(1.0 / (1.0 + exp(-${t})))`))},su=e=>re(e),uu=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"HardSigmoid\",n=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${n} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},du=e=>{e.compute(fe(e.inputs[0],\"Sin\",\"sin\"))},lu=e=>{e.compute(fe(e.inputs[0],\"Sinh\",\"sinh\"))},cu=e=>{e.compute(fe(e.inputs[0],\"Sqrt\",\"sqrt\"))},pu=e=>{e.compute(fe(e.inputs[0],\"Tan\",\"tan\"))},mu=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,fu=e=>{e.compute(fe(e.inputs[0],\"Tanh\",mu))},mo=(e=\"f32\")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${mu(\"v\")};\n}\n`,fo=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,hu=e=>{let t=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"FastGelu\",fo,mo(t),void 0,e.inputs[0].dataType))},gu=(e,t)=>{let r=Ee(e.inputs[0].dataType);return e.compute(fe(e.inputs[0],\"ThresholdedRelu\",n=>`select(vec4<${r}>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},bu=e=>{e.compute(fe(e.inputs[0],\"Log\",\"log\"))},Km=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,jm=e=>`quick_gelu_impl(${e})`,yu=(e,t)=>{let r=Ee(e.inputs[0].dataType);e.compute(fe(e.inputs[0],\"QuickGelu\",jm,Km(r,t.alpha),t.cacheKey,e.inputs[0].dataType))}});var Ym,Zm,wu,vu=U(()=>{\"use strict\";oe();ae();Kr();Ym=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error(\"hidden state should be 2560, 5120 or 10240\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Zm=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=E(\"input\",e[0].dataType,e[0].dims,4),n=E(\"bias\",e[0].dataType,[e[0].dims[2]],4),o=M(\"output\",e[0].dataType,t,4),i=C.size(t)/4,a=_e(e[0].dataType);return{name:\"BiasSplitGelu\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:l=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${l.declareVariables(r,n,o)}\n\n  ${qr(a)}\n\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset(\"global_idx\",\"valueLeft * geluRight\")}\n  }`}},wu=e=>{Ym(e.inputs),e.compute(Zm(e.inputs))}});var Qm,Xm,at,$u,xu,Su,Tu,Iu,Cu,Au,ku,Eu,Pu,zu=U(()=>{\"use strict\";te();oe();ae();Qm=(e,t,r,n,o,i,a,d,l,p,m,u)=>{let h,_;typeof d==\"string\"?h=_=(v,S)=>`${d}((${v}),(${S}))`:typeof d==\"function\"?h=_=d:(h=d.scalar,_=d.vector);let y=M(\"outputData\",m,n.length,4),g=E(\"aData\",l,t.length,4),x=E(\"bData\",p,r.length,4),$;if(o)if(i){let v=C.size(t)===1,S=C.size(r)===1,T=t.length>0&&t[t.length-1]%4===0,A=r.length>0&&r[r.length-1]%4===0;v||S?$=y.setByOffset(\"global_idx\",_(v?`${g.type.value}(${g.getByOffset(\"0\")}.x)`:g.getByOffset(\"global_idx\"),S?`${x.type.value}(${x.getByOffset(\"0\")}.x)`:x.getByOffset(\"global_idx\"))):$=`\n            let outputIndices = ${y.offsetToIndices(\"global_idx * 4u\")};\n            let offsetA = ${g.broadcastedIndicesToOffset(\"outputIndices\",y)};\n            let offsetB = ${x.broadcastedIndicesToOffset(\"outputIndices\",y)};\n            ${y.setByOffset(\"global_idx\",_(a||T?g.getByOffset(\"offsetA / 4u\"):`${g.type.value}(${g.getByOffset(\"offsetA / 4u\")}[offsetA % 4u])`,a||A?x.getByOffset(\"offsetB / 4u\"):`${x.type.value}(${x.getByOffset(\"offsetB / 4u\")}[offsetB % 4u])`))}\n          `}else $=y.setByOffset(\"global_idx\",_(g.getByOffset(\"global_idx\"),x.getByOffset(\"global_idx\")));else{if(!i)throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");let v=(S,T,A=\"\")=>{let k=`aData[indexA${T}][componentA${T}]`,P=`bData[indexB${T}][componentB${T}]`;return`\n            let outputIndices${T} = ${y.offsetToIndices(`global_idx * 4u + ${T}u`)};\n            let offsetA${T} = ${g.broadcastedIndicesToOffset(`outputIndices${T}`,y)};\n            let offsetB${T} = ${x.broadcastedIndicesToOffset(`outputIndices${T}`,y)};\n            let indexA${T} = offsetA${T} / 4u;\n            let indexB${T} = offsetB${T} / 4u;\n            let componentA${T} = offsetA${T} % 4u;\n            let componentB${T} = offsetB${T} % 4u;\n            ${S}[${T}] = ${A}(${h(k,P)});\n          `};m===9?$=`\n            var data = vec4<u32>(0);\n            ${v(\"data\",0,\"u32\")}\n            ${v(\"data\",1,\"u32\")}\n            ${v(\"data\",2,\"u32\")}\n            ${v(\"data\",3,\"u32\")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:$=`\n            ${v(\"outputData[global_idx]\",0)}\n            ${v(\"outputData[global_idx]\",1)}\n            ${v(\"outputData[global_idx]\",2)}\n            ${v(\"outputData[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(g,x,y)}\n\n        ${u??\"\"}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${$}\n      }`},Xm=(e,t,r,n,o,i,a=r.dataType)=>{let d=r.dims.map(g=>Number(g)??1),l=n.dims.map(g=>Number(g)??1),p=!C.areEqual(d,l),m=d,u=C.size(d),h=!1,_=!1,y=[p];if(p){let g=tt.calcShape(d,l,!1);if(!g)throw new Error(\"Can't perform binary op on the given tensors\");m=g.slice(),u=C.size(m);let x=C.size(d)===1,$=C.size(l)===1,v=d.length>0&&d[d.length-1]%4===0,S=l.length>0&&l[l.length-1]%4===0;y.push(x),y.push($),y.push(v),y.push(S);let T=1;for(let A=1;A<m.length;A++){let k=d[d.length-A],P=l[l.length-A];if(k===P)T*=k;else break}T%4===0?(_=!0,h=!0):(x||$||v||S)&&(h=!0)}else h=!0;return y.push(h),{name:e,shaderCache:{hint:t+y.map(g=>g.toString()).join(\"_\"),inputDependencies:[\"rank\",\"rank\"]},getShaderSource:g=>Qm(g,d,l,m,h,p,_,o,r.dataType,n.dataType,a,i),getRunData:()=>({outputs:[{dims:m,dataType:a}],dispatchGroup:{x:Math.ceil(u/64/4)},programUniforms:[{type:12,data:Math.ceil(C.size(m)/4)},...N(d,l,m)]})}},at=(e,t,r,n,o,i)=>{e.compute(Xm(t,o??\"\",e.inputs[0],e.inputs[1],r,n,i))},$u=e=>{at(e,\"Add\",(t,r)=>`${t}+${r}`)},xu=e=>{at(e,\"Div\",(t,r)=>`${t}/${r}`)},Su=e=>{at(e,\"Equal\",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Tu=e=>{at(e,\"Mul\",(t,r)=>`${t}*${r}`)},Iu=e=>{let t=E(\"input\",e.inputs[0].dataType,e.inputs[0].dims).type.value;at(e,\"Pow\",{scalar:(n,o)=>`pow_custom(${n},${o})`,vector:(n,o)=>`pow_vector_custom(${n},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t===\"i32\"?\"round\":\"\"}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Cu=e=>{at(e,\"Sub\",(t,r)=>`${t}-${r}`)},Au=e=>{at(e,\"Greater\",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},ku=e=>{at(e,\"Less\",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Eu=e=>{at(e,\"GreaterOrEqual\",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Pu=e=>{at(e,\"LessOrEqual\",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var ef,tf,rf,nf,Ou,Du,Bu=U(()=>{\"use strict\";te();oe();Se();ae();ef=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");let r=0,n=e[r],o=n.dataType,i=n.dims.length;e.forEach((a,d)=>{if(d!==r){if(a.dataType!==o)throw new Error(\"input tensors should be one type\");if(a.dims.length!==i)throw new Error(\"input tensors should have the same shape\");a.dims.forEach((l,p)=>{if(p!==t&&l!==n.dims[p])throw new Error(\"non concat dimensions must match\")})}})},tf=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,rf=(e,t)=>{let r=e.length,n=[];for(let o=0;o<r;++o){let i=t.setByOffset(\"global_idx\",e[o].getByIndices(\"indices\"));r===1?n.push(i):o===0?n.push(`if (inputIndex == ${o}u) { ${i} }`):o===r-1?n.push(`else { ${i} }`):n.push(`else if (inputIndex == ${o}) { ${i} }`)}return n.join(`\n`)},nf=(e,t,r,n)=>{let o=C.size(r),i=new Array(e.length),a=new Array(e.length),d=0,l=[],p=[],m=[{type:12,data:o}];for(let g=0;g<e.length;++g)d+=e[g].dims[t],i[g]=d,p.push(e[g].dims.length),a[g]=E(`input${g}`,n,p[g]),l.push(\"rank\"),m.push({type:12,data:i[g]});for(let g=0;g<e.length;++g)m.push(...N(e[g].dims));m.push(...N(r));let u=M(\"output\",n,r.length),h=u.indicesGet(\"indices\",t),_=Array.from(Array(i.length).keys()).map(g=>`uniforms.sizeInConcatAxis${g}`).join(\",\"),y=g=>`\n\n  ${(()=>{g.registerUniform(\"outputSize\",\"u32\");for(let x=0;x<e.length;x++)g.registerUniform(`sizeInConcatAxis${x}`,\"u32\");return g.declareVariables(...a,u)})()}\n\n  ${tf(i.length,_)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n    var indices = ${u.offsetToIndices(\"global_idx\")};\n\n    let inputIndex = calculateInputIndex(${h});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${_});\n      ${h} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${rf(a,u)}\n  }`;return{name:\"Concat\",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:r,dataType:n}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:m}),getShaderSource:y}},Ou=(e,t)=>{let r=e.inputs,n=r[0].dims,o=C.normalizeAxis(t.axis,n.length);ef(r,o);let i=n.slice();i[o]=r.reduce((d,l)=>d+(l.dims.length>o?l.dims[o]:0),0);let a=r.filter(d=>C.size(d.dims)>0);e.compute(nf(a,o,i,r[0].dataType),{inputs:a})},Du=e=>re({axis:e.axis})});var qe,Ke,je,jr,yt=U(()=>{\"use strict\";te();oe();qe=(e,t,r=\"f32\")=>{switch(e.activation){case\"Relu\":return`value = max(value, ${t}(0.0));`;case\"Sigmoid\":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case\"Clip\":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case\"HardSigmoid\":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case\"LeakyRelu\":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case\"Tanh\":return`let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        `;case\"\":return\"\";default:throw new Error(`Unsupported activation ${e.activation}`)}},Ke=(e,t)=>{e.activation===\"Clip\"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation===\"HardSigmoid\"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation===\"LeakyRelu\"&&t.push({type:1,data:e.alpha})},je=(e,t)=>{e.activation===\"Clip\"?t.push({name:\"clip_max\",type:\"f32\"},{name:\"clip_min\",type:\"f32\"}):e.activation===\"HardSigmoid\"?t.push({name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}):e.activation===\"LeakyRelu\"&&t.push({name:\"alpha\",type:\"f32\"})},jr=e=>{let t=e?.activation||\"\";if(t===\"HardSigmoid\"){let[r,n]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:n}}else if(t===\"Clip\"){let[r,n]=e?.activation_params||[es,ts];return{activation:t,clipMax:n,clipMin:r}}else if(t===\"LeakyRelu\"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}});var Ae,Mu,Yr=U(()=>{\"use strict\";Ae=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Mu=e=>`\n      ${e?\"value = value + getBiasByOutputCoords(coords);\":\"\"}\n      `});var Ru,Uu=U(()=>{\"use strict\";Ru=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var Jt,Zr,Qr=U(()=>{\"use strict\";te();oe();ae();yt();Jt=(e,t,r,n,o)=>{let i=n-r;return`\n      ${Array.from({length:r}).map((a,d)=>`\n      if (${F(t.shape,d,t.rank)} != 1) {\n        ${t.indicesSet(e,d,F(o,d+i,n))}\n      } else {\n        ${t.indicesSet(e,d,0)}\n      }`).join(\"\")}\n`},Zr=(e,t,r,n,o=!1,i)=>{let a=e[0].dims,d=e[1].dims,l=a[a.length-2],p=d[d.length-1],m=a[a.length-1],u=me(p),h=me(m),_=me(l),y=C.size(r)/u/_,g=e.length>2,x=n?n.slice(0,-2):r.slice(0,-2),v=[C.size(x),l,p],S=[{type:12,data:y},{type:12,data:l},{type:12,data:p},{type:12,data:m}];Ke(t,S),S.push(...N(x,a,d)),g&&S.push(...N(e[2].dims)),S.push(...N(v));let T=A=>{let k=Lr(\"batch_dims\",e[0].dataType,x.length),P=E(\"a\",e[0].dataType,a.length,h),D=E(\"b\",e[1].dataType,d.length,u),R=M(\"output\",e[0].dataType,v.length,u),G=_e(R.type.tensor),K=qe(t,R.type.value,G),j=[P,D],V=\"\";if(g){let Y=o?u:1;j.push(E(\"bias\",e[2].dataType,e[2].dims.length,Y)),V=`${o?`value += bias[col / ${Y}];`:`value += ${R.type.value}(bias[row + i]);`}`}let Q=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"}];je(t,Q);let se=()=>{let Y=`var a_data: ${P.type.value};`;for(let ee=0;ee<h;ee++)Y+=`\n              let b_data${ee} = b[(b_offset + (k + ${ee}) * uniforms.N + col) / ${u}];`;for(let ee=0;ee<_;ee++){Y+=`a_data = a[(a_offset + (row + ${ee}) * uniforms.K + k) / ${h}];`;for(let J=0;J<h;J++)Y+=`\n            values[${ee}] = fma(${D.type.value}(a_data${h===1?\"\":`[${J}]`}), b_data${J}, values[${ee}]);\n`}return Y};return`\n  ${A.registerUniforms(Q).registerInternalVariables(k).declareVariables(...j,R)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let col = (global_idx % (uniforms.N / ${u})) * ${u};\n    var index1 = global_idx / (uniforms.N / ${u});\n    let stride1 = uniforms.M / ${_};\n    let row = (index1 % stride1) * ${_};\n    let batch = index1 / stride1;\n\n    ${r.length===2?\"\":`let batch_indices = ${k.offsetToIndices(\"batch\")};`}\n\n    var a_indices: ${P.type.indices};\n    ${Jt(\"a_indices\",P,P.rank-2,k.rank,\"batch_indices\")}\n    ${P.indicesSet(\"a_indices\",P.rank-2,0)}\n    ${P.indicesSet(\"a_indices\",P.rank-1,0)}\n    let a_offset = ${P.indicesToOffset(\"a_indices\")};\n\n    var b_indices: ${D.type.indices};\n    ${Jt(\"b_indices\",D,D.rank-2,k.rank,\"batch_indices\")}\n    ${D.indicesSet(\"b_indices\",D.rank-2,0)}\n    ${D.indicesSet(\"b_indices\",D.rank-1,0)}\n    let b_offset = ${D.indicesToOffset(\"b_indices\")};\n    var values: array<${R.type.value}, ${_}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {\n      ${se()}\n    }\n    for (var i = 0u; i < ${_}u; i++) {\n      var value = values[i];\n      ${V}\n      ${K}\n      let cur_indices = ${R.type.indices}(batch, row + i, col);\n      let offset = ${R.indicesToOffset(\"cur_indices\")};\n      ${R.setByOffset(`offset / ${u}`,\"value\")};\n    }\n  }\n  `};return{name:\"MatMulNaive\",shaderCache:{hint:`${t.activation};${u};${h};${_};${o}`,inputDependencies:g?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:i?i(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:S}),getShaderSource:T}}});var of,af,ho,Nu,sf,go,uf,er,Xr=U(()=>{\"use strict\";te();oe();ae();yt();Qr();Yr();of=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `,af=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?\"\":\"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached3[i] + acc[i];\"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached.w + acc[i];\"}\n        }`,ho=(e,t,r=\"f32\",n,o=!1,i=32,a=!1,d=32)=>{let l=t[1]*e[1],p=t[0]*e[0],m=o?l:i,u=o?i:l,h=m/t[0],_=i/t[1];if(!((o&&h===4&&e[1]===4||!o&&(h===3||h===4))&&m%t[0]===0&&i%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${h} must be 3 or 4.\n  tileAWidth ${m} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${h}<${r}>, ${m/h}>, ${u}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${i}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${h};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${a?\"0\":\"i32(globalId.z)\"};\n  ${n?`let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};`:\"\"}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${a?`${Math.ceil(d/i)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n  var kStart = ${a?`i32(globalId.z) * ${d}`:\"0\"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${of(o,n)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n?\", batchIndices\":\"\"});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${h===3?\"\":\"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\"}\n\n          ${af(o,h)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Nu=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?\", batchIndices\":\"\"});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?\", batchIndices\":\"\"});\n            `,sf=e=>e?\"let ACached = mm_Asub[k][tileRow + innerRow];\":\"let ACached = mm_Asub[tileRow + innerRow][k];\",go=(e,t,r=\"f32\",n,o=!1,i=32,a=!1,d=32,l=!1)=>{let p=e[1]*t[1],m=e[0]*t[0],u=o?p:i,h=o?i:p;if(!(h%t[1]===0&&u%t[0]===0&&i%t[1]===0))throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let _=h/t[1],y=u/t[0],g=i/t[1],x=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${m};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {\n          ${Nu(o,n)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${m}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${n?\", batchIndices\":\"\"});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${y};\nlet tileRowB = i32(localId.y) * ${g};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Nu(o,n)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${n?\", batchIndices\":\"\"});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${sf(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${u}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${m}>, ${i}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${a?\"0\":\"i32(globalId.z)\"};\n    ${n?`let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};`:\"\"}\n    let num_tiles = ${a?`${Math.ceil(d/i)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n    var kStart = ${a?`i32(globalId.z) * ${d}`:\"0\"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n    ${x}\n  }\n`},uf=(e,t,r,n,o=!1)=>{let[i,a,d,l]=n,p=_e(n[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ae(e,p)} {\n      var value = ${Ae(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${a.type.indices};\n        ${Jt(\"aIndices\",a,a.rank-2,i.rank,\"batchIndices\")}\n        ${a.indicesSet(\"aIndices\",a.rank-2,\"u32(row)\")}\n        ${a.indicesSet(\"aIndices\",a.rank-1,\"u32(colIn)\")}\n        value = ${a.getByIndices(\"aIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ae(e,p)} {\n      var value = ${Ae(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${d.type.indices};\n        ${Jt(\"bIndices\",d,d.rank-2,i.rank,\"batchIndices\")}\n        ${d.indicesSet(\"bIndices\",d.rank-2,\"u32(row)\")}\n        ${d.indicesSet(\"bIndices\",d.rank-1,\"u32(colIn)\")}\n        value = ${d.getByIndices(\"bIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ae(e,p)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${o?\"bias[colIn]\":`${Ae(e,p)}(bias[row])`};`:\"\"}\n        ${r}\n        ${l.setByIndices(\"vec3<u32>(coords)\",\"value\")}\n      }\n    }\n    `},er=(e,t,r,n,o=!1,i)=>{let a=e[0].dims,d=e[1].dims,l=a.slice(0,-2),p=d.slice(0,-2),m=n?n.slice(0,-2):r.slice(0,-2),u=C.size(m),h=a[a.length-2],_=a[a.length-1],y=d[d.length-1],g=_%4===0&&y%4===0,x=h<=8?[4,1,1]:[4,4,1],$=[8,8,1],v=[Math.ceil(y/$[0]/x[0]),Math.ceil(h/$[1]/x[1]),Math.ceil(u/$[2]/x[2])],S=g?4:1,T=[...l,h,_/S],A=T.length,k=[...p,_,y/S],P=k.length,D=[u,h,y/S],R=[{type:6,data:h},{type:6,data:y},{type:6,data:_}];Ke(t,R),R.push(...N(m,T,k));let G=[\"rank\",\"rank\"],K=e.length>2;K&&(R.push(...N(e[2].dims)),G.push(\"rank\")),R.push(...N(D));let j=V=>{let Q=m.length,se=Lr(\"batchDims\",e[0].dataType,Q,1),Y=_e(e[0].dataType),ee=E(\"a\",e[0].dataType,A,S),J=E(\"b\",e[1].dataType,P,S),ne=M(\"result\",e[0].dataType,D.length,S),be=[ee,J];if(K){let q=o?S:1;be.push(E(\"bias\",e[2].dataType,e[2].dims.length,q))}let Oe=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"}];je(t,Oe);let $e=_e(ne.type.tensor),le=qe(t,ne.type.value,$e),W=uf(S,K,le,[se,ee,J,ne],o);return`\n  ${V.registerUniforms(Oe).registerInternalVariables(se).declareVariables(...be,ne)}\n  ${W}\n  ${g?ho(x,$,Y,se):go(x,$,Y,se)}\n                   `};return{name:\"MatMul\",shaderCache:{hint:`${x};${t.activation};${g};${o}`,inputDependencies:G},getRunData:()=>({outputs:[{dims:i?i(r):r,dataType:e[0].dataType}],dispatchGroup:{x:v[0],y:v[1],z:v[2]},programUniforms:R}),getShaderSource:j}}});var df,Vu,Wu=U(()=>{\"use strict\";te();et();ae();yt();Yr();Uu();Xr();df=(e,t,r,n,o=!1,i,a=4,d=4,l=4,p=\"f32\")=>{let m=G=>{switch(G){case 1:return\"resData = x[xIndex];\";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return\"resData = x[xIndex / 4];\";default:throw new Error(`innerElementSize ${G} is not supported.`)}},u=G=>{switch(G){case 1:return\"return w[row * i32(uniforms.w_shape[3]) + colIn];\";case 4:return\"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";default:throw new Error(`innerElementSize ${G} is not supported.`)}},h=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?\"i32(uniforms.x_shape[1])\":\"i32(uniforms.x_shape[2])\",g=e?\"i32(uniforms.x_shape[2])\":\"i32(uniforms.x_shape[3])\",x=e?\"row\":\"col\",$=e?\"col\":\"row\",v=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n    let outRow = ${x} / outWidth;\n    let outCol = ${x} % outWidth;\n\n    let WRow = ${$} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${$} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Ae(a,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${g}) {\n      ${h}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${m(a)}\n    }\n    return resData;`,S=e?t&&n?`\n    let col = colIn * ${a};\n    ${v}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${v}\n    }\n    return ${Ae(a,p)}(0.0);`:n&&r?`\n    let col = colIn * ${a};\n    ${v}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${v}\n    }\n    return ${Ae(a,p)}(0.0);`,T=e?n&&r?u(d):`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${u(d)}\n    }\n    return ${Ae(d,p)}(0.0);`:`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${u(d)}\n    }\n    return ${Ae(d,p)}(0.0);`,A=Ae(l,p),k=e?Ae(a,p):Ae(d,p),P=e?Ae(d,p):Ae(a,p),D=qe(i,A,p);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {\n      ${e?S:T}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${P} {\n      ${e?T:S}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      ${_}\n      ${Mu(o)}\n      ${D}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Vu=(e,t,r,n,o,i,a,d,l)=>{let p=t.format===\"NHWC\",m=p?e[0].dims[3]:e[0].dims[1],u=r[0],h=p?r[2]:r[3],_=p?r[1]:r[2],y=p?r[3]:r[1],g=p&&(m%4===0||m%3===0)&&y%4===0,x=p?y:h*_,$=p?h*_:y,v=[8,8,1],S=n<=8?[4,1,1]:[4,4,1],T=[Math.ceil(x/v[0]/S[0]),Math.ceil($/v[1]/S[1]),Math.ceil(u/v[2]/S[2])];ue(\"verbose\",()=>`[conv2d_mm_webgpu] dispatch = ${T}`);let A=g?p&&m%4!==0?3:4:1,k=v[1]*S[1],P=v[0]*S[0],D=Math.max(v[0]*A,v[1]),R=n%k===0,G=o%P===0,K=i%D===0,j=g?[A,4,4]:[1,1,1],V=[{type:6,data:n},{type:6,data:o},{type:6,data:i},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Ke(t,V),V.push(...N(e[0].dims,e[1].dims));let Q=[\"rank\",\"rank\"];a&&(V.push(...N(e[2].dims)),Q.push(\"rank\")),V.push(...N(r));let se=Y=>{let ee=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"},{name:\"pad\",type:\"i32\",length:2},{name:\"stride\",type:\"i32\",length:2},{name:\"dilation\",type:\"i32\",length:2}];je(t,ee);let J=g?4:1,ne=_e(e[0].dataType),be=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${g?`vec4<${ne}>`:ne}) {\n        result[flatIndex] = ${g?`vec4<${ne}>`:ne}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${g?`vec4<${ne}>`:ne}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${g?\"/ 4\":\"\"}, value);\n      }`,Oe=E(\"x\",e[0].dataType,e[0].dims.length,A===3?1:A),$e=E(\"w\",e[1].dataType,e[1].dims.length,J),le=[Oe,$e],W=M(\"result\",e[0].dataType,r.length,J);if(a){let q=E(\"bias\",e[2].dataType,e[2].dims.length,J);le.push(q),be+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${g?`vec4<${ne}>`:ne} {\n          return bias[coords.${p?\"w\":\"y\"}${g?\"/ 4\":\"\"}];\n        }`}return`\n        ${Ru(\"uniforms.result_strides\")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Y.registerUniforms(ee).declareVariables(...le,W)}\n        ${be}\n        ${df(p,R,G,K,a,t,j[0],j[1],j[2],ne)}\n        ${g?ho(S,v,ne,void 0,!p,D):go(S,v,ne,void 0,!p,D,!1,void 0,d)}`};return{name:\"Conv2DMatMul\",shaderCache:{hint:`${t.cacheKey};${A};${g};${R};${G};${K};${k};${P};${D}`,inputDependencies:Q},getRunData:()=>({outputs:[{dims:l?l(r):r,dataType:e[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]},programUniforms:V}),getShaderSource:se}}});var lf,Lu,Jr,cf,Gu,pf,Hu,Fu,qu=U(()=>{\"use strict\";te();et();oe();ae();yt();Yr();lf=e=>{let t=1;for(let r=0;r<e.length;r++)t*=e[r];return t},Lu=e=>typeof e==\"number\"?[e,e,e]:e,Jr=(e,t)=>t<=1?e:e+(e-1)*(t-1),cf=(e,t,r,n=1)=>{let o=Jr(t,n);return Math.floor((e[0]*(r-1)-r+o)/2)},Gu=(e,t,r,n,o)=>{o==null&&(o=cf(e,t[0],n[0]));let i=[0,0,0,r];for(let a=0;a<3;a++)e[a]+2*o>=t[a]&&(i[a]=Math.trunc((e[a]-t[a]+2*o)/n[a]+1));return i},pf=(e,t,r,n,o,i,a,d,l,p)=>{let m,u,h,_;if(e===\"VALID\"&&(e=0),typeof e==\"number\"){m={top:e,bottom:e,left:e,right:e,front:e,back:e};let y=Gu([t,r,n,1],[d,l,p],1,[o,i,a],e);u=y[0],h=y[1],_=y[2]}else if(Array.isArray(e)){if(!e.every((g,x,$)=>g===$[0]))throw Error(`Unsupported padding parameter: ${e}`);m={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let y=Gu([t,r,n,1],[d,l,p],1,[o,i,a],e[0]);u=y[0],h=y[1],_=y[2]}else if(e===\"SAME_UPPER\"){u=Math.ceil(t/o),h=Math.ceil(r/i),_=Math.ceil(n/a);let y=(u-1)*o+d-t,g=(h-1)*i+l-r,x=(_-1)*a+p-n,$=Math.floor(y/2),v=y-$,S=Math.floor(g/2),T=g-S,A=Math.floor(x/2),k=x-A;m={top:S,bottom:T,left:A,right:k,front:$,back:v}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:m,outDepth:u,outHeight:h,outWidth:_}},Hu=(e,t,r,n,o,i=!1,a=\"channelsLast\")=>{let d,l,p,m,u;if(a===\"channelsLast\")[d,l,p,m,u]=e;else if(a===\"channelsFirst\")[d,u,l,p,m]=e;else throw new Error(`Unknown dataFormat ${a}`);let[h,,_,y,g]=t,[x,$,v]=Lu(r),[S,T,A]=Lu(n),k=Jr(_,S),P=Jr(y,T),D=Jr(g,A),{padInfo:R,outDepth:G,outHeight:K,outWidth:j}=pf(o,l,p,m,x,$,v,k,P,D),V=i?h*u:h,Q=[0,0,0,0,0];return a===\"channelsFirst\"?Q=[d,V,G,K,j]:a===\"channelsLast\"&&(Q=[d,G,K,j,V]),{batchSize:d,dataFormat:a,inDepth:l,inHeight:p,inWidth:m,inChannels:u,outDepth:G,outHeight:K,outWidth:j,outChannels:V,padInfo:R,strideDepth:x,strideHeight:$,strideWidth:v,filterDepth:_,filterHeight:y,filterWidth:g,effectiveFilterDepth:k,effectiveFilterHeight:P,effectiveFilterWidth:D,dilationDepth:S,dilationHeight:T,dilationWidth:A,inShape:e,outShape:Q,filterShape:t}},Fu=(e,t,r,n,o,i)=>{let a=i===\"channelsLast\",d=a?e[0].dims[3]:e[0].dims[1],l=!1,p=[64,1,1],m={x:r.map((v,S)=>S)},u=[Math.ceil(lf(m.x.map(v=>r[v]))/p[0]),1,1];ue(\"verbose\",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let h=l?a&&d%4!==0?3:4:1,_=C.size(r),y=[{type:12,data:_},{type:12,data:n},{type:12,data:o},{type:12,data:t.strides},{type:12,data:t.dilations}];Ke(t,y),y.push(...N(e[0].dims,e[1].dims));let g=[\"rank\",\"rank\"],x=e.length===3;x&&(y.push(...N(e[2].dims)),g.push(\"rank\")),y.push(...N(r));let $=v=>{let S=[{name:\"output_size\",type:\"u32\"},{name:\"filter_dims\",type:\"u32\",length:n.length},{name:\"pads\",type:\"u32\",length:o.length},{name:\"strides\",type:\"u32\",length:t.strides.length},{name:\"dilations\",type:\"u32\",length:t.dilations.length}];je(t,S);let T=l?4:1,A=_e(e[0].dataType),k=E(\"x\",e[0].dataType,e[0].dims.length,h===3?1:h),P=E(\"W\",e[1].dataType,e[1].dims.length,T),D=[k,P],R=M(\"result\",e[0].dataType,r.length,T),G=\"\";if(x){let V=E(\"bias\",e[2].dataType,e[2].dims.length,T);D.push(V),G+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l?`vec4<${A}>`:A} {\n          return bias[${a?F(\"coords\",4,5):F(\"coords\",1,5)}${l?\"/ 4\":\"\"}];\n        }`}let K=Ae(h,A),j=qe(t,K,A);return`\n            ${G}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${k.getByIndices(\"aIndices\")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${P.getByIndices(\"aIndices\")};\n            }\n          ${v.registerUniforms(S).declareVariables(...D,R)}\n          ${v.mainStart()}\n          ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n              let coords = ${R.offsetToIndices(\"global_idx\")};\n              let batch = ${F(\"coords\",0,k.rank)};\n              let d2 = ${a?F(\"coords\",k.rank-1,k.rank):F(\"coords\",1,k.rank)};\n              let xFRCCorner = vec3<u32>(${a?F(\"coords\",1,k.rank):F(\"coords\",2,k.rank)},\n              ${a?F(\"coords\",2,k.rank):F(\"coords\",3,k.rank)},\n              ${a?F(\"coords\",3,k.rank):F(\"coords\",4,k.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${a?F(\"uniforms.x_shape\",1,k.rank):F(\"uniforms.x_shape\",2,k.rank)};\n              let xShapeZ = ${a?F(\"uniforms.x_shape\",2,k.rank):F(\"uniforms.x_shape\",3,k.rank)};\n              let xShapeW = ${a?F(\"uniforms.x_shape\",3,k.rank):F(\"uniforms.x_shape\",4,k.rank)};\n              let xShapeU = ${a?F(\"uniforms.x_shape\",4,k.rank):F(\"uniforms.x_shape\",1,k.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${a?`let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            `:`let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            `}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${a?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${a?`let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      `:`let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    `}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${a?`let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      `:`let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    `}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${x?\"value = value + getBiasByOutputCoords(coords)\":\"\"};\n              ${j}\n              result[global_idx] = f32(value);\n          }`};return{name:\"Conv3DNaive\",shaderCache:{hint:`${t.cacheKey};${a};${h};${x}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:y}),getShaderSource:$}}});var Ku,ju,Yu=U(()=>{\"use strict\";te();oe();ae();yt();Ku=(e,t,r,n)=>{let o=e.length>2,i=o?\"value += b[output_channel];\":\"\",a=e[0].dims,d=e[1].dims,l=t.format===\"NHWC\",p=l?r[3]:r[1],m=p/t.group,u=l&&m>=4?me(p):1,h=C.size(r)/u,_=[{type:12,data:h},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:m}];Ke(t,_),_.push(...N(a,[d[0],d[1],d[2],d[3]/u]));let y=o?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"];_.push(...N([r[0],r[1],r[2],r[3]/u]));let g=x=>{let $=M(\"output\",e[0].dataType,r.length,u),v=_e($.type.tensor),S=qe(t,$.type.value,v),T=E(\"x\",e[0].dataType,a.length),A=E(\"w\",e[1].dataType,d.length,u),k=[T,A];o&&k.push(E(\"b\",e[2].dataType,e[2].dims,u));let P=[{name:\"output_size\",type:\"u32\"},{name:\"dilations\",type:\"u32\",length:t.dilations.length},{name:\"strides\",type:\"u32\",length:2},{name:\"pads\",type:\"u32\",length:2},{name:\"output_channels_per_group\",type:\"u32\"}];je(t,P);let D=l?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${T.get(\"batch\",\"xHeight\",\"xWidth\",\"input_channel\")};\n            let wVal = ${A.get(\"wHeight\",\"wWidth\",\"wInChannel\",\"output_channel\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${T.get(\"batch\",\"input_channel\",\"xHeight\",\"xWidth\")};\n            let wVal = ${A.get(\"output_channel\",\"wInChannel\",\"wHeight\",\"wWidth\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${x.registerUniforms(P).declareVariables(...k,$)}\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let outputIndices = ${$.offsetToIndices(\"global_idx\")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${u} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    ${D}\n    ${i}\n    ${S}\n    ${$.setByOffset(\"global_idx\",\"value\")}\n  }`};return{name:\"GroupedConv\",shaderCache:{hint:`${t.cacheKey}_${u}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_}),getShaderSource:g}},ju=(e,t,r,n)=>{let o=e.length>2,i=me(r[3]),a=me(r[2]),d=C.size(r)/i/a,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],m=[r[0],r[1],r[2],r[3]/i],u=[{type:12,data:d},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Ke(t,u),u.push(...N(l,p,m));let h=(a-1)*t.strides[1]+p[1],_=y=>{let g=M(\"output\",e[0].dataType,m.length,i),x=_e(g.type.tensor),$=qe(t,g.type.value,x),v=E(\"x\",e[0].dataType,l.length,i),S=E(\"w\",e[1].dataType,p.length,i),T=[v,S];o&&T.push(E(\"b\",e[2].dataType,e[2].dims,i));let A=o?\"value += b[output_channel];\":\"\",k=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"i32\",length:2},{name:\"pads\",type:\"i32\",length:2}];return je(t,k),`\n  ${y.registerUniforms(k).declareVariables(...T,g)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${a}u;\n    let col = (index1 % width1) * ${a}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${v.type.value}, ${h}>;\n    var values: array<${g.type.value}, ${a}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${h}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${v.get(\"batch\",\"u32(x_height)\",\"u32(x_width)\",\"input_channel\")};\n          } else {\n            x_vals[i] = ${v.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${S.get(\"w_height\",\"w_width\",\"0\",\"output_channel\")};\n          for (var i = 0u; i < ${a}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${a}u; i++) {\n      var value = values[i];\n      ${A}\n      ${$}\n      ${g.set(\"batch\",\"row\",\"col + i\",\"output_channel\",\"value\")};\n    }\n  }`};return{name:\"GroupedConv-Vectorize\",shaderCache:{hint:`${t.cacheKey};${i};${a};${h};${p[0]};${p[1]}`,inputDependencies:o?[\"rank\",\"rank\",\"type\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}),getShaderSource:_}}});var mf,bo,ff,yo,_o,Zu,hf,gf,wo,Qu=U(()=>{\"use strict\";oe();Wu();qu();Xr();Yu();yt();Qr();dt();mf=(e,t,r,n,o,i)=>{let a=e[0],d=e.slice(i?1:2,i?3:4),l=d.length,p=t[0],u=t.slice(2).map((y,g)=>y+(y-1)*(r[g]-1)),_=d.map((y,g)=>y+n[g]+n[g+l]).map((y,g)=>Math.floor((y-u[g]+o[g])/o[g]));return _.splice(0,0,a),_.splice(i?3:1,0,p),_},bo=[2,3,1,0],ff=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length>5)throw new Error(\"greater than 5D is not supported\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let r=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],n=e[1].dims[1]*t.group;if(r!==n)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error(\"invalid bias\");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\")},yo=(e,t)=>{let r=e.kernelShape.slice();r.length<t[1].dims.length-2&&r.push(...Array(t[1].dims.length-2-r.length).fill(0));for(let i=2;i<t[1].dims.length;++i)r[i-2]===0&&(r[i-2]=t[1].dims[i]);let n=e.pads.slice();At.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,n,e.format===\"NHWC\",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:n}),o},_o=e=>{let t=jr(e),r=e.format,n=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],o=e.dilations,i=e.group,a=e.kernel_shape,d=e.pads,l=e.strides,p=e.w_is_const();return{autoPad:n,format:r,dilations:o,group:i,kernelShape:a,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},Zu=(e,t,r,n)=>{let o=r.format===\"NHWC\",i=mf(t[0].dims,t[1].dims,r.dilations,r.pads,r.strides,o);if(r.group!==1){let k=[t[0]];if(o){let D=e.kernelCustomData.wT??e.compute(Pe(t[1],bo),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=D),k.push(D)}else k.push(t[1]);t.length===3&&k.push(t[2]),!e.adapterInfo.isArchitecture(\"ampere\")&&o&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1?e.compute(ju(k,r,i,n),{inputs:k}):e.compute(Ku(k,r,i,n),{inputs:k});return}let a=t.length===3,d=t[0].dims[o?1:2],l=t[0].dims[o?2:3],p=t[0].dims[o?3:1],m=t[1].dims[2],u=t[1].dims[3],h=i[o?1:2],_=i[o?2:3],y=i[o?3:1],g=o&&m===d&&u===l&&r.pads[0]===0&&r.pads[1]===0;if(g||m===1&&u===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let k=i[0],P,D,R,G=[];if(o){let V=e.kernelCustomData.wT??e.compute(Pe(t[1],bo),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=V),g){let Q=d*l*p;P=t[0].reshape([1,k,Q]),D=V.reshape([1,Q,y]),R=[1,k,y]}else P=t[0].reshape([k,d*l,p]),D=V.reshape([1,p,y]),R=[k,h*_,y];G.push(P),G.push(D)}else P=t[0].reshape([k,p,d*l]),D=t[1].reshape([1,y,p]),R=[k,y,h*_],G.push(D),G.push(P);a&&G.push(t[2]);let K=R[2],j=G[0].dims[G[0].dims.length-1];K<8&&j<8?e.compute(Zr(G,r,i,R,o,n),{inputs:G}):e.compute(er(G,r,i,R,o,n),{inputs:G});return}let x=!0,$=e.kernelCustomData.wT??e.compute(Pe(t[1],bo),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=$);let v=[t[0],$];a&&v.push(t[2]);let S=o?h*_:y,T=o?y:h*_,A=m*u*p;e.compute(Vu(v,r,i,S,T,A,a,x,n),{inputs:v})},hf=(e,t)=>{let r=t.format===\"NHWC\",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),a=[1].concat(t.dilations),d=[1].concat(t.kernelShape),l=yo({...t,pads:o,strides:i,dilations:a,kernelShape:d},n);Zu(e,n,l,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]])},gf=(e,t,r)=>{let n=r.format===\"NHWC\"?\"channelsLast\":\"channelsFirst\",o=yo(r,t),i=r.autoPad===\"NOTSET\"?r.pads:r.autoPad,a=Hu(t[0].dims,t[1].dims,r.strides,r.dilations,i,!1,n);e.compute(Fu(t,o,a.outShape,[a.filterDepth,a.filterHeight,a.filterWidth],[a.padInfo.front,a.padInfo.top,a.padInfo.left],n))},wo=(e,t)=>{if(ff(e.inputs,t),e.inputs[0].dims.length===3)hf(e,t);else if(e.inputs[0].dims.length===5)gf(e,e.inputs,t);else{let r=yo(t,e.inputs);Zu(e,e.inputs,r)}}});var Xu,Ju=U(()=>{\"use strict\";te();et();oe();ae();Xu=(e,t,r)=>{let n=e.length>2,o=t.outputShape,i=t.format===\"NHWC\",a=t.group,d=e[1].dims,l=d[2]/a,p=d[3],m=i?me(l):1,u=i?me(p):1,h=i?p===1?m:u:1,_=C.size(o)/u,y=[Math.ceil(_/64),1,1];ue(\"verbose\",()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);let g=[\"rank\",\"rank\"],x=[t.strides[0],t.strides[1]],$=[t.kernelShape[i?1:2],t.kernelShape[i?2:3]],v=[t.dilations[0],t.dilations[1]],S=[$[0]+(t.dilations[0]<=1?0:(t.kernelShape[i?1:2]-1)*(t.dilations[0]-1)),$[1]+(t.dilations[1]<=1?0:(t.kernelShape[i?2:3]-1)*(t.dilations[1]-1))],T=[S[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),S[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],A=[{type:12,data:_},{type:12,data:x},{type:12,data:$},{type:12,data:v},{type:12,data:S},{type:6,data:T},{type:12,data:l},{type:12,data:p},...N(e[0].dims,e[1].dims)];n&&(A.push(...N(e[2].dims)),g.push(\"rank\")),A.push(...N(o));let k=P=>{let D=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"u32\",length:x.length},{name:\"filter_dims\",type:\"u32\",length:$.length},{name:\"dilations\",type:\"u32\",length:$.length},{name:\"effective_filter_dims\",type:\"u32\",length:S.length},{name:\"pads\",type:\"i32\",length:T.length},{name:\"input_channels_per_group\",type:\"u32\"},{name:\"output_channels_per_group\",type:\"u32\"}],R=_e(e[0].dataType),G=i?1:2,K=i?2:3,j=i?3:1,V=E(\"W\",e[1].dataType,e[1].dims.length,h),Q=E(\"Dy\",e[0].dataType,e[0].dims.length,m),se=[Q,V];n&&se.push(E(\"bias\",e[2].dataType,[o[j]].length,u));let Y=M(\"result\",e[0].dataType,o.length,u),ee=()=>{let ne=\"\";if(m===1)ne+=`\n        let w_offset = ${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n        let wValue = ${V.getByOffset(`w_offset / ${h}`)};\n        dotProd = dotProd + xValue * wValue;`;else if(p===1)ne+=`\n          let wValue = ${V.getByOffset(`${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${h}`)};\n          dotProd = dotProd + dot(xValue, wValue);`;else for(let be=0;be<m;be++)ne+=`\n            let wValue${be} = ${V.getByOffset(`${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${be}, wOutChannel)`)} / ${h}`)};\n            dotProd = dotProd + xValue[${be}] * wValue${be};`;return ne},J=`\n            let outputIndices = ${Y.offsetToIndices(`global_idx * ${u}`)};\n            let batch = ${Y.indicesGet(\"outputIndices\",0)};\n            let d1 = ${Y.indicesGet(\"outputIndices\",j)};\n            let r = ${Y.indicesGet(\"outputIndices\",G)};\n            let c = ${Y.indicesGet(\"outputIndices\",K)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${Y.type.value}(0.0);\n            for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${R}(dyRCorner) + ${R}(wR)) / ${R}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${R}(uniforms.Dy_shape[${G}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n              let idyR: u32 = u32(dyR);\n\n              for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${R}(dyCCorner) + ${R}(wC)) / ${R}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${R}(uniforms.Dy_shape[${K}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                wC = wC + uniforms.strides.y - 1;\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${m}) {\n                  let xValue = ${i?Q.getByOffset(`${Q.indicesToOffset(`${Q.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${m}`):Q.get(\"batch\",\"inputChannel\",\"idyR\",\"idyC\")};\n                  ${ee()}\n                  inputChannel = inputChannel + ${m};\n                }\n              }\n            }\n            let value = dotProd${n?` + bias[d1 / ${u}]`:\"\"};\n            ${Y.setByOffset(\"global_idx\",\"value\")};\n          `;return`\n    ${P.registerUniforms(D).declareVariables(...se,Y)}\n      ${P.mainStart()}\n      ${P.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")};\n    ${J}}`};return{name:\"ConvTranspose2D\",shaderCache:{hint:`${t.cacheKey};${m}${h}${u}${p===1}`,inputDependencies:g},getRunData:()=>({dispatchGroup:{x:y[0],y:y[1],z:y[2]},outputs:[{dims:r?r(o):o,dataType:e[0].dataType}],programUniforms:A}),getShaderSource:k}}});var bf,yf,_f,ed,td,wf,rd,vf,nd,od=U(()=>{\"use strict\";Ju();yt();dt();bf=(e,t,r,n,o,i)=>(e-1)*t+r+(n-1)*o+1-i,yf=(e,t,r,n,o)=>{let i=Math.floor(e/2);t===\"SAME_UPPER\"?(r[n]=i,r[o]=e-i):t===\"SAME_LOWER\"&&(r[n]=e-i,r[o]=i)},_f=(e,t,r,n,o,i,a,d,l,p)=>{let m=e.length-2,u=p.length===0;l.length<m&&l.push(...Array(m-l.length).fill(0));let h=e[0],_=t[d?3:1]*o;for(let y=0,g=e.length-m-(d?1:0);y<m;++y,++g){let x=e[g],$=u?x*a[y]:p[y],v=bf(x,a[y],i[y],t[g],r[y],$);yf(v,n,i,y,y+m),u&&p.push(a[y]*(x-1)+l[y]+(t[g]-1)*r[y]+1-i[y]-i[y+m])}p.splice(0,0,h),p.splice(d?3:1,0,_)},ed=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((u,h)=>u*h,1)===0){r.length=0;for(let u=2;u<t[1].dims.length;++u)r.push(t[1].dims[u])}let n=e.format===\"NHWC\";r.splice(0,0,t[1].dims[0]),r.splice(n?3:1,0,t[1].dims[1]);let o=e.pads.slice(),i=e.outputShape.slice(),a=e.outputPadding.slice(),d=t[0].dims,l=e.dilations.slice();if(l.reduce((u,h)=>u+h,0)===0){let u=t[0].dims.length-2;l=new Array(u).fill(1)}let p=e.strides.slice();if(p.reduce((u,h)=>u+h,0)===0){let u=t[0].dims.length-2;p=new Array(u).fill(1)}_f(d,r,l,e.autoPad,e.group,o,p,n,a,i);let m=Object.assign({},e);return Object.assign(m,{kernelShape:r,pads:o,outputPadding:a,outputShape:i,dilations:l,strides:p}),m},td=e=>{let t=jr(e),r=e.format,n=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][typeof e.autoPad>\"u\"?0:e.autoPad],o=e.dilations,i=e.group,a=e.kernelShape,d=e.pads,l=e.strides,p=e.wIsConst(),m=e.outputPadding,u=e.outputShape;return{autoPad:n,format:r,dilations:o,group:i,kernelShape:a,outputPadding:m,outputShape:u,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},wf=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error(\"currently only support 2-dimensional conv\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let r=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],n=e[1].dims[0];if(r!==n)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error(\"invalid bias\");let i=e[0].dims.length-2;if(t.dilations.reduce((m,u)=>m+u,0)>0&&t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.reduce((m,u)=>m+u,0)>0&&t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.reduce((m,u)=>m+u,0)>0&&t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.outputPadding.length!==i&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(t.kernelShape.reduce((m,u)=>m+u,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error(\"invalid output shape\")},rd=(e,t,r,n)=>{let o=e.kernelCustomData.wT??e.compute(Pe(t[1],[2,3,0,1]),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=o);let i=[t[0],o];t.length===3&&i.push(t[2]),e.compute(Xu(i,r,n),{inputs:i})},vf=(e,t)=>{let r=t.format===\"NHWC\",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let i=t.dilations;(i.length===0||i[0]===0)&&(i=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],a=[1].concat(a),i=[1].concat(i),o=[1].concat(o);let l=ed({...t,pads:d,strides:a,dilations:i,kernelShape:o},n);rd(e,n,l,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]])},nd=(e,t)=>{if(wf(e.inputs,t),e.inputs[0].dims.length===3)vf(e,t);else{let r=ed(t,e.inputs);rd(e,e.inputs,r)}}});var $f,id,ad,sd=U(()=>{\"use strict\";te();oe();Se();ae();$f=(e,t,r,n)=>{let o=C.size(t),i=t.length,a=E(\"input\",e,i),d=M(\"output\",e,i),l=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),p=C.normalizeAxis(l,i),m=u=>{let h=` i32(${a.indicesGet(\"inputIndices\",\"uniforms.axis\")}) `,_=F(\"uniforms.input_shape\",\"uniforms.axis\",i),y=n.reverse?h+(n.exclusive?\" + 1\":\"\"):\"0\",g=n.reverse?_:h+(n.exclusive?\"\":\" + 1\");return`\n                ${u.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axis\",\"u32\").declareVariables(a,d)}\n                ${u.mainStart()}\n                  ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n                  var inputIndices = ${d.offsetToIndices(\"global_idx\")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${y};\n                  let last : i32 = ${g};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${a.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(i)\")};\n                    sum = sum + ${a.getByIndices(\"inputIndices\")};\n                  }\n                  ${d.setByOffset(\"global_idx\",\"sum\")};\n                }`};return{name:\"CumSum\",shaderCache:{hint:n.cacheKey,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},{type:12,data:p},...N(t,t)]}),getShaderSource:m}},id=(e,t)=>{let r=e.inputs[0].dims,n=e.inputs[0].dataType,o=e.inputs[1];e.compute($f(n,r,o,t),{inputs:[0]})},ad=e=>{let t=e.exclusive===1,r=e.reverse===1;return re({exclusive:t,reverse:r})}});var xf,Sf,Tf,ud,dd,ld=U(()=>{\"use strict\";te();oe();Se();ae();xf=e=>{if(!e||e.length!==1)throw new Error(\"DepthToSpace requires 1 input.\");if(e[0].dims.length!==4)throw new Error(\"DepthToSpace requires 4D input.\")},Sf=(e,t,r,n)=>{let o=[];o.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let i=0;i<t;++i)o.push(r.indicesSet(\"a\",e[i],`i[${i}]`));return o.push(\"return a;}\"),o.join(`\n`)},Tf=(e,t)=>{let r,n,o,i,a,d,l=t.format===\"NHWC\",p=t.blocksize,m=t.mode===\"DCR\";l?([r,n,o,i]=e.dims,a=m?[r,n,o,p,p,i/p**2]:[r,n,o,i/p**2,p,p],d=m?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,n,o,i]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=m?[r,p,p,i/p**2,n,o]:[r,i/p**2,p,p,n,o],d=m?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let u=e.reshape(a),h=u.dims.length,_=e.dataType,y=E(\"a\",_,h),g=M(\"output\",_,h),x=$=>`\n  ${$.registerUniform(\"output_size\",\"u32\").declareVariables(y,g)}\n\n  ${Sf(d,h,y,g)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${g.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${g.setByOffset(\"global_idx\",y.getByIndices(\"aIndices\"))}\n  }`;return{name:\"DepthToSpace\",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:[\"rank\"]},getRunData:$=>{let v=l?[r,n*p,o*p,i/p**2]:[r,i/p**2,n*p,o*p],S=C.size(v),T=u.dims,A=C.sortBasedOnPerm(T,d);return{outputs:[{dims:v,dataType:$[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:[{type:12,data:S},...N(T,A)]}},getShaderSource:x}},ud=(e,t)=>{xf(e.inputs),e.compute(Tf(e.inputs[0],t))},dd=e=>re({blocksize:e.blocksize,mode:e.mode,format:e.format})});var vo,en,cd,If,Cf,$o,xo,pd,Af,md,fd,hd=U(()=>{\"use strict\";te();oe();Se();ae();vo=\"[a-zA-Z]|\\\\.\\\\.\\\\.\",en=\"(\"+vo+\")+\",cd=\"^\"+en+\"$\",If=\"(\"+en+\",)*\"+en,Cf=\"^\"+If+\"$\",$o=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let n=this.symbolToIndices.get(t);n===void 0?n=[r]:n.push(r),this.symbolToIndices.set(t,n)}},xo=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,o]=r.includes(\"->\")?r.split(\"->\",2):[r,\"\"];if(!n.match(RegExp(Cf)))throw new Error(\"Invalid LHS term\");if(n.split(\",\").forEach((d,l)=>{let p=t[l].dims.slice();if(!d.match(RegExp(cd)))throw new Error(\"Invalid LHS term\");let m=this.processTerm(d,!0,p,l);this.lhs.push(m)}),o===\"\")o+=[...this.symbolToInfo.entries()].filter(([d,l])=>l.count===1||d===\"...\").map(([d])=>d).join(\"\");else if(!o.match(RegExp(en)))throw new Error(\"Invalid RHS\");o.match(RegExp(vo,\"g\"))?.forEach(d=>{if(d===\"...\")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(d);if(l===void 0)throw new Error(\"Invalid RHS symbol\");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(o,!1,this.outputDims)}addSymbol(t,r,n){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==r&&o.count!==1)throw new Error(\"Dimension mismatch\");o.count++,o.inputIndices.push(n)}else o={count:1,dimValue:r,inputIndices:[n]};this.symbolToInfo.set(t,o)}processTerm(t,r,n,o=-1){let i=n.length,a=!1,d=[],l=0;if(!t.match(RegExp(cd))&&!r&&t!==\"\")throw new Error(\"Invalid LHS term\");let p=t.match(RegExp(vo,\"g\")),m=new $o(o);return p?.forEach((u,h)=>{if(u===\"...\"){if(a)throw new Error(\"Only one ellipsis is allowed per input term\");a=!0;let _=i-p.length+1;if(_<0)throw new Error(\"Ellipsis out of bounds\");if(d=n.slice(l,l+_),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error(\"Ellipsis dimensions mismatch\")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error(\"Ellipsis must be specified in the LHS\");for(let y=0;y<d.length;y++){let g=String.fromCharCode(\"0\".charCodeAt(0)+y);m.addSymbol(g,h+y),this.addSymbol(g,n[l++],o)}}else m.addSymbol(u,h+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(u,n[l++],o)}),m}},pd=e=>e+\"_max\",Af=(e,t,r,n)=>{let i=e.map(m=>m.length).map((m,u)=>E(`input${u}`,t,m)),a=C.size(n),d=M(\"output\",t,n.length),l=[...r.symbolToInfo.keys()].filter(m=>!r.rhs.symbolToIndices.has(m)),p=m=>{let u=[],h=\"var prod = 1.0;\",_=\"var sum = 0.0;\",y=\"sum += prod;\",g=[],x=[],$=[],v=[],S=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((A,k)=>{if(r.rhs.symbolToIndices.has(k)){let P=r.rhs.symbolToIndices.get(k)?.[0];P!==void 0&&r.lhs.forEach((D,R)=>{if(A.inputIndices.includes(R)){let G=D.symbolToIndices.get(k);if(G===void 0)throw new Error(\"Invalid symbol error\");G.forEach(K=>{u.push(`${i[R].indicesSet(`input${R}Indices`,K,d.indicesGet(\"outputIndices\",P))}`)})}})}else r.lhs.forEach((P,D)=>{if(A.inputIndices.includes(D)){let R=P.symbolToIndices.get(k);if(R===void 0)throw new Error(\"Invalid symbol error\");R.forEach(G=>{g.push(`${i[D].indicesSet(`input${D}Indices`,G,`${k}`)}`)}),v.push(`prod *= ${i[D].getByIndices(`input${D}Indices`)};`)}}),x.push(`for(var ${k}: u32 = 0; ${k} < uniforms.${pd(k)}; ${k}++) {`),$.push(\"}\")});let T=S?[...u,`let sum = ${i.map((A,k)=>A.getByIndices(`input${k}Indices`)).join(\" * \")};`]:[...u,_,...x,...g,h,...v,y,...$];return`\n            ${m.registerUniforms(l.map(A=>({name:`${pd(A)}`,type:\"u32\"}))).registerUniform(\"outputSize\",\"u32\").declareVariables(...i,d)}\n\n            ${m.mainStart()}\n            ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n            var outputIndices = ${d.offsetToIndices(\"global_idx\")};\n            ${i.map((A,k)=>`var input${k}Indices: ${i[k].type.indices};`).join(`\n`)}\n            ${T.join(`\n`)};\n            ${d.setByOffset(\"global_idx\",\"sum\")};\n          }`};return{name:\"Einsum\",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>\"rank\")},getRunData:()=>{let m=l.filter(h=>r.symbolToInfo.has(h)).map(h=>({type:12,data:r.symbolToInfo.get(h)?.dimValue||0}));m.push({type:12,data:a});let u=e.map((h,_)=>[...N(h)]).reduce((h,_)=>h.concat(_),m);return u.push(...N(n)),{outputs:[{dims:n,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}},getShaderSource:p}},md=(e,t)=>{let r=new xo(e.inputs,t.equation),n=r.outputDims,o=e.inputs.map((i,a)=>i.dims);e.compute(Af(o,e.inputs[0].dataType,r,n))},fd=e=>{let t=e.equation.replace(/\\s+/g,\"\");return re({equation:t})}});var kf,gd,Ef,Pf,bd,yd=U(()=>{\"use strict\";te();oe();ae();kf=e=>{if(!e||e.length!==2)throw new Error(\"Expand requires 2 input.\");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=r.length<t.length?0:r.length-t.length,o=t.length<r.length?0:t.length-r.length;for(;n<r.length&&o<t.length;++n,++o)if(r[n]!==t[o]&&r[n]!==1&&t[o]!==1)throw new Error(\"Expand requires shape to be broadcastable to input\")},gd=(e,t)=>{let r=e.length-t.length,n=[];for(let o=0;o<r;++o)n.push(e[o]);for(let o=0;o<t.length;++o)n.push(t[o]===1?e[o+r]:t[o]);return n},Ef=(e,t)=>e.length>t.length?gd(e,t):gd(t,e),Pf=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=Ef(t,r),o=e[0].dataType,i=o===9||C.size(t)===1,a=o===9||t.length>0&&t[t.length-1]%4===0?4:1,d=i||n.length>0&&n[n.length-1]%4===0?4:1,l=Math.ceil(C.size(n)/d),p=u=>{let h=E(\"input\",o,t.length,a),_=M(\"output\",o,n.length,d),y;if(o===9){let g=(x,$,v=\"\")=>`\n          let outputIndices${$} = ${_.offsetToIndices(`outputOffset + ${$}u`)};\n          let offset${$} = ${h.broadcastedIndicesToOffset(`outputIndices${$}`,_)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${x}[${$}] = ${v}(${h.getByOffset(`index${$}`)}[component${$}]);\n        `;y=`\n        let outputOffset = global_idx * ${d};\n        var data = vec4<u32>(0);\n        ${g(\"data\",0,\"u32\")}\n        ${g(\"data\",1,\"u32\")}\n        ${g(\"data\",2,\"u32\")}\n        ${g(\"data\",3,\"u32\")}\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`}else y=`\n        let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\n        let inputOffset = ${h.broadcastedIndicesToOffset(\"outputIndices\",_)};\n        let data = ${_.type.value}(${h.getByOffset(`inputOffset / ${a}`)});\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`;return`\n    ${u.registerUniform(\"vec_size\",\"u32\").declareVariables(h,_)}\n    ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n    ${y}`},m=[{type:12,data:l},...N(t,n)];return{name:\"Expand\",shaderCache:{hint:`${n.length};${a}${d}`,inputDependencies:[\"rank\"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:m})}},bd=e=>{kf(e.inputs),e.compute(Pf(e.inputs),{inputs:[0]})}});var zf,_d,wd=U(()=>{\"use strict\";te();oe();ae();Kr();zf=e=>{let t=e[0].dataType,r=C.size(e[0].dims),n=C.size(e[1].dims),o=n%4===0,i=a=>{let d=E(\"x\",t,[1],4),l=E(\"bias\",t,[1],4),p=M(\"y\",t,[1],4),m=[{name:\"output_vec_size\",type:\"u32\"},{name:\"bias_size\",type:\"u32\"}],u=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${l.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,h=o?`\n      let bias = ${l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\")};`:`${u(0)}${u(1)}${u(2)}${u(3)}\n      let bias = ${d.type.value}(bias0, bias1, bias2, bias3);`;return`${a.registerUniforms(m).declareVariables(d,l,p)}\n\n    ${mo(Ee(t))}\n\n    ${a.mainStart(kt)}\n      ${a.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\")}\n\n      let x = ${d.getByOffset(\"global_idx\")};\n      ${h}\n      let x_in = x + bias;\n      ${p.setByOffset(\"global_idx\",fo(\"x_in\"))}\n    }`};return{name:\"FastGeluWithBias\",shaderCache:{hint:`${o}`,inputDependencies:[\"type\",\"type\"]},getShaderSource:i,getRunData:a=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:n}],dispatchGroup:{x:Math.ceil(r/kt/4)}})}},_d=e=>{e.inputs.length<2||C.size(e.inputs[1].dims)===0?hu(e):e.compute(zf(e.inputs))}});var Of,Df,vd,$d,xd=U(()=>{\"use strict\";te();oe();Se();ae();Of=e=>{if(!e||e.length!==2)throw new Error(\"Gather requires 2 inputs.\")},Df=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r.length,i=C.normalizeAxis(t.axis,o),a=r.slice(0);a.splice(i,1,...n);let d=r[i],l=e[0].dataType===9?4:1,p=Math.ceil(C.size(a)/l),m=[{type:12,data:p},{type:6,data:d},{type:12,data:i},...N(e[0].dims,e[1].dims,a)],u=h=>{let _=E(\"data\",e[0].dataType,e[0].dims.length,l),y=E(\"inputIndices\",e[1].dataType,e[1].dims.length),g=M(\"output\",e[0].dataType,a.length,l),x=v=>{let S=n.length,T=`var indicesIndices${v}  = ${y.type.indices}(0);`;for(let A=0;A<S;A++)T+=`${S>1?`indicesIndices${v}[${A}]`:`indicesIndices${v}`} = ${a.length>1?`outputIndices${v}[uniforms.axis + ${A}]`:`outputIndices${v}`};`;T+=`\n          var idx${v} = ${y.getByIndices(`indicesIndices${v}`)};\n          if (idx${v} < 0) {\n            idx${v} = idx${v} + uniforms.axisDimLimit;\n          }\n          var dataIndices${v} : ${_.type.indices};\n        `;for(let A=0,k=0;A<o;A++)A===i?(T+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = u32(idx${v});`,k+=S):(T+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = ${a.length>1?`outputIndices${v}[${k}]`:`outputIndices${v}`};`,k++);return T},$;if(e[0].dataType===9){let v=(S,T,A=\"\")=>`\n          let outputIndices${T} = ${g.offsetToIndices(`outputOffset + ${T}u`)};\n          ${x(T)};\n          let offset${T} = ${_.indicesToOffset(`dataIndices${T}`)};\n          let index${T} = offset${T} / 4u;\n          let component${T} = offset${T} % 4u;\n          ${S}[${T}] = ${A}(${_.getByOffset(`index${T}`)}[component${T}]);\n        `;$=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${v(\"value\",0,\"u32\")}\n        ${v(\"value\",1,\"u32\")}\n        ${v(\"value\",2,\"u32\")}\n        ${v(\"value\",3,\"u32\")}\n        ${g.setByOffset(\"global_idx\",\"value\")}\n      `}else $=`\n      let outputIndices = ${g.offsetToIndices(\"global_idx\")};\n      ${x(\"\")};\n      let value = ${_.getByIndices(\"dataIndices\")};\n      ${g.setByOffset(\"global_idx\",\"value\")};\n      `;return`\n      ${h.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(_,y,g)}\n      ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        ${$}\n      }`};return{name:\"Gather\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:u}},vd=e=>re({axis:e.axis}),$d=(e,t)=>{let r=e.inputs;Of(r),e.compute(Df(e.inputs,t))}});var Bf,Sd,Td,Id=U(()=>{\"use strict\";te();oe();ae();Bf=(e,t,r,n,o,i,a,d,l)=>{let p=[{type:12,data:i},{type:12,data:n},{type:12,data:o},{type:12,data:r},{type:12,data:a},{type:12,data:d},{type:12,data:l}],m=[i];p.push(...N(t.dims,m));let u=h=>{let _=E(\"indices_data\",t.dataType,t.dims.length),y=M(\"input_slice_offsets_data\",12,1,1),g=[_,y],x=[{name:\"output_size\",type:\"u32\"},{name:\"batch_dims\",type:\"u32\"},{name:\"input_dims\",type:\"u32\",length:o.length},{name:\"sizes_from_slice_dims_data\",type:\"u32\",length:r.length},{name:\"num_slices_per_batch\",type:\"u32\"},{name:\"input_batch_stride\",type:\"u32\"},{name:\"num_slice_dims\",type:\"u32\"}];return`\n  ${h.registerUniforms(x).declareVariables(...g)}\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${o.length===1?\"index += i32(uniforms.input_dims);\":\"index += i32(uniforms.input_dims[input_dim_idx]);\"}\n      }\n      ${r.length===1?\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\":\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`};return e.compute({name:\"computeSliceOffsets\",shaderCache:{hint:`${o.length}_${r.length}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:m,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:p}),getShaderSource:u},{inputs:[t],outputs:[-1]})[0]},Sd=(e,t)=>{let r=e.inputs,n=r[0].dims,o=r[0].dataType,i=r[1].dims,a=i[i.length-1],d=C.sizeToDimension(i,i.length-1),l=C.sizeFromDimension(n,t.batchDims+a),p=C.sizeToDimension(n,t.batchDims),m=C.sizeFromDimension(n,t.batchDims),u=d/p,h=new Array(a),_=l;for(let T=0;T<a;++T)h[a-1-T]=_,_*=n[t.batchDims+a-1-T];let y=Bf(e,r[1],h,t.batchDims,n,d,u,m,a),g=t.batchDims+a;if(g>n.length)throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");let x=i.slice(0,-1).concat(n.slice(g)),$=C.size(x),v=[{type:12,data:$},{type:12,data:l},...N(r[0].dims,y.dims,x)],S=T=>{let A=E(\"data\",r[0].dataType,r[0].dims.length),k=E(\"slice_offsets\",12,y.dims.length),P=M(\"output\",r[0].dataType,x.length);return`\n          ${T.registerUniform(\"output_size\",\"u32\").registerUniform(\"slice_size\",\"u32\").declareVariables(A,k,P)}\n            ${T.mainStart()}\n            ${T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`};e.compute({name:\"GatherND\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:x,dataType:o}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:v}),getShaderSource:S},{inputs:[r[0],y]})},Td=e=>({batchDims:e.batch_dims,cacheKey:\"\"})});var Mf,Rf,Cd,Ad,kd=U(()=>{\"use strict\";te();oe();Se();ae();Mf=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");let r=C.normalizeAxis(t.quantizeAxis,e[0].dims.length),n=t.blockSize,o=e[0],i=e[2],a=e.length===4?e[3]:void 0;if(i.dims.length!==o.dims.length||!o.dims.map((d,l)=>l===r?Math.ceil(d/n)===i.dims[l]:d===i.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");if(a){if(a.dataType!==o.dataType)throw new Error(\"Zero point must have the same data type as the input tensor.\");if(a.dims.length!==i.dims.length||!a.dims.map((d,l)=>d===i.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\")}},Rf=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r.length,i=C.normalizeAxis(t.gatherAxis,o),a=C.normalizeAxis(t.quantizeAxis,o),d=r.slice(0);d.splice(i,1,...n);let l=C.size(d),p=e[2].dataType,u=e[0].dataType===22,h=[{type:12,data:l},{type:12,data:a},{type:12,data:i},{type:12,data:t.blockSize},...N(...e.map((y,g)=>y.dims),d)],_=y=>{let g=E(\"data\",e[0].dataType,e[0].dims.length),x=E(\"inputIndices\",e[1].dataType,e[1].dims.length),$=E(\"scales\",e[2].dataType,e[2].dims.length),v=e.length>3?E(\"zeroPoint\",e[3].dataType,e[3].dims.length):void 0,S=M(\"output\",p,d.length),T=[g,x,$];v&&T.push(v);let A=[{name:\"output_size\",type:\"u32\"},{name:\"quantize_axis\",type:\"u32\"},{name:\"gather_axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n        ${y.registerUniforms(A).declareVariables(...T,S)}\n        ${y.mainStart()}\n        let output_indices = ${S.offsetToIndices(\"global_idx\")};\n        var indices_indices = ${x.type.indices}(0);\n        ${(()=>n.length>1?`\n          for (var i: u32 = 0; i < ${n.length}; i++) {\n            let index = ${S.indicesGet(\"output_indices\",\"uniforms.gather_axis + i\")};\n            ${x.indicesSet(\"indices_indices\",\"i\",\"index\")};\n          }`:`indices_indices = ${S.indicesGet(\"output_indices\",\"uniforms.gather_axis\")};`)()};\n        var data_indices = ${g.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${S.indicesGet(\"output_indices\",\"i\")};\n          ${g.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        var index_from_indices = ${x.getByIndices(\"indices_indices\")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${r[i]};\n        }\n        ${g.indicesSet(\"data_indices\",\"uniforms.gather_axis\",\"u32(index_from_indices)\")};\n        for (var i = uniforms.gather_axis + 1; i < ${d.length}; i++) {\n          let index = ${S.indicesGet(\"output_indices\",`i + ${n.length} - 1`)};\n          ${g.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        let data_offset = ${g.indicesToOffset(\"data_indices\")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${g.getByOffset(\"data_offset / 8\")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${u?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${$.indicesGet(\"data_indices\",\"uniforms.quantize_axis\")} / uniforms.block_size;\n        ${$.indicesSet(\"scale_indices\",\"uniforms.quantize_axis\",\"quantize_axis_index\")};\n        var scale = ${$.getByIndices(\"scale_indices\")};\n        ${(()=>v?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${v.indicesToOffset(\"zero_point_indices\")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${v.getByOffset(\"zero_point_offset / 8\")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${u?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:\"var zero_point = 0\")()};\n        let dequantized_data = ${Ee(p)}(quantized_data - zero_point) * scale;\n        ${S.setByOffset(\"global_idx\",\"dequantized_data\")};\n    }`};return{name:\"GatherBlockQuantized\",shaderCache:{hint:`${t.cacheKey};${e.filter((y,g)=>g!==1).map(y=>y.dims.join(\"_\")).join(\";\")}`,inputDependencies:Array.from({length:e.length},(y,g)=>\"rank\")},getRunData:()=>({outputs:[{dims:d,dataType:p}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:h}),getShaderSource:_}},Cd=(e,t)=>{let r=e.inputs;Mf(r,t),e.compute(Rf(e.inputs,t))},Ad=e=>re({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})});var Uf,Nf,Ed,Pd,zd=U(()=>{\"use strict\";te();oe();Se();ae();Uf=e=>{if(!e||e.length!==2)throw new Error(\"GatherElements requires 2 inputs.\");if(e[0].dims.length<1)throw new Error(\"GatherElements requires that the data input be rank >= 1.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Nf=(e,t)=>{let r=e[0].dims,n=e[0].dataType,o=r.length,i=e[1].dims,a=e[1].dataType,d=C.normalizeAxis(t.axis,o),l=r[d],p=i.slice(0),m=C.size(p),u=E(\"input\",n,o),h=E(\"indicesInput\",a,i.length),_=M(\"output\",n,p.length),y=[{type:12,data:m},{type:6,data:l},{type:12,data:d}];return y.push(...N(r,i,p)),{name:\"GatherElements\",shaderCache:{inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:y}),getShaderSource:$=>`\n      ${$.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(u,h,_)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n      let outputIndices = ${_.offsetToIndices(\"global_idx\")};\n\n      var idx = ${h.getByOffset(\"global_idx\")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${u.type.indices}(outputIndices);\n      ${u.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(idx)\")};\n      let value = ${u.getByIndices(\"inputIndices\")};\n\n      ${_.setByOffset(\"global_idx\",\"value\")};\n  }`}},Ed=e=>re({axis:e.axis}),Pd=(e,t)=>{let r=e.inputs;Uf(r),e.compute(Nf(e.inputs,t))}});var Vf,Wf,Od,Dd,Bd=U(()=>{\"use strict\";te();oe();ae();Vf=e=>{if(!e)throw new Error(\"Input is missing\");if(e.length<2||e.length>3)throw new Error(\"Invaid input number.\");if(e.length===3&&e[2].dims.length>2)throw new Error(\"Invalid input shape of C\");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"Input types are mismatched\")},Wf=(e,t)=>{let r=e[0].dims.slice(),n=e[1].dims.slice(),[o,i,a]=Vr.getShapeOfGemmResult(r,t.transA,n,t.transB,e.length===3?e[2].dims:void 0),d=[o,i];if(!d)throw new Error(\"Can't use gemm on the given tensors\");let l=16,p=Math.ceil(i/l),m=Math.ceil(o/l),u=!0,h=C.size(d),_=[{type:12,data:u?p:h},{type:12,data:o},{type:12,data:i},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}],y=[\"type\",\"type\"];e.length===3&&(_.push(...N(e[2].dims)),y.push(\"rank\")),_.push(...N(d));let g=$=>{let v=\"\";t.transA&&t.transB?v=\"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\":t.transA&&!t.transB?v=\"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\":!t.transA&&t.transB?v=\"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\":!t.transA&&!t.transB&&(v=\"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");let S=t.alpha===1?\"\":\"value *= uniforms.alpha;\",T=E(\"a\",e[0].dataType,e[0].dims),A=E(\"b\",e[1].dataType,e[1].dims),k=T.type.value,P=null,D=[T,A];e.length===3&&(P=E(\"c\",e[2].dataType,e[2].dims.length),D.push(P));let R=M(\"output\",e[0].dataType,d.length);D.push(R);let G=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}];return`\n  ${$.registerUniforms(G).declareVariables(...D)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${k}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${v}\n    }\n\n    ${S}\n    ${(()=>P!=null?`let cOffset = ${P.broadcastedIndicesToOffset(\"vec2(m, n)\",R)}; value += ${k}(uniforms.beta) * ${P.getByOffset(\"cOffset\")};`:\"\")()}\n    output[global_idx] = value;\n  }`},x=$=>{let v=E(\"a\",e[0].dataType,e[0].dims),S=E(\"b\",e[1].dataType,e[1].dims),T=null,A=[v,S];e.length===3&&(T=E(\"c\",e[2].dataType,e[2].dims.length),A.push(T));let k=M(\"output\",e[0].dataType,d.length);A.push(k);let P=[{name:\"num_tile_n\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}],D=\"\",R=\"\";t.transA&&t.transB?(R=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\"):t.transA&&!t.transB?(R=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\"):!t.transA&&t.transB?(R=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\"):!t.transA&&!t.transB&&(R=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `,D=\"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");let G=t.alpha===1?\"\":\"value *= uniforms.alpha;\";return`\n  ${$.registerUniforms(P).declareVariables(...A)}\n  var<workgroup> tile_a: array<array<${v.type.storage}, ${l}>, ${l}>;\n  var<workgroup> tile_b: array<array<${S.type.storage}, ${l}>, ${l}>;\n  ${$.mainStart([l,l,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};\n    let num_tiles = (uniforms.K - 1) / ${l} + 1;\n    var k_start = 0u;\n    var value = ${k.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${R}\n      k_start = k_start + ${l};\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < ${l}; k++) {\n        ${D}\n      }\n      workgroupBarrier();\n    }\n\n    ${G}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${(()=>T!=null?`let cOffset = ${T.broadcastedIndicesToOffset(\"vec2(m, n)\",k)}; value += ${k.type.value}(uniforms.beta) * ${T.getByOffset(\"cOffset\")};`:\"\")()}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`};return u?{name:\"GemmShared\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:p*m},programUniforms:_}),getShaderSource:x}:{name:\"Gemm\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_}),getShaderSource:g}},Od=e=>{let t=e.transA,r=e.transB,n=e.alpha,o=e.beta;return{transA:t,transB:r,alpha:n,beta:o,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},Dd=(e,t)=>{Vf(e.inputs),e.compute(Wf(e.inputs,t))}});var lt,_t,Ut,Nt,Lf,Gf,Hf,Ff,qf,Kf,jf,Yf,Md,Rd,Ud=U(()=>{\"use strict\";te();oe();Se();ae();[lt,_t,Ut,Nt]=[0,1,2,3],Lf=e=>{if(e[0].dims.length!==4)throw new Error(\"only 4-D tensor is supported.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"input dimensions must be equal to grid dimensions\");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error(\"grid batch size must match input batch size\")},Gf=`\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n`,Hf=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Ff=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${e.alignCorners===0?`\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    `:`\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    `}\n  }\n`,qf=e=>`\n  ${e.paddingMode===\"reflection\"?`\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }`:\"\"}\n`,Kf=(e,t,r)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${lt}] = batch;\n     indices[${_t}] = channel;`+(()=>{switch(r.paddingMode){case\"zeros\":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${Ut}] = u32(r);\n            indices[${Nt}] = u32(c);\n          }\n        `;case\"border\":return`\n          indices[${Ut}] = u32(clamp(r, 0, H - 1));\n          indices[${Nt}] = u32(clamp(c, 0, W - 1));\n        `;case\"reflection\":return`\n          indices[${Ut}] = gs_reflect(r, border[1], border[3]);\n          indices[${Nt}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${r.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices(\"indices\")};\n  }\n`,jf=(e,t,r)=>(()=>{switch(r.mode){case\"nearest\":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${lt}], indices[${_t}], border);\n        `;case\"bilinear\":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${lt}], indices[${_t}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case\"bicubic\":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${lt}], indices[${_t}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${r.mode} is not supported`)}})()+`${e.setByOffset(\"global_idx\",\"result\")}`,Yf=(e,t)=>{let r=E(\"x\",e[0].dataType,e[0].dims.length),n=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],o=E(\"grid\",e[1].dataType,n.length,2),i=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format===\"NHWC\"&&(i=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[lt,_t,Ut,Nt]=[0,3,1,2]);let a=M(\"output\",e[0].dataType,i.length),d=r.type.value,l=C.size(i),p=[{type:12,data:l},...N(e[0].dims,n,i)],m=u=>`\n  ${u.registerUniform(\"output_size\",\"u32\").declareVariables(r,o,a)}\n  ${Gf}\n  ${Hf(d)}\n  ${Ff(t)}\n  ${qf(t)}\n  ${Kf(r,d,t)}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let H_in = i32(uniforms.x_shape[${Ut}]);\n      let W_in = i32(uniforms.x_shape[${Nt}]);\n\n      ${t.alignCorners===0?`\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      `:`\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      `};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${a.offsetToIndices(\"global_idx\")};\n      var grid_indices = vec3<u32>(indices[${lt}], indices[${Ut}], indices[${Nt}]);\n      let nxy = ${o.getByIndices(\"grid_indices\")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${jf(a,d,t)}\n  }`;return{name:\"GridSample\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:[\"type\",\"type\"]},getRunData:u=>{let h=C.size(i);return{outputs:[{dims:i,dataType:u[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:p}},getShaderSource:m}},Md=(e,t)=>{Lf(e.inputs),e.compute(Yf(e.inputs,t))},Rd=e=>re({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})});var Be,Xf,Vd,Nd,Jf,tr,Wd,So=U(()=>{\"use strict\";te();oe();Se();Nr();Fr();ae();dt();Be=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Xf=(e,t)=>{let r=e[0],n=Be(e,1),o=Be(e,2),i=Be(e,3),a=Be(e,4),d=Be(e,5),l=Be(e,6),p=Be(e,7);if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let m=r.dims[0],u=r.dims[1],h=r.dims.length===3?r.dims[2]:t.numHeads*r.dims[4],_=u,y=0,g=0,x=Math.floor(h/t.numHeads);if(l&&p&&C.size(l.dims)&&C.size(p.dims)){if(l.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(l.dims[0]!==m||l.dims[1]!==t.numHeads||l.dims[3]!==x)throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(p.dims[0]!==m||p.dims[1]!==t.numHeads||p.dims[3]!==x)throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==p.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');if(p.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');y=l.dims[2],g=l.dims[2]}else if(l&&C.size(l.dims)||p&&C.size(p.dims))throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let $;if(n&&C.size(n.dims)>0){if(r.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(n.dims.length===3){if(n.dims[2]!==r.dims[2])throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');$=2,_=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==x)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');$=5,_=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==x)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');$=0,_=n.dims[2]}}else{if(r.dims.length!==5)throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');if(r.dims[2]!==t.numHeads||r.dims[3]!==3)throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');$=3}if(i&&C.size(i.dims)>0){if(i.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimension');if(n&&n.dims.length===5&&n.dims[3]===2)throw new Error(\"bias is not allowed for packed kv.\")}let v=y+_,S=0;if(a&&C.size(a.dims)>0){S=8;let P=a.dims;throw P.length===1?P[0]===m?S=1:P[0]===3*m+2&&(S=3):P.length===2&&P[0]===m&&P[1]===v&&(S=5),S===8?new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error(\"Mask not supported\")}let T=!1,A=h;if(o&&C.size(o.dims)>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(r.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(_!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(_!==o.dims[2])throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],T=!0}}let k=!1;if(a&&C.size(a.dims)>0)throw new Error(\"Key padding mask is not supported\");if(d&&C.size(d.dims)>0){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');if(d.dims[0]!==m||d.dims[1]!==t.numHeads||d.dims[2]!==u||d.dims[3]!==v)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:m,sequenceLength:u,pastSequenceLength:y,kvSequenceLength:_,totalSequenceLength:v,maxSequenceLength:g,inputHiddenSize:0,hiddenSize:h,vHiddenSize:A,headSize:x,vHeadSize:Math.floor(A/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:S,scale:t.scale,broadcastResPosBias:k,passPastInKv:T,qkvFormat:$}},Vd=e=>re({...e}),Nd=re({perm:[0,2,1,3]}),Jf=(e,t,r,n,o,i,a)=>{let d=[n,o,i],l=C.size(d),p=[{type:12,data:l},{type:12,data:a},{type:12,data:i}],m=u=>{let h=M(\"qkv_with_bias\",t.dataType,d),_=E(\"qkv\",t.dataType,d),y=E(\"bias\",r.dataType,d),g=[{name:\"output_size\",type:\"u32\"},{name:\"bias_offset\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"}];return`\n  ${u.registerUniforms(g).declareVariables(_,y,h)}\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:\"MultiHeadAttentionAddBias\",shaderCache:{inputDependencies:[\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:m},{inputs:[t,r],outputs:[-1]})[0]},tr=(e,t,r,n,o,i,a,d)=>{let l=i;if(a&&C.size(a.dims)>0){if(n===1)throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");return l=Jf(e,i,a,t,n,r*o,d),l=l.reshape([t,n,r,o]),r===1||n===1?l:e.compute(Pe(l,Nd.perm),{inputs:[l],outputs:[-1]})[0]}else return i.dims.length===3&&(l=i.reshape([t,n,r,o])),r===1||n===1?l:e.compute(Pe(l,Nd.perm),{inputs:[l],outputs:[-1]})[0]},Wd=(e,t)=>{let r=Xf(e.inputs,t),n=e.inputs[0],o=Be(e.inputs,1),i=Be(e.inputs,2),a=Be(e.inputs,3),d=Be(e.inputs,4),l=Be(e.inputs,5),p=Be(e.inputs,6),m=Be(e.inputs,7);if(n.dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(o?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let u=o&&i&&o.dims.length===4&&i.dims.length===4,h=tr(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,n,a,0);if(u)return Rt(e,h,o,i,d,void 0,p,m,l,r);if(!o||!i)throw new Error(\"key and value must be provided\");let _=tr(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,o,a,r.hiddenSize),y=tr(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,i,a,2*r.hiddenSize);Rt(e,h,_,y,d,void 0,p,m,l,r)}});var eh,th,rh,nh,To,Ld,Gd,Io=U(()=>{\"use strict\";te();oe();Se();ae();eh=e=>{if(!e||e.length<1)throw new Error(\"too few inputs\")},th=(e,t)=>{let r=[],n=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),n=r.length),re({numOutputs:n,axis:t.axis,splitSizes:r})},rh=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${F(\"uniforms.size_in_split_axis\",\"i\",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,nh=e=>{let t=e.length,r=[];for(let n=0;n<t;++n){let o=e[n].setByIndices(\"indices\",\"input[global_idx]\");t===1?r.push(o):n===0?r.push(`if (output_number == ${n}u) { ${o} }`):n===t-1?r.push(`else { ${o} }`):r.push(`else if (output_number == ${n}) { ${o} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},To=(e,t)=>{let r=e[0].dims,n=C.size(r),o=e[0].dataType,i=C.normalizeAxis(t.axis,r.length),a=new Array(t.numOutputs),d=E(\"input\",o,r.length),l=new Array(t.numOutputs),p=[],m=[],u=0,h=[{type:12,data:n}];for(let y=0;y<t.numOutputs;y++){u+=t.splitSizes[y],l[y]=u;let g=r.slice();g[i]=t.splitSizes[y],m.push(g),a[y]=M(`output${y}`,o,g.length),p.push({dims:m[y],dataType:e[0].dataType})}h.push({type:12,data:l},...N(r,...m));let _=y=>`\n  ${y.registerUniform(\"input_size\",\"u32\").registerUniform(\"size_in_split_axis\",\"u32\",l.length).declareVariables(d,...a)}\n  ${rh(l.length)}\n  ${nh(a)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\")}\n\n    var indices = ${d.offsetToIndices(\"global_idx\")};\n    var index = ${d.indicesGet(\"indices\",i)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${F(\"uniforms.size_in_split_axis\",\"output_number - 1u\",l.length)};\n      ${d.indicesSet(\"indices\",i,\"index\")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:\"Split\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\"]},getShaderSource:_,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(n/64)},programUniforms:h})}},Ld=(e,t)=>{eh(e.inputs);let r=e.inputs.length===1?t:th(e.inputs,t);e.compute(To(e.inputs,r),{inputs:[0]})},Gd=e=>{let t=e.axis,r=e.splitSizes,n=e.numOutputs<0?r.length:e.numOutputs;if(n!==r.length)throw new Error(\"numOutputs and splitSizes lengh must be equal\");return re({axis:t,numOutputs:n,splitSizes:r})}});var oh,ih,Hd,Fd,qd=U(()=>{\"use strict\";Se();Fr();So();Io();dt();oh=(e,t)=>{if(t.doRotary)throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");if(t.doRotary&&e.length<=7)throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");let r=e[0],n=e[1],o=e[2],i=e[3],a=e[4];if(t.localWindowSize!==-1)throw new Error(\"Local attention is not supported\");if(t.softcap!==0)throw new Error(\"Softcap is not supported\");if(t.rotaryInterleaved!==0)throw new Error(\"Rotary interleaved is not supported\");if(t.smoothSoftmax)throw new Error(\"Smooth softmax is not supported\");if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let d=!1,l=r.dims[0],p=r.dims[1],m=r.dims.length===3?d?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],u=p,h=0,_=!n||n.dims.length===0,y=Math.floor(_?m/(t.numHeads+2*t.kvNumHeads):m/t.numHeads);_&&(m=y*t.numHeads);let g=i&&i.dims.length!==0,x=a&&a.dims.length!==0;if(g&&i.dims.length===4&&i.dims[0]===l&&i.dims[1]!==t.kvNumHeads&&i.dims[2]===t.kvNumHeads&&i.dims[3]===y)throw new Error(\"BSNH pastKey/pastValue is not supported\");if(g&&x){if(i.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(a.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');h=i.dims[2]}else if(g||x)throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let v=1;if(n&&n.dims.length>0){if(r.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(n.dims.length===3){if(r.dims[2]%n.dims[2]!==0)throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');u=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==y)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');u=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==y)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');u=n.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');v=3}let S=0,T=!1,A=t.kvNumHeads?y*t.kvNumHeads:m;if(o&&o.dims.length>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(r.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(u!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(u!==o.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],T=!0}}let k=e.length>4?e[5]:void 0;if(k&&k.dims.length!==1&&k.dims[0]!==l)throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');let P=-1,D=-1,R=!1;return{batchSize:l,sequenceLength:p,pastSequenceLength:h,kvSequenceLength:u,totalSequenceLength:P,maxSequenceLength:D,inputHiddenSize:0,hiddenSize:m,vHiddenSize:A,headSize:y,vHeadSize:Math.floor(A/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:S,scale:t.scale,broadcastResPosBias:R,passPastInKv:T,qkvFormat:v}},ih=re({perm:[0,2,1,3]}),Hd=(e,t,r)=>{let n=t,o=r.kvNumHeads;return t.dims.length===3&&r.kvSequenceLength!==0&&(n=t.reshape([r.batchSize,r.kvSequenceLength,o,r.headSize]),n=e.compute(Pe(n,ih.perm),{inputs:[n],outputs:[-1]})[0]),n},Fd=(e,t)=>{let r=oh(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(e.inputs[1]?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let n=e.inputs[0],o=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,i=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,a=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,d=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,p=e.inputs.length>5?e.inputs[6]:void 0,m=r.kvNumHeads?r.kvNumHeads:r.numHeads,u=re({axis:2,numOutputs:3,splitSizes:[r.numHeads*r.headSize,m*r.headSize,m*r.headSize]}),[h,_,y]=!o&&!i?e.compute(To([n],u),{inputs:[n],outputs:[-1,-1,-1]}):[n,o,i],g=tr(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,h,void 0,0);Rt(e,g,Hd(e,_,r),Hd(e,y,r),void 0,void 0,a,d,void 0,r,l,p)}});var Kd,ah,sh,jd,Yd=U(()=>{\"use strict\";te();oe();dt();ae();Kd=(e,t,r,n,o,i,a,d)=>{let l=me(i),p=l===1?\"f32\":`vec${l}f`,m=l===1?\"vec2f\":`mat2x${l}f`,u=o*a,h=64;u===1&&(h=256);let _=[o,a,i/l],y=[o,a,2],g=[\"rank\",\"type\",\"type\"],x=[];x.push(...N(_,y));let $=v=>{let S=E(\"x\",t.dataType,3,l),T=E(\"scale\",r.dataType,r.dims),A=E(\"bias\",n.dataType,n.dims),k=M(\"output\",1,3,2),P=[S,T,A,k];return`\n  var<workgroup> workgroup_shared : array<${m}, ${h}>;\n  const workgroup_size = ${h}u;\n  ${v.declareVariables(...P)}\n  ${v.mainStart(h)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${p}(0);\n    var squared_sum = ${p}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${p}(${S.get(\"batch\",\"channel\",\"h\")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${m}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${Fe(\"workgroup_shared[0][0]\",l)} / f32(hight * ${l});\n      let squared_sum_final = ${Fe(\"workgroup_shared[0][1]\",l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${d}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`};return e.compute({name:\"InstanceNormComputeChannelScaleShift\",shaderCache:{hint:`${l};${d};${h}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:y,dataType:1}],dispatchGroup:{x:u},programUniforms:x}),getShaderSource:$},{inputs:[t,r,n],outputs:[-1]})[0]},ah=(e,t,r)=>{let n=t[0].dims,o=n,i=2,a=n[0],d=n[1],l=C.sizeFromDimension(n,i),p=me(l),m=C.size(o)/p,u=Kd(e,t[0],t[1],t[2],a,l,d,r.epsilon),h=[a,d,l/p],_=[a,d],y=[\"type\",\"none\"],g=x=>{let $=E(\"x\",t[0].dataType,h.length,p),v=E(\"scale_shift\",1,_.length,2),S=M(\"output\",t[0].dataType,h.length,p),T=[$,v,S];return`\n  ${x.registerUniform(\"output_size\",\"u32\").declareVariables(...T)}\n  ${x.mainStart()}\n  ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let outputIndices = ${S.offsetToIndices(\"global_idx\")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${v.getByIndices(\"vec2<u32>(batch, channel)\")};\n      let value = ${$.getByOffset(\"global_idx\")} * ${S.type.value}(scale_shift.x) + ${S.type.value}(scale_shift.y);\n      ${S.setByOffset(\"global_idx\",\"value\")};\n  }`};e.compute({name:\"InstanceNormalization\",shaderCache:{hint:`${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...N(h,_,h)]}),getShaderSource:g},{inputs:[t[0],u]})},sh=(e,t,r)=>{let n=t[0].dims,o=n,i=n[0],a=n[n.length-1],d=C.sizeFromDimension(n,1)/a,l=me(a),p=C.size(o)/l,m=[{type:12,data:d},{type:12,data:Math.floor(a/l)}],u=[\"type\",\"type\"],h=!1,_=[0,n.length-1];for(let $=0;$<n.length-2;$++)h=h||n[$+1]!==1,_.push($+1);h=h&&n[n.length-1]!==1;let y=h?e.compute(Pe(e.inputs[0],_),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:n.length},($,v)=>n[_[v]])),g=Kd(e,y,t[1],t[2],i,d,a,r.epsilon),x=$=>{let v=_e(t[0].dataType),S=l===1?\"vec2f\":`mat${l}x2f`,T=P=>{let D=P===0?\"x\":\"y\",R=l===1?\"f32\":`vec${l}f`;switch(l){case 1:return`${v}(${R}(scale.${D}))`;case 2:return`vec2<${v}>(${R}(scale[0].${D}, scale[1].${D}))`;case 4:return`vec4<${v}>(${R}(scale[0].${D}, scale[1].${D}, scale[2].${D}, scale[3].${D}))`;default:throw new Error(`Not supported compoents ${l}`)}},A=E(\"input\",t[0].dataType,t[0].dims,l),k=M(\"output\",t[0].dataType,o,l);return`\n  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${S}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${k.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${$.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${T(0)}, ${T(1)});\n  }`};e.compute({name:\"InstanceNormalizationNHWC\",shaderCache:{hint:`${l}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:x},{inputs:[t[0],g]})},jd=(e,t)=>{t.format===\"NHWC\"?sh(e,e.inputs,t):ah(e,e.inputs,t)}});var uh,dh,Zd,Qd=U(()=>{\"use strict\";te();oe();ae();uh=e=>{if(!e||e.length<2)throw new Error(\"layerNorm requires at least 2 inputs.\")},dh=(e,t,r)=>{let n=t.simplified,o=e[0].dims,i=e[1],a=!n&&e[2],d=o,l=C.normalizeAxis(t.axis,o.length),p=C.sizeToDimension(o,l),m=C.sizeFromDimension(o,l),u=C.size(i.dims),h=a?C.size(a.dims):0;if(u!==m||a&&h!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${u} and bias size of ${h}`);let _=[];for(let A=0;A<o.length;++A)A<l?_.push(o[A]):_.push(1);let y=me(m),g=[\"type\",\"type\"],x=[{type:12,data:p},{type:1,data:m},{type:12,data:Math.floor(m/y)},{type:1,data:t.epsilon}];a&&g.push(\"type\");let $=r>1,v=r>2,S=A=>{let k=_e(e[0].dataType),P=[E(\"x\",e[0].dataType,e[0].dims,y),E(\"scale\",i.dataType,i.dims,y)];a&&P.push(E(\"bias\",a.dataType,a.dims,y)),P.push(M(\"output\",e[0].dataType,d,y)),$&&P.push(M(\"mean_data_output\",1,_)),v&&P.push(M(\"inv_std_output\",1,_));let D=[{name:\"norm_count\",type:\"u32\"},{name:\"norm_size\",type:\"f32\"},{name:\"norm_size_vectorized\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}];return`\n  ${A.registerUniforms(D).declareVariables(...P)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${uo(\"f32\",y)};\n    var mean_square_vector = ${uo(\"f32\",y)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Et(k,y,\"x[h + offset]\")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${Fe(\"mean_vector\",y)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${Fe(\"mean_square_vector\",y)} / uniforms.norm_size ${n?\"\":\"- mean * mean\"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Et(k,y,\"x[j + offset]\")};\n      let f32scale = ${Et(k,y,\"scale[j]\")};\n      output[j + offset] = ${P[0].type.value}((f32input ${n?\"\":\"- mean\"}) * inv_std_dev * f32scale\n        ${a?`+ ${Et(k,y,\"bias[j]\")}`:\"\"}\n      );\n    }\n\n    ${$?\"mean_data_output[global_idx] = mean\":\"\"};\n    ${v?\"inv_std_output[global_idx] = inv_std_dev\":\"\"};\n  }`},T=[{dims:d,dataType:e[0].dataType}];return $&&T.push({dims:_,dataType:1}),v&&T.push({dims:_,dataType:1}),{name:\"LayerNormalization\",shaderCache:{hint:`${y};${r};${n}`,inputDependencies:g},getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(p/64)},programUniforms:x}),getShaderSource:S}},Zd=(e,t)=>{uh(e.inputs),e.compute(dh(e.inputs,t,e.outputCount))}});var lh,Xd,Jd=U(()=>{\"use strict\";oe();Qr();Xr();lh=e=>{if(!e||e.length!==2)throw new Error(\"MatMul requires 2 inputs.\");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error(\"shared dimension does not match.\")},Xd=e=>{lh(e.inputs);let t=tt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error(\"Can't use matmul on the given tensors\");let r=t[t.length-1],n=e.inputs[0].dims[e.inputs[0].dims.length-1];if(r<8&&n<8)e.compute(Zr(e.inputs,{activation:\"\"},t));else{let o=t[t.length-2],i=C.size(e.inputs[0].dims.slice(0,-2)),a=C.size(e.inputs[1].dims.slice(0,-2));if(i!==1&&o===1&&a===1){let d=e.inputs[0].reshape([1,i,n]),l=e.inputs[1].reshape([1,n,r]),p=[1,i,r],m=[d,l];e.compute(er(m,{activation:\"\"},t,p),{inputs:m})}else e.compute(er(e.inputs,{activation:\"\"},t))}}});var ch,ph,mh,el,tl,rl=U(()=>{\"use strict\";te();oe();Se();ae();ch=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"MatMulNBits requires 3 or 4 inputs\");let r=e[0],n=r.dims.length;if(r.dims[n-1]!==t.k)throw new Error(\"The last dim of input shape does not match the k value\");let o=Math.floor((t.k+t.blockSize-1)/t.blockSize),i=t.blockSize/8*t.bits,a=e[1];if(!C.areEqual(a.dims,[t.n,o,i]))throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");let l=e[2].dims;if(C.size(l)!==t.n*o)throw new Error(\"scales input size error.\");if(e.length===4){let m=e[3].dims,u=t.bits>4?t.n*o:t.n*Math.floor((o+1)/2);if(C.size(m)!==u)throw new Error(\"zeroPoints input size error.\")}},ph=(e,t)=>{let r=e[0].dims,n=r.length,o=r[n-2],i=t.k,a=t.n,d=r.slice(0,n-2),l=C.size(d),m=e[1].dims[2]/4,u=e[0].dataType,h=me(t.k),_=me(m),y=me(a),g=d.concat([o,a]),x=o>1&&a/y%2===0?2:1,$=C.size(g)/y/x,v=64,S=[],T=[l,o,i/h],A=C.convertShape(e[1].dims).slice();A.splice(-1,1,m/_),S.push(...N(T)),S.push(...N(A)),S.push(...N(e[2].dims)),e.length===4&&S.push(...N(C.convertShape(e[3].dims)));let k=[l,o,a/y];S.push(...N(k));let P=D=>{let R=T.length,G=E(\"a\",e[0].dataType,R,h),K=E(\"b\",12,A.length,_),j=E(\"scales\",e[2].dataType,e[2].dims.length),V=[G,K,j],Q=e.length===4?E(\"zero_points\",12,e[3].dims.length):void 0;Q&&V.push(Q);let se=k.length,Y=M(\"output\",e[0].dataType,se,y),ee=_e(e[0].dataType),J=(()=>{switch(h){case 1:return`array<${ee}, 8>`;case 2:return`mat4x2<${ee}>`;case 4:return`mat2x4<${ee}>`;default:throw new Error(`${h}-component is not supported.`)}})(),ne=()=>{let $e=`\n          // reuse a data\n            var input_offset = ${G.indicesToOffset(`${G.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${J};\n            for (var j: u32 = 0; j < ${8/h}; j++) {\n              a_data[j] = ${G.getByOffset(\"input_offset\")};\n              input_offset++;\n            }\n          `;for(let le=0;le<y*x;le++)$e+=`\n            b_value = ${_===1?`b${le}_data`:`b${le}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${J}(${Array.from({length:4},(W,q)=>`${ee}(b_value_lower[${q}]), ${ee}(b_value_upper[${q}])`).join(\", \")});\n            b_dequantized_values = ${(()=>h===1?`${J}(${Array.from({length:8},(W,q)=>`(b_quantized_values[${q}] - ${Q?`zero_point${le}`:\"zero_point\"}) * scale${le}`).join(\", \")});`:`(b_quantized_values - ${J}(${Array(8).fill(`${Q?`zero_point${le}`:\"zero_point\"}`).join(\",\")})) * scale${le};`)()};\n            workgroup_shared[local_id.x * ${x} + ${Math.floor(le/y)}]${y>1?`[${le%y}]`:\"\"} += ${Array.from({length:8/h},(W,q)=>`${h===1?`a_data[${q}] * b_dequantized_values[${q}]`:`dot(a_data[${q}], b_dequantized_values[${q}])`}`).join(\" + \")};\n          `;return $e},be=()=>{let $e=`\n            var col_index = col * ${y};\n            ${Q?`\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${ee}(8);`}\n            `;for(let le=0;le<y*x;le++)$e+=`\n            let scale${le} = ${j.getByOffset(\"col_index * nBlocksPerCol + block\")};\n            ${Q?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${Q.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point${le} = ${ee}((zero_point_word) & 0xFu);`:\"\"}\n            col_index += 1;`;return $e},Oe=()=>{let $e=`col_index = col * ${y};`;for(let le=0;le<y*x;le++)$e+=`\n            let b${le}_data = ${K.getByIndices(`${K.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return $e+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${J};\n            var b_dequantized_values: ${J};`,$e};return`\n        var<workgroup> workgroup_shared: array<${Y.type.value}, ${x*v}>;\n        ${D.declareVariables(...V,Y)}\n        ${D.mainStart([v,1,1])}\n          let output_indices = ${Y.offsetToIndices(`(global_idx / ${v}) * ${x}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += ${v}) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/h};\n            ${be()}\n            for (var word: u32 = 0; word < ${m}; word += ${_}) {\n              ${Oe()}\n              for (var i: u32 = 0; i < ${_}; i++) {\n                ${ne()}\n                word_offset += ${8/h};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${x}) {\n            var output_value: ${Y.type.value} = ${Y.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < ${v}u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${x};\n            }\n            ${Y.setByIndices(`${Y.type.indices}(batch, row, col + local_id.x)`,\"output_value\")};\n          }\n        }`};return{name:\"MatMulNBits\",shaderCache:{hint:`${t.blockSize};${t.bits};${h};${_};${y};${x};${v}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:g,dataType:u}],dispatchGroup:{x:$},programUniforms:S}),getShaderSource:P}},mh=(e,t)=>{let r=e[0].dims,n=r.length,o=r[n-2],i=t.k,a=t.n,d=r.slice(0,n-2),l=C.size(d),m=e[1].dims[2]/4,u=e[0].dataType,h=me(t.k),_=me(m),y=d.concat([o,a]),g=128,x=a%8===0?8:a%4===0?4:1,$=g/x,v=$*_*8,S=v/h,T=v/t.blockSize,A=C.size(y)/x,k=[],P=[l,o,i/h],D=C.convertShape(e[1].dims).slice();D.splice(-1,1,m/_),k.push(...N(P)),k.push(...N(D)),k.push(...N(e[2].dims)),e.length===4&&k.push(...N(C.convertShape(e[3].dims)));let R=[l,o,a];k.push(...N(R));let G=K=>{let j=P.length,V=E(\"a\",e[0].dataType,j,h),Q=E(\"b\",12,D.length,_),se=E(\"scales\",e[2].dataType,e[2].dims.length),Y=[V,Q,se],ee=e.length===4?E(\"zero_points\",12,e[3].dims.length):void 0;ee&&Y.push(ee);let J=R.length,ne=M(\"output\",e[0].dataType,J),be=_e(e[0].dataType),Oe=()=>{switch(h){case 1:return`\n          let a_data0 = vec4<${be}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${be}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${be}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${be}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${h}-component is not supported.`)}};return`\n        var<workgroup> sub_a: array<${V.type.value}, ${S}>;\n        var<workgroup> inter_results: array<array<${ne.type.value}, ${$}>, ${x}>;\n        ${K.declareVariables(...Y,ne)}\n        ${K.mainStart([$,x,1])}\n          let output_indices = ${ne.offsetToIndices(`workgroup_index * ${x}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${T} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${S};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${S}; a_offset += ${g})\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${V.getByIndices(`${V.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${V.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${T} + local_id.x;\n            ${ee?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${ee.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point = ${be}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${be}(8);`}\n            let scale = ${se.getByOffset(\"b_row * n_blocks_per_col + block\")};\n            let b_data = ${Q.getByIndices(`${Q.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/h};\n            for (var i: u32 = 0; i < ${_}; i++) {\n              ${Oe()}\n              let b_value = ${_===1?\"b_data\":\"b_data[i]\"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${be}>(${Array.from({length:4},($e,le)=>`${be}(b_value_lower[${le}]), ${be}(b_value_upper[${le}])`).join(\", \")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${be}>(${Array(8).fill(\"zero_point\").join(\",\")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},($e,le)=>`${`dot(a_data${le}, b_dequantized_values[${le}])`}`).join(\" + \")};\n              word_offset += ${8/h};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${x}) {\n            var output_value: ${ne.type.value} = ${ne.type.value}(0);\n            for (var b = 0u; b < ${$}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${ne.setByIndices(`${ne.type.indices}(batch, row, col + local_idx)`,\"output_value\")}\n            }\n          }\n        }`};return{name:\"BlockwiseMatMulNBits32\",shaderCache:{hint:`${t.blockSize};${h};${_};${$};${x}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:y,dataType:u}],dispatchGroup:{x:A},programUniforms:k}),getShaderSource:G}},el=(e,t)=>{ch(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor(\"intel\")&&e.adapterInfo.isArchitecture(\"gen-12lp\")?e.compute(mh(e.inputs,t)):e.compute(ph(e.inputs,t))},tl=e=>re(e)});var fh,hh,gh,bh,yh,_h,wh,vh,nl,ol=U(()=>{\"use strict\";te();oe();ae();fh=e=>{if(!e||e.length<1)throw new Error(\"Too few inputs\");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error(\"Input type must be float or float16.\");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\")}},hh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n            k = i32(${e.indicesGet(\"indices\",o)}) - ${F(\"uniforms.pads\",o,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${F(\"uniforms.x_shape\",o,t)})) {\n              break;\n            }\n            offset += k * i32(${F(\"uniforms.x_strides\",o,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${n}\n            value = x[offset];\n          }\n      `},gh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${F(\"uniforms.pads\",o,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${F(\"uniforms.x_shape\",o,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${F(\"uniforms.x_shape\",o,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${F(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},bh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${F(\"uniforms.pads\",o,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${F(\"uniforms.x_shape\",o,t)})) {\n                  k = i32(${F(\"uniforms.x_shape\",o,t)}) - 1;\n                }\n                offset += k * i32(${F(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},yh=(e,t,r)=>{let n=\"\";for(let o=t-1;o>=0;--o)n+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${F(\"uniforms.pads\",o,r)};\n                if (k < 0)  {\n                  k += i32(${F(\"uniforms.x_shape\",o,t)}]);\n                }\n                if (k >= i32(${F(\"uniforms.x_shape\",o,t)})) {\n                  k -= i32(${F(\"uniforms.x_shape\",o,t)});\n                }\n                offset += k * i32(${F(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},_h=(e,t,r)=>{switch(r.mode){case 0:return hh(e,t,r.pads.length);case 1:return gh(e,t,r.pads.length);case 2:return bh(e,t,r.pads.length);case 3:return yh(e,t,r.pads.length);default:throw new Error(\"Invalid mode\")}},wh=(e,t)=>{let r=C.padShape(e[0].dims.slice(),t.pads),n=e[0].dims,o=C.size(r),i=[{type:12,data:o},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;t.mode===0&&i.push({type:a?e[2].dataType:1,data:t.value}),i.push(...N(e[0].dims,r));let d=[\"rank\"],l=p=>{let m=M(\"output\",e[0].dataType,r.length),u=E(\"x\",e[0].dataType,n.length),h=u.type.value,_=_h(m,n.length,t),y=[{name:\"output_size\",type:\"u32\"},{name:\"pads\",type:\"i32\",length:t.pads.length}];return t.mode===0&&y.push({name:\"constant_value\",type:a?h:\"f32\"}),`\n            ${p.registerUniforms(y).declareVariables(u,m)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n            let indices = ${m.offsetToIndices(\"global_idx\")};\n\n            var value = ${h}(0);\n            ${_}\n            output[global_idx] = value;\n        }`};return{name:\"Pad\",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(C.size(r)/64)},programUniforms:i}),getShaderSource:l}},vh=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),n=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,o=e[0].dims.length,i=new Int32Array(2*o).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let l=0;l<d.length;l++)i[Number(d[l])]=Number(r[l]),i[Number(d[l])+o]=Number(r[l+d.length])}else r.forEach((d,l)=>i[Number(l)]=Number(d));let a=[];return i.forEach(d=>a.push(d)),{mode:t.mode,value:n,pads:a}}else return t},nl=(e,t)=>{fh(e.inputs);let r=vh(e.inputs,t);e.compute(wh(e.inputs,r),{inputs:[0]})}});var tn,il,al,sl,ul,$h,xh,dl,ll,cl,pl,ml,fl,hl,gl,bl,yl,_l,wl,vl=U(()=>{\"use strict\";We();te();oe();ae();tn=e=>{if(ve.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error(\"Pool ops requires 1 input.\")},il=(e,t,r)=>{let n=t.format===\"NHWC\",o=e.dims.slice();n&&o.splice(1,0,o.pop());let i=Object.hasOwnProperty.call(t,\"dilations\"),a=t.kernelShape.slice(),d=t.strides.slice(),l=i?t.dilations.slice():[],p=t.pads.slice();At.adjustPoolAttributes(r,o,a,d,l,p);let m=At.computePoolOutputShape(r,o,d,l,a,p,t.autoPad),u=Object.assign({},t);i?Object.assign(u,{kernelShape:a,strides:d,pads:p,dilations:l,cacheKey:t.cacheKey}):Object.assign(u,{kernelShape:a,strides:d,pads:p,cacheKey:t.cacheKey});let h=m.slice();return h.push(h.splice(1,1)[0]),[u,n?h:m]},al=(e,t)=>{let r=t.format===\"NHWC\",n=C.size(e),o=C.size(t.kernelShape),i=[{type:12,data:n},{type:12,data:o}],a=[{name:\"outputSize\",type:\"u32\"},{name:\"kernelSize\",type:\"u32\"}];if(t.kernelShape.length<=2){let d=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],m=t.pads[t.pads.length-1],u=!!(p+m);i.push({type:12,data:d},{type:12,data:l},{type:12,data:p},{type:12,data:m}),a.push({name:\"kw\",type:\"u32\"},{name:\"sw\",type:\"u32\"},{name:\"pwStart\",type:\"u32\"},{name:\"pwEnd\",type:\"u32\"});let h=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],y=t.strides[t.strides.length-2],g=t.pads[t.pads.length/2-2],x=t.pads[t.pads.length-2];h=!!(g+x),i.push({type:12,data:_},{type:12,data:y},{type:12,data:g},{type:12,data:x}),a.push({name:\"kh\",type:\"u32\"},{name:\"sh\",type:\"u32\"},{name:\"phStart\",type:\"u32\"},{name:\"phEnd\",type:\"u32\"})}return[i,a,!0,u,h]}else{if(r)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let d=C.computeStrides(t.kernelShape);i.push({type:12,data:d},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:\"kernelStrides\",type:\"u32\",length:d.length},{name:\"pads\",type:\"u32\",length:t.pads.length},{name:\"strides\",type:\"u32\",length:t.strides.length});let l=t.pads.reduce((p,m)=>p+m);return[i,a,!!l,!1,!1]}},sl=(e,t,r,n,o,i,a,d,l,p,m,u)=>{let h=o.format===\"NHWC\",_=t.type.value,y=M(\"output\",t.type.tensor,n);if(o.kernelShape.length<=2){let g=\"\",x=\"\",$=\"\",v=r-(h?2:1);if(m?g=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${v}] < 0 || xIndices[${v}]\n                      >= uniforms.x_shape[${v}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`:g=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`,o.kernelShape.length===2){let T=r-(h?3:2);u?x=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:x=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                `,$=`\n              }\n            `}return`\n            ${e.registerUniforms(l).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n              let indices = ${y.offsetToIndices(\"global_idx\")};\n              var xIndices = ${y.offsetToIndices(\"global_idx\")};\n\n              var value = ${_}(${d});\n              var pad = 0;\n              ${x}\n              ${g}\n              ${$}\n              ${a}\n\n              output[global_idx] = value;\n            }`}else{if(h)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let g=o.kernelShape.length,x=o.pads.length,$=\"\";return p?$=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                ${i}\n              }`:$=`\n              }\n              let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n              ${i}\n            `,`\n            ${e.registerUniforms(l).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n              let indices = ${y.offsetToIndices(\"global_idx\")};\n              var xIndices = ${y.offsetToIndices(\"global_idx\")};\n\n              var offsets: array<u32, ${g}>;\n\n              var value = ${_}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${g-1}u; j++) {\n                  offsets[j] = offset / ${F(\"uniforms.kernelStrides\",\"j\",g)};\n                  offset -= offsets[j] * ${F(\"uniforms.kernelStrides\",\"j\",g)};\n                }\n                offsets[${g-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-g}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${F(\"uniforms.strides\",`j - ${r-g}u`,g)}\n                    + offsets[j - ${r-g}u] - ${F(\"uniforms.pads\",\"j - 2u\",x)};\n                  ${$}\n              }\n              ${a}\n\n              output[global_idx] = value;\n            }`}},ul=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,$h=e=>`${ul(e)};${e.countIncludePad}`,xh=e=>`${ul(e)};${e.storageOrder};${e.dilations}`,dl=e=>({format:e.format,autoPad:[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),ll=(e,t,r,n)=>{let[o,i]=il(t,n,r),a=E(\"x\",t.dataType,t.dims.length),d=a.type.value,l=\"value += x_val;\",p=\"\";o.countIncludePad?p+=`value /= ${d}(uniforms.kernelSize);`:p+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[m,u,h,_,y]=al(i,o);m.push(...N(t.dims,i));let g=[\"rank\"];return{name:e,shaderCache:{hint:`${n.cacheKey};${h};${_};${y}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(C.size(i)/64)},programUniforms:m}),getShaderSource:x=>sl(x,a,t.dims.length,i.length,o,l,p,0,u,h,_,y)}},cl=e=>{let t=e.count_include_pad!==0,r=dl(e);if(r.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");let n={countIncludePad:t,...r,cacheKey:\"\"};return{...n,cacheKey:$h(n)}},pl=(e,t)=>{tn(e.inputs),e.compute(ll(\"AveragePool\",e.inputs[0],!1,t))},ml={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},fl=e=>{let t=e.format;return{format:t,...ml,cacheKey:t}},hl=(e,t)=>{tn(e.inputs),e.compute(ll(\"GlobalAveragePool\",e.inputs[0],!0,t))},gl=(e,t,r,n)=>{let[o,i]=il(t,n,r),a=`\n      value = max(x_val, value);\n    `,d=\"\",l=E(\"x\",t.dataType,t.dims.length),p=[\"rank\"],[m,u,h,_,y]=al(i,o);return m.push(...N(t.dims,i)),{name:e,shaderCache:{hint:`${n.cacheKey};${h};${_};${y}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(C.size(i)/64)},programUniforms:m}),getShaderSource:g=>sl(g,l,t.dims.length,i.length,o,a,d,t.dataType===10?-65504:-1e5,u,h,_,y)}},bl=(e,t)=>{tn(e.inputs),e.compute(gl(\"MaxPool\",e.inputs[0],!1,t))},yl=e=>{let t=e.storage_order,r=e.dilations,n=dl(e);if(t!==0)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(n.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");let o={storageOrder:t,dilations:r,...n,cacheKey:\"\"};return{...o,cacheKey:xh(o)}},_l=e=>{let t=e.format;return{format:t,...ml,cacheKey:t}},wl=(e,t)=>{tn(e.inputs),e.compute(gl(\"GlobalMaxPool\",e.inputs[0],!0,t))}});var Th,Ih,$l,xl,Sl=U(()=>{\"use strict\";te();oe();Se();ae();Th=(e,t)=>{if(e.length<2||e.length>3)throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");if(e.length===3&&e[1].dims===e[2].dims)throw new Error(\"x-scale and x-zero-point must have the same shape.\");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[0].dataType===6&&e.length>2)throw new Error(\"In the case of dequantizing int32 there is no zero point.\");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[1].dims.length!==e[2].dims.length)throw new Error(\"scale and zero-point inputs must have the same rank.\");if(!e[1].dims.map((r,n)=>r===e[2].dims[n]).reduce((r,n)=>r&&n,!0))throw new Error(\"scale and zero-point inputs must have the same shape.\")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error(\"blockSize must be set only for block quantization.\");if(!e[1].dims.map((o,i)=>i===t.axis||o===e[0].dims[i]).reduce((o,i)=>o&&i,!0))throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");if(e[1].dims.length!==e[0].dims.length)throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");let r=e[0].dims[t.axis],n=e[1].dims[t.axis];if(t.blockSize<Math.ceil(r/n)||t.blockSize>Math.ceil(r/(n-1)-1))throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\")}},Ih=(e,t)=>{let r=C.normalizeAxis(t.axis,e[0].dims.length),n=e[0].dataType,o=n===3,i=e[0].dims,a=e[1].dataType,d=C.size(i),l=n===3||n===2,p=l?[Math.ceil(C.size(e[0].dims)/4)]:e[0].dims,m=e[1].dims,u=e.length>2?e[2]:void 0,h=u?l?[Math.ceil(C.size(u.dims)/4)]:u.dims:void 0,_=m.length===0||m.length===1&&m[0]===1,y=_===!1&&m.length===1,g=me(d),x=_&&(!l||g===4),$=x?g:1,v=x&&!l?g:1,S=E(\"input\",l?12:n,p.length,v),T=E(\"scale\",a,m.length),A=u?E(\"zero_point\",l?12:n,h.length):void 0,k=M(\"output\",a,i.length,$),P=[S,T];A&&P.push(A);let D=[p,m];u&&D.push(h);let R=[{type:12,data:d/$},{type:12,data:r},{type:12,data:t.blockSize},...N(...D,i)],G=K=>{let j=[{name:\"output_size\",type:\"u32\"},{name:\"axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n      ${K.registerUniforms(j).declareVariables(...P,k)}\n      ${K.mainStart()}\n          ${K.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let output_indices = ${k.offsetToIndices(\"global_idx\")};\n\n          // Set input x\n          ${(()=>l?`\n            let input = ${S.getByOffset(\"global_idx / 4\")};\n            let x_vec = ${o?\"unpack4xI8(input)\":\"unpack4xU8(input)\"};\n            let x_value = ${$===1?\"x_vec[global_idx % 4]\":\"x_vec\"};`:`let x_value = ${S.getByOffset(\"global_idx\")};`)()};\n\n          // Set scale input\n          ${(()=>_?`let scale_value= ${T.getByOffset(\"0\")}`:y?`\n            let scale_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n            let scale_value= ${T.getByOffset(\"scale_index\")};`:`\n            var scale_indices: ${T.type.indices} = output_indices;\n            let index = ${T.indicesGet(\"scale_indices\",\"uniforms.axis\")} / uniforms.block_size;\n            ${T.indicesSet(\"scale_indices\",\"uniforms.axis\",\"index\")};\n            let scale_value= ${T.getByIndices(\"scale_indices\")};`)()};\n\n          // Set zero-point input\n          ${(()=>A?_?l?`\n                let zero_point_input = ${A.getByOffset(\"0\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${A.getByOffset(\"0\")}`:y?l?`\n                let zero_point_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_index / 4\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_value = ${A.getByOffset(\"zero_point_index\")};`:l?`\n                let zero_point_offset = ${T.indicesToOffset(\"scale_indices\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_offset / 4\")};\n                let zero_point_vec = ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${A.getByIndices(\"scale_indices\")};`:`let zero_point_value = ${l?o?\"i32\":\"u32\":S.type.value}(0);`)()};\n      // Compute and write output\n      ${k.setByOffset(\"global_idx\",`${k.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`};return{name:\"DequantizeLinear\",shaderCache:{hint:t.cacheKey,inputDependencies:A?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getShaderSource:G,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(d/$/64),y:1,z:1},programUniforms:R})}},$l=(e,t)=>{Th(e.inputs,t),e.compute(Ih(e.inputs,t))},xl=e=>re({axis:e.axis,blockSize:e.blockSize})});var Ch,Ah,Tl,Il=U(()=>{\"use strict\";We();te();ae();Ch=(e,t,r)=>{let n=e===t,o=e<t&&r<0,i=e>t&&r>0;if(n||o||i)throw new Error(\"Range these inputs' contents are invalid.\")},Ah=(e,t,r,n)=>{let o=Math.abs(Math.ceil((t-e)/r)),i=[o],a=o,d=[{type:12,data:a},{type:n,data:e},{type:n,data:r},...N(i)],l=p=>{let m=M(\"output\",n,i.length),u=m.type.value,h=[{name:\"outputSize\",type:\"u32\"},{name:\"start\",type:u},{name:\"delta\",type:u}];return`\n        ${p.registerUniforms(h).declareVariables(m)}\n        ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        output[global_idx] = uniforms.start + ${u}(global_idx) * uniforms.delta;\n      }`};return{name:\"Range\",shaderCache:{hint:`${n}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:i,dataType:n}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:d})}},Tl=e=>{let t=0,r=0,n=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],n=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],n=e.inputs[2].getFloat32Array()[0]),ve.webgpu.validateInputContent&&Ch(t,r,n),e.compute(Ah(t,r,n,e.inputs[0].dataType),{inputs:[]})}});var kh,Eh,Cl,Al,kl=U(()=>{\"use strict\";te();oe();Se();ae();kh=(e,t,r,n)=>{if(e!==\"none\"&&n!==\"i32\"&&n!==\"u32\"&&n!==\"f32\")throw new Error(`Input ${n} is not supported with reduction ${e}.`);let o=`{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =`,i=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case\"none\":return`${t}=${r};`;case\"add\":return n===\"i32\"||n===\"u32\"?`atomicAdd(&${t}, bitcast<${n}>(${r}));`:`\n              ${o}bitcast<${n}>(oldValue) + (${r})${i}`;case\"max\":return n===\"i32\"||n===\"u32\"?`atomicMax(&${t}, bitcast<${n}>(${r}));`:`\n                ${o}max(bitcast<f32>(oldValue), (${r}))${i}`;case\"min\":return n===\"i32\"||n===\"u32\"?`atomicMin(&${t}, bitcast<${n}>(${r}));`:`${o}min(bitcast<${n}>(oldValue), (${r}))${i}`;case\"mul\":return`${o}(bitcast<${n}>(oldValue) * (${r}))${i}`;default:throw new Error(`Reduction ${e} is not supported.`)}},Eh=(e,t)=>{let r=e[0].dims,n=e[1].dims,o=r,i=1,a=Math.ceil(C.size(n)/i),d=n[n.length-1],l=C.sizeFromDimension(r,d),p=[{type:12,data:a},{type:12,data:d},{type:12,data:l},...N(e[1].dims,e[2].dims,o)],m=u=>{let h=E(\"indices\",e[1].dataType,e[1].dims.length),_=E(\"updates\",e[2].dataType,e[2].dims.length,i),y=t.reduction!==\"none\"&&t.reduction!==\"\"?rs(\"output\",e[0].dataType,o.length):M(\"output\",e[0].dataType,o.length,i);return`\n      ${u.registerUniform(\"output_size\",\"u32\").registerUniform(\"last_index_dimension\",\"u32\").registerUniform(\"num_updates_elements\",\"u32\").declareVariables(h,_,y)}\n      ${u.mainStart()}\n        ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n  var data_offset = 0u;\n  let indices_start = uniforms.last_index_dimension * global_idx;\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${e[0].dims.length===1?`\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;`:`\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${kh(t.reduction,\"output[data_offset + i]\",\"value\",y.type.value)}\n  }\n\n      }`};return{name:\"ScatterND\",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:m}},Cl=e=>re({reduction:e.reduction}),Al=(e,t)=>{e.compute(Eh(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}});var Ph,zh,Oh,Dh,Bh,Mh,Rh,Uh,Nh,Vh,Wh,El,Lh,Gh,Hh,Fh,qh,Pl,zl,Ol=U(()=>{\"use strict\";te();oe();Se();ae();Ph=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error(\"Resize requires scales input values to be positive\")})),e.length>0){if(t.mode===\"linear\"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode===\"cubic\"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\")}},zh=(e,t,r)=>{t.every(o=>o>=0&&o<r||(()=>{throw new Error(\"Resize requires axes input values to be positive and less than rank\")}));let n=new Array(r).fill(1);return t.forEach((o,i)=>n[o]=e[i]),n},Oh=(e,t,r,n,o,i)=>{let[a,d,l]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(m=>i.push(m));else if(t.coordinateTransformMode===\"tf_crop_and_resize\")throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");if(d>0&&e.length>d&&e[d].dims.length===1&&e[d].dims[0]>0){if(e[d].getFloat32Array().forEach(m=>n.push(m)),n.length!==0&&n.length!==p&&r>=18&&n.length!==t.axes.length)throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");Ph(n,t),t.axes.length>0&&zh(n,t.axes,p).forEach((m,u)=>n[u]=m)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(m=>o.push(Number(m))),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length))throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");if(t.axes.length>0){if(n.length!==0&&n.length!==t.axes.length)throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');if(o.length!==0&&o.length!==t.axes.length)throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified')}if(typeof n<\"u\"&&typeof o<\"u\"&&n.length>0&&o.length>p)throw new Error(\"Resize requires only of scales or sizes to be specified\")},Dh=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case\"asymmetric\":return`return ${t}(xResized) / ${t}(xScale);`;case\"pytorch_half_pixel\":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case\"tf_half_pixel_for_nn\":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case\"align_corners\":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case\"tf_crop_and_resize\":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case\"half_pixel_symmetric\":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case\"half_pixel\":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+\"}\",Bh=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case\"round_prefer_ceil\":return\"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";case\"floor\":return\"return floor(xOriginal);\";case\"ceil\":return\"return ceil(xOriginal);\";case\"round_prefer_floor\":return\"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";case\"simple\":default:if(t<11)return\"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";throw new Error(`Nearest mode ${e} is not supported`)}})()+\"}\",Mh=(e,t,r)=>{let n=new Array(r).fill(0).concat(new Array(r).fill(1)),o=e.length===0?n:e.slice();return t.length>0?(t.forEach((i,a)=>{n[i]=o[a],n[a+r]=o[t.length+a]}),n):o},Rh=(e,t,r,n)=>{let o=[];if(r.length>0)if(n.length>0){if(e.forEach(i=>o.push(i)),Math.max(...n)>e.length)throw new Error(\"axes is out of bound\");n.forEach((i,a)=>o[i]=r[a])}else r.forEach(i=>o.push(i));else{if(t.length===0)throw new Error(\"Resize requires either scales or sizes.\");o=e.map((i,a)=>Math.round(i*t[a]))}return o},Uh=(e,t,r)=>{let n=(()=>{switch(r.keepAspectRatioPolicy){case\"not_larger\":return r.axes.length>0?Math.min(...r.axes.map(i=>t[i]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case\"not_smaller\":return r.axes.length>0?Math.max(...r.axes.map(i=>t[i]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let o=e.slice();return r.axes.length>0?(r.axes.forEach(i=>t[i]=n),r.axes.forEach(i=>o[i]=Math.round(e[i]*t[i]))):(t.fill(n,0,t.length),o.forEach((i,a)=>o[a]=Math.round(i*t[a]))),o},Nh=(e,t,r,n,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet(\"output_indices\",\"i\")};\n        var scale = ${F(\"uniforms.scales\",\"i\",n)};\n        var roi_low = ${F(\"uniforms.roi\",\"i\",o)};\n        var roi_hi = ${F(\"uniforms.roi\",`i + ${t.length}`,o)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${F(\"uniforms.input_shape\",\"i\",t.length)};\n          var output_shape_i = ${F(\"uniforms.output_shape\",\"i\",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Vh=(e,t,r,n,o,i,a)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n        var input_index: u32;\n        var scale = ${F(\"uniforms.scales\",\"i\",o)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${F(\"uniforms.roi\",\"i\",i)};\n          var roi_hi = ${F(\"uniforms.roi\",`i + ${r.length}`,i)};\n          var input_shape_i = ${F(\"uniforms.input_shape\",\"i\",r.length)};\n          var output_shape_i = ${F(\"uniforms.output_shape\",\"i\",n.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet(\"input_indices\",\"i\",\" input_index\")}\n      }\n      return input_indices;\n    }`,Wh=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet(\"input_indices\",\"i\")};\n        if (input_index < 0 || input_index >= ${F(\"uniforms.input_shape\",\"i\",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,El=(e,t,r,n)=>e.rank>n?`\n    ${e.indicesSet(\"input_indices\",t,\"channel\")};\n    ${e.indicesSet(\"input_indices\",r,\"batch\")};\n`:\"\",Lh=(e,t,r,n,o)=>{let[a,d,l,p]=r.length===2?[-1,0,1,-1]:[0,2,3,1],m=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${m} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(row, ${r[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(col, ${r[l]} - 1))`)};\n      ${El(e,p,a,2)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${m} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${m} = originalIndices[${d}];\n      var col:${m} = originalIndices[${l}];\n      ${n?`if (row < 0 || row > (${r[d]} - 1) || col < 0 || col > (${r[l]} - 1)) {\n        return ${o};\n      }`:\"\"};\n      row = max(0, min(row, ${r[d]} - 1));\n      col = max(0, min(col, ${r[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${p}])`:\"0\"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${a}])`:\"0\"};\n      var x11: ${m} = getInputValue(batch, channel, row1, col1);\n      var x12: ${m} = getInputValue(batch, channel, row1, col2);\n      var x21: ${m} = getInputValue(batch, channel, row2, col1);\n      var x22: ${m} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${m} = abs(row - ${m}(row1));\n      var dx2: ${m} = abs(${m}(row2) - row);\n      var dy1: ${m} = abs(col - ${m}(col1));\n      var dy2: ${m} = abs(${m}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Gh=(e,t,r,n,o,i,a,d,l,p)=>{let m=r.length===2,u=!0,[h,_]=m?[0,1]:u?[2,3]:[1,2],y=e.type.value,g=x=>{let $=x===h?\"row\":\"col\";return`\n      fn ${$}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${y} {\n        var output_index = ${t.indicesGet(\"output_indices\",x)};\n        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[x]},\n        ${n[x]}, ${r[x]}, ${i[x]}, ${i[x]} + ${r.length});\n        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[x]} - 1))) {\n          return ${l};\n        }\n        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: ${y} = originalIdx + ${y}(i);\n          if (${$} < 0 || ${$} >= ${r[x]}) {\n            ${(()=>p?`coefs[i + 1] = 0.0;\n                        continue;`:d?`return ${l};`:`${$} = max(0, min(${$}, ${r[x]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet(\"input_indices_copy\",x,`u32(${$})`)};\n          data[i + 1] = ${x===h?e.getByIndices(\"input_indices_copy\"):\"rowCubicInterpolation(input_indices_copy, output_indices)\"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${g(h)};\n    ${g(_)};\n  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${y} = 1.0 - absS;\n    var twoMinusAbsS: ${y} = 2.0 - absS;\n    var onePlusAbsS: ${y} = 1.0 + absS;\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {\n    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},Hh=(e,t,r,n,o)=>{let[a,d,l,p,m]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],u=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${u} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(depth, ${r[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(height, ${r[l]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",p,`max(0, min(width, ${r[p]} - 1))`)};\n      ${El(e,m,a,3)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${u} = originalIndices[${d}];\n      var height:${u} = originalIndices[${l}];\n      var width:${u} = originalIndices[${p}];\n      ${n?`if (depth < 0 || depth > (${r[d]} - 1) || height < 0 || height > (${r[l]} - 1) || width < 0 || (width > ${r[p]} - 1)) {\n      return ${o};\n        }`:\"\"};\n\n    depth = max(0, min(depth, ${r[d]} - 1));\n      height = max(0, min(height, ${r[l]} - 1));\n      width = max(0, min(width, ${r[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${m}])`:\"0\"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${a}])`:\"0\"};\n\n      var x111: ${u} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${u} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${u} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${u} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${u} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${u} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${u} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${u} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${u} = abs(depth - ${u}(depth1));\n      var dx2: ${u} = abs(${u}(depth2) - depth);\n      var dy1: ${u} = abs(height - ${u}(height1));\n      var dy2: ${u} = abs(${u}(height2) - height);\n      var dz1: ${u} = abs(width - ${u}(width1));\n      var dz2: ${u} = abs(${u}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Fh=(e,t,r,n,o,i)=>{let a=e.dims,d=Mh(i,t.axes,a.length),l=Rh(a,n,o,t.axes),p=n.slice();n.length===0&&(p=a.map((v,S)=>v===0?1:l[S]/v),t.keepAspectRatioPolicy!==\"stretch\"&&(l=Uh(a,p,t)));let m=M(\"output\",e.dataType,l.length),u=E(\"input\",e.dataType,a.length),h=C.size(l),_=a.length===l.length&&a.every((v,S)=>v===l[S]),y=t.coordinateTransformMode===\"tf_crop_and_resize\",g=t.extrapolationValue,x=u.type.value,$=v=>`\n      ${_?\"\":`\n      ${Dh(t.coordinateTransformMode,x)};\n      ${(()=>{switch(t.mode){case\"nearest\":return`\n              ${Wh(u,a)};\n              ${Bh(t.nearestMode,r,x)};\n              ${Vh(u,m,a,l,p.length,d.length,y)};\n              `;case\"linear\":return`\n              ${Nh(m,a,l,p.length,d.length)};\n              ${(()=>{if(a.length===2||a.length===4)return`${Lh(u,m,a,y,g)}`;if(a.length===3||a.length===5)return`${Hh(u,m,a,y,g)}`;throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\")})()};\n            `;case\"cubic\":return`\n            ${(()=>{if(a.length===2||a.length===4)return`${Gh(u,m,a,l,p,d,t.cubicCoeffA,y,t.extrapolationValue,t.excludeOutside)}`;throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\")})()};\n            `;default:throw Error(\"Invalid resize mode\")}})()};\n      `}\n      ${v.registerUniform(\"output_size\",\"u32\").registerUniform(\"scales\",\"f32\",p.length).registerUniform(\"roi\",\"f32\",d.length).declareVariables(u,m)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n        ${_?\"output[global_idx] = input[global_idx];\":`\n        let output_indices = ${m.offsetToIndices(\"global_idx\")};\n        var input_indices: ${u.type.indices};\n        ${(()=>{switch(t.mode){case\"nearest\":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${u.getByIndices(\"input_indices\")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case\"linear\":return`output[global_idx] = ${a.length===2||a.length===4?\"bilinearInterpolation\":\"trilinearInterpolation\"}(output_indices);`;case\"cubic\":return\"output[global_idx] = bicubicInterpolation(output_indices);\";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:\"Resize\",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:\"\"}|${o.length>0?o:\"\"}|${d.length>0?d:\"\"}|${_}|${a}`,inputDependencies:[\"rank\"]},getShaderSource:$,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:p},{type:1,data:d},...N(a,l)]})}},qh=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Pl=(e,t)=>{let r=[],n=[],o=[],i=qh(e);if(t.antialias!==0)throw Error(\"Only default value (0) for Antialias attribute is supported\");Oh(e.inputs,t,i,r,n,o),e.compute(Fh(e.inputs[0],t,i,r,n,o),{inputs:[0]})},zl=e=>{let t=e.antialias,r=e.axes,n=e.coordinateTransformMode,o=e.cubicCoeffA,i=e.excludeOutside!==0,a=e.extrapolationValue,d=e.keepAspectRatioPolicy,l=e.mode,p=e.nearestMode===\"\"?\"simple\":e.nearestMode;return re({antialias:t,axes:r,coordinateTransformMode:n,cubicCoeffA:o,excludeOutside:i,extrapolationValue:a,keepAspectRatioPolicy:d,mode:l,nearestMode:p})}});var Kh,jh,Dl,Bl=U(()=>{\"use strict\";te();oe();Se();ae();Kh=(e,t)=>{let[r,n,o,i]=e,{numHeads:a,rotaryEmbeddingDim:d}=t;if(r.dims.length!==3&&r.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!C.areEqual(n.dims,[])&&!C.areEqual(n.dims,[1])&&n.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(!C.areEqual(o.dims,i.dims))throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");if(d>0&&a===0)throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");let l=r.dims[0],p=r.dims[r.dims.length-2],m=o.dims[0],u=C.sizeFromDimension(r.dims,1)/p,h=d===0?o.dims[1]*2:u/a;if(d>h)throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");if(n.dims.length===2){if(l!==n.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);if(p!==n.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`)}if(h/2!==o.dims[1]&&d/2!==o.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);if(p>m)throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\")},jh=(e,t)=>{let{interleaved:r,numHeads:n,rotaryEmbeddingDim:o,scale:i}=t,a=e[0].dims[0],d=C.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],p=d/l,m=e[2].dims[1],u=o===0?m*2:p/n,h=new Array(a,l,p/u,u-m),_=C.computeStrides(h),y=[{type:1,data:i},{type:12,data:h},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[d,p,u,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[d,u,l*u,1]}):[],...N(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],g=x=>{let $=E(\"input\",e[0].dataType,e[0].dims.length),v=E(\"position_ids\",e[1].dataType,e[1].dims.length),S=E(\"cos_cache\",e[2].dataType,e[2].dims.length),T=E(\"sin_cache\",e[3].dataType,e[3].dims.length),A=M(\"output\",e[0].dataType,e[0].dims.length);return x.registerUniforms([{name:\"scale\",type:\"f32\"},{name:\"global_shape\",type:\"u32\",length:h.length},{name:\"global_strides\",type:\"u32\",length:_.length},{name:\"input_output_strides\",type:\"u32\",length:_.length}]),`\n        ${x.declareVariables($,v,S,T,A)}\n\n        ${x.mainStart(kt)}\n          let half_rotary_emb_dim = uniforms.${S.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"size\")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${v.broadcastedIndicesToOffset(\"bsnh.xy\",M(\"\",v.type.tensor,2))};\n            let position_id =\n                u32(${v.getByOffset(\"position_ids_idx\")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${$.getByOffset(\"i\")} * ${S.get(\"position_id\",\"bsnh[3]\")} -\n                ${$.getByOffset(\"j\")} * ${T.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"i\",\"re\")}\n            let im = ${$.getByOffset(\"i\")} * ${T.get(\"position_id\",\"bsnh[3]\")} +\n                ${$.getByOffset(\"j\")} * ${S.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"j\",\"im\")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${A.setByOffset(\"k\",$.getByOffset(\"k\"))}\n          }\n        }`};return{name:\"RotaryEmbedding\",shaderCache:{hint:re({interleaved:r}).cacheKey,inputDependencies:[\"rank\",\"rank\",\"rank\",\"rank\"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(C.size(h)/kt)},programUniforms:y})}},Dl=(e,t)=>{Kh(e.inputs,t),e.compute(jh(e.inputs,t))}});var Yh,Zh,Ml,Rl=U(()=>{\"use strict\";te();oe();ae();Yh=e=>{if(!e||e.length<3)throw new Error(\"layerNorm requires at least 3 inputs.\");let t=e[0],r=e[1],n=e[2];if(t.dataType!==r.dataType||t.dataType!==n.dataType)throw new Error(\"All inputs must have the same data type\");if(t.dims.length!==3&&t.dims.length!==2)throw new Error(\"Input must be 2D or 3D\");if(r.dims.length!==3&&r.dims.length!==2)throw new Error(\"Skip must be 2D or 3D\");let o=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==o)throw new Error(\"Skip must have the same hidden size as input\");if(r.dims[r.dims.length-2]!==i)throw new Error(\"Skip must have the same sequence length as input\");if(n.dims.length!==1)throw new Error(\"Gamma must be 1D\");if(n.dims[n.dims.length-1]!==o)throw new Error(\"Gamma must have the same hidden size as input\");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error(\"Beta must be 1D\");if(a.dims[a.dims.length-1]!==o)throw new Error(\"Beta must have the same hidden size as input\")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error(\"Bias must be 1D\");if(a.dims[a.dims.length-1]!==o)throw new Error(\"Bias must have the same hidden size as input\")}},Zh=(e,t,r,n)=>{let o=t.simplified,i=e[0].dims,a=C.size(i),d=i,l=a,p=i.slice(-1)[0],m=n?i.slice(0,-1).concat(1):[],u=!o&&e.length>3,h=e.length>4,_=n&&r>1,y=n&&r>2,g=r>3,x=64,$=me(p),v=[{type:12,data:l},{type:12,data:$},{type:12,data:p},{type:1,data:t.epsilon}],S=A=>{let k=[{name:\"output_size\",type:\"u32\"},{name:\"components\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}],P=[E(\"x\",e[0].dataType,e[0].dims,$),E(\"skip\",e[1].dataType,e[1].dims,$),E(\"gamma\",e[2].dataType,e[2].dims,$)];u&&P.push(E(\"beta\",e[3].dataType,e[3].dims,$)),h&&P.push(E(\"bias\",e[4].dataType,e[4].dims,$)),P.push(M(\"output\",e[0].dataType,d,$)),_&&P.push(M(\"mean_output\",1,m)),y&&P.push(M(\"inv_std_output\",1,m)),g&&P.push(M(\"input_skip_bias_sum\",e[0].dataType,d,$));let D=_e(e[0].dataType),R=_e(1,$);return`\n\n      ${A.registerUniforms(k).declareVariables(...P)}\n      var<workgroup> sum_shared : array<${R}, ${x}>;\n      var<workgroup> sum_squared_shared : array<${R}, ${x}>;\n\n      ${A.mainStart([x,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${x};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${x};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${x-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${h?\"bias[offset1d + i]\":D+\"(0.0)\"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${g?\"input_skip_bias_sum[offset + i] = value;\":\"\"}\n          output[offset + i] = value;\n          let f32_value = ${Et(D,$,\"value\")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${x};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${Fe(\"sum\",$)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Fe(\"square_sum\",$)} / f32(uniforms.hidden_size) ${o?\"\":\"- mean * mean\"} + uniforms.epsilon);\n        ${_?\"mean_output[global_idx] = mean;\":\"\"}\n        ${y?\"inv_std_output[global_idx] = inv_std_dev;\":\"\"}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${o?\"\":`- ${D}(mean)`}) *\n            ${D}(inv_std_dev) * gamma[offset1d + i]\n            ${u?\"+ beta[offset1d + i]\":\"\"};\n        }\n      }`},T=[{dims:d,dataType:e[0].dataType}];return r>1&&T.push({dims:m,dataType:1}),r>2&&T.push({dims:m,dataType:1}),r>3&&T.push({dims:i,dataType:e[0].dataType}),{name:\"SkipLayerNormalization\",shaderCache:{hint:`${$};${_};${y};${g}`,inputDependencies:e.map((A,k)=>\"type\")},getShaderSource:S,getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(l/p)},programUniforms:v})}},Ml=(e,t)=>{Yh(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Zh(e.inputs,t,e.outputCount,!1),{outputs:n})}});var Qh,rn,Xh,Ul,Jh,eg,Nl,Vl,Wl=U(()=>{\"use strict\";te();oe();Se();ae();Qh=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error(\"axes, starts and ends must have the same length\")}else if(t.starts.length!==t.ends.length)throw new Error(\"starts and ends must have the same length\");e.slice(1).forEach((r,n)=>{if(e[n+1].dataType!==6&&e[n+1].dataType!==7)throw new Error(`Input ${n} must be an array of int32 or int64`)})},rn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(n=>r.push(Number(n)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(n=>r.push(Number(n)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Xh=(e,t)=>{if(e.length>1){let r=rn(e,1),n=rn(e,2),o=rn(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),re({starts:r,ends:n,axes:o})}else return t},Ul=(e,t,r,n,o)=>{let i=e;return e<0&&(i+=r[n[t]]),o[t]<0?Math.max(0,Math.min(i,r[n[t]]-1)):Math.max(0,Math.min(i,r[n[t]]))},Jh=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${F(\"uniforms.input_shape\",\"i\",r.length)};\n            let steps_i = ${F(\"uniforms.steps\",\"i\",r.length)};\n            let signs_i = ${F(\"uniforms.signs\",\"i\",r.length)};\n            let starts_i = ${F(\"uniforms.starts\",\"i\",r.length)};\n            var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")};\n          }\n          return input_indices;\n      }`,eg=(e,t)=>{let r=e[0].dims,n=C.size(r),o=t.axes.length>0?C.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],i=rn(e,4);i.forEach($=>$!==0||(()=>{throw new Error(\"step cannot be 0\")})),i.length===0&&(i=Array(o.length).fill(1));let a=t.starts.map(($,v)=>Ul($,v,r,o,i)),d=t.ends.map(($,v)=>Ul($,v,r,o,i));if(o.length!==a.length||o.length!==d.length)throw new Error(\"start, ends and axes should have the same number of elements\");if(o.length!==r.length)for(let $=0;$<r.length;++$)o.includes($)||(a.splice($,0,0),d.splice($,0,r[$]),i.splice($,0,1));let l=i.map($=>Math.sign($));i.forEach(($,v,S)=>{if($<0){let T=(d[v]-a[v])/$,A=a[v],k=A+T*i[v];a[v]=k,d[v]=A,S[v]=-$}});let p=r.slice(0);o.forEach(($,v)=>{p[$]=Math.ceil((d[$]-a[$])/i[$])});let m={dims:p,dataType:e[0].dataType},u=M(\"output\",e[0].dataType,p.length),h=E(\"input\",e[0].dataType,e[0].dims.length),_=C.size(p),y=[{name:\"outputSize\",type:\"u32\"},{name:\"starts\",type:\"u32\",length:a.length},{name:\"signs\",type:\"i32\",length:l.length},{name:\"steps\",type:\"u32\",length:i.length}],g=[{type:12,data:_},{type:12,data:a},{type:6,data:l},{type:12,data:i},...N(e[0].dims,p)],x=$=>`\n      ${$.registerUniforms(y).declareVariables(h,u)}\n        ${Jh(h,u,r)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n          let output_indices = ${u.offsetToIndices(\"global_idx\")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${u.setByOffset(\"global_idx\",h.getByIndices(\"input_indices\"))}\n      }`;return{name:\"Slice\",shaderCache:{hint:`${l.length}_${a.length}_${i.length}`,inputDependencies:[\"rank\"]},getShaderSource:x,getRunData:()=>({outputs:[m],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:g})}},Nl=(e,t)=>{Qh(e.inputs,t);let r=Xh(e.inputs,t);e.compute(eg(e.inputs,r),{inputs:[0]})},Vl=e=>{let t=e.starts,r=e.ends,n=e.axes;return re({starts:t,ends:r,axes:n})}});var tg,rg,Ll,Gl,Hl=U(()=>{\"use strict\";te();oe();Se();dt();ae();tg=e=>{if(!e||e.length!==1)throw new Error(\"Softmax op requires 1 input.\")},rg=(e,t)=>{let r=e.inputs[0],n=r.dims,o=C.size(n),i=n.length,a=C.normalizeAxis(t.axis,i),d=a<n.length-1,l,p=[];d?(p=Array.from({length:i},(P,D)=>D),p[a]=i-1,p[i-1]=a,l=e.compute(Pe(r,p),{inputs:[r],outputs:[-1]})[0]):l=r;let m=l.dims,u=m[i-1],h=o/u,_=me(u),y=u/_,g=64;h===1&&(g=256);let x=(P,D)=>D===4?`max(max(${P}.x, ${P}.y), max(${P}.z, ${P}.w))`:D===2?`max(${P}.x, ${P}.y)`:D===3?`max(max(${P}.x, ${P}.y), ${P}.z)`:P,$=E(\"x\",l.dataType,l.dims,_),v=M(\"result\",l.dataType,l.dims,_),S=$.type.value,T=_e(l.dataType)===\"f32\"?`var threadMax = ${S}(-3.402823e+38f);`:`var threadMax = ${S}(-65504.0h);`,A=P=>`\n      var<workgroup> rowMaxShared : ${S};\n      var<workgroup> rowSumShared : ${S};\n      var<workgroup> threadShared : array<${S}, ${g}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${S} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${S}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${P.registerUniform(\"packedCols\",\"i32\").declareVariables($,v)}\n      ${P.mainStart(g)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${g};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${T}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${S}(${x(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${S}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${S}(${Fe(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`,k=e.compute({name:\"Softmax\",shaderCache:{hint:`${_};${g}`,inputDependencies:[\"type\"]},getRunData:()=>({outputs:[{dims:m,dataType:l.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:y}]}),getShaderSource:A},{inputs:[l],outputs:[d?-1:0]})[0];d&&e.compute(Pe(k,p),{inputs:[k]})},Ll=(e,t)=>{tg(e.inputs),rg(e,t)},Gl=e=>re({axis:e.axis})});var Fl,ng,og,ig,ql,Kl=U(()=>{\"use strict\";te();oe();ae();Fl=e=>Array.from(e.getBigInt64Array(),Number),ng=e=>{if(!e||e.length!==2)throw new Error(\"Tile requires 2 inputs.\");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");if(e[1].dataType!==7)throw new Error(\"Tile `repeats` input should be of int64 data type\");if(e[1].dims.length!==1)throw new Error(\"Tile `repeats` input should be 1-D\");if(Fl(e[1]).length!==e[0].dims.length)throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\")},og=(e,t)=>{let r=[];for(let n=0;n<e.length;++n)r.push(e[n]*t[n]);return r},ig=(e,t)=>{let r=e[0].dims,n=t??Fl(e[1]),o=og(r,n),i=C.size(o),a=e[0].dataType,d=E(\"input\",a,r.length),l=M(\"output\",a,o.length),p=m=>`\n      const inputShape = ${d.indices(...r)};\n      ${m.registerUniform(\"output_size\",\"u32\").declareVariables(d,l)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let output_indices = ${l.offsetToIndices(\"global_idx\")};\n      var input_indices: ${d.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let input_dim_i = ${d.indicesGet(\"uniforms.input_shape\",\"i\")};\n        let input_dim_value = ${l.indicesGet(\"output_indices\",\"i\")}  % input_dim_i;\n\n        ${d.indicesSet(\"input_indices\",\"i\",\"input_dim_value\")}\n      }\n      ${l.setByOffset(\"global_idx\",d.getByIndices(\"input_indices\"))}\n    }`;return{name:\"Tile\",shaderCache:{hint:`${n}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...N(e[0].dims,o)]}),getShaderSource:p}},ql=e=>{ng(e.inputs),e.compute(ig(e.inputs),{inputs:[0]})}});var ag,sg,jl,Yl=U(()=>{\"use strict\";te();oe();ae();ag=(e,t,r,n,o)=>{let i=M(\"output_data\",o,r.length,4),a=E(\"a_data\",t[1].dataType,t[1].dims.length,4),d=E(\"b_data\",t[2].dataType,t[2].dims.length,4),l=E(\"c_data\",t[0].dataType,t[0].dims.length,4),p,m=(u,h,_)=>`select(${h}, ${u}, ${_})`;if(!n)p=i.setByOffset(\"global_idx\",m(a.getByOffset(\"global_idx\"),d.getByOffset(\"global_idx\"),l.getByOffset(\"global_idx\")));else{let u=(h,_,y=\"\")=>{let g=`a_data[index_a${_}][component_a${_}]`,x=`b_data[index_b${_}][component_b${_}]`,$=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${i.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let offset_b${_} = ${d.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let offset_c${_} = ${l.broadcastedIndicesToOffset(`output_indices${_}`,i)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${h}[${_}] = ${y}(${m(g,x,$)});\n          `};o===9?p=`\n            var data = vec4<u32>(0);\n            ${u(\"data\",0,\"u32\")}\n            ${u(\"data\",1,\"u32\")}\n            ${u(\"data\",2,\"u32\")}\n            ${u(\"data\",3,\"u32\")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${u(\"output_data[global_idx]\",0)}\n            ${u(\"output_data[global_idx]\",1)}\n            ${u(\"output_data[global_idx]\",2)}\n            ${u(\"output_data[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(l,a,d,i)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${p}\n      }`},sg=e=>{let t=e[1].dims,r=e[2].dims,n=e[0].dims,o=e[1].dataType,i=!(C.areEqual(t,r)&&C.areEqual(r,n)),a=t,d=C.size(t);if(i){let p=tt.calcShape(tt.calcShape(t,r,!1),n,!1);if(!p)throw new Error(\"Can't perform where op on the given tensors\");a=p,d=C.size(a)}let l=Math.ceil(d/4);return{name:\"Where\",shaderCache:{inputDependencies:[\"rank\",\"rank\",\"rank\"]},getShaderSource:p=>ag(p,e,a,i,o),getRunData:()=>({outputs:[{dims:a,dataType:o}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:l},...N(n,t,r,a)]})}},jl=e=>{e.compute(sg(e.inputs))}});var Zl,Ql=U(()=>{\"use strict\";Ps();Fr();Ds();Ms();vu();zu();Bu();Qu();od();sd();ld();hd();yd();wd();xd();Id();kd();zd();Bd();Ud();qd();Yd();Qd();Jd();rl();So();ol();vl();Sl();Il();kl();Gr();Ol();Bl();Rl();Wl();Hl();Io();Kl();dt();Kr();Yl();Zl=new Map([[\"Abs\",[Rs]],[\"Acos\",[Us]],[\"Acosh\",[Ns]],[\"Add\",[$u]],[\"ArgMax\",[Es,co]],[\"ArgMin\",[ks,co]],[\"Asin\",[Vs]],[\"Asinh\",[Ws]],[\"Atan\",[Ls]],[\"Atanh\",[Gs]],[\"Attention\",[zs]],[\"AveragePool\",[pl,cl]],[\"BatchNormalization\",[Os]],[\"BiasAdd\",[Bs]],[\"BiasSplitGelu\",[wu]],[\"Cast\",[Fs,Hs]],[\"Ceil\",[Ks]],[\"Clip\",[qs]],[\"Concat\",[Ou,Du]],[\"Conv\",[wo,_o]],[\"ConvTranspose\",[nd,td]],[\"Cos\",[js]],[\"Cosh\",[Ys]],[\"CumSum\",[id,ad]],[\"DepthToSpace\",[ud,dd]],[\"DequantizeLinear\",[$l,xl]],[\"Div\",[xu]],[\"Einsum\",[md,fd]],[\"Elu\",[Zs,Xt]],[\"Equal\",[Su]],[\"Erf\",[Qs]],[\"Exp\",[Xs]],[\"Expand\",[bd]],[\"FastGelu\",[_d]],[\"Floor\",[Js]],[\"FusedConv\",[wo,_o]],[\"Gather\",[$d,vd]],[\"GatherElements\",[Pd,Ed]],[\"GatherBlockQuantized\",[Cd,Ad]],[\"GatherND\",[Sd,Td]],[\"Gelu\",[eu]],[\"Gemm\",[Dd,Od]],[\"GlobalAveragePool\",[hl,fl]],[\"GlobalMaxPool\",[wl,_l]],[\"Greater\",[Au]],[\"GreaterOrEqual\",[Eu]],[\"GridSample\",[Md,Rd]],[\"GroupQueryAttention\",[Fd]],[\"HardSigmoid\",[uu,su]],[\"InstanceNormalization\",[jd]],[\"LayerNormalization\",[Zd]],[\"LeakyRelu\",[tu,Xt]],[\"Less\",[ku]],[\"LessOrEqual\",[Pu]],[\"Log\",[bu]],[\"MatMul\",[Xd]],[\"MatMulNBits\",[el,tl]],[\"MaxPool\",[bl,yl]],[\"Mul\",[Tu]],[\"MultiHeadAttention\",[Wd,Vd]],[\"Neg\",[nu]],[\"Not\",[ru]],[\"Pad\",[nl]],[\"Pow\",[Iu]],[\"QuickGelu\",[yu,Xt]],[\"Range\",[Tl]],[\"Reciprocal\",[ou]],[\"ReduceMin\",[xs]],[\"ReduceMean\",[ys]],[\"ReduceMax\",[$s]],[\"ReduceSum\",[Ts]],[\"ReduceProd\",[Ss]],[\"ReduceL1\",[_s]],[\"ReduceL2\",[ws]],[\"ReduceLogSum\",[Cs]],[\"ReduceLogSumExp\",[vs]],[\"ReduceSumSquare\",[Is]],[\"Relu\",[iu]],[\"Resize\",[Pl,zl]],[\"RotaryEmbedding\",[Dl]],[\"ScatterND\",[Al,Cl]],[\"Sigmoid\",[au]],[\"Sin\",[du]],[\"Sinh\",[lu]],[\"Slice\",[Nl,Vl]],[\"SkipLayerNormalization\",[Ml]],[\"Split\",[Ld,Gd]],[\"Sqrt\",[cu]],[\"Softmax\",[Ll,Gl]],[\"Sub\",[Cu]],[\"Tan\",[pu]],[\"Tanh\",[fu]],[\"ThresholdedRelu\",[gu,Xt]],[\"Tile\",[ql]],[\"Transpose\",[is,as]],[\"Where\",[jl]]])});var nn,Xl=U(()=>{\"use strict\";We();et();ae();nn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,n,o,i){Ue(t.programInfo.name);let a=this.backend.device,d=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let l=[];for(let m of r)l.push({binding:l.length,resource:{buffer:m.buffer}});for(let m of n)l.push({binding:l.length,resource:{buffer:m.buffer}});i&&l.push({binding:l.length,resource:i});let p=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:l,label:t.programInfo.name});if(this.backend.sessionStatus===\"capturing\"){let m={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:p,dispatchGroup:o};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(m)}d.setPipeline(t.computePipeline),d.setBindGroup(0,p),d.dispatchWorkgroups(...o),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType===\"at-passes\")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),De(t.programInfo.name)}dispose(){}build(t,r){Ue(t.name);let n=this.backend.device,o=[];[{feature:\"shader-f16\",extension:\"f16\"},{feature:\"subgroups\",extension:\"subgroups\"},{feature:\"subgroups-f16\",extension:\"subgroups_f16\"}].forEach(u=>{n.features.has(u.feature)&&o.push(`enable ${u.extension};`)});let a=ns(r,this.backend.device.limits),d=t.getShaderSource(a),l=`${o.join(`\n`)}\n${a.additionalImplementations}\n${d}`,p=n.createShaderModule({code:l,label:t.name});ue(\"verbose\",()=>`[WebGPU] ${t.name} shader code: ${l}`);let m=n.createComputePipeline({compute:{module:p,entryPoint:\"main\"},layout:\"auto\",label:t.name});return De(t.name),{programInfo:t,computePipeline:m,uniformVariablesInfo:a.variablesInfo}}normalizeDispatchGroupSize(t){let r=typeof t==\"number\"?t:t.x,n=typeof t==\"number\"?1:t.y||1,o=typeof t==\"number\"?1:t.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=i&&n<=i&&o<=i)return[r,n,o];let a=r*n*o,d=Math.ceil(Math.sqrt(a));if(d>i){if(d=Math.ceil(Math.cbrt(a)),d>i)throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");return[d,d,d]}else return[d,d,1]}}});var ug,dg,Co,Ao,on,Jl=U(()=>{\"use strict\";We();te();et();Jn();Ja();Ql();Xl();ug=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let n=0;n<e.length;++n){let o=e[n].dataType;switch(t[n]){case\"none\":{r.push(\"\");break}case\"type\":{r.push(`${o}`);break}case\"rank\":{let i=e[n].dims.length;r.push(`${o};${i}`);break}case\"dims\":{let i=e[n].dims.join(\",\");r.push(`${o};${i}`);break}default:throw new Error(`unsupported input dependency: ${t[n]}`)}}return r.join(\"|\")},dg=(e,t,r)=>{let n=e.name;return e.shaderCache?.hint&&(n+=\"[\"+e.shaderCache.hint+\"]\"),n+=\":\"+r+`:${ug(t,e.shaderCache?.inputDependencies??new Array(t.length).fill(\"dims\"))}`,n},Co=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Ao=class{constructor(t){this.subgroupsSupported=t.features.has(\"subgroups\"),this.subgroupsF16Supported=t.features.has(\"subgroups\");let r=t.limits;!this.subgroupsSupported||!r.minSubgroupSize||!r.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[r.minSubgroupSize,r.maxSubgroupSize]}},on=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus=\"default\";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let n=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},i=a=>r.features.has(a)&&n.push(a)&&!0;i(\"chromium-experimental-timestamp-query-inside-passes\")||i(\"timestamp-query\"),i(\"shader-f16\"),i(\"subgroups\")&&i(\"subgroups-f16\"),this.device=await r.requestDevice(o),this.deviceInfo=new Ao(this.device),this.adapterInfo=new Co(r.info||await r.requestAdapterInfo()),this.gpuDataManager=Xa(this),this.programManager=new nn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Rr(t.logLevel,!!t.debug),this.device.onuncapturederror=a=>{a.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`)},Object.defineProperty(this.env.webgpu,\"device\",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,\"adapter\",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<\"u\"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),r={};this.queryType===\"at-passes\"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ue(),this.endComputePass();let t;this.queryType!==\"none\"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!==\"none\"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let o=0;o<r.length/2;o++){let i=n[o],a=i.kernelId,d=this.kernels.get(a),l=d.kernelType,p=d.kernelName,m=i.programName,u=i.inputTensorViews,h=i.outputTensorViews,_=r[o*2],y=r[o*2+1];typeof this.queryTimeBase>\"u\"&&(this.queryTimeBase=_);let g=Number(_-this.queryTimeBase),x=Number(y-this.queryTimeBase);if(!Number.isSafeInteger(g)||!Number.isSafeInteger(x))throw new RangeError(\"incorrect timestamp range\");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:u.map($=>({dims:$.dims,dataType:bt($.dataType)})),outputsMetadata:h.map($=>({dims:$.dims,dataType:bt($.dataType)})),kernelId:a,kernelType:l,kernelName:p,programName:m,startTime:g,endTime:x});else{let $=\"\";u.forEach((S,T)=>{$+=`input[${T}]: [${S.dims}] | ${bt(S.dataType)}, `});let v=\"\";h.forEach((S,T)=>{v+=`output[${T}]: [${S.dims}] | ${bt(S.dataType)}, `}),console.log(`[profiling] kernel \"${a}|${l}|${p}|${m}\" ${$}${v}execution time: ${x-g} ns`)}wr(\"GPU\",`${m}::${_}::${y}`)}t.unmap(),this.pendingQueries.delete(t)}),De()}run(t,r,n,o,i,a){Ue(t.name);let d=[];for(let S=0;S<r.length;++S){let T=r[S].data;if(T===0)continue;let A=this.gpuDataManager.get(T);if(!A)throw new Error(`no GPU data for input: ${T}`);d.push(A)}let{outputs:l,dispatchGroup:p,programUniforms:m}=t.getRunData(r),u=n.length===0?l.map((S,T)=>T):n;if(u.length!==l.length)throw new Error(`Output size ${u.length} must be equal to ${l.length}.`);let h=[],_=[];for(let S=0;S<l.length;++S){if(!Number.isInteger(u[S])||u[S]<-3||u[S]>=a)throw new Error(`Invalid output index: ${u[S]}`);if(u[S]===-3)continue;let T=u[S]===-1,A=u[S]===-2,k=T||A?i(l[S].dataType,l[S].dims):o(u[S],l[S].dataType,l[S].dims);if(h.push(k),k.data===0)continue;let P=this.gpuDataManager.get(k.data);if(!P)throw new Error(`no GPU data for output: ${k.data}`);if(T&&this.temporaryData.push(P),A){let D=this.kernelPersistentData.get(this.currentKernelId);D||(D=[],this.kernelPersistentData.set(this.currentKernelId,D)),D.push(P)}_.push(P)}if(d.length!==r.length||_.length!==h.length){if(_.length===0)return De(t.name),h;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let y;if(m){let S=0,T=[];m.forEach(D=>{let R=typeof D.data==\"number\"?[D.data]:D.data;if(R.length===0)return;let G=D.type===10?2:4,K,j;D.type===10?(j=R.length>4?16:R.length>2?8:R.length*G,K=R.length>4?16:G*R.length):(j=R.length<=2?R.length*G:16,K=16),S=Math.ceil(S/j)*j,T.push(S);let V=D.type===10?8:4;S+=R.length>4?Math.ceil(R.length/V)*K:R.length*G});let A=16;S=Math.ceil(S/A)*A;let k=new ArrayBuffer(S);m.forEach((D,R)=>{let G=T[R],K=typeof D.data==\"number\"?[D.data]:D.data;if(D.type===6)new Int32Array(k,G,K.length).set(K);else if(D.type===12)new Uint32Array(k,G,K.length).set(K);else if(D.type===10)new Uint16Array(k,G,K.length).set(K);else if(D.type===1)new Float32Array(k,G,K.length).set(K);else throw new Error(`Unsupported uniform type: ${bt(D.type)}`)});let P=this.gpuDataManager.create(S,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(P.buffer,0,k,0,S),this.gpuDataManager.release(P.id),y={offset:0,size:S,buffer:P.buffer}}let g=this.programManager.normalizeDispatchGroupSize(p),x=g[1]===1&&g[2]===1,$=dg(t,r,x),v=this.programManager.getArtifact($);if(v||(v=this.programManager.build(t,g),this.programManager.setArtifact($,v),ue(\"info\",()=>`[artifact] key: ${$}, programName: ${t.name}`)),m&&v.uniformVariablesInfo){if(m.length!==v.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${v.uniformVariablesInfo.length}, got ${m.length} in program \"${v.programInfo.name}\".`);for(let S=0;S<m.length;S++){let T=m[S],A=T.type,k=typeof T.data==\"number\"?1:T.data.length,[P,D]=v.uniformVariablesInfo[S];if(A!==P||k!==D)throw new Error(`Uniform variable ${S} mismatch: expect type ${P} with size ${D}, got type ${A} with size ${k} in program \"${v.programInfo.name}\".`)}}if(ue(\"info\",()=>`[ProgramManager] run \"${t.name}\" (key=${$}) with ${g[0]}x${g[1]}x${g[2]}`),this.queryType!==\"none\"||this.sessionStatus===\"capturing\"){let S={kernelId:this.currentKernelId,programName:v.programInfo.name,inputTensorViews:r,outputTensorViews:h};this.pendingKernels.push(S),this.sessionStatus===\"capturing\"&&this.capturedPendingKernels.get(this.currentSessionId).push(S)}return this.programManager.run(v,d,_,g,y),De(t.name),h}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,n,o){let i=Zl.get(t);if(!i)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:o,kernelEntry:i[0],attributes:[i[1],n]};this.kernels.set(r,a)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let n of r)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,n){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let i=o.kernelType,a=o.kernelName,d=o.kernelEntry,l=o.attributes;if(this.currentKernelId!==null)throw new Error(`kernel \"[${i}] ${a}\" is not allowed to be called recursively`);this.currentKernelId=t,l[0]&&(l[1]=l[0](l[1]),l[0]=void 0),ue(\"info\",()=>`[WebGPU] Start to run kernel \"[${i}] ${a}\"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope(\"validation\"),d(r,l[1]),0}catch(m){return n.push(Promise.resolve(`[WebGPU] Kernel \"[${i}] ${a}\" failed. ${m}`)),1}finally{p&&n.push(this.device.popErrorScope().then(m=>m?`GPU validation error for kernel \"[${i}] ${a}\": ${m.message}`:null));for(let m of this.temporaryData)this.gpuDataManager.release(m.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,n,o){let i=this.sessionExternalDataMapping.get(t);i||(i=new Map,this.sessionExternalDataMapping.set(t,i));let a=i.get(r),d=this.gpuDataManager.registerExternalBuffer(n,o,a);return i.set(r,[d,n]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,n){return async()=>{let o=await no(this,t,r);return Ur(o.buffer,n)}}writeTimestamp(t){this.queryType===\"inside-passes\"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType=\"none\",(this.env.webgpu.profiling?.mode===\"default\"||(typeof this.env.trace>\"u\"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\")?this.queryType=\"inside-passes\":this.device.features.has(\"timestamp-query\")&&(this.queryType=\"at-passes\"),this.queryType!==\"none\"&&typeof this.querySet>\"u\"&&(this.querySet=this.device.createQuerySet({type:\"timestamp\",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){ue(\"info\",\"captureBegin\"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus=\"capturing\"}captureEnd(){ue(\"info\",\"captureEnd\"),this.flush(),this.sessionStatus=\"default\"}replay(){ue(\"info\",\"replay\"),this.sessionStatus=\"replaying\";let t=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),n=t.length;this.pendingKernels=[];for(let o=0;o<n;o++){let i=this.getComputePassEncoder(),a=t[o];this.writeTimestamp(this.pendingDispatchNumber*2),i.setPipeline(a.computePipeline),i.setBindGroup(0,a.bindGroup),i.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!==\"none\"&&this.pendingKernels.push(r[o]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType===\"at-passes\")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus=\"default\"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var lg,ec,cg,tc,an,sn,ko,rc,nc=U(()=>{\"use strict\";et();lg=1,ec=()=>lg++,cg=new Map([[\"float32\",32],[\"float16\",16],[\"int32\",32],[\"uint32\",32],[\"int64\",64],[\"uint64\",64],[\"int8\",8],[\"uint8\",8],[\"int4\",4],[\"uint4\",4]]),tc=(e,t)=>{let r=cg.get(e);if(!r)throw new Error(\"Unsupported data type.\");return t.length>0?Math.ceil(t.reduce((n,o)=>n*o)*r/8):0},an=class{constructor(t){this.sessionId=t.sessionId,this.mlContext=t.context,this.mlTensor=t.tensor,this.dataType=t.dataType,this.tensorShape=t.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return tc(this.dataType,this.tensorShape)}destroy(){ue(\"verbose\",()=>\"[WebNN] TensorWrapper.destroy\"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,r,n){return this.mlContext===t&&this.dataType===r&&this.tensorShape.length===n.length&&this.tensorShape.every((o,i)=>o===n[i])}},sn=class{constructor(t,r){this.tensorManager=t;this.wrapper=r}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,r,n,o){if(this.wrapper){if(this.wrapper.canReuseTensor(t,r,n))return this.wrapper.tensor;if(o){if(this.wrapper.byteLength!==tc(r,n))throw new Error(\"Unable to copy data to tensor with different size.\");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let i=typeof MLTensorUsage>\"u\"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(r,n,i,!0,!0),o&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){if(this.wrapper)if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else ue(\"verbose\",()=>\"Data size does not match tensor size. Releasing tensor.\"),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(t){if(this.activeUpload)if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(this.activeUpload):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error(\"Tensor has not been created.\");return t?this.wrapper.read(t):this.wrapper.read()}},ko=class{constructor(t){this.backend=t;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}reserveTensorId(){let t=ec();return this.tensorTrackersById.set(t,new sn(this)),t}releaseTensorId(t){let r=this.tensorTrackersById.get(t);r&&(this.tensorTrackersById.delete(t),r.tensorWrapper&&this.releaseTensor(r.tensorWrapper))}async ensureTensor(t,r,n,o){ue(\"verbose\",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${r}, shape: ${n}, copyOld: ${o}}`);let i=this.tensorTrackersById.get(t);if(!i)throw new Error(\"Tensor not found.\");return i.ensureTensor(this.backend.currentContext,r,n,o)}upload(t,r){let n=this.tensorTrackersById.get(t);if(!n)throw new Error(\"Tensor not found.\");n.upload(r)}async download(t,r){ue(\"verbose\",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${r?.byteLength}}`);let n=this.tensorTrackersById.get(t);if(!n)throw new Error(\"Tensor not found.\");return n.download(r)}releaseTensorsForSession(t){for(let r of this.freeTensors)r.sessionId===t&&r.destroy();this.freeTensors=this.freeTensors.filter(r=>r.sessionId!==t)}registerTensor(t,r,n,o){let i=ec(),a=new an({sessionId:this.backend.currentSessionId,context:t,tensor:r,dataType:n,shape:o});return this.tensorTrackersById.set(i,new sn(this,a)),this.externalTensors.add(a),i}async getCachedTensor(t,r,n,o,i){let a=this.backend.currentSessionId,d=this.backend.currentContext;for(let[p,m]of this.freeTensors.entries())if(m.canReuseTensor(d,t,r)){ue(\"verbose\",()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${r}}`);let u=this.freeTensors.splice(p,1)[0];return u.sessionId=a,u}ue(\"verbose\",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${r}}`);let l=await d.createTensor({dataType:t,shape:r,dimensions:r,usage:n,writable:o,readable:i});return new an({sessionId:a,context:d,tensor:l,dataType:t,shape:r})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},rc=(...e)=>new ko(...e)});var oc,pg,un,ic=U(()=>{\"use strict\";te();gt();Jn();nc();et();oc=new Map([[1,\"float32\"],[10,\"float16\"],[6,\"int32\"],[12,\"uint32\"],[7,\"int64\"],[13,\"uint64\"],[22,\"int4\"],[21,\"uint4\"],[3,\"int8\"],[2,\"uint8\"],[9,\"uint8\"]]),pg=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let r=Object.keys(e).sort(),n=Object.keys(t).sort();return r.length===n.length&&r.every((o,i)=>o===n[i]&&e[o]===t[o])},un=class{constructor(t){this.tensorManager=rc(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];Rr(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error(\"No active session\");return this.activeSessionId}onRunStart(t){this.activeSessionId=t}async createMLContext(t){if(t instanceof GPUDevice){let n=this.mlContextCache.findIndex(o=>o.gpuDevice===t);if(n!==-1)return this.mlContextCache[n].mlContext;{let o=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:o}),o}}else if(t===void 0){let n=this.mlContextCache.findIndex(o=>o.options===void 0&&o.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let o=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:o}),o}}let r=this.mlContextCache.findIndex(n=>pg(n.options,t));if(r!==-1)return this.mlContextCache[r].mlContext;{let n=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:n}),n}}get currentContext(){let t=this.getMLContext(this.currentSessionId);if(!t)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return t}registerMLContext(t,r){this.mlContextBySessionId.set(t,r);let n=this.sessionIdsByMLContext.get(r);n||(n=new Set,this.sessionIdsByMLContext.set(r,n)),n.add(t)}onReleaseSession(t){let r=this.mlContextBySessionId.get(t);if(!r)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let n=this.sessionIdsByMLContext.get(r);if(n.delete(t),n.size===0){this.sessionIdsByMLContext.delete(r);let o=this.mlContextCache.findIndex(i=>i.mlContext===r);o!==-1&&this.mlContextCache.splice(o,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){ue(\"verbose\",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,r,n,o){let i=oc.get(r);if(!i)throw new Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(t,i,n,o)}uploadTensor(t,r){if(!Ie().shouldTransferToMLTensor)throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");ue(\"verbose\",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${r.byteLength}}`),this.tensorManager.upload(t,r)}async downloadTensor(t,r){return this.tensorManager.download(t,r)}createMLTensorDownloader(t,r){return async()=>{let n=await this.tensorManager.download(t);return Ur(n,r)}}registerMLTensor(t,r,n){let o=oc.get(r);if(!o)throw new Error(`Unsupported ONNX data type: ${r}`);let i=this.tensorManager.registerTensor(this.currentContext,t,o,n);return ue(\"verbose\",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${o}, dimensions: ${n}} -> {tensorId: ${i}}`),i}registerMLConstant(t,r,n,o,i,a){if(!a)throw new Error(\"External mounted files are not available.\");let d=t;t.startsWith(\"./\")&&(d=t.substring(2));let l=a.get(d);if(!l)throw new Error(`File with name ${d} not found in preloaded files.`);if(r+n>l.byteLength)throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");let p=l.slice(r,r+n).buffer,m;switch(i.dataType){case\"float32\":m=new Float32Array(p);break;case\"float16\":m=new Uint16Array(p);break;case\"int32\":m=new Int32Array(p);break;case\"uint32\":m=new Uint32Array(p);break;case\"int64\":m=new BigInt64Array(p);break;case\"uint64\":m=new BigUint64Array(p);break;case\"int8\":m=new Int8Array(p);break;case\"int4\":case\"uint4\":case\"uint8\":m=new Uint8Array(p);break;default:throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`)}return ue(\"verbose\",()=>`[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}}`),o.constant(i,m)}flush(){}}});var ac={};Ft(ac,{init:()=>mg});var rr,Eo,mg,sc=U(()=>{\"use strict\";te();Jl();et();oe();ic();rr=class e{constructor(t,r,n,o){this.module=t;this.dataType=r;this.data=n;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error(\"Invalid data type\");let t=C.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error(\"Invalid data type\");let t=C.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error(\"Invalid data type\");let t=C.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error(\"Invalid data type\");let t=C.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(C.size(t)!==C.size(this.dims))throw new Error(\"Invalid new shape\");return new e(this.module,this.dataType,this.data,t)}},Eo=class{constructor(t,r,n){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=r.adapterInfo,this.deviceInfo=r.deviceInfo;let o=t.PTR_SIZE,i=n/t.PTR_SIZE,a=o===4?\"i32\":\"i64\";this.opKernelContext=Number(t.getValue(o*i++,a));let d=Number(t.getValue(o*i++,a));this.outputCount=Number(t.getValue(o*i++,a)),this.customDataOffset=Number(t.getValue(o*i++,\"*\")),this.customDataSize=Number(t.getValue(o*i++,a));let l=[];for(let p=0;p<d;p++){let m=Number(t.getValue(o*i++,a)),u=Number(t.getValue(o*i++,\"*\")),h=Number(t.getValue(o*i++,a)),_=[];for(let y=0;y<h;y++)_.push(Number(t.getValue(o*i++,a)));l.push(new rr(t,m,u,_))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let n=r?.inputs?.map(d=>typeof d==\"number\"?this.inputs[d]:d)??this.inputs,o=r?.outputs??[],i=(d,l,p)=>new rr(this.module,l,this.output(d,p),p),a=(d,l)=>{let p=Ct(d,l);if(!p)throw new Error(`Unsupported data type: ${d}`);let m=p>0?this.backend.gpuDataManager.create(p).id:0;return new rr(this.module,d,m,l)};return this.backend.run(t,n,o,i,a,this.outputCount)}output(t,r){let n=this.module.stackSave();try{let o=this.module.PTR_SIZE,i=o===4?\"i32\":\"i64\",a=this.module.stackAlloc((1+r.length)*o);this.module.setValue(a,r.length,i);for(let d=0;d<r.length;d++)this.module.setValue(a+o*(d+1),r[d],i);return this.module._JsepOutput(this.opKernelContext,t,a)}catch(o){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(n)}}},mg=async(e,t,r,n)=>{let o=t.jsepInit;if(!o)throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");if(e===\"webgpu\"){let i=new on;await i.initialize(r,n),o(\"webgpu\",[i,a=>i.alloc(Number(a)),a=>i.free(a),(a,d,l,p=!1)=>{if(p)ue(\"verbose\",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(a)}, dst=${Number(d)}, size=${Number(l)}`),i.memcpy(Number(a),Number(d));else{ue(\"verbose\",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(a)}, gpuDataId=${Number(d)}, size=${Number(l)}`);let m=t.HEAPU8.subarray(Number(a>>>0),Number(a>>>0)+Number(l));i.upload(Number(d),m)}},async(a,d,l)=>{ue(\"verbose\",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${d}, size=${l}`),await i.download(Number(a),()=>t.HEAPU8.subarray(Number(d)>>>0,Number(d+l)>>>0))},(a,d,l)=>i.createKernel(a,Number(d),l,t.UTF8ToString(t._JsepGetNodeName(Number(d)))),a=>i.releaseKernel(a),(a,d,l,p)=>{ue(\"verbose\",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${a}, contextDataOffset=${d}`);let m=new Eo(t,i,Number(d));return i.computeKernel(Number(a),m,p)},()=>i.captureBegin(),()=>i.captureEnd(),()=>i.replay()])}else{let i=new un(r);o(\"webnn\",[i,()=>i.reserveTensorId(),a=>i.releaseTensorId(a),async(a,d,l,p)=>i.ensureTensor(a,d,l,p),(a,d)=>{i.uploadTensor(a,d)},async(a,d)=>i.downloadTensor(a,d)])}}});var fg,Tr,Ir,Pt,hg,Kt,Cr,Ar,uc,kr,Er,Pr,qn=U(()=>{\"use strict\";Ha();qa();te();gt();Or();Xn();fg=(e,t)=>{Ie()._OrtInit(e,t)!==0&&pe(\"Can't initialize onnxruntime.\")},Tr=async e=>{fg(e.wasm.numThreads,Zt(e.logLevel))},Ir=async(e,t)=>{{let r=(sc(),br(ac)).init;if(t===\"webgpu\"){if(typeof navigator>\"u\"||!navigator.gpu)throw new Error(\"WebGPU is not supported in current environment\");let n=e.webgpu.adapter;if(n){if(typeof n.limits!=\"object\"||typeof n.features!=\"object\"||typeof n.requestDevice!=\"function\")throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!==\"low-power\"&&o!==\"high-performance\")throw new Error(`Invalid powerPreference setting: \"${o}\"`);let i=e.webgpu.forceFallbackAdapter;if(i!==void 0&&typeof i!=\"boolean\")throw new Error(`Invalid forceFallbackAdapter setting: \"${i}\"`);if(n=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:i}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.')}await r(\"webgpu\",Ie(),e,n)}if(t===\"webnn\"){if(typeof navigator>\"u\"||!navigator.ml)throw new Error(\"WebNN is not supported in current environment\");await r(\"webnn\",Ie(),e)}}},Pt=new Map,hg=e=>{let t=Ie(),r=t.stackSave();try{let n=t.PTR_SIZE,o=t.stackAlloc(2*n);t._OrtGetInputOutputCount(e,o,o+n)!==0&&pe(\"Can't get session input/output count.\");let a=n===4?\"i32\":\"i64\";return[Number(t.getValue(o,a)),Number(t.getValue(o+n,a))]}finally{t.stackRestore(r)}},Kt=e=>{let t=Ie(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Cr=async(e,t)=>{let r,n,o=Ie();Array.isArray(e)?[r,n]=e:e.buffer===o.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=Kt(e);let i=0,a=0,d=0,l=[],p=[],m=[];try{if([a,l]=Fa(t),t?.externalData&&o.mountExternalData){let v=[];for(let S of t.externalData){let T=typeof S==\"string\"?S:S.path;v.push(Qt(typeof S==\"string\"?S:S.data).then(A=>{o.mountExternalData(T,A)}))}await Promise.all(v)}for(let v of t?.executionProviders??[])if((typeof v==\"string\"?v:v.name)===\"webnn\"){if(o.shouldTransferToMLTensor=!1,typeof v!=\"string\"){let T=v,A=T?.context,k=T?.gpuDevice,P=T?.deviceType,D=T?.powerPreference;A?o.currentContext=A:k?o.currentContext=await o.jsepCreateMLContext(k):o.currentContext=await o.jsepCreateMLContext({deviceType:P,powerPreference:D})}else o.currentContext=await o.jsepCreateMLContext();break}i=await o._OrtCreateSession(r,n,a),i===0&&pe(\"Can't create a session.\"),o.jsepOnCreateSession?.(),o.currentContext&&(o.jsepRegisterMLContext(i,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[u,h]=hg(i),_=!!t?.enableGraphCapture,y=[],g=[],x=[];for(let v=0;v<u;v++){let S=o._OrtGetInputName(i,v);S===0&&pe(\"Can't get an input name.\"),p.push(S),y.push(o.UTF8ToString(S))}for(let v=0;v<h;v++){let S=o._OrtGetOutputName(i,v);S===0&&pe(\"Can't get an output name.\"),m.push(S);let T=o.UTF8ToString(S);g.push(T);{if(_&&t?.preferredOutputLocation===void 0){x.push(\"gpu-buffer\");continue}let A=typeof t?.preferredOutputLocation==\"string\"?t.preferredOutputLocation:t?.preferredOutputLocation?.[T]??\"cpu\";if(A!==\"cpu\"&&A!==\"cpu-pinned\"&&A!==\"gpu-buffer\"&&A!==\"ml-tensor\")throw new Error(`Not supported preferred output location: ${A}.`);if(_&&A!==\"gpu-buffer\")throw new Error(`Not supported preferred output location: ${A}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);x.push(A)}}let $=null;return x.some(v=>v===\"gpu-buffer\"||v===\"ml-tensor\")&&(d=o._OrtCreateBinding(i),d===0&&pe(\"Can't create IO binding.\"),$={handle:d,outputPreferredLocations:x,outputPreferredLocationsEncoded:x.map(v=>Qn(v))}),Pt.set(i,[i,p,m,$,_,!1]),[i,y,g]}catch(u){throw p.forEach(h=>o._OrtFree(h)),m.forEach(h=>o._OrtFree(h)),d!==0&&o._OrtReleaseBinding(d)!==0&&pe(\"Can't release IO binding.\"),i!==0&&o._OrtReleaseSession(i)!==0&&pe(\"Can't release session.\"),u}finally{o._free(r),a!==0&&o._OrtReleaseSessionOptions(a)!==0&&pe(\"Can't release session options.\"),l.forEach(u=>o._free(u)),o.unmountExternalData?.()}},Ar=e=>{let t=Ie(),r=Pt.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[n,o,i,a,d]=r;a&&(d&&t._OrtClearBoundOutputs(a.handle)!==0&&pe(\"Can't clear bound outputs.\"),t._OrtReleaseBinding(a.handle)!==0&&pe(\"Can't release IO binding.\")),t.jsepOnReleaseSession?.(e),o.forEach(l=>t._OrtFree(l)),i.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(n)!==0&&pe(\"Can't release session.\"),Pt.delete(e)},uc=(e,t,r,n,o,i=!1)=>{if(!e){t.push(0);return}let a=Ie(),d=a.PTR_SIZE,l=e[0],p=e[1],m=e[3],u,h;if(l===\"string\"&&(m===\"gpu-buffer\"||m===\"ml-tensor\"))throw new Error(\"String tensor is not supported on GPU.\");if(i&&m!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if(m===\"gpu-buffer\"){let g=e[2].gpuBuffer;h=Ct(Yt(l),p);let x=a.jsepRegisterBuffer;if(!x)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');u=x(n,o,g,h)}else if(m===\"ml-tensor\"){let g=e[2].mlTensor;h=Ct(Yt(l),p);let x=a.jsepRegisterMLTensor;if(!x)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');u=x(g,Yt(l),p)}else{let g=e[2];if(Array.isArray(g)){h=d*g.length,u=a._malloc(h),r.push(u);for(let x=0;x<g.length;x++){if(typeof g[x]!=\"string\")throw new TypeError(`tensor data at index ${x} is not a string`);a.setValue(u+x*d,ke(g[x],r),\"*\")}}else h=g.byteLength,u=a._malloc(h),r.push(u),a.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,h),u)}let _=a.stackSave(),y=a.stackAlloc(4*p.length);try{p.forEach((x,$)=>a.setValue(y+$*d,x,d===4?\"i32\":\"i64\"));let g=a._OrtCreateTensor(Yt(l),u,h,y,p.length,Qn(m));g===0&&pe(`Can't create tensor for input/output. session=${n}, index=${o}.`),t.push(g)}finally{a.stackRestore(_)}},kr=async(e,t,r,n,o,i)=>{let a=Ie(),d=a.PTR_SIZE,l=Pt.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=l[0],m=l[1],u=l[2],h=l[3],_=l[4],y=l[5],g=t.length,x=n.length,$=0,v=[],S=[],T=[],A=[],k=a.stackSave(),P=a.stackAlloc(g*d),D=a.stackAlloc(g*d),R=a.stackAlloc(x*d),G=a.stackAlloc(x*d);try{a.jsepOnRunStart?.(p),[$,v]=Ga(i);for(let V=0;V<g;V++)uc(r[V],S,A,e,t[V],_);for(let V=0;V<x;V++)uc(o[V],T,A,e,g+n[V],_);for(let V=0;V<g;V++)a.setValue(P+V*d,S[V],\"*\"),a.setValue(D+V*d,m[t[V]],\"*\");for(let V=0;V<x;V++)a.setValue(R+V*d,T[V],\"*\"),a.setValue(G+V*d,u[n[V]],\"*\");if(h&&!y){let{handle:V,outputPreferredLocations:Q,outputPreferredLocationsEncoded:se}=h;if(m.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${m.length}).`);for(let Y=0;Y<g;Y++){let ee=t[Y];await a._OrtBindInput(V,m[ee],S[Y])!==0&&pe(`Can't bind input[${Y}] for session=${e}.`)}for(let Y=0;Y<x;Y++){let ee=n[Y];o[Y]?.[3]?a._OrtBindOutput(V,u[ee],T[Y],0)!==0&&pe(`Can't bind pre-allocated output[${Y}] for session=${e}.`):a._OrtBindOutput(V,u[ee],0,se[ee])!==0&&pe(`Can't bind output[${Y}] to ${Q[Y]} for session=${e}.`)}Pt.set(e,[p,m,u,h,_,!0])}let K;h?K=await a._OrtRunWithBinding(p,h.handle,x,R,$):K=await a._OrtRun(p,D,P,g,G,x,R,$),K!==0&&pe(\"failed to call OrtRun().\");let j=[];for(let V=0;V<x;V++){let Q=Number(a.getValue(R+V*d,\"*\"));if(Q===T[V]){j.push(o[V]);continue}let se=a.stackSave(),Y=a.stackAlloc(4*d),ee=!1,J,ne=0;try{a._OrtGetTensorData(Q,Y,Y+d,Y+2*d,Y+3*d)!==0&&pe(`Can't access output tensor data on index ${V}.`);let Oe=d===4?\"i32\":\"i64\",$e=Number(a.getValue(Y,Oe));ne=a.getValue(Y+d,\"*\");let le=a.getValue(Y+d*2,\"*\"),W=Number(a.getValue(Y+d*3,Oe)),q=[];for(let we=0;we<W;we++)q.push(Number(a.getValue(le+we*d,Oe)));a._OrtFree(le)!==0&&pe(\"Can't free memory for tensor dims.\");let he=q.reduce((we,ye)=>we*ye,1);J=bt($e);let Ge=h?.outputPreferredLocations[n[V]];if(J===\"string\"){if(Ge===\"gpu-buffer\"||Ge===\"ml-tensor\")throw new Error(\"String tensor is not supported on GPU.\");let we=[];for(let ye=0;ye<he;ye++){let Ye=a.getValue(ne+ye*d,\"*\"),Lt=a.getValue(ne+(ye+1)*d,\"*\"),fn=ye===he-1?void 0:Lt-Ye;we.push(a.UTF8ToString(Ye,fn))}j.push([J,q,we,\"cpu\"])}else if(Ge===\"gpu-buffer\"&&he>0){let we=a.jsepGetBuffer;if(!we)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let ye=we(ne),Ye=Ct($e,he);if(Ye===void 0||!Br(J))throw new Error(`Unsupported data type: ${J}`);ee=!0,j.push([J,q,{gpuBuffer:ye,download:a.jsepCreateDownloader(ye,Ye,J),dispose:()=>{a._OrtReleaseTensor(Q)!==0&&pe(\"Can't release tensor.\")}},\"gpu-buffer\"])}else if(Ge===\"ml-tensor\"&&he>0){let we=a.jsepEnsureTensor;if(!we)throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');if(Ct($e,he)===void 0||!Mr(J))throw new Error(`Unsupported data type: ${J}`);let Ye=await we(ne,$e,q,!1);ee=!0,j.push([J,q,{mlTensor:Ye,download:a.jsepCreateMLTensorDownloader(ne,J),dispose:()=>{a.jsepReleaseTensorId(ne),a._OrtReleaseTensor(Q)}},\"ml-tensor\"])}else{let we=Dr(J),ye=new we(he);new Uint8Array(ye.buffer,ye.byteOffset,ye.byteLength).set(a.HEAPU8.subarray(ne,ne+ye.byteLength)),j.push([J,q,ye,\"cpu\"])}}finally{a.stackRestore(se),J===\"string\"&&ne&&a._free(ne),ee||a._OrtReleaseTensor(Q)}}return h&&!_&&(a._OrtClearBoundOutputs(h.handle)!==0&&pe(\"Can't clear bound outputs.\"),Pt.set(e,[p,m,u,h,_,!1])),j}finally{a.stackRestore(k),S.forEach(K=>a._OrtReleaseTensor(K)),T.forEach(K=>a._OrtReleaseTensor(K)),A.forEach(K=>a._free(K)),$!==0&&a._OrtReleaseRunOptions($),v.forEach(K=>a._free(K))}},Er=e=>{let t=Ie(),r=Pt.get(e);if(!r)throw new Error(\"invalid session id\");let n=r[0],o=t._OrtEndProfiling(n);o===0&&pe(\"Can't get an profile file name.\"),t._OrtFree(o)},Pr=e=>{let t=[];for(let r of e){let n=r[2];!Array.isArray(n)&&\"buffer\"in n&&t.push(n.buffer)}return t}});var zt,Le,nr,ln,cn,dn,Po,zo,Vt,Wt,bg,dc,lc,cc,pc,mc,fc,hc,Oo=U(()=>{\"use strict\";We();qn();gt();xr();zt=()=>!!ve.wasm.proxy&&typeof document<\"u\",nr=!1,ln=!1,cn=!1,zo=new Map,Vt=(e,t)=>{let r=zo.get(e);r?r.push(t):zo.set(e,[t])},Wt=()=>{if(nr||!ln||cn||!Le)throw new Error(\"worker not ready\")},bg=e=>{switch(e.data.type){case\"init-wasm\":nr=!1,e.data.err?(cn=!0,Po[1](e.data.err)):(ln=!0,Po[0]()),dn&&(URL.revokeObjectURL(dn),dn=void 0);break;case\"init-ep\":case\"copy-from\":case\"create\":case\"release\":case\"run\":case\"end-profiling\":{let t=zo.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},dc=async()=>{if(!ln){if(nr)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(cn)throw new Error(\"previous call to 'initWasm()' failed.\");if(nr=!0,zt())return new Promise((e,t)=>{Le?.terminate(),Va().then(([r,n])=>{try{Le=n,Le.onerror=i=>t(i),Le.onmessage=bg,Po=[e,t];let o={type:\"init-wasm\",in:ve};!o.in.wasm.wasmPaths&&(r||\"file:///home/kyeung/repos/personal/picture-editor/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\"))&&(o.in.wasm.wasmPaths={wasm:new URL(/* asset import */ __webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\"), __webpack_require__.b).href}),Le.postMessage(o),dn=r}catch(o){t(o)}},t)});try{await Sr(ve.wasm),await Tr(ve),ln=!0}catch(e){throw cn=!0,e}finally{nr=!1}}},lc=async e=>{if(zt())return Wt(),new Promise((t,r)=>{Vt(\"init-ep\",[t,r]);let n={type:\"init-ep\",in:{epName:e,env:ve}};Le.postMessage(n)});await Ir(ve,e)},cc=async e=>zt()?(Wt(),new Promise((t,r)=>{Vt(\"copy-from\",[t,r]);let n={type:\"copy-from\",in:{buffer:e}};Le.postMessage(n,[e.buffer])})):Kt(e),pc=async(e,t)=>{if(zt()){if(t?.preferredOutputLocation)throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');return Wt(),new Promise((r,n)=>{Vt(\"create\",[r,n]);let o={type:\"create\",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),Le.postMessage(o,i)})}else return Cr(e,t)},mc=async e=>{if(zt())return Wt(),new Promise((t,r)=>{Vt(\"release\",[t,r]);let n={type:\"release\",in:e};Le.postMessage(n)});Ar(e)},fc=async(e,t,r,n,o,i)=>{if(zt()){if(r.some(a=>a[3]!==\"cpu\"))throw new Error(\"input tensor on GPU is not supported for proxy.\");if(o.some(a=>a))throw new Error(\"pre-allocated output tensor is not supported for proxy.\");return Wt(),new Promise((a,d)=>{Vt(\"run\",[a,d]);let l=r,p={type:\"run\",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:n,options:i}};Le.postMessage(p,Pr(l))})}else return kr(e,t,r,n,o,i)},hc=async e=>{if(zt())return Wt(),new Promise((t,r)=>{Vt(\"end-profiling\",[t,r]);let n={type:\"end-profiling\",in:e};Le.postMessage(n)});Er(e)}});var gc,yg,pn,bc=U(()=>{\"use strict\";We();Oo();te();$r();Xn();gc=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];case\"ml-tensor\":return[e.type,e.dims,{mlTensor:e.mlTensor},\"ml-tensor\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},yg=e=>{switch(e[3]){case\"cpu\":return new He(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!Br(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:o}=e[2];return He.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:o})}case\"ml-tensor\":{let t=e[0];if(!Mr(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:o}=e[2];return He.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},pn=class{async fetchModelAndCopyToWasmMemory(t){return cc(await Qt(t))}async loadModel(t,r){Ue();let n;typeof t==\"string\"? false?0:n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames]=await pc(n,r),De()}async dispose(){return mc(this.sessionId)}async run(t,r,n){Ue();let o=[],i=[];Object.entries(t).forEach(h=>{let _=h[0],y=h[1],g=this.inputNames.indexOf(_);if(g===-1)throw new Error(`invalid input '${_}'`);o.push(y),i.push(g)});let a=[],d=[];Object.entries(r).forEach(h=>{let _=h[0],y=h[1],g=this.outputNames.indexOf(_);if(g===-1)throw new Error(`invalid output '${_}'`);a.push(y),d.push(g)});let l=o.map((h,_)=>gc(h,()=>`input \"${this.inputNames[i[_]]}\"`)),p=a.map((h,_)=>h?gc(h,()=>`output \"${this.outputNames[d[_]]}\"`):null),m=await fc(this.sessionId,i,l,d,p,n),u={};for(let h=0;h<m.length;h++)u[this.outputNames[d[h]]]=a[h]??yg(m[h]);return De(),u}startProfiling(){}endProfiling(){hc(this.sessionId)}}});var _c={};Ft(_c,{OnnxruntimeWebAssemblyBackend:()=>mn,initializeFlags:()=>yc,wasmBackend:()=>_g});var yc,mn,_g,wc=U(()=>{\"use strict\";We();Oo();bc();yc=()=>{if((typeof ve.wasm.initTimeout!=\"number\"||ve.wasm.initTimeout<0)&&(ve.wasm.initTimeout=0),ve.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof ve.wasm.proxy!=\"boolean\"&&(ve.wasm.proxy=!1),typeof ve.wasm.trace!=\"boolean\"&&(ve.wasm.trace=!1),typeof ve.wasm.numThreads!=\"number\"||!Number.isInteger(ve.wasm.numThreads)||ve.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)ve.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?Nn(\"node:os\").cpus().length:navigator.hardwareConcurrency;ve.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},mn=class{async init(t){yc(),await dc(),await lc(t)}async createInferenceSessionHandler(t,r){let n=new pn;return await n.loadModel(t,r),Promise.resolve(n)}},_g=new mn});We();We();We();var Ca=\"1.21.0-dev.20250114-228dd16893\";var $1=Fn;{let e=(wc(),br(_c)).wasmBackend;St(\"webgpu\",e,5),St(\"webnn\",e,5),St(\"cpu\",e,10),St(\"wasm\",e,10)}Object.defineProperty(ve.versions,\"web\",{value:Ca,enumerable:!0});\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n//# sourceMappingURL=ort.webgpu.bundle.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcz83OWQ3IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUMsa0NBQWtDLHVDQUF1QyxvRUFBb0UsNkNBQTZDLGlCQUFpQiwyREFBMkQsMkRBQTJELEVBQUUsbUNBQW1DLGVBQWUsdUJBQXVCLHVCQUF1QixFQUFFLGdCQUFnQixnR0FBZ0csbURBQW1ELEVBQUUsVUFBVSxrQkFBa0IsZUFBZSxTQUFTLEtBQUssNkJBQTZCLGFBQWEsOEJBQThCLHFGQUFxRixnQkFBZ0Isd0JBQXdCLHFCQUFxQixFQUFFLEtBQUssdUJBQXVCLDZFQUE2RSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsU0FBUyxvQkFBb0IsdUJBQXVCLFlBQVksWUFBWSxrQ0FBa0MsaUJBQWlCLE9BQU8sV0FBVyxPQUFPLDJDQUEyQyxjQUFjLGdCQUFnQixpQ0FBaUMsa0NBQWtDLDZCQUE2QixzQkFBc0IsSUFBSSwyRkFBMkYsU0FBUyxzQkFBc0IsRUFBRSx3QkFBd0IsUUFBUSx1QkFBdUIsY0FBYyw0R0FBNEcsZ0JBQWdCLGtCQUFrQiwyQkFBMkIsYUFBYSw2QkFBNkIsMERBQTBELGFBQWEsT0FBTyxJQUFJLE1BQU0sY0FBYyxHQUFHLFFBQVEsYUFBYSwyRUFBMkUsRUFBRSxzREFBc0QsRUFBRSxHQUFHLHNEQUFzRCxzQkFBc0IsdURBQXVELElBQUksRUFBRSxjQUFjLGFBQWEsS0FBSyxFQUFFLGlCQUFpQixhQUFhLG9DQUFvQyxFQUFFLG9CQUFvQixhQUFhLEtBQUssaUJBQWlCLE9BQU8sU0FBUyxVQUFVLFdBQVcsVUFBVSxpQkFBaUIsZUFBZSxrSUFBa0ksRUFBRSxHQUFHLE1BQU0sZ0JBQWdCLFlBQVkscUNBQXFDLGNBQWMsRUFBRSxFQUFFLGlCQUFpQixhQUFhLEtBQUssTUFBTSxFQUFFLG9CQUFvQixhQUFhLFdBQVcsb0ZB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LGNBQWMsNEJBQTRCLHlDQUF5QyxhQUFhLGtEQUFrRCxXQUFXLEVBQUUsS0FBSyxLQUFLLEtBQUssd0NBQXdDLFdBQVcsZ0NBQWdDLGdFQUFnRSx5Q0FBeUMsdUJBQXVCLEVBQW9KO0FBQ3RnekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcz8xNDYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogT05OWCBSdW50aW1lIFdlYiB2MS4yMS4wLWRldi4yMDI1MDExNC0yMjhkZDE2ODkzXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xudmFyIFVuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgVnA9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgV3A9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIExwPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIE5uPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LHIpPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0KVtyXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgVT0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBGdD0oZSx0KT0+e2Zvcih2YXIgciBpbiB0KVVuKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSxHcD0oZSx0LHIsbik9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IG8gb2YgV3AodCkpIUxwLmNhbGwoZSxvKSYmbyE9PXImJlVuKGUsbyx7Z2V0OigpPT50W29dLGVudW1lcmFibGU6IShuPVZwKHQsbykpfHxuLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIGJyPWU9PkdwKFVuKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciB5cix4dCxTdCxIcCxKaSxWbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eXI9bmV3IE1hcCx4dD1bXSxTdD0oZSx0LHIpPT57aWYodCYmdHlwZW9mIHQuaW5pdD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj09XCJmdW5jdGlvblwiKXtsZXQgbj15ci5nZXQoZSk7aWYobj09PXZvaWQgMCl5ci5zZXQoZSx7YmFja2VuZDp0LHByaW9yaXR5OnJ9KTtlbHNle2lmKG4ucHJpb3JpdHk+cilyZXR1cm47aWYobi5wcmlvcml0eT09PXImJm4uYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke3J9YCl9aWYocj49MCl7bGV0IG89eHQuaW5kZXhPZihlKTtvIT09LTEmJnh0LnNwbGljZShvLDEpO2ZvcihsZXQgaT0wO2k8eHQubGVuZ3RoO2krKylpZih5ci5nZXQoeHRbaV0pLnByaW9yaXR5PD1yKXt4dC5zcGxpY2UoaSwwLGUpO3JldHVybn14dC5wdXNoKGUpfXJldHVybn10aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKX0sSHA9YXN5bmMgZT0+e2xldCB0PXlyLmdldChlKTtpZighdClyZXR1cm5cImJhY2tlbmQgbm90IGZvdW5kLlwiO2lmKHQuaW5pdGlhbGl6ZWQpcmV0dXJuIHQuYmFja2VuZDtpZih0LmFib3J0ZWQpcmV0dXJuIHQuZXJyb3I7e2xldCByPSEhdC5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIHJ8fCh0LmluaXRQcm9taXNlPXQuYmFja2VuZC5pbml0KGUpKSxhd2FpdCB0LmluaXRQcm9taXNlLHQuaW5pdGlhbGl6ZWQ9ITAsdC5iYWNrZW5kfWNhdGNoKG4pe3JldHVybiByfHwodC5lcnJvcj1gJHtufWAsdC5hYm9ydGVkPSEwKSx0LmVycm9yfWZpbmFsbHl7ZGVsZXRlIHQuaW5pdFByb21pc2V9fX0sSmk9YXN5bmMgZT0+e2xldCB0PWUuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSxyPXQubWFwKGw9PnR5cGVvZiBsPT1cInN0cmluZ1wiP2w6bC5uYW1lKSxuPXIubGVuZ3RoPT09MD94dDpyLG8saT1bXSxhPW5ldyBTZXQ7Zm9yKGxldCBsIG9mIG4pe2xldCBwPWF3YWl0IEhwKGwpO3R5cGVvZiBwPT1cInN0cmluZ1wiP2kucHVzaCh7bmFtZTpsLGVycjpwfSk6KG98fChvPXApLG89PT1wJiZhLmFkZChsKSl9aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2kubWFwKGw9PmBbJHtsLm5hbWV9XSAke2wuZXJyfWApLmpvaW4oXCIsIFwiKX1gKTtmb3IobGV0e25hbWU6bCxlcnI6cH1vZiBpKXIuaW5jbHVkZXMobCkmJmNvbnNvbGUud2FybihgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bH1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7cH1gKTtsZXQgZD10LmZpbHRlcihsPT5hLmhhcyh0eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSkpO3JldHVybltvLG5ldyBQcm94eShlLHtnZXQ6KGwscCk9PnA9PT1cImV4ZWN1dGlvblByb3ZpZGVyc1wiP2Q6UmVmbGVjdC5nZXQobCxwKX0pXX19KTt2YXIgZWE9VSgoKT0+e1widXNlIHN0cmljdFwiO1ZuKCl9KTt2YXIgdGEscmE9VSgoKT0+e1widXNlIHN0cmljdFwiO3RhPVwiMS4yMS4wLWRldi4yMDI0MTIxMi0xZjg4Mjg0Zjk2XCJ9KTt2YXIgbmEsUmUsV249VSgoKT0+e1widXNlIHN0cmljdFwiO3JhKCk7bmE9XCJ3YXJuaW5nXCIsUmU9e3dhc206e30sd2ViZ2w6e30sd2ViZ3B1Ont9LHZlcnNpb25zOntjb21tb246dGF9LHNldCBsb2dMZXZlbChlKXtpZihlIT09dm9pZCAwKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTtuYT1lfX0sZ2V0IGxvZ0xldmVsKCl7cmV0dXJuIG5hfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KFJlLFwibG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMH0pfSk7dmFyIHZlLG9hPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXbigpO3ZlPVJlfSk7dmFyIGlhLGFhLHNhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtpYT0oZSx0KT0+e2xldCByPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTtyLndpZHRoPWUuZGltc1szXSxyLmhlaWdodD1lLmRpbXNbMl07bGV0IG49ci5nZXRDb250ZXh0KFwiMmRcIik7aWYobiE9bnVsbCl7bGV0IG8saTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0pO2xldCBhPXQ/LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGQ9dD8ubm9ybSxsLHA7ZD09PXZvaWQgMHx8ZC5tZWFuPT09dm9pZCAwP2w9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGQubWVhbj09XCJudW1iZXJcIj9sPVtkLm1lYW4sZC5tZWFuLGQubWVhbixkLm1lYW5dOihsPVtkLm1lYW5bMF0sZC5tZWFuWzFdLGQubWVhblsyXSwwXSxkLm1lYW5bM10hPT12b2lkIDAmJihsWzNdPWQubWVhblszXSkpLGQ9PT12b2lkIDB8fGQuYmlhcz09PXZvaWQgMD9wPVswLDAsMCwwXTp0eXBlb2YgZC5iaWFzPT1cIm51bWJlclwiP3A9W2QuYmlhcyxkLmJpYXMsZC5iaWFzLGQuYmlhc106KHA9W2QuYmlhc1swXSxkLmJpYXNbMV0sZC5iaWFzWzJdLDBdLGQuYmlhc1szXSE9PXZvaWQgMCYmKHBbM109ZC5iaWFzWzNdKSk7bGV0IG09aSpvLHU9MCxoPW0sXz1tKjIseT0tMTthPT09XCJSR0JBXCI/KHU9MCxoPW0sXz1tKjIseT1tKjMpOmE9PT1cIlJHQlwiPyh1PTAsaD1tLF89bSoyKTphPT09XCJSQkdcIiYmKHU9MCxfPW0saD1tKjIpO2ZvcihsZXQgZz0wO2c8aTtnKyspZm9yKGxldCB4PTA7eDxvO3grKyl7bGV0ICQ9KGUuZGF0YVt1KytdLXBbMF0pKmxbMF0sdj0oZS5kYXRhW2grK10tcFsxXSkqbFsxXSxTPShlLmRhdGFbXysrXS1wWzJdKSpsWzJdLFQ9eT09PS0xPzI1NTooZS5kYXRhW3krK10tcFszXSkqbFszXTtuLmZpbGxTdHlsZT1cInJnYmEoXCIrJCtcIixcIit2K1wiLFwiK1MrXCIsXCIrVCtcIilcIixuLmZpbGxSZWN0KHgsZywxLDEpfWlmKFwidG9EYXRhVVJMXCJpbiByKXJldHVybiByLnRvRGF0YVVSTCgpO3Rocm93IG5ldyBFcnJvcihcInRvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkXCIpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX0sYWE9KGUsdCk9PntsZXQgcj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpLmdldENvbnRleHQoXCIyZFwiKSxuO2lmKHIhPW51bGwpe2xldCBvLGksYTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzFdLGE9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0sYT1lLmRpbXNbMV0pO2xldCBkPXQhPT12b2lkIDAmJnQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsbD10Py5ub3JtLHAsbTtsPT09dm9pZCAwfHxsLm1lYW49PT12b2lkIDA/cD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgbC5tZWFuPT1cIm51bWJlclwiP3A9W2wubWVhbixsLm1lYW4sbC5tZWFuLGwubWVhbl06KHA9W2wubWVhblswXSxsLm1lYW5bMV0sbC5tZWFuWzJdLDI1NV0sbC5tZWFuWzNdIT09dm9pZCAwJiYocFszXT1sLm1lYW5bM10pKSxsPT09dm9pZCAwfHxsLmJpYXM9PT12b2lkIDA/bT1bMCwwLDAsMF06dHlwZW9mIGwuYmlhcz09XCJudW1iZXJcIj9tPVtsLmJpYXMsbC5iaWFzLGwuYmlhcyxsLmJpYXNdOihtPVtsLmJpYXNbMF0sbC5iaWFzWzFdLGwuYmlhc1syXSwwXSxsLmJpYXNbM10hPT12b2lkIDAmJihtWzNdPWwuYmlhc1szXSkpO2xldCB1PWkqbztpZih0IT09dm9pZCAwJiYodC5mb3JtYXQhPT12b2lkIDAmJmE9PT00JiZ0LmZvcm1hdCE9PVwiUkdCQVwifHxhPT09MyYmdC5mb3JtYXQhPT1cIlJHQlwiJiZ0LmZvcm1hdCE9PVwiQkdSXCIpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtsZXQgaD00LF89MCx5PTEsZz0yLHg9MywkPTAsdj11LFM9dSoyLFQ9LTE7ZD09PVwiUkdCQVwiPygkPTAsdj11LFM9dSoyLFQ9dSozKTpkPT09XCJSR0JcIj8oJD0wLHY9dSxTPXUqMik6ZD09PVwiUkJHXCImJigkPTAsUz11LHY9dSoyKSxuPXIuY3JlYXRlSW1hZ2VEYXRhKG8saSk7Zm9yKGxldCBBPTA7QTxpKm87Xys9aCx5Kz1oLGcrPWgseCs9aCxBKyspbi5kYXRhW19dPShlLmRhdGFbJCsrXS1tWzBdKSpwWzBdLG4uZGF0YVt5XT0oZS5kYXRhW3YrK10tbVsxXSkqcFsxXSxuLmRhdGFbZ109KGUuZGF0YVtTKytdLW1bMl0pKnBbMl0sbi5kYXRhW3hdPVQ9PT0tMT8yNTU6KGUuZGF0YVtUKytdLW1bM10pKnBbM119ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3JldHVybiBufX0pO3ZhciBMbix1YSxkYSxsYSxjYSxwYSxtYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3IoKTtMbj0oZSx0KT0+e2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LmhlaWdodD09PXZvaWQgMHx8dC53aWR0aD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXR7aGVpZ2h0OnIsd2lkdGg6bn09dCxvPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH0saSxhO3R5cGVvZiBvLm1lYW49PVwibnVtYmVyXCI/aT1bby5tZWFuLG8ubWVhbixvLm1lYW4sby5tZWFuXTppPVtvLm1lYW5bMF0sby5tZWFuWzFdLG8ubWVhblsyXSxvLm1lYW5bM10/PzI1NV0sdHlwZW9mIG8uYmlhcz09XCJudW1iZXJcIj9hPVtvLmJpYXMsby5iaWFzLG8uYmlhcyxvLmJpYXNdOmE9W28uYmlhc1swXSxvLmJpYXNbMV0sby5iaWFzWzJdLG8uYmlhc1szXT8/MF07bGV0IGQ9dC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JBXCIsbD10LnRlbnNvckZvcm1hdCE9PXZvaWQgMCYmdC50ZW5zb3JGb3JtYXQhPT12b2lkIDA/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixwPXIqbixtPWw9PT1cIlJHQkFcIj9uZXcgRmxvYXQzMkFycmF5KHAqNCk6bmV3IEZsb2F0MzJBcnJheShwKjMpLHU9NCxoPTAsXz0xLHk9MixnPTMseD0wLCQ9cCx2PXAqMixTPS0xO2Q9PT1cIlJHQlwiJiYodT0zLGg9MCxfPTEseT0yLGc9LTEpLGw9PT1cIlJHQkFcIj9TPXAqMzpsPT09XCJSQkdcIj8oeD0wLHY9cCwkPXAqMik6bD09PVwiQkdSXCImJih2PTAsJD1wLHg9cCoyKTtmb3IobGV0IEE9MDtBPHA7QSsrLGgrPXUseSs9dSxfKz11LGcrPXUpbVt4KytdPShlW2hdK2FbMF0pL2lbMF0sbVskKytdPShlW19dK2FbMV0pL2lbMV0sbVt2KytdPShlW3ldK2FbMl0pL2lbMl0sUyE9PS0xJiZnIT09LTEmJihtW1MrK109KGVbZ10rYVszXSkvaVszXSk7cmV0dXJuIGw9PT1cIlJHQkFcIj9uZXcgemUoXCJmbG9hdDMyXCIsbSxbMSw0LHIsbl0pOm5ldyB6ZShcImZsb2F0MzJcIixtLFsxLDMscixuXSl9LHVhPWFzeW5jKGUsdCk9PntsZXQgcj10eXBlb2YgSFRNTEltYWdlRWxlbWVudDxcInVcIiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsbj10eXBlb2YgSW1hZ2VEYXRhPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhLG89dHlwZW9mIEltYWdlQml0bWFwPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAsaT10eXBlb2YgZT09XCJzdHJpbmdcIixhLGQ9dD8/e30sbD0oKT0+e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtpZih0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPFwidVwiKXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7dGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWRcIil9LHA9bT0+dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PFwidVwiJiZtIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fG0gaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXM/bS5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDtpZihyKXtsZXQgbT1sKCk7bS53aWR0aD1lLndpZHRoLG0uaGVpZ2h0PWUuaGVpZ2h0O2xldCB1PXAobSk7aWYodSE9bnVsbCl7bGV0IGg9ZS5oZWlnaHQsXz1lLndpZHRoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJihoPXQucmVzaXplZEhlaWdodCxfPXQucmVzaXplZFdpZHRoKSx0IT09dm9pZCAwKXtpZihkPXQsdC50ZW5zb3JGb3JtYXQhPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7ZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9aCxkLndpZHRoPV99ZWxzZSBkLnRlbnNvckZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1oLGQud2lkdGg9Xzt1LmRyYXdJbWFnZShlLDAsMCksYT11LmdldEltYWdlRGF0YSgwLDAsXyxoKS5kYXRhfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGlmKG4pe2xldCBtLHU7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMD8obT10LnJlc2l6ZWRIZWlnaHQsdT10LnJlc2l6ZWRXaWR0aCk6KG09ZS5oZWlnaHQsdT1lLndpZHRoKSx0IT09dm9pZCAwJiYoZD10KSxkLmZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1tLGQud2lkdGg9dSx0IT09dm9pZCAwKXtsZXQgaD1sKCk7aC53aWR0aD11LGguaGVpZ2h0PW07bGV0IF89cChoKTtpZihfIT1udWxsKV8ucHV0SW1hZ2VEYXRhKGUsMCwwKSxhPV8uZ2V0SW1hZ2VEYXRhKDAsMCx1LG0pLmRhdGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2UgYT1lLmRhdGF9ZWxzZSBpZihvKXtpZih0PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXBcIik7bGV0IG09bCgpO20ud2lkdGg9ZS53aWR0aCxtLmhlaWdodD1lLmhlaWdodDtsZXQgdT1wKG0pO2lmKHUhPW51bGwpe2xldCBoPWUuaGVpZ2h0LF89ZS53aWR0aDtyZXR1cm4gdS5kcmF3SW1hZ2UoZSwwLDAsXyxoKSxhPXUuZ2V0SW1hZ2VEYXRhKDAsMCxfLGgpLmRhdGEsZC5oZWlnaHQ9aCxkLndpZHRoPV8sTG4oYSxkKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZXtpZihpKXJldHVybiBuZXcgUHJvbWlzZSgobSx1KT0+e2xldCBoPWwoKSxfPXAoaCk7aWYoIWV8fCFfKXJldHVybiB1KCk7bGV0IHk9bmV3IEltYWdlO3kuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIix5LnNyYz1lLHkub25sb2FkPSgpPT57aC53aWR0aD15LndpZHRoLGguaGVpZ2h0PXkuaGVpZ2h0LF8uZHJhd0ltYWdlKHksMCwwLGgud2lkdGgsaC5oZWlnaHQpO2xldCBnPV8uZ2V0SW1hZ2VEYXRhKDAsMCxoLndpZHRoLGguaGVpZ2h0KTtkLmhlaWdodD1oLmhlaWdodCxkLndpZHRoPWgud2lkdGgsbShMbihnLmRhdGEsZCkpfX0pO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfWlmKGEhPT12b2lkIDApcmV0dXJuIExuKGEsZCk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9LGRhPShlLHQpPT57bGV0e3dpZHRoOnIsaGVpZ2h0Om4sZG93bmxvYWQ6byxkaXNwb3NlOml9PXQsYT1bMSxuLHIsNF07cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdHlwZTpcImZsb2F0MzJcIix0ZXh0dXJlOmUsZGltczphLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGxhPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLHR5cGU6cj8/XCJmbG9hdDMyXCIsZ3B1QnVmZmVyOmUsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGNhPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwibWwtdGVuc29yXCIsdHlwZTpyPz9cImZsb2F0MzJcIixtbFRlbnNvcjplLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxwYT0oZSx0LHIpPT5uZXcgemUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLHR5cGU6ZSxkYXRhOnQsZGltczpyPz9bdC5sZW5ndGhdfSl9KTt2YXIgVHQscXQsZmEsaGEsZ2E9VSgoKT0+e1widXNlIHN0cmljdFwiO1R0PW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldLFtcImludDRcIixVaW50OEFycmF5XSxbXCJ1aW50NFwiLFVpbnQ4QXJyYXldXSkscXQ9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pLGZhPSExLGhhPSgpPT57aWYoIWZhKXtmYT0hMDtsZXQgZT10eXBlb2YgQmlnSW50NjRBcnJheTxcInVcIiYmQmlnSW50NjRBcnJheS5mcm9tLHQ9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5PFwidVwiJiZCaWdVaW50NjRBcnJheS5mcm9tLHI9dHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb207ZSYmKFR0LnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSkscXQuc2V0KEJpZ0ludDY0QXJyYXksXCJpbnQ2NFwiKSksdCYmKFR0LnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSxxdC5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpLHI/KFR0LnNldChcImZsb2F0MTZcIixGbG9hdDE2QXJyYXkpLHF0LnNldChGbG9hdDE2QXJyYXksXCJmbG9hdDE2XCIpKTpUdC5zZXQoXCJmbG9hdDE2XCIsVWludDE2QXJyYXkpfX19KTt2YXIgYmEseWEsX2E9VSgoKT0+e1widXNlIHN0cmljdFwiO19yKCk7YmE9ZT0+e2xldCB0PTE7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2xldCBuPWVbcl07aWYodHlwZW9mIG4hPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke259YCk7aWYobjwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke259YCk7dCo9bn1yZXR1cm4gdH0seWE9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyB6ZShlLnR5cGUsZS5kYXRhLHQpO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIixkYXRhOmUuZGF0YSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdGV4dHVyZTplLnRleHR1cmUsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiBuZXcgemUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLGdwdUJ1ZmZlcjplLmdwdUJ1ZmZlcix0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLG1sVGVuc29yOmUubWxUZW5zb3IsdHlwZTplLnR5cGUsZGltczp0fSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHRlbnNvclJlc2hhcGU6IHRlbnNvciBsb2NhdGlvbiAke2UubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKX19fSk7dmFyIHplLF9yPVUoKCk9PntcInVzZSBzdHJpY3RcIjtzYSgpO21hKCk7Z2EoKTtfYSgpO3plPWNsYXNze2NvbnN0cnVjdG9yKHQscixuKXtoYSgpO2xldCBvLGk7aWYodHlwZW9mIHQ9PVwib2JqZWN0XCImJlwibG9jYXRpb25cImluIHQpc3dpdGNoKHRoaXMuZGF0YUxvY2F0aW9uPXQubG9jYXRpb24sbz10LnR5cGUsaT10LmRpbXMsdC5sb2NhdGlvbil7Y2FzZVwiY3B1LXBpbm5lZFwiOntsZXQgZD1UdC5nZXQobyk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO2lmKCEodC5kYXRhIGluc3RhbmNlb2YgZCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7ZC5uYW1lfWApO3RoaXMuY3B1RGF0YT10LmRhdGE7YnJlYWt9Y2FzZVwidGV4dHVyZVwiOntpZihvIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO3RoaXMuZ3B1VGV4dHVyZURhdGE9dC50ZXh0dXJlLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcImdwdS1idWZmZXJcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7dGhpcy5ncHVCdWZmZXJEYXRhPXQuZ3B1QnVmZmVyLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcIm1sLXRlbnNvclwiOntpZihvIT09XCJmbG9hdDMyXCImJm8hPT1cImZsb2F0MTZcIiYmbyE9PVwiaW50MzJcIiYmbyE9PVwiaW50NjRcIiYmbyE9PVwidWludDMyXCImJm8hPT1cInVpbnQ2NFwiJiZvIT09XCJpbnQ4XCImJm8hPT1cInVpbnQ4XCImJm8hPT1cImJvb2xcIiYmbyE9PVwidWludDRcIiYmbyE9PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7dGhpcy5tbFRlbnNvckRhdGE9dC5tbFRlbnNvcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCl9ZWxzZXtsZXQgZCxsO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKWlmKG89dCxsPW4sdD09PVwic3RyaW5nXCIpe2lmKCFBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO2Q9cn1lbHNle2xldCBwPVR0LmdldCh0KTtpZihwPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke3R9LmApO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHQ9PT1cImZsb2F0MTZcIiYmcD09PVVpbnQxNkFycmF5fHx0PT09XCJ1aW50NFwifHx0PT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ3JlYXRpbmcgYSAke3R9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7cC5uYW1lfSBhcyBkYXRhLmApO3Q9PT1cInVpbnQ2NFwifHx0PT09XCJpbnQ2NFwiP2Q9cC5mcm9tKHIsQmlnSW50KTpkPXAuZnJvbShyKX1lbHNlIGlmKHIgaW5zdGFuY2VvZiBwKWQ9cjtlbHNlIGlmKHIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlpZih0PT09XCJ1aW50OFwiKWQ9VWludDhBcnJheS5mcm9tKHIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgVWludDhDbGFtcGVkQXJyYXkgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgdWludDhcIik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7b30gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtwfWApfWVsc2UgaWYobD1yLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBwPXR5cGVvZiB0WzBdO2lmKHA9PT1cInN0cmluZ1wiKW89XCJzdHJpbmdcIixkPXQ7ZWxzZSBpZihwPT09XCJib29sZWFuXCIpbz1cImJvb2xcIixkPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7cH0uYCl9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpbz1cInVpbnQ4XCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZXtsZXQgcD1xdC5nZXQodC5jb25zdHJ1Y3Rvcik7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtvPXAsZD10fWlmKGw9PT12b2lkIDApbD1bZC5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkobCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO2k9bCx0aGlzLmNwdURhdGE9ZCx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCBhPWJhKGkpO2lmKHRoaXMuY3B1RGF0YSYmYSE9PXRoaXMuY3B1RGF0YS5sZW5ndGgmJiEoKG89PT1cInVpbnQ0XCJ8fG89PT1cImludDRcIikmJk1hdGguY2VpbChhLzIpPT09dGhpcy5jcHVEYXRhLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7YX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1vLHRoaXMuZGltcz1pLHRoaXMuc2l6ZT1hfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxyKXtyZXR1cm4gdWEodCxyKX1zdGF0aWMgZnJvbVRleHR1cmUodCxyKXtyZXR1cm4gZGEodCxyKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LHIpe3JldHVybiBsYSh0LHIpfXN0YXRpYyBmcm9tTUxUZW5zb3IodCxyKXtyZXR1cm4gY2EodCxyKX1zdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcih0LHIsbil7cmV0dXJuIHBhKHQscixuKX10b0RhdGFVUkwodCl7cmV0dXJuIGlhKHRoaXMsdCl9dG9JbWFnZURhdGEodCl7cmV0dXJuIGFhKHRoaXMsdCl9Z2V0IGRhdGEoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuY3B1RGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCBvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuXCIpO3JldHVybiB0aGlzLmNwdURhdGF9Z2V0IGxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9ufWdldCB0ZXh0dXJlKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdVRleHR1cmVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLlwiKTtyZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YX1nZXQgZ3B1QnVmZmVyKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdUJ1ZmZlckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuXCIpO3JldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGF9Z2V0IG1sVGVuc29yKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLm1sVGVuc29yRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuXCIpO3JldHVybiB0aGlzLm1sVGVuc29yRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6Y2FzZVwibWwtdGVuc29yXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IHI9YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9cix0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxyfWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLm1sVGVuc29yRGF0YT12b2lkIDAsdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmlzRG93bmxvYWRpbmc9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwibm9uZVwifWVuc3VyZVZhbGlkKCl7aWYodGhpcy5kYXRhTG9jYXRpb249PT1cIm5vbmVcIil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLlwiKX1yZXNoYXBlKHQpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRvd25sb2FkZXJ8fHRoaXMuZGlzcG9zZXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS5cIik7cmV0dXJuIHlhKHRoaXMsdCl9fX0pO3ZhciBIZSxHbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3IoKTtIZT16ZX0pO3ZhciB3cix3YSxVZSxEZSxIbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V24oKTt3cj0oZSx0KT0+eyh0eXBlb2YgUmUudHJhY2U+XCJ1XCI/IVJlLndhc20udHJhY2U6IVJlLnRyYWNlKXx8Y29uc29sZS50aW1lU3RhbXAoYCR7ZX06Ok9SVDo6JHt0fWApfSx3YT0oZSx0KT0+e2xldCByPW5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyl8fFtdLG49ITE7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspe2lmKG4mJiFyW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSl7bGV0IGk9YEZVTkNfJHtlfTo6JHtyW29dLnRyaW0oKS5zcGxpdChcIiBcIilbMV19YDt0JiYoaSs9YDo6JHt0fWApLHdyKFwiQ1BVXCIsaSk7cmV0dXJufXJbb10uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpJiYobj0hMCl9fSxVZT1lPT57KHR5cGVvZiBSZS50cmFjZT5cInVcIj8hUmUud2FzbS50cmFjZTohUmUudHJhY2UpfHx3YShcIkJFR0lOXCIsZSl9LERlPWU9PnsodHlwZW9mIFJlLnRyYWNlPlwidVwiPyFSZS53YXNtLnRyYWNlOiFSZS50cmFjZSl8fHdhKFwiRU5EXCIsZSl9fSk7dmFyIHZyLHZhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtWbigpO0duKCk7SG4oKTt2cj1jbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaGFuZGxlcj10fWFzeW5jIHJ1bih0LHIsbil7VWUoKTtsZXQgbz17fSxpPXt9O2lmKHR5cGVvZiB0IT1cIm9iamVjdFwifHx0PT09bnVsbHx8dCBpbnN0YW5jZW9mIEhlfHxBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IGE9ITA7aWYodHlwZW9mIHI9PVwib2JqZWN0XCIpe2lmKHI9PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYociBpbnN0YW5jZW9mIEhlKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7YT0hMTtmb3IobGV0IHAgb2Ygcil7aWYodHlwZW9mIHAhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHApPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke3B9LmApO29bcF09bnVsbH1pZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpaT1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgcD0hMSxtPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpO2ZvcihsZXQgdSBvZiB0aGlzLm91dHB1dE5hbWVzKWlmKG0uaW5kZXhPZih1KSE9PS0xKXtsZXQgaD1yW3VdOyhoPT09bnVsbHx8aCBpbnN0YW5jZW9mIEhlKSYmKHA9ITAsYT0hMSxvW3VdPWgpfWlmKHApe2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClpPW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGk9cn19ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IobGV0IHAgb2YgdGhpcy5pbnB1dE5hbWVzKWlmKHR5cGVvZiB0W3BdPlwidVwiKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7cH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZihhKWZvcihsZXQgcCBvZiB0aGlzLm91dHB1dE5hbWVzKW9bcF09bnVsbDtsZXQgZD1hd2FpdCB0aGlzLmhhbmRsZXIucnVuKHQsbyxpKSxsPXt9O2ZvcihsZXQgcCBpbiBkKWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQscCkpe2xldCBtPWRbcF07bSBpbnN0YW5jZW9mIEhlP2xbcF09bTpsW3BdPW5ldyBIZShtLnR5cGUsbS5kYXRhLG0uZGltcyl9cmV0dXJuIERlKCksbH1hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LHIsbixvKXtVZSgpO2xldCBpLGE9e307aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKGk9dCx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYoaT10LHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPFwidVwiJiZ0IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpe2xldCBtPXQsdT0wLGg9dC5ieXRlTGVuZ3RoO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2Ygcj09XCJudW1iZXJcIil7aWYodT1yLCFOdW1iZXIuaXNTYWZlSW50ZWdlcih1KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlT2Zmc2V0JyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKHU8MHx8dT49bS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke20uYnl0ZUxlbmd0aH0pLmApO2lmKGg9dC5ieXRlTGVuZ3RoLXUsdHlwZW9mIG49PVwibnVtYmVyXCIpe2lmKGg9biwhTnVtYmVyLmlzU2FmZUludGVnZXIoaCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihoPD0wfHx1K2g+bS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke20uYnl0ZUxlbmd0aC11fV0uYCk7aWYodHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsKWE9bztlbHNlIGlmKHR5cGVvZiBvPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO2k9bmV3IFVpbnQ4QXJyYXkobSx1LGgpfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTtsZXRbZCxsXT1hd2FpdCBKaShhKSxwPWF3YWl0IGQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoaSxsKTtyZXR1cm4gRGUoKSxuZXcgZShwKX1zdGFydFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfX19KTt2YXIgRnAsJGE9VSgoKT0+e1widXNlIHN0cmljdFwiO3ZhKCk7RnA9dnJ9KTt2YXIgeGE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFNhPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBUYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgSWE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIEZuPXt9O0Z0KEZuLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5GcCxUUkFDRTooKT0+d3IsVFJBQ0VfRlVOQ19CRUdJTjooKT0+VWUsVFJBQ0VfRlVOQ19FTkQ6KCk9PkRlLFRlbnNvcjooKT0+SGUsZW52OigpPT52ZSxyZWdpc3RlckJhY2tlbmQ6KCk9PlN0fSk7dmFyIFdlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtlYSgpO29hKCk7JGEoKTtHbigpO3hhKCk7U2EoKTtIbigpO1RhKCk7SWEoKX0pO3ZhciAkcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgRWE9e307RnQoRWEse2RlZmF1bHQ6KCk9PnFwfSk7dmFyIEFhLGthLHFwLFBhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtxbigpO2d0KCk7eHIoKTtBYT1cIm9ydC13YXNtLXByb3h5LXdvcmtlclwiLGthPWdsb2JhbFRoaXMuc2VsZj8ubmFtZT09PUFhO2thJiYoc2VsZi5vbm1lc3NhZ2U9ZT0+e2xldHt0eXBlOnQsaW46cn09ZS5kYXRhO3RyeXtzd2l0Y2godCl7Y2FzZVwiaW5pdC13YXNtXCI6U3Ioci53YXNtKS50aGVuKCgpPT57VHIocikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0sbj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm59KX0pfSxuPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bn0pfSk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOntsZXR7ZXBOYW1lOm4sZW52Om99PXI7SXIobyxuKS50aGVuKCgpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dH0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwiY29weS1mcm9tXCI6e2xldHtidWZmZXI6bn09cixvPUt0KG4pO3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Om99KTticmVha31jYXNlXCJjcmVhdGVcIjp7bGV0e21vZGVsOm4sb3B0aW9uczpvfT1yO0NyKG4sbykudGhlbihpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6aX0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOkFyKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztjYXNlXCJydW5cIjp7bGV0e3Nlc3Npb25JZDpuLGlucHV0SW5kaWNlczpvLGlucHV0czppLG91dHB1dEluZGljZXM6YSxvcHRpb25zOmR9PXI7a3IobixvLGksYSxuZXcgQXJyYXkoYS5sZW5ndGgpLmZpbGwobnVsbCksZCkudGhlbihsPT57bC5zb21lKHA9PnBbM10hPT1cImNwdVwiKT9wb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpcIlByb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uXCJ9KTpwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpsfSxQcihbLi4uaSwuLi5sXSkpfSxsPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bH0pfSk7YnJlYWt9Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOkVyKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztkZWZhdWx0On19Y2F0Y2gobil7cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bn0pfX0pO3FwPWthP251bGw6ZT0+bmV3IFdvcmtlcihlPz9OZSx7dHlwZTpcIm1vZHVsZVwiLG5hbWU6QWF9KX0pO3ZhciBPYT17fTtGdChPYSx7ZGVmYXVsdDooKT0+S3B9KTt2YXIgS24semEsS3AsRGE9VSgoKT0+e1widXNlIHN0cmljdFwiO3phPShLbj1pbXBvcnQubWV0YS51cmwsYXN5bmMgZnVuY3Rpb24oZT17fSl7ZnVuY3Rpb24gdCgpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLEp9ZnVuY3Rpb24gcigpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLG5lfWZ1bmN0aW9uIG4oKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSxiZX1mdW5jdGlvbiBvKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksT2V9ZnVuY3Rpb24gaSgpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLCRlfWZ1bmN0aW9uIGEoKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSxsZX1mdW5jdGlvbiBkKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksV31mdW5jdGlvbiBsKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksR2V9dmFyIHAsbSx1PU9iamVjdC5hc3NpZ24oe30sZSksaD1uZXcgUHJvbWlzZSgocyxjKT0+e3A9cyxtPWN9KSxfPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIseT10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLGc9eSYmc2VsZi5uYW1lPT1cImVtLXB0aHJlYWRcIjt1Lm1vdW50RXh0ZXJuYWxEYXRhPShzLGMpPT57cy5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSwodS5GYnx8KHUuRmI9bmV3IE1hcCkpLnNldChzLGMpfSx1LnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgdS5GYn07dmFyIHg9Z2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlcj8/bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDowLG1heGltdW06MCxzaGFyZWQ6ITB9KS5idWZmZXIuY29uc3RydWN0b3I7bGV0ICQ9KCk9PntsZXQgcz0oZixiLHcpPT4oLi4uSSk9PntsZXQgTz1YZSxCPWI/LigpO0k9ZiguLi5JKTtsZXQgTD1iPy4oKTtyZXR1cm4gQiE9PUwmJihmPUwsdyhCKSxiPXc9bnVsbCksWGUhPU8/bmV3IFByb21pc2UoKEgsWCk9PntFbj17cmVzb2x2ZTpILHJlamVjdDpYfX0pOkl9LGM9Zj0+YXN5bmMoLi4uYik9Pnt0cnl7aWYodS5HYil0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCB3PXUuR2I9e2hjOmJbMF0sZXJyb3JzOltdfSxJPWF3YWl0IGYoLi4uYik7aWYodS5HYiE9PXcpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO3UuSGI/LmZsdXNoKCk7bGV0IE89dy5lcnJvcnM7aWYoMDxPLmxlbmd0aCl7bGV0IEI9YXdhaXQgUHJvbWlzZS5hbGwoTyk7aWYoQj1CLmZpbHRlcihMPT5MKSwwPEIubGVuZ3RoKXRocm93IEVycm9yKEIuam9pbihgXG5gKSl9cmV0dXJuIEl9ZmluYWxseXt1LkdiPW51bGx9fTt1Ll9PcnRDcmVhdGVTZXNzaW9uPXModS5fT3J0Q3JlYXRlU2Vzc2lvbiwoKT0+dS5fT3J0Q3JlYXRlU2Vzc2lvbixmPT51Ll9PcnRDcmVhdGVTZXNzaW9uPWYpLHUuX09ydFJ1bj1jKHModS5fT3J0UnVuLCgpPT51Ll9PcnRSdW4sZj0+dS5fT3J0UnVuPWYpKSx1Ll9PcnRSdW5XaXRoQmluZGluZz1jKHModS5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PnUuX09ydFJ1bldpdGhCaW5kaW5nLGY9PnUuX09ydFJ1bldpdGhCaW5kaW5nPWYpKSx1Ll9PcnRCaW5kSW5wdXQ9cyh1Ll9PcnRCaW5kSW5wdXQsKCk9PnUuX09ydEJpbmRJbnB1dCxmPT51Ll9PcnRCaW5kSW5wdXQ9ZiksJD12b2lkIDB9O3UuanNlcEluaXQ9KHMsYyk9PntpZigkPy4oKSxzPT09XCJ3ZWJncHVcIil7W3UuSGIsdS5WYix1LlpiLHUuT2IsdS5ZYix1LmtiLHUuJGIsdS5jYyx1LldiLHUuWGIsdS5hY109YztsZXQgZj11LkhiO3UuanNlcFJlZ2lzdGVyQnVmZmVyPShiLHcsSSxPKT0+Zi5yZWdpc3RlckJ1ZmZlcihiLHcsSSxPKSx1LmpzZXBHZXRCdWZmZXI9Yj0+Zi5nZXRCdWZmZXIoYiksdS5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oYix3LEkpPT5mLmNyZWF0ZURvd25sb2FkZXIoYix3LEkpLHUuanNlcE9uQ3JlYXRlU2Vzc2lvbj1iPT57Zi5vbkNyZWF0ZVNlc3Npb24oYil9LHUuanNlcE9uUmVsZWFzZVNlc3Npb249Yj0+e2Yub25SZWxlYXNlU2Vzc2lvbihiKX0sdS5qc2VwT25SdW5TdGFydD1iPT5mLm9uUnVuU3RhcnQoYiksdS5kYz0oYix3KT0+e2YudXBsb2FkKGIsdyl9fWVsc2UgaWYocz09PVwid2Vibm5cIil7W3UuSGIsdS5iYyx1LlBiLHUuanNlcEVuc3VyZVRlbnNvcix1LmVjLHUuanNlcERvd25sb2FkVGVuc29yXT1jLHUuanNlcFJlbGVhc2VUZW5zb3JJZD11LlBiO2xldCBmPXUuSGI7dS5qc2VwT25SdW5TdGFydD1iPT5mLm9uUnVuU3RhcnQoYiksdS5qc2VwUmVnaXN0ZXJNTENvbnRleHQ9KGIsdyk9PntmLnJlZ2lzdGVyTUxDb250ZXh0KGIsdyl9LHUuanNlcE9uUmVsZWFzZVNlc3Npb249Yj0+e2Yub25SZWxlYXNlU2Vzc2lvbihiKX0sdS5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyPShiLHcpPT5mLmNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcihiLHcpLHUuanNlcFJlZ2lzdGVyTUxUZW5zb3I9KGIsdyxJKT0+Zi5yZWdpc3Rlck1MVGVuc29yKGIsdyxJKSx1LmpzZXBDcmVhdGVNTENvbnRleHQ9Yj0+Zi5jcmVhdGVNTENvbnRleHQoYiksdS5qc2VwUmVnaXN0ZXJNTENvbnN0YW50PShiLHcsSSxPLEIpPT5mLnJlZ2lzdGVyTUxDb25zdGFudChiLHcsSSxPLEIsdS5GYil9fTt2YXIgdixTLFQ9T2JqZWN0LmFzc2lnbih7fSx1KSxBPVwiLi90aGlzLnByb2dyYW1cIixrPShzLGMpPT57dGhyb3cgY30sUD1cIlwiOyhffHx5KSYmKHk/UD1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoUD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksS24mJihQPUtuKSxQPVAuc3RhcnRzV2l0aChcImJsb2I6XCIpP1wiXCI6UC5zdWJzdHIoMCxQLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpLHkmJihTPXM9Pnt2YXIgYz1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGMub3BlbihcIkdFVFwiLHMsITEpLGMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixjLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoYy5yZXNwb25zZSl9KSx2PShzLGMsZik9Pnt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiR0VUXCIscywhMCksYi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGIub25sb2FkPSgpPT57Yi5zdGF0dXM9PTIwMHx8Yi5zdGF0dXM9PTAmJmIucmVzcG9uc2U/YyhiLnJlc3BvbnNlKTpmKCl9LGIub25lcnJvcj1mLGIuc2VuZChudWxsKX0pO3ZhciBELFI9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxHPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxLPVIsaj1HO2lmKE9iamVjdC5hc3NpZ24odSxUKSxUPW51bGwsZyl7bGV0IHM9ZnVuY3Rpb24oYyl7dHJ5e3ZhciBmPWMuZGF0YSxiPWYuY21kO2lmKGI9PT1cImxvYWRcIil7bGV0IHc9W107c2VsZi5vbm1lc3NhZ2U9ST0+dy5wdXNoKEkpLHNlbGYuc3RhcnRXb3JrZXI9KCk9Pntwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtmb3IobGV0IEkgb2YgdylzKEkpO3NlbGYub25tZXNzYWdlPXN9O2ZvcihsZXQgSSBvZiBmLmhhbmRsZXJzKXVbSV0mJiF1W0ldLnByb3h5fHwodVtJXT0oLi4uTyk9Pntwb3N0TWVzc2FnZSh7TmI6XCJjYWxsSGFuZGxlclwiLHBjOkksYXJnczpPfSl9LEk9PVwicHJpbnRcIiYmKEs9dVtJXSksST09XCJwcmludEVyclwiJiYoaj11W0ldKSk7c2U9Zi53YXNtTWVtb3J5LHllKCksVihmLndhc21Nb2R1bGUpfWVsc2UgaWYoYj09PVwicnVuXCIpe0RuKGYucHRocmVhZF9wdHIsMCwwLDEsMCwwKSxBbihmLnB0aHJlYWRfcHRyKSx4YygpLEhvKCksUXx8KFdpKCksUT0hMCk7dHJ5e1NjKGYuc3RhcnRfcm91dGluZSxmLmFyZyl9Y2F0Y2godyl7aWYodyE9XCJ1bndpbmRcIil0aHJvdyB3fX1lbHNlIGI9PT1cImNhbmNlbFwiP010KCkmJmhyKC0xKTpmLnRhcmdldCE9PVwic2V0aW1tZWRpYXRlXCImJihiPT09XCJjaGVja01haWxib3hcIj9RJiZpcigpOmImJihqKGB3b3JrZXI6IHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke2J9YCksaihmKSkpfWNhdGNoKHcpe3Rocm93IExpKCksd319O3ZhciB3Zz1zLFYsUT0hMTtqPWZ1bmN0aW9uKC4uLmMpe2M9Yy5qb2luKFwiIFwiKSxjb25zb2xlLmVycm9yKGMpfSxzZWxmLmFsZXJ0PWZ1bmN0aW9uKC4uLmMpe3Bvc3RNZXNzYWdlKHtOYjpcImFsZXJ0XCIsdGV4dDpjLmpvaW4oXCIgXCIpLHJjOk10KCl9KX0sdS5pbnN0YW50aWF0ZVdhc209KGMsZik9Pm5ldyBQcm9taXNlKGI9PntWPXc9Pnt3PW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZSh3LE5vKCkpLGYodyksYigpfX0pLHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249Yz0+e3Rocm93IGMucmVhc29ufHxjfSxzZWxmLm9ubWVzc2FnZT1zfXUud2FzbUJpbmFyeSYmKEQ9dS53YXNtQmluYXJ5KTt2YXIgc2UsWSxlZSxKLG5lLGJlLE9lLCRlLGxlLFcscSxoZSxHZSx3ZT0hMTtmdW5jdGlvbiB5ZSgpe3ZhciBzPXNlLmJ1ZmZlcjt1LkhFQVA4PUo9bmV3IEludDhBcnJheShzKSx1LkhFQVAxNj1iZT1uZXcgSW50MTZBcnJheShzKSx1LkhFQVBVOD1uZT1uZXcgVWludDhBcnJheShzKSx1LkhFQVBVMTY9T2U9bmV3IFVpbnQxNkFycmF5KHMpLHUuSEVBUDMyPSRlPW5ldyBJbnQzMkFycmF5KHMpLHUuSEVBUFUzMj1sZT1uZXcgVWludDMyQXJyYXkocyksdS5IRUFQRjMyPVc9bmV3IEZsb2F0MzJBcnJheShzKSx1LkhFQVBGNjQ9R2U9bmV3IEZsb2F0NjRBcnJheShzKSx1LkhFQVA2ND1xPW5ldyBCaWdJbnQ2NEFycmF5KHMpLHUuSEVBUFU2ND1oZT1uZXcgQmlnVWludDY0QXJyYXkocyl9aWYoIWcpe2lmKCEoKHNlPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MjU2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIHgpKXRocm93IGooXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpO3llKCl9dmFyIFllPVtdLEx0PVtdLGZuPVtdLEd0PTAsaG49bnVsbCxIdD1udWxsO2Z1bmN0aW9uIERvKCl7aWYoLS1HdD09MCYmKGhuIT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoaG4pLGhuPW51bGwpLEh0KSl7dmFyIHM9SHQ7SHQ9bnVsbCxzKCl9fWZ1bmN0aW9uIGN0KHMpe3Rocm93IGoocz1cIkFib3J0ZWQoXCIrcytcIilcIiksd2U9ITAsZWU9MSxzPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IocytcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbShzKSxzfXZhciBnbixCbz1zPT5zLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpLE1vPXM9PnMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik7ZnVuY3Rpb24gUm8ocyl7aWYocz09Z24mJkQpcmV0dXJuIG5ldyBVaW50OEFycmF5KEQpO2lmKFMpcmV0dXJuIFMocyk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gVW8ocyxjLGYpe3JldHVybiBmdW5jdGlvbihiKXtpZighRCYmKF98fHkpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIU1vKGIpKXJldHVybiBmZXRjaChiLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHc9PntpZighdy5vayl0aHJvd2BmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICcke2J9J2A7cmV0dXJuIHcuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT5SbyhiKSk7aWYodilyZXR1cm4gbmV3IFByb21pc2UoKHcsSSk9Pnt2KGIsTz0+dyhuZXcgVWludDhBcnJheShPKSksSSl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Um8oYikpfShzKS50aGVuKGI9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGIsYykpLnRoZW4oZixiPT57aihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtifWApLGN0KGIpfSl9ZnVuY3Rpb24gTm8oKXtyZXR1cm57YTp7TzokYyxBYTp2YyxiOkljLGFhOmpvLEI6UW8scWE6WG8sWTplaSxfOnRpLHJhOnJpLG9hOm5pLGhhOm9pLG5hOmlpLEw6YWksWjpzaSxXOnVpLHBhOmRpLFg6bGksdmE6Q2MsRjprYyxROkVjLFA6emMsRTpEYyx1OkJjLHE6TWMsRzpSYyxBOkhjLFI6RmMsdWE6cWMsa2E6S2MsVTpqYyxiYTpZYyxIOlpjLGphOkFuLHRhOlFjLHQ6WGMsQmE6SmMseDpycCxuOm5wLGw6aXAsYzpJbixvOmFwLGo6ZHAsdzpscCxwOmNwLGY6cHAsczptcCxtOmZwLGU6aHAsazpncCxpOmJwLGg6eXAsZDpfcCxlYTp3cCxmYTp2cCxnYTokcCxjYTpTaSxkYTpUaSxUOnhwLGc6U3AsRDpUcCxJOklwLE06Q3AseTpBcCxzYTprcCxWOkVwLHY6Q2ksejpQcCxOOnpwLFM6T3AsemE6RHAseWE6QnAsbGE6RWksbWE6UGksJDp2bixDOnppLEs6T2ksaWE6RGksSjpCaSxhOnNlLHhhOnduLHdhOlVpLHI6VXB9fX12YXIgYm49ezkxMzcwMDoocyxjLGYsYix3KT0+e2lmKHU9PT12b2lkIDB8fCF1LkZiKXJldHVybiAxO2lmKChzPUNlKE51bWJlcihzPj4+MCkpKS5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSwhKHM9dS5GYi5nZXQocykpKXJldHVybiAyO2lmKGM9TnVtYmVyKGM+Pj4wKSxmPU51bWJlcihmPj4+MCksYj1OdW1iZXIoYj4+PjApLGMrZj5zLmJ5dGVMZW5ndGgpcmV0dXJuIDM7dHJ5e2xldCBJPXMuc3ViYXJyYXkoYyxjK2YpO3N3aXRjaCh3KXtjYXNlIDA6cigpLnNldChJLGI+Pj4wKTticmVhaztjYXNlIDE6dS5kYyhiLEkpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIDR9cmV0dXJuIDB9Y2F0Y2h7cmV0dXJuIDR9fSw5MTQ0MTU6KHMsYyxmKT0+e3UuZWMocyxyKCkuc3ViYXJyYXkoYz4+PjAsYytmPj4+MCkpfSw5MTQ0Nzg6KCk9PnUuYmMoKSw5MTQ1MTk6cz0+e3UuUGIocyl9LDkxNDU1NTooKT0+e3UuV2IoKX0sOTE0NTg2OigpPT57dS5YYigpfSw5MTQ2MTU6KCk9Pnt1LmFjKCl9LDkxNDY0MDpzPT51LlZiKHMpLDkxNDY3MzpzPT51LlpiKHMpLDkxNDcwNToocyxjLGYpPT57dS5PYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSwhMCl9LDkxNDc2ODoocyxjLGYpPT57dS5PYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSl9LDkxNDgyNTooKT0+dHlwZW9mIHdhc21PZmZzZXRDb252ZXJ0ZXI8XCJ1XCIsOTE0ODgyOnM9Pnt1LmtiKFwiQWJzXCIscyx2b2lkIDApfSw5MTQ5MzM6cz0+e3Uua2IoXCJOZWdcIixzLHZvaWQgMCl9LDkxNDk4NDpzPT57dS5rYihcIkZsb29yXCIscyx2b2lkIDApfSw5MTUwMzc6cz0+e3Uua2IoXCJDZWlsXCIscyx2b2lkIDApfSw5MTUwODk6cz0+e3Uua2IoXCJSZWNpcHJvY2FsXCIscyx2b2lkIDApfSw5MTUxNDc6cz0+e3Uua2IoXCJTcXJ0XCIscyx2b2lkIDApfSw5MTUxOTk6cz0+e3Uua2IoXCJFeHBcIixzLHZvaWQgMCl9LDkxNTI1MDpzPT57dS5rYihcIkVyZlwiLHMsdm9pZCAwKX0sOTE1MzAxOnM9Pnt1LmtiKFwiU2lnbW9pZFwiLHMsdm9pZCAwKX0sOTE1MzU2OihzLGMsZik9Pnt1LmtiKFwiSGFyZFNpZ21vaWRcIixzLHthbHBoYTpjLGJldGE6Zn0pfSw5MTU0MzU6cz0+e3Uua2IoXCJMb2dcIixzLHZvaWQgMCl9LDkxNTQ4NjpzPT57dS5rYihcIlNpblwiLHMsdm9pZCAwKX0sOTE1NTM3OnM9Pnt1LmtiKFwiQ29zXCIscyx2b2lkIDApfSw5MTU1ODg6cz0+e3Uua2IoXCJUYW5cIixzLHZvaWQgMCl9LDkxNTYzOTpzPT57dS5rYihcIkFzaW5cIixzLHZvaWQgMCl9LDkxNTY5MTpzPT57dS5rYihcIkFjb3NcIixzLHZvaWQgMCl9LDkxNTc0MzpzPT57dS5rYihcIkF0YW5cIixzLHZvaWQgMCl9LDkxNTc5NTpzPT57dS5rYihcIlNpbmhcIixzLHZvaWQgMCl9LDkxNTg0NzpzPT57dS5rYihcIkNvc2hcIixzLHZvaWQgMCl9LDkxNTg5OTpzPT57dS5rYihcIkFzaW5oXCIscyx2b2lkIDApfSw5MTU5NTI6cz0+e3Uua2IoXCJBY29zaFwiLHMsdm9pZCAwKX0sOTE2MDA1OnM9Pnt1LmtiKFwiQXRhbmhcIixzLHZvaWQgMCl9LDkxNjA1ODpzPT57dS5rYihcIlRhbmhcIixzLHZvaWQgMCl9LDkxNjExMDpzPT57dS5rYihcIk5vdFwiLHMsdm9pZCAwKX0sOTE2MTYxOihzLGMsZik9Pnt1LmtiKFwiQ2xpcFwiLHMse21pbjpjLG1heDpmfSl9LDkxNjIzMDpzPT57dS5rYihcIkNsaXBcIixzLHZvaWQgMCl9LDkxNjI4MjoocyxjKT0+e3Uua2IoXCJFbHVcIixzLHthbHBoYTpjfSl9LDkxNjM0MDpzPT57dS5rYihcIkdlbHVcIixzLHZvaWQgMCl9LDkxNjM5MjpzPT57dS5rYihcIlJlbHVcIixzLHZvaWQgMCl9LDkxNjQ0NDoocyxjKT0+e3Uua2IoXCJMZWFreVJlbHVcIixzLHthbHBoYTpjfSl9LDkxNjUwODoocyxjKT0+e3Uua2IoXCJUaHJlc2hvbGRlZFJlbHVcIixzLHthbHBoYTpjfSl9LDkxNjU3ODoocyxjKT0+e3Uua2IoXCJDYXN0XCIscyx7dG86Y30pfSw5MTY2MzY6cz0+e3Uua2IoXCJBZGRcIixzLHZvaWQgMCl9LDkxNjY4NzpzPT57dS5rYihcIlN1YlwiLHMsdm9pZCAwKX0sOTE2NzM4OnM9Pnt1LmtiKFwiTXVsXCIscyx2b2lkIDApfSw5MTY3ODk6cz0+e3Uua2IoXCJEaXZcIixzLHZvaWQgMCl9LDkxNjg0MDpzPT57dS5rYihcIlBvd1wiLHMsdm9pZCAwKX0sOTE2ODkxOnM9Pnt1LmtiKFwiRXF1YWxcIixzLHZvaWQgMCl9LDkxNjk0NDpzPT57dS5rYihcIkdyZWF0ZXJcIixzLHZvaWQgMCl9LDkxNjk5OTpzPT57dS5rYihcIkdyZWF0ZXJPckVxdWFsXCIscyx2b2lkIDApfSw5MTcwNjE6cz0+e3Uua2IoXCJMZXNzXCIscyx2b2lkIDApfSw5MTcxMTM6cz0+e3Uua2IoXCJMZXNzT3JFcXVhbFwiLHMsdm9pZCAwKX0sOTE3MTcyOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1lYW5cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTczNDc6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTWF4XCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE3NTIxOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1pblwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxNzY5NToocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VQcm9kXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE3ODcwOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZVN1bVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODA0NDoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMMVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODIxNzoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMMlwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODM5MDoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMb2dTdW1cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTg1Njc6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlU3VtU3F1YXJlXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE4NzQ3OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZUxvZ1N1bUV4cFwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODkyNzpzPT57dS5rYihcIldoZXJlXCIscyx2b2lkIDApfSw5MTg5ODA6KHMsYyxmKT0+e3Uua2IoXCJUcmFuc3Bvc2VcIixzLHtwZXJtOmM/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIoZik+Pj4wKSk6W119KX0sOTE5MTA0OihzLGMsZixiKT0+e3Uua2IoXCJEZXB0aFRvU3BhY2VcIixzLHtibG9ja3NpemU6Yyxtb2RlOkNlKGYpLGZvcm1hdDpiP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkxOTIzNzoocyxjLGYsYik9Pnt1LmtiKFwiRGVwdGhUb1NwYWNlXCIscyx7YmxvY2tzaXplOmMsbW9kZTpDZShmKSxmb3JtYXQ6Yj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MTkzNzA6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6LGRlKT0+e3Uua2IoXCJDb252VHJhbnNwb3NlXCIscyx7Zm9ybWF0Okw/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbZl0sZ3JvdXA6YixrZXJuZWxTaGFwZTpbd10scGFkczpbSSxPXSxzdHJpZGVzOltCXSx3SXNDb25zdDooKT0+ISF0KClbSD4+PjBdLG91dHB1dFBhZGRpbmc6WD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcihjZSk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Z2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGdlKT4+PjAsTnVtYmVyKHopPj4+MCkpOltdLGFjdGl2YXRpb246Q2UoZGUpfSl9LDkxOTgwMzoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHopPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6Qj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsMisoTnVtYmVyKGYpPj4+MCk+Pj4wKSksZ3JvdXA6YixrZXJuZWxTaGFwZTpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIodyk+Pj4wLDIrKE51bWJlcih3KT4+PjApPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCw0KyhOdW1iZXIoSSk+Pj4wKT4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihPKT4+PjAsMisoTnVtYmVyKE8pPj4+MCk+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhdCgpW0w+Pj4wXSxvdXRwdXRQYWRkaW5nOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Y2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGNlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXSxhY3RpdmF0aW9uOkNlKHopfSl9LDkyMDQ2NDoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHosZGUpPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6TD9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltmXSxncm91cDpiLGtlcm5lbFNoYXBlOlt3XSxwYWRzOltJLE9dLHN0cmlkZXM6W0JdLHdJc0NvbnN0OigpPT4hIXQoKVtIPj4+MF0sb3V0cHV0UGFkZGluZzpYP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKGNlKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpnZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZ2UpPj4+MCxOdW1iZXIoeik+Pj4wKSk6W10sYWN0aXZhdGlvbjpDZShkZSl9KX0sOTIwODk3OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpCP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGYpPj4+MCwyKyhOdW1iZXIoZik+Pj4wKT4+PjApKSxncm91cDpiLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcih3KT4+PjAsMisoTnVtYmVyKHcpPj4+MCk+Pj4wKSkscGFkczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDQrKE51bWJlcihJKT4+PjApPj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKE8pPj4+MCwyKyhOdW1iZXIoTyk+Pj4wKT4+PjApKSx3SXNDb25zdDooKT0+ISF0KClbTD4+PjBdLG91dHB1dFBhZGRpbmc6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpjZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoY2UpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdLGFjdGl2YXRpb246Q2Uoeil9KX0sOTIxNTU4OihzLGMpPT57dS5rYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIxNjQ5OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEwpPj4+MCkpOltdLHBhZHM6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmNlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTIyMTI4OihzLGMpPT57dS5rYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyMjE5OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEwpPj4+MCkpOltdLHBhZHM6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmNlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTIyNjk4OihzLGMpPT57dS5rYihcIkdsb2JhbE1heFBvb2xcIixzLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjI3ODU6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6KT0+e3Uua2IoXCJNYXhQb29sXCIscyx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6dyxkaWxhdGlvbnM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihMKT4+PjApKTpbXSxwYWRzOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sc3RyaWRlczpjZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoY2UpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdfSl9LDkyMzI2MDoocyxjKT0+e3Uua2IoXCJHbG9iYWxNYXhQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIzMzQ3OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiTWF4UG9vbFwiLHMse2Zvcm1hdDp6P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6YixzdG9yYWdlX29yZGVyOncsZGlsYXRpb25zOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOkI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoTCk+Pj4wKSk6W10scGFkczpIP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihIKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLHN0cmlkZXM6Y2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGNlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXX0pfSw5MjM4MjI6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiR2VtbVwiLHMse2FscGhhOmMsYmV0YTpmLHRyYW5zQTpiLHRyYW5zQjp3fSl9LDkyMzkyNjpzPT57dS5rYihcIk1hdE11bFwiLHMsdm9pZCAwKX0sOTIzOTgwOihzLGMsZixiKT0+e3Uua2IoXCJBcmdNYXhcIixzLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOmJ9KX0sOTI0MDg4OihzLGMsZixiKT0+e3Uua2IoXCJBcmdNaW5cIixzLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOmJ9KX0sOTI0MTk2OihzLGMpPT57dS5rYihcIlNvZnRtYXhcIixzLHtheGlzOmN9KX0sOTI0MjU5OihzLGMpPT57dS5rYihcIkNvbmNhdFwiLHMse2F4aXM6Y30pfSw5MjQzMTk6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiU3BsaXRcIixzLHtheGlzOmMsbnVtT3V0cHV0czpmLHNwbGl0U2l6ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjQ0NzU6cz0+e3Uua2IoXCJFeHBhbmRcIixzLHZvaWQgMCl9LDkyNDUyOToocyxjKT0+e3Uua2IoXCJHYXRoZXJcIixzLHtheGlzOk51bWJlcihjKX0pfSw5MjQ2MDA6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyRWxlbWVudHNcIixzLHtheGlzOk51bWJlcihjKX0pfSw5MjQ2Nzk6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyTkRcIixzLHtiYXRjaF9kaW1zOk51bWJlcihjKX0pfSw5MjQ3NTg6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCk9Pnt1LmtiKFwiUmVzaXplXCIscyx7YW50aWFsaWFzOmMsYXhlczpmP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsTnVtYmVyKGIpPj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOkNlKHcpLGN1YmljQ29lZmZBOkksZXhjbHVkZU91dHNpZGU6TyxleHRyYXBvbGF0aW9uVmFsdWU6QixrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6Q2UoTCksbW9kZTpDZShIKSxuZWFyZXN0TW9kZTpDZShYKX0pfSw5MjUxMjA6KHMsYyxmLGIsdyxJLE8pPT57dS5rYihcIlNsaWNlXCIscyx7c3RhcnRzOmM/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIoZik+Pj4wKSk6W10sZW5kczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdLGF4ZXM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXX0pfSw5MjUzODQ6cz0+e3Uua2IoXCJUaWxlXCIscyx2b2lkIDApfSw5MjU0MzY6KHMsYyxmKT0+e3Uua2IoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsZm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI1NTUwOihzLGMsZik9Pnt1LmtiKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLGZvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNTY2NDpzPT57dS5rYihcIlJhbmdlXCIscyx2b2lkIDApfSw5MjU3MTc6KHMsYyk9Pnt1LmtiKFwiRWluc3VtXCIscyx7ZXF1YXRpb246Q2UoYyl9KX0sOTI1Nzk4OihzLGMsZixiLHcpPT57dS5rYihcIlBhZFwiLHMse21vZGU6Yyx2YWx1ZTpmLHBhZHM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjU5NDE6KHMsYyxmLGIsdyxJKT0+e3Uua2IoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsbW9tZW50dW06ZixzcGF0aWFsOiEhdyx0cmFpbmluZ01vZGU6ISFiLGZvcm1hdDpJP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjExMDoocyxjLGYsYix3LEkpPT57dS5rYihcIkJhdGNoTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246Yyxtb21lbnR1bTpmLHNwYXRpYWw6ISF3LHRyYWluaW5nTW9kZTohIWIsZm9ybWF0Okk/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI2Mjc5OihzLGMsZik9Pnt1LmtiKFwiQ3VtU3VtXCIscyx7ZXhjbHVzaXZlOk51bWJlcihjKSxyZXZlcnNlOk51bWJlcihmKX0pfSw5MjYzNzY6KHMsYyxmKT0+e3Uua2IoXCJEZXF1YW50aXplTGluZWFyXCIscyx7YXhpczpjLGJsb2NrU2l6ZTpmfSl9LDkyNjQ2NjoocyxjLGYsYix3KT0+e3Uua2IoXCJHcmlkU2FtcGxlXCIscyx7YWxpZ25fY29ybmVyczpjLG1vZGU6Q2UoZikscGFkZGluZ19tb2RlOkNlKGIpLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjYzNjoocyxjLGYsYix3KT0+e3Uua2IoXCJHcmlkU2FtcGxlXCIscyx7YWxpZ25fY29ybmVyczpjLG1vZGU6Q2UoZikscGFkZGluZ19tb2RlOkNlKGIpLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjgwNjoocyxjLGYsYix3LEksTyxCLEwpPT57dS5rYihcIkF0dGVudGlvblwiLHMse251bUhlYWRzOmMsaXNVbmlkaXJlY3Rpb25hbDpmLG1hc2tGaWx0ZXJWYWx1ZTpiLHNjYWxlOncsZG9Sb3Rhcnk6SSxxa3ZIaWRkZW5TaXplczpPP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEIpK08+Pj4wKSk6W10scGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohIUx9KX0sOTI3MDc4OnM9Pnt1LmtiKFwiQmlhc0FkZFwiLHMsdm9pZCAwKX0sOTI3MTMzOnM9Pnt1LmtiKFwiQmlhc1NwbGl0R2VsdVwiLHMsdm9pZCAwKX0sOTI3MTk0OnM9Pnt1LmtiKFwiRmFzdEdlbHVcIixzLHZvaWQgMCl9LDkyNzI1MDoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHosZGUsVGUpPT57dS5rYihcIkNvbnZcIixzLHtmb3JtYXQ6Y2U/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6Zj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZik+Pj4wLE51bWJlcihiKT4+PjApKTpbXSxncm91cDp3LGtlcm5lbF9zaGFwZTpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLHBhZHM6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihMKT4+PjApKTpbXSxzdHJpZGVzOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sd19pc19jb25zdDooKT0+ISF0KClbTnVtYmVyKGdlKT4+PjBdLGFjdGl2YXRpb246Q2UoeiksYWN0aXZhdGlvbl9wYXJhbXM6ZGU/QXJyYXkuZnJvbShkKCkuc3ViYXJyYXkoTnVtYmVyKGRlKT4+PjAsTnVtYmVyKFRlKT4+PjApKTpbXX0pfSw5Mjc4MzQ6cz0+e3Uua2IoXCJHZWx1XCIscyx2b2lkIDApfSw5Mjc4ODY6KHMsYyxmLGIsdyxJLE8sQixMKT0+e3Uua2IoXCJHcm91cFF1ZXJ5QXR0ZW50aW9uXCIscyx7bnVtSGVhZHM6Yyxrdk51bUhlYWRzOmYsc2NhbGU6Yixzb2Z0Y2FwOncsZG9Sb3Rhcnk6SSxyb3RhcnlJbnRlcmxlYXZlZDpPLHNtb290aFNvZnRtYXg6Qixsb2NhbFdpbmRvd1NpemU6TH0pfSw5MjgxMDM6KHMsYyxmLGIpPT57dS5rYihcIkxheWVyTm9ybWFsaXphdGlvblwiLHMse2F4aXM6YyxlcHNpbG9uOmYsc2ltcGxpZmllZDohIWJ9KX0sOTI4MjE0OihzLGMsZixiKT0+e3Uua2IoXCJMYXllck5vcm1hbGl6YXRpb25cIixzLHtheGlzOmMsZXBzaWxvbjpmLHNpbXBsaWZpZWQ6ISFifSl9LDkyODMyNToocyxjLGYsYix3LEkpPT57dS5rYihcIk1hdE11bE5CaXRzXCIscyx7azpjLG46ZixhY2N1cmFjeUxldmVsOmIsYml0czp3LGJsb2NrU2l6ZTpJfSl9LDkyODQ1MjoocyxjLGYsYix3LEkpPT57dS5rYihcIk11bHRpSGVhZEF0dGVudGlvblwiLHMse251bUhlYWRzOmMsaXNVbmlkaXJlY3Rpb25hbDpmLG1hc2tGaWx0ZXJWYWx1ZTpiLHNjYWxlOncsZG9Sb3Rhcnk6SX0pfSw5Mjg2MTE6KHMsYyk9Pnt1LmtiKFwiUXVpY2tHZWx1XCIscyx7YWxwaGE6Y30pfSw5Mjg2NzU6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUm90YXJ5RW1iZWRkaW5nXCIscyx7aW50ZXJsZWF2ZWQ6ISFjLG51bUhlYWRzOmYscm90YXJ5RW1iZWRkaW5nRGltOmIsc2NhbGU6d30pfSw5Mjg4MTQ6KHMsYyxmKT0+e3Uua2IoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLHNpbXBsaWZpZWQ6ISFmfSl9LDkyODkxNjoocyxjLGYpPT57dS5rYihcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsc2ltcGxpZmllZDohIWZ9KX0sOTI5MDE4OihzLGMsZixiKT0+e3Uua2IoXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLHMse2dhdGhlckF4aXM6YyxxdWFudGl6ZUF4aXM6ZixibG9ja1NpemU6Yn0pfSw5MjkxMzk6cz0+e3UuJGIocyl9LDkyOTE3MzoocyxjKT0+dS5jYyhOdW1iZXIocyksTnVtYmVyKGMpLHUuR2IuaGMsdS5HYi5lcnJvcnMpfTtmdW5jdGlvbiB2YyhzLGMsZil7cmV0dXJuIF9pKGFzeW5jKCk9Pnthd2FpdCB1LlliKE51bWJlcihzKSxOdW1iZXIoYyksTnVtYmVyKGYpKX0pfWZ1bmN0aW9uICRjKCl7cmV0dXJuIHR5cGVvZiB3YXNtT2Zmc2V0Q29udmVydGVyPFwidVwifWZ1bmN0aW9uIHluKHMpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzfSlgLHRoaXMuc3RhdHVzPXN9dmFyIF9uPXM9PntzLnRlcm1pbmF0ZSgpLHMub25tZXNzYWdlPSgpPT57fX0sVm89cz0+e3B0Lmxlbmd0aD09MCYmKHFvKCksRm8ocHRbMF0pKTt2YXIgYz1wdC5wb3AoKTtpZighYylyZXR1cm4gNjt2dC5wdXNoKGMpLFplW3MuQmJdPWMsYy5CYj1zLkJiO3ZhciBmPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOnMuaWMsYXJnOnMuUmIscHRocmVhZF9wdHI6cy5CYn07cmV0dXJuIGMucG9zdE1lc3NhZ2UoZixzLm5jKSwwfSx3dD0wLHhlPShzLGMsLi4uZik9Pntmb3IodmFyIGI9MipmLmxlbmd0aCx3PVJuKCksST1Nbig4KmIpLE89ST4+PjMsQj0wO0I8Zi5sZW5ndGg7QisrKXt2YXIgTD1mW0JdO3R5cGVvZiBMPT1cImJpZ2ludFwiPyhxW08rMipCXT0xbixxW08rMipCKzFdPUwpOihxW08rMipCXT0wbixsKClbTysyKkIrMT4+PjBdPUwpfXJldHVybiBzPUdpKHMsMCxiLEksYyksZ3Iodyksc307ZnVuY3Rpb24gd24ocyl7aWYoZylyZXR1cm4geGUoMCwxLHMpO2lmKGVlPXMsISgwPHd0KSl7Zm9yKHZhciBjIG9mIHZ0KV9uKGMpO2ZvcihjIG9mIHB0KV9uKGMpO3B0PVtdLHZ0PVtdLFplPVtdLHdlPSEwfWsocyxuZXcgeW4ocykpfWZ1bmN0aW9uIFdvKHMpe2lmKGcpcmV0dXJuIHhlKDEsMCxzKTt2bihzKX12YXIgdm49cz0+e2lmKGVlPXMsZyl0aHJvdyBXbyhzKSxcInVud2luZFwiO3duKHMpfSxwdD1bXSx2dD1bXSxMbz1bXSxaZT17fSxHbz1zPT57dmFyIGM9cy5CYjtkZWxldGUgWmVbY10scHQucHVzaChzKSx2dC5zcGxpY2UodnQuaW5kZXhPZihzKSwxKSxzLkJiPTAsQm4oYyl9O2Z1bmN0aW9uIEhvKCl7TG8uZm9yRWFjaChzPT5zKCkpfXZhciBGbz1zPT5uZXcgUHJvbWlzZShjPT57cy5vbm1lc3NhZ2U9dz0+e3ZhciBJPSh3PXcuZGF0YSkuY21kO2lmKHcudGFyZ2V0VGhyZWFkJiZ3LnRhcmdldFRocmVhZCE9TXQoKSl7dmFyIE89WmVbdy50YXJnZXRUaHJlYWRdO08/Ty5wb3N0TWVzc2FnZSh3LHcudHJhbnNmZXJMaXN0KTpqKGBJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJHtJfVwiIHRvIHRhcmdldCBwdGhyZWFkICR7dy50YXJnZXRUaHJlYWR9LCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFgKX1lbHNlIEk9PT1cImNoZWNrTWFpbGJveFwiP2lyKCk6ST09PVwic3Bhd25UaHJlYWRcIj9Wbyh3KTpJPT09XCJjbGVhbnVwVGhyZWFkXCI/R28oWmVbdy50aHJlYWRdKTpJPT09XCJraWxsVGhyZWFkXCI/KHc9dy50aHJlYWQsST1aZVt3XSxkZWxldGUgWmVbd10sX24oSSksQm4odyksdnQuc3BsaWNlKHZ0LmluZGV4T2YoSSksMSksSS5CYj0wKTpJPT09XCJjYW5jZWxUaHJlYWRcIj9aZVt3LnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6ST09PVwibG9hZGVkXCI/KHMubG9hZGVkPSEwLGMocykpOkk9PT1cImFsZXJ0XCI/YWxlcnQoYFRocmVhZCAke3cudGhyZWFkSWR9OiAke3cudGV4dH1gKTp3LnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/cy5wb3N0TWVzc2FnZSh3KTpJPT09XCJjYWxsSGFuZGxlclwiP3Vbdy5oYW5kbGVyXSguLi53LmFyZ3MpOkkmJmooYHdvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCAke0l9YCl9LHMub25lcnJvcj13PT57dGhyb3cgaihgd29ya2VyIHNlbnQgYW4gZXJyb3IhICR7dy5maWxlbmFtZX06JHt3LmxpbmVub306ICR7dy5tZXNzYWdlfWApLHd9O3ZhciBmLGI9W107Zm9yKGYgb2ZbXSl1Lmhhc093blByb3BlcnR5KGYpJiZiLnB1c2goZik7cy5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmIsd2FzbU1lbW9yeTpzZSx3YXNtTW9kdWxlOll9KX0pO2Z1bmN0aW9uIHFvKCl7dmFyIHM9bmV3IFdvcmtlcihpbXBvcnQubWV0YS51cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwoXCJvcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzXCIsaW1wb3J0Lm1ldGEudXJsKTpuZXcgVVJMKGltcG9ydC5tZXRhLnVybCkse3R5cGU6XCJtb2R1bGVcIix3b3JrZXJEYXRhOlwiZW0tcHRocmVhZFwiLG5hbWU6XCJlbS1wdGhyZWFkXCJ9KTtwdC5wdXNoKHMpfXZhciBvcj1zPT57Zm9yKDswPHMubGVuZ3RoOylzLnNoaWZ0KCkodSl9LHhjPSgpPT57dmFyIHM9TXQoKSxjPWEoKVtzKzUyPj4+Mj4+PjBdO3M9YSgpW3MrNTY+Pj4yPj4+MF0sRmkoYyxjLXMpLGdyKGMpfSxTYz0ocyxjKT0+e3d0PTAscz1xaShzLGMpLDA8d3Q/ZWU9czpocihzKX07Y2xhc3MgVGN7Y29uc3RydWN0b3IoYyl7dGhpcy5LYj1jLTI0fX1mdW5jdGlvbiBJYyhzLGMsZil7dmFyIGI9bmV3IFRjKHM+Pj49MCk7dGhyb3cgYz4+Pj0wLGY+Pj49MCxhKClbYi5LYisxNj4+PjI+Pj4wXT0wLGEoKVtiLktiKzQ+Pj4yPj4+MF09YyxhKClbYi5LYis4Pj4+Mj4+PjBdPWYsc31mdW5jdGlvbiBLbyhzLGMsZixiKXtyZXR1cm4gZz94ZSgyLDEscyxjLGYsYik6am8ocyxjLGYsYil9ZnVuY3Rpb24gam8ocyxjLGYsYil7aWYocz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wLHg9PT12b2lkIDApcmV0dXJuIGooXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciB3PVtdO3JldHVybiBnJiZ3Lmxlbmd0aD09PTA/S28ocyxjLGYsYik6KHM9e2ljOmYsQmI6cyxSYjpiLG5jOnd9LGc/KHMuTmI9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHMsdyksMCk6Vm8ocykpfXZhciBZbz10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsWm89KHMsYyxmKT0+e3ZhciBiPShjPj4+PTApK2Y7Zm9yKGY9YztzW2ZdJiYhKGY+PWIpOykrK2Y7aWYoMTY8Zi1jJiZzLmJ1ZmZlciYmWW8pcmV0dXJuIFlvLmRlY29kZShzLmJ1ZmZlciBpbnN0YW5jZW9mIHg/cy5zbGljZShjLGYpOnMuc3ViYXJyYXkoYyxmKSk7Zm9yKGI9XCJcIjtjPGY7KXt2YXIgdz1zW2MrK107aWYoMTI4Jncpe3ZhciBJPTYzJnNbYysrXTtpZigoMjI0JncpPT0xOTIpYis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdyk8PDZ8SSk7ZWxzZXt2YXIgTz02MyZzW2MrK107NjU1MzY+KHc9KDI0MCZ3KT09MjI0PygxNSZ3KTw8MTJ8STw8NnxPOig3JncpPDwxOHxJPDwxMnxPPDw2fDYzJnNbYysrXSk/Yis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KToody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKX19ZWxzZSBiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxDZT0ocyxjKT0+KHM+Pj49MCk/Wm8ocigpLHMsYyk6XCJcIjtmdW5jdGlvbiBRbyhzLGMsZil7cmV0dXJuIGc/eGUoMywxLHMsYyxmKTowfWZ1bmN0aW9uIFhvKHMsYyl7aWYoZylyZXR1cm4geGUoNCwxLHMsYyl9dmFyICRuPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTsxMjc+PWI/YysrOjIwNDc+PWI/Yys9Mjo1NTI5Njw9YiYmNTczNDM+PWI/KGMrPTQsKytmKTpjKz0zfXJldHVybiBjfSxKbz0ocyxjLGYsYik9PntpZighKDA8YikpcmV0dXJuIDA7dmFyIHc9Zj4+Pj0wO2I9ZitiLTE7Zm9yKHZhciBJPTA7STxzLmxlbmd0aDsrK0kpe3ZhciBPPXMuY2hhckNvZGVBdChJKTtpZig1NTI5Njw9TyYmNTczNDM+PU8mJihPPTY1NTM2KygoMTAyMyZPKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrSSkpLDEyNz49Tyl7aWYoZj49YilicmVhaztjW2YrKz4+PjBdPU99ZWxzZXtpZigyMDQ3Pj1PKXtpZihmKzE+PWIpYnJlYWs7Y1tmKys+Pj4wXT0xOTJ8Tz4+Nn1lbHNle2lmKDY1NTM1Pj1PKXtpZihmKzI+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yMjR8Tz4+MTJ9ZWxzZXtpZihmKzM+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yNDB8Tz4+MTgsY1tmKys+Pj4wXT0xMjh8Tz4+MTImNjN9Y1tmKys+Pj4wXT0xMjh8Tz4+NiY2M31jW2YrKz4+PjBdPTEyOHw2MyZPfX1yZXR1cm4gY1tmPj4+MF09MCxmLXd9LE90PShzLGMsZik9PkpvKHMscigpLGMsZik7ZnVuY3Rpb24gZWkocyxjKXtpZihnKXJldHVybiB4ZSg1LDEscyxjKX1mdW5jdGlvbiB0aShzLGMsZil7aWYoZylyZXR1cm4geGUoNiwxLHMsYyxmKX1mdW5jdGlvbiByaShzLGMsZil7cmV0dXJuIGc/eGUoNywxLHMsYyxmKTowfWZ1bmN0aW9uIG5pKHMsYyl7aWYoZylyZXR1cm4geGUoOCwxLHMsYyl9ZnVuY3Rpb24gb2kocyxjLGYpe2lmKGcpcmV0dXJuIHhlKDksMSxzLGMsZil9ZnVuY3Rpb24gaWkocyxjLGYsYil7aWYoZylyZXR1cm4geGUoMTAsMSxzLGMsZixiKX1mdW5jdGlvbiBhaShzLGMsZixiKXtpZihnKXJldHVybiB4ZSgxMSwxLHMsYyxmLGIpfWZ1bmN0aW9uIHNpKHMsYyxmLGIpe2lmKGcpcmV0dXJuIHhlKDEyLDEscyxjLGYsYil9ZnVuY3Rpb24gdWkocyl7aWYoZylyZXR1cm4geGUoMTMsMSxzKX1mdW5jdGlvbiBkaShzLGMpe2lmKGcpcmV0dXJuIHhlKDE0LDEscyxjKX1mdW5jdGlvbiBsaShzLGMsZil7aWYoZylyZXR1cm4geGUoMTUsMSxzLGMsZil9dmFyIGNpLG10LENjPSgpPT57Y3QoXCJcIil9LFFlPXM9Pntmb3IodmFyIGM9XCJcIjtyKClbcz4+PjBdOyljKz1jaVtyKClbcysrPj4+MF1dO3JldHVybiBjfSx4bj17fSxTbj17fSxBYz17fTtmdW5jdGlvbiBzdChzLGMsZj17fSl7aWYoIShcImFyZ1BhY2tBZHZhbmNlXCJpbiBjKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtyZXR1cm4gZnVuY3Rpb24oYix3LEk9e30pe3ZhciBPPXcubmFtZTtpZighYil0aHJvdyBuZXcgbXQoYHR5cGUgXCIke099XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKFNuLmhhc093blByb3BlcnR5KGIpKXtpZihJLlRiKXJldHVybjt0aHJvdyBuZXcgbXQoYENhbm5vdCByZWdpc3RlciB0eXBlICcke099JyB0d2ljZWApfVNuW2JdPXcsZGVsZXRlIEFjW2JdLHhuLmhhc093blByb3BlcnR5KGIpJiYodz14bltiXSxkZWxldGUgeG5bYl0sdy5mb3JFYWNoKEI9PkIoKSkpfShzLGMsZil9dmFyIHBpPShzLGMsZik9Pntzd2l0Y2goYyl7Y2FzZSAxOnJldHVybiBmP2I9PnQoKVtiPj4+MF06Yj0+cigpW2I+Pj4wXTtjYXNlIDI6cmV0dXJuIGY/Yj0+bigpW2I+Pj4xPj4+MF06Yj0+bygpW2I+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBmP2I9PmkoKVtiPj4+Mj4+PjBdOmI9PmEoKVtiPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gZj9iPT5xW2I+Pj4zXTpiPT5oZVtiPj4+M107ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7Y30pOiAke3N9YCl9fTtmdW5jdGlvbiBrYyhzLGMsZil7Zj4+Pj0wLHN0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6Yj0+Yix0b1dpcmVUeXBlOmZ1bmN0aW9uKGIsdyl7aWYodHlwZW9mIHchPVwiYmlnaW50XCImJnR5cGVvZiB3IT1cIm51bWJlclwiKXRocm93IHc9dz09PW51bGw/XCJudWxsXCI6KGI9dHlwZW9mIHcpPT1cIm9iamVjdFwifHxiPT09XCJhcnJheVwifHxiPT09XCJmdW5jdGlvblwiP3cudG9TdHJpbmcoKTpcIlwiK3csbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgXCIke3d9XCIgdG8gJHt0aGlzLm5hbWV9YCk7cmV0dXJuIHR5cGVvZiB3PT1cIm51bWJlclwiJiYodz1CaWdJbnQodykpLHd9LGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOnBpKGMsZixjLmluZGV4T2YoXCJ1XCIpPT0tMSksRWI6bnVsbH0pfXZhciBmdD04O2Z1bmN0aW9uIEVjKHMsYyxmLGIpe3N0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24odyl7cmV0dXJuISF3fSx0b1dpcmVUeXBlOmZ1bmN0aW9uKHcsSSl7cmV0dXJuIEk/ZjpifSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbih3KXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUocigpW3c+Pj4wXSl9LEViOm51bGx9KX12YXIgVG49W10sdXQ9W107ZnVuY3Rpb24gSW4ocyl7OTwocz4+Pj0wKSYmLS11dFtzKzFdPT0wJiYodXRbc109dm9pZCAwLFRuLnB1c2gocykpfXZhciBNZT1zPT57aWYoIXMpdGhyb3cgbmV3IG10KFwiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gXCIrcyk7cmV0dXJuIHV0W3NdfSxWZT1zPT57c3dpdGNoKHMpe2Nhc2Ugdm9pZCAwOnJldHVybiAyO2Nhc2UgbnVsbDpyZXR1cm4gNDtjYXNlITA6cmV0dXJuIDY7Y2FzZSExOnJldHVybiA4O2RlZmF1bHQ6bGV0IGM9VG4ucG9wKCl8fHV0Lmxlbmd0aDtyZXR1cm4gdXRbY109cyx1dFtjKzFdPTEsY319O2Z1bmN0aW9uIENuKHMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShhKClbcz4+PjI+Pj4wXSl9dmFyIFBjPXtuYW1lOlwiZW1zY3JpcHRlbjo6dmFsXCIsZnJvbVdpcmVUeXBlOnM9Pnt2YXIgYz1NZShzKTtyZXR1cm4gSW4ocyksY30sdG9XaXJlVHlwZToocyxjKT0+VmUoYyksYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sRWI6bnVsbH07ZnVuY3Rpb24gemMocyl7cmV0dXJuIHN0KHM+Pj4wLFBjKX12YXIgT2M9KHMsYyk9Pntzd2l0Y2goYyl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoZCgpW2Y+Pj4yPj4+MF0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShsKClbZj4+PjM+Pj4wXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHtjfSk6ICR7c31gKX19O2Z1bmN0aW9uIERjKHMsYyxmKXtmPj4+PTAsc3Qocz4+Pj0wLHtuYW1lOmM9UWUoYz4+PjApLGZyb21XaXJlVHlwZTpiPT5iLHRvV2lyZVR5cGU6KGIsdyk9PncsYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6T2MoYyxmKSxFYjpudWxsfSl9ZnVuY3Rpb24gQmMocyxjLGYsYix3KXtpZihzPj4+PTAsZj4+Pj0wLGM9UWUoYz4+PjApLHc9PT0tMSYmKHc9NDI5NDk2NzI5NSksdz1CPT5CLGI9PT0wKXt2YXIgST0zMi04KmY7dz1CPT5CPDxJPj4+SX12YXIgTz1jLmluY2x1ZGVzKFwidW5zaWduZWRcIik/ZnVuY3Rpb24oQixMKXtyZXR1cm4gTD4+PjB9OmZ1bmN0aW9uKEIsTCl7cmV0dXJuIEx9O3N0KHMse25hbWU6Yyxmcm9tV2lyZVR5cGU6dyx0b1dpcmVUeXBlOk8sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6cGkoYyxmLGIhPT0wKSxFYjpudWxsfSl9ZnVuY3Rpb24gTWMocyxjLGYpe2Z1bmN0aW9uIGIoSSl7dmFyIE89YSgpW0k+Pj4yPj4+MF07cmV0dXJuIEk9YSgpW0krND4+PjI+Pj4wXSxuZXcgdyh0KCkuYnVmZmVyLEksTyl9dmFyIHc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQmlnVWludDY0QXJyYXldW2NdO3N0KHM+Pj49MCx7bmFtZTpmPVFlKGY+Pj4wKSxmcm9tV2lyZVR5cGU6YixhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpifSx7VGI6ITB9KX1mdW5jdGlvbiBSYyhzLGMpe3M+Pj49MDt2YXIgZj0oYz1RZShjPj4+MCkpPT09XCJzdGQ6OnN0cmluZ1wiO3N0KHMse25hbWU6Yyxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oYil7dmFyIHc9YSgpW2I+Pj4yPj4+MF0sST1iKzQ7aWYoZilmb3IodmFyIE89SSxCPTA7Qjw9dzsrK0Ipe3ZhciBMPUkrQjtpZihCPT13fHxyKClbTD4+PjBdPT0wKXtpZihPPUNlKE8sTC1PKSxIPT09dm9pZCAwKXZhciBIPU87ZWxzZSBIKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEgrPU87Tz1MKzF9fWVsc2V7Zm9yKEg9QXJyYXkodyksQj0wO0I8dzsrK0IpSFtCXT1TdHJpbmcuZnJvbUNoYXJDb2RlKHIoKVtJK0I+Pj4wXSk7SD1ILmpvaW4oXCJcIil9cmV0dXJuIEplKGIpLEh9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oYix3KXt3IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih3PW5ldyBVaW50OEFycmF5KHcpKTt2YXIgST10eXBlb2Ygdz09XCJzdHJpbmdcIjtpZighKEl8fHcgaW5zdGFuY2VvZiBVaW50OEFycmF5fHx3IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHcgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXRocm93IG5ldyBtdChcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmdcIik7dmFyIE89ZiYmST8kbih3KTp3Lmxlbmd0aCxCPWZyKDQrTysxKSxMPUIrNDtpZihhKClbQj4+PjI+Pj4wXT1PLGYmJkkpT3QodyxMLE8rMSk7ZWxzZSBpZihJKWZvcihJPTA7STxPOysrSSl7dmFyIEg9dy5jaGFyQ29kZUF0KEkpO2lmKDI1NTxIKXRocm93IEplKEwpLG5ldyBtdChcIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0c1wiKTtyKClbTCtJPj4+MF09SH1lbHNlIGZvcihJPTA7STxPOysrSSlyKClbTCtJPj4+MF09d1tJXTtyZXR1cm4gYiE9PW51bGwmJmIucHVzaChKZSxCKSxCfSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpDbixFYihiKXtKZShiKX19KX12YXIgbWk9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpOnZvaWQgMCxVYz0ocyxjKT0+e2Zvcih2YXIgZj1zPj4xLGI9ZitjLzI7IShmPj1iKSYmbygpW2Y+Pj4wXTspKytmO2lmKDMyPChmPDw9MSktcyYmbWkpcmV0dXJuIG1pLmRlY29kZShyKCkuc2xpY2UocyxmKSk7Zm9yKGY9XCJcIixiPTA7IShiPj1jLzIpOysrYil7dmFyIHc9bigpW3MrMipiPj4+MT4+PjBdO2lmKHc9PTApYnJlYWs7Zis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KX1yZXR1cm4gZn0sTmM9KHMsYyxmKT0+e2lmKGY/Pz0yMTQ3NDgzNjQ3LDI+ZilyZXR1cm4gMDt2YXIgYj1jO2Y9KGYtPTIpPDIqcy5sZW5ndGg/Zi8yOnMubGVuZ3RoO2Zvcih2YXIgdz0wO3c8ZjsrK3cpe3ZhciBJPXMuY2hhckNvZGVBdCh3KTtuKClbYz4+PjE+Pj4wXT1JLGMrPTJ9cmV0dXJuIG4oKVtjPj4+MT4+PjBdPTAsYy1ifSxWYz1zPT4yKnMubGVuZ3RoLFdjPShzLGMpPT57Zm9yKHZhciBmPTAsYj1cIlwiOyEoZj49Yy80KTspe3ZhciB3PWkoKVtzKzQqZj4+PjI+Pj4wXTtpZih3PT0wKWJyZWFrOysrZiw2NTUzNjw9dz8ody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKTpiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxMYz0ocyxjLGYpPT57aWYoYz4+Pj0wLGY/Pz0yMTQ3NDgzNjQ3LDQ+ZilyZXR1cm4gMDt2YXIgYj1jO2Y9YitmLTQ7Zm9yKHZhciB3PTA7dzxzLmxlbmd0aDsrK3cpe3ZhciBJPXMuY2hhckNvZGVBdCh3KTtpZig1NTI5Njw9SSYmNTczNDM+PUkmJihJPTY1NTM2KygoMTAyMyZJKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrdykpLGkoKVtjPj4+Mj4+PjBdPUksKGMrPTQpKzQ+ZilicmVha31yZXR1cm4gaSgpW2M+Pj4yPj4+MF09MCxjLWJ9LEdjPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTs1NTI5Njw9YiYmNTczNDM+PWImJisrZixjKz00fXJldHVybiBjfTtmdW5jdGlvbiBIYyhzLGMsZil7aWYocz4+Pj0wLGM+Pj49MCxmPVFlKGY+Pj49MCksYz09PTIpdmFyIGI9VWMsdz1OYyxJPVZjLE89Qj0+bygpW0I+Pj4xPj4+MF07ZWxzZSBjPT09NCYmKGI9V2Msdz1MYyxJPUdjLE89Qj0+YSgpW0I+Pj4yPj4+MF0pO3N0KHMse25hbWU6Zixmcm9tV2lyZVR5cGU6Qj0+e2Zvcih2YXIgTCxIPWEoKVtCPj4+Mj4+PjBdLFg9Qis0LGNlPTA7Y2U8PUg7KytjZSl7dmFyIGdlPUIrNCtjZSpjO2NlIT1IJiZPKGdlKSE9MHx8KFg9YihYLGdlLVgpLEw9PT12b2lkIDA/TD1YOihMKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEwrPVgpLFg9Z2UrYyl9cmV0dXJuIEplKEIpLEx9LHRvV2lyZVR5cGU6KEIsTCk9PntpZih0eXBlb2YgTCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgbXQoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7Zn1gKTt2YXIgSD1JKEwpLFg9ZnIoNCtIK2MpO3JldHVybiBhKClbWD4+PjI+Pj4wXT1IL2MsdyhMLFgrNCxIK2MpLEIhPT1udWxsJiZCLnB1c2goSmUsWCksWH0sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sRWIoQil7SmUoQil9fSl9ZnVuY3Rpb24gRmMocyxjKXtzdChzPj4+PTAse1ViOiEwLG5hbWU6Yz1RZShjPj4+MCksYXJnUGFja0FkdmFuY2U6MCxmcm9tV2lyZVR5cGU6KCk9Pnt9LHRvV2lyZVR5cGU6KCk9Pnt9fSl9dmFyIHFjPSgpPT4xO2Z1bmN0aW9uIEtjKHMpe0RuKHM+Pj4wLCF5LDEsIV8sMTMxMDcyLCExKSxIbygpfXZhciBmaT1zPT57aWYoIXdlKXRyeXtpZihzKCksISgwPHd0KSl0cnl7Zz9ocihlZSk6dm4oZWUpfWNhdGNoKGMpe2MgaW5zdGFuY2VvZiB5bnx8Yz09XCJ1bndpbmRcInx8aygxLGMpfX1jYXRjaChjKXtjIGluc3RhbmNlb2YgeW58fGM9PVwidW53aW5kXCJ8fGsoMSxjKX19O2Z1bmN0aW9uIEFuKHMpe3M+Pj49MCx0eXBlb2YgQXRvbWljcy5vYz09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5vYyhpKCkscz4+PjIscykudmFsdWUudGhlbihpcikscys9MTI4LEF0b21pY3Muc3RvcmUoaSgpLHM+Pj4yLDEpKX12YXIgaXI9KCk9Pnt2YXIgcz1NdCgpO3MmJihBbihzKSxmaShIaSkpfTtmdW5jdGlvbiBqYyhzLGMpeyhzPj4+PTApPT1jPj4+MD9zZXRUaW1lb3V0KGlyKTpnP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6cyxjbWQ6XCJjaGVja01haWxib3hcIn0pOihzPVplW3NdKSYmcy5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX12YXIga249W107ZnVuY3Rpb24gWWMocyxjLGYsYix3KXtmb3IoYz4+Pj0wLGIvPTIsa24ubGVuZ3RoPWIsZj13Pj4+MD4+PjMsdz0wO3c8Yjt3Kyspa25bd109cVtmKzIqd10/cVtmKzIqdysxXTpsKClbZisyKncrMT4+PjBdO3JldHVybihjP2JuW2NdOk5wW3NdKSguLi5rbil9ZnVuY3Rpb24gWmMocyl7cz4+Pj0wLGc/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6c30pOkdvKFplW3NdKX1mdW5jdGlvbiBRYyhzKXt9dmFyIGFyPShzLGMpPT57dmFyIGY9U25bc107aWYoZj09PXZvaWQgMCl0aHJvdyBzPVZpKHMpLGY9UWUocyksSmUocyksbmV3IG10KGAke2N9IGhhcyB1bmtub3duIHR5cGUgJHtmfWApO3JldHVybiBmfSxoaT0ocyxjLGYpPT57dmFyIGI9W107cmV0dXJuIHM9cy50b1dpcmVUeXBlKGIsZiksYi5sZW5ndGgmJihhKClbYz4+PjI+Pj4wXT1WZShiKSksc307ZnVuY3Rpb24gWGMocyxjLGYpe3JldHVybiBjPj4+PTAsZj4+Pj0wLHM9TWUocz4+PjApLGM9YXIoYyxcImVtdmFsOjphc1wiKSxoaShjLGYscyl9ZnVuY3Rpb24gSmMocyxjKXtyZXR1cm4gYz4+Pj0wLHM9TWUocz4+PjApLChjPWFyKGMsXCJlbXZhbDo6YXNcIikpLnRvV2lyZVR5cGUobnVsbCxzKX12YXIgc3I9cz0+e3RyeXtzKCl9Y2F0Y2goYyl7Y3QoYyl9fSxodD0wLFhlPW51bGwsZ2k9MCx1cj1bXSxiaT17fSx5aT17fSxlcD0wLEVuPW51bGwsdHA9W107ZnVuY3Rpb24gX2kocyl7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKCF3ZSl7aWYoaHQ9PT0wKXt2YXIgZj0hMSxiPSExO2MoKHc9MCk9PntpZighd2UmJihnaT13LGY9ITAsYikpe2h0PTIsc3IoKCk9PllpKFhlKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuTGIuU2ImJkJyb3dzZXIuTGIucmVzdW1lKCksdz0hMTt0cnl7dmFyIEk9ZnVuY3Rpb24oKXt2YXIgTD1pKClbWGUrOD4+PjI+Pj4wXTtyZXR1cm4gTD1aW3lpW0xdXSwtLXd0LEwoKX0oKX1jYXRjaChMKXtJPUwsdz0hMH12YXIgTz0hMTtpZighWGUpe3ZhciBCPUVuO0ImJihFbj1udWxsLCh3P0IucmVqZWN0OkIucmVzb2x2ZSkoSSksTz0hMCl9aWYodyYmIU8pdGhyb3cgSX19KSxiPSEwLGZ8fChodD0xLFhlPWZ1bmN0aW9uKCl7dmFyIHc9ZnIoNjU1NDgpLEk9dysxMjthKClbdz4+PjI+Pj4wXT1JLGEoKVt3KzQ+Pj4yPj4+MF09SSs2NTUzNixJPXVyWzBdO3ZhciBPPWJpW0ldO3JldHVybiBPPT09dm9pZCAwJiYoTz1lcCsrLGJpW0ldPU8seWlbT109SSksST1PLGkoKVt3Kzg+Pj4yPj4+MF09SSx3fSgpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkxiLlNiJiZCcm93c2VyLkxiLnBhdXNlKCksc3IoKCk9PktpKFhlKSkpfWVsc2UgaHQ9PT0yPyhodD0wLHNyKFppKSxKZShYZSksWGU9bnVsbCx0cC5mb3JFYWNoKGZpKSk6Y3QoYGludmFsaWQgc3RhdGU6ICR7aHR9YCk7cmV0dXJuIGdpfX0oYz0+e3MoKS50aGVuKGMpfSl9ZnVuY3Rpb24gcnAocyl7cmV0dXJuIHM+Pj49MCxfaSgoKT0+KHM9TWUocykpLnRoZW4oVmUpKX12YXIgZHI9W107ZnVuY3Rpb24gbnAocyxjLGYsYil7cmV0dXJuIGY+Pj49MCxiPj4+PTAsKHM9ZHJbcz4+PjBdKShudWxsLGM9TWUoYz4+PjApLGYsYil9dmFyIG9wPXt9LGxyPXM9Pnt2YXIgYz1vcFtzXTtyZXR1cm4gYz09PXZvaWQgMD9RZShzKTpjfTtmdW5jdGlvbiBpcChzLGMsZixiLHcpe3JldHVybiBmPj4+PTAsYj4+Pj0wLHc+Pj49MCwocz1kcltzPj4+MF0pKGM9TWUoYz4+PjApLGNbZj1scihmKV0sYix3KX12YXIgd2k9KCk9PnR5cGVvZiBnbG9iYWxUaGlzPT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO2Z1bmN0aW9uIGFwKHMpe3JldHVybihzPj4+PTApPT0wP1ZlKHdpKCkpOihzPWxyKHMpLFZlKHdpKClbc10pKX12YXIgc3A9cz0+e3ZhciBjPWRyLmxlbmd0aDtyZXR1cm4gZHIucHVzaChzKSxjfSx1cD0ocyxjKT0+e2Zvcih2YXIgZj1BcnJheShzKSxiPTA7YjxzOysrYilmW2JdPWFyKGEoKVtjKzQqYj4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIitiKTtyZXR1cm4gZn0sdmk9KHMsYyk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwibmFtZVwiLHt2YWx1ZTpzfSk7ZnVuY3Rpb24gZHAocyxjLGYpe3ZhciBiPShjPXVwKHMsYz4+PjApKS5zaGlmdCgpO3MtLTt2YXIgdz1gcmV0dXJuIGZ1bmN0aW9uIChvYmosIGZ1bmMsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XG5gLEk9MCxPPVtdO2Y9PT0wJiZPLnB1c2goXCJvYmpcIik7Zm9yKHZhciBCPVtcInJldFR5cGVcIl0sTD1bYl0sSD0wO0g8czsrK0gpTy5wdXNoKFwiYXJnXCIrSCksQi5wdXNoKFwiYXJnVHlwZVwiK0gpLEwucHVzaChjW0hdKSx3Kz1gICB2YXIgYXJnJHtIfSA9IGFyZ1R5cGUke0h9LnJlYWRWYWx1ZUZyb21Qb2ludGVyKGFyZ3Mke0k/XCIrXCIrSTpcIlwifSk7XG5gLEkrPWNbSF0uYXJnUGFja0FkdmFuY2U7cmV0dXJuIHcrPWAgIHZhciBydiA9ICR7Zj09PTE/XCJuZXcgZnVuY1wiOlwiZnVuYy5jYWxsXCJ9KCR7Ty5qb2luKFwiLCBcIil9KTtcbmAsYi5VYnx8KEIucHVzaChcImVtdmFsX3JldHVyblZhbHVlXCIpLEwucHVzaChoaSksdys9YCAgcmV0dXJuIGVtdmFsX3JldHVyblZhbHVlKHJldFR5cGUsIGRlc3RydWN0b3JzUmVmLCBydik7XG5gKSxCLnB1c2godytgfTtcbmApLHM9ZnVuY3Rpb24oWCl7dmFyIGNlPUZ1bmN0aW9uO2lmKCEoY2UgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihgbmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICR7dHlwZW9mIGNlfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciBnZT12aShjZS5uYW1lfHxcInVua25vd25GdW5jdGlvbk5hbWVcIixmdW5jdGlvbigpe30pO3JldHVybiBnZS5wcm90b3R5cGU9Y2UucHJvdG90eXBlLGdlPW5ldyBnZSwoWD1jZS5hcHBseShnZSxYKSlpbnN0YW5jZW9mIE9iamVjdD9YOmdlfShCKSguLi5MKSxmPWBtZXRob2RDYWxsZXI8KCR7Yy5tYXAoWD0+WC5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAke2IubmFtZX0+YCxzcCh2aShmLHMpKX1mdW5jdGlvbiBscChzKXtyZXR1cm4gcz1scihzPj4+MCksVmUodVtzXSl9ZnVuY3Rpb24gY3AocyxjKXtyZXR1cm4gYz4+Pj0wLHM9TWUocz4+PjApLGM9TWUoYyksVmUoc1tjXSl9ZnVuY3Rpb24gcHAocyl7OTwocz4+Pj0wKSYmKHV0W3MrMV0rPTEpfWZ1bmN0aW9uIG1wKCl7cmV0dXJuIFZlKFtdKX1mdW5jdGlvbiBmcChzKXtzPU1lKHM+Pj4wKTtmb3IodmFyIGM9QXJyYXkocy5sZW5ndGgpLGY9MDtmPHMubGVuZ3RoO2YrKyljW2ZdPXNbZl07cmV0dXJuIFZlKGMpfWZ1bmN0aW9uIGhwKHMpe3JldHVybiBWZShscihzPj4+MCkpfWZ1bmN0aW9uIGdwKCl7cmV0dXJuIFZlKHt9KX1mdW5jdGlvbiBicChzKXtmb3IodmFyIGM9TWUocz4+Pj0wKTtjLmxlbmd0aDspe3ZhciBmPWMucG9wKCk7Yy5wb3AoKShmKX1JbihzKX1mdW5jdGlvbiB5cChzLGMsZil7Yz4+Pj0wLGY+Pj49MCxzPU1lKHM+Pj4wKSxjPU1lKGMpLGY9TWUoZiksc1tjXT1mfWZ1bmN0aW9uIF9wKHMsYyl7cmV0dXJuIGM+Pj49MCxzPShzPWFyKHM+Pj4wLFwiX2VtdmFsX3Rha2VfdmFsdWVcIikpLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGMpLFZlKHMpfWZ1bmN0aW9uIHdwKHMsYyl7cz0tOTAwNzE5OTI1NDc0MDk5Mj5zfHw5MDA3MTk5MjU0NzQwOTkyPHM/TmFOOk51bWJlcihzKSxjPj4+PTAscz1uZXcgRGF0ZSgxZTMqcyksaSgpW2M+Pj4yPj4+MF09cy5nZXRVVENTZWNvbmRzKCksaSgpW2MrND4+PjI+Pj4wXT1zLmdldFVUQ01pbnV0ZXMoKSxpKClbYys4Pj4+Mj4+PjBdPXMuZ2V0VVRDSG91cnMoKSxpKClbYysxMj4+PjI+Pj4wXT1zLmdldFVUQ0RhdGUoKSxpKClbYysxNj4+PjI+Pj4wXT1zLmdldFVUQ01vbnRoKCksaSgpW2MrMjA+Pj4yPj4+MF09cy5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2MrMjQ+Pj4yPj4+MF09cy5nZXRVVENEYXkoKSxzPShzLmdldFRpbWUoKS1EYXRlLlVUQyhzLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGkoKVtjKzI4Pj4+Mj4+PjBdPXN9dmFyIER0PXM9PnMlND09MCYmKHMlMTAwIT0wfHxzJTQwMD09MCksJGk9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0seGk9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gdnAocyxjKXtzPS05MDA3MTk5MjU0NzQwOTkyPnN8fDkwMDcxOTkyNTQ3NDA5OTI8cz9OYU46TnVtYmVyKHMpLGM+Pj49MCxzPW5ldyBEYXRlKDFlMypzKSxpKClbYz4+PjI+Pj4wXT1zLmdldFNlY29uZHMoKSxpKClbYys0Pj4+Mj4+PjBdPXMuZ2V0TWludXRlcygpLGkoKVtjKzg+Pj4yPj4+MF09cy5nZXRIb3VycygpLGkoKVtjKzEyPj4+Mj4+PjBdPXMuZ2V0RGF0ZSgpLGkoKVtjKzE2Pj4+Mj4+PjBdPXMuZ2V0TW9udGgoKSxpKClbYysyMD4+PjI+Pj4wXT1zLmdldEZ1bGxZZWFyKCktMTkwMCxpKClbYysyND4+PjI+Pj4wXT1zLmdldERheSgpO3ZhciBmPShEdChzLmdldEZ1bGxZZWFyKCkpPyRpOnhpKVtzLmdldE1vbnRoKCldK3MuZ2V0RGF0ZSgpLTF8MDtpKClbYysyOD4+PjI+Pj4wXT1mLGkoKVtjKzM2Pj4+Mj4+PjBdPS02MCpzLmdldFRpbWV6b25lT2Zmc2V0KCksZj1uZXcgRGF0ZShzLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBiPW5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7cz0wfChmIT1iJiZzLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKGIsZikpLGkoKVtjKzMyPj4+Mj4+PjBdPXN9ZnVuY3Rpb24gJHAocyl7cz4+Pj0wO3ZhciBjPW5ldyBEYXRlKGkoKVtzKzIwPj4+Mj4+PjBdKzE5MDAsaSgpW3MrMTY+Pj4yPj4+MF0saSgpW3MrMTI+Pj4yPj4+MF0saSgpW3MrOD4+PjI+Pj4wXSxpKClbcys0Pj4+Mj4+PjBdLGkoKVtzPj4+Mj4+PjBdLDApLGY9aSgpW3MrMzI+Pj4yPj4+MF0sYj1jLmdldFRpbWV6b25lT2Zmc2V0KCksdz1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEk9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxPPU1hdGgubWluKEksdyk7cmV0dXJuIDA+Zj9pKClbcyszMj4+PjI+Pj4wXT0rKHchPUkmJk89PWIpOjA8ZiE9KE89PWIpJiYodz1NYXRoLm1heChJLHcpLGMuc2V0VGltZShjLmdldFRpbWUoKSs2ZTQqKCgwPGY/Tzp3KS1iKSkpLGkoKVtzKzI0Pj4+Mj4+PjBdPWMuZ2V0RGF5KCksZj0oRHQoYy5nZXRGdWxsWWVhcigpKT8kaTp4aSlbYy5nZXRNb250aCgpXStjLmdldERhdGUoKS0xfDAsaSgpW3MrMjg+Pj4yPj4+MF09ZixpKClbcz4+PjI+Pj4wXT1jLmdldFNlY29uZHMoKSxpKClbcys0Pj4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLGkoKVtzKzg+Pj4yPj4+MF09Yy5nZXRIb3VycygpLGkoKVtzKzEyPj4+Mj4+PjBdPWMuZ2V0RGF0ZSgpLGkoKVtzKzE2Pj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxpKClbcysyMD4+PjI+Pj4wXT1jLmdldFllYXIoKSxzPWMuZ2V0VGltZSgpLEJpZ0ludChpc05hTihzKT8tMTpzLzFlMyl9ZnVuY3Rpb24gU2kocyxjLGYsYix3LEksTyl7cmV0dXJuIGc/eGUoMTYsMSxzLGMsZixiLHcsSSxPKTotNTJ9ZnVuY3Rpb24gVGkocyxjLGYsYix3LEkpe2lmKGcpcmV0dXJuIHhlKDE3LDEscyxjLGYsYix3LEkpfWZ1bmN0aW9uIHhwKHMsYyxmLGIpe3M+Pj49MCxjPj4+PTAsZj4+Pj0wLGI+Pj49MDt2YXIgdz1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksST1uZXcgRGF0ZSh3LDAsMSksTz1uZXcgRGF0ZSh3LDYsMSk7dz1JLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEI9Ty5nZXRUaW1lem9uZU9mZnNldCgpLEw9TWF0aC5tYXgodyxCKTthKClbcz4+PjI+Pj4wXT02MCpMLGkoKVtjPj4+Mj4+PjBdPSsodyE9QiksST0ocz1IPT5ILnRvTG9jYWxlVGltZVN0cmluZyh2b2lkIDAse2hvdXIxMjohMSx0aW1lWm9uZU5hbWU6XCJzaG9ydFwifSkuc3BsaXQoXCIgXCIpWzFdKShJKSxPPXMoTyksQjx3PyhPdChJLGYsMTcpLE90KE8sYiwxNykpOihPdChJLGIsMTcpLE90KE8sZiwxNykpfXZhciBQbj1bXSxJaT0ocyxjKT0+e1BuLmxlbmd0aD0wO2Zvcih2YXIgZjtmPXIoKVtzKys+Pj4wXTspe3ZhciBiPWYhPTEwNTtjKz0oYiY9ZiE9MTEyKSYmYyU4PzQ6MCxQbi5wdXNoKGY9PTExMj9hKClbYz4+PjI+Pj4wXTpmPT0xMDY/cVtjPj4+M106Zj09MTA1P2koKVtjPj4+Mj4+PjBdOmwoKVtjPj4+Mz4+PjBdKSxjKz1iPzg6NH1yZXR1cm4gUG59O2Z1bmN0aW9uIFNwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9SWkoYz4+PjAsZj4+PjApLGJuW3NdKC4uLmMpfWZ1bmN0aW9uIFRwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9SWkoYz4+PjAsZj4+PjApLGJuW3NdKC4uLmMpfXZhciBJcD0oKT0+e30sQ3A9KCk9PkRhdGUubm93KCk7ZnVuY3Rpb24gQXAocyxjKXtyZXR1cm4gaihDZShzPj4+MCxjPj4+MCkpfXZhciBDaSxrcD0oKT0+e3Rocm93IHd0Kz0xLFwidW53aW5kXCJ9O2Z1bmN0aW9uIEVwKCl7cmV0dXJuIDQyOTQ5MDE3NjB9Q2k9KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCk7dmFyIFBwPSgpPT5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtmdW5jdGlvbiB6cCgpe3JldHVybiBjdChcIkNhbm5vdCB1c2UgZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb24gd2l0aG91dCAtc1VTRV9PRkZTRVRfQ09OVkVSVEVSXCIpLDB9ZnVuY3Rpb24gT3Aocyl7cz4+Pj0wO3ZhciBjPXIoKS5sZW5ndGg7aWYoczw9Y3x8NDI5NDkwMTc2MDxzKXJldHVybiExO2Zvcih2YXIgZj0xOzQ+PWY7Zio9Mil7dmFyIGI9YyooMSsuMi9mKTtiPU1hdGgubWluKGIscysxMDA2NjMyOTYpO3ZhciB3PU1hdGg7Yj1NYXRoLm1heChzLGIpO2U6e3c9KHcubWluLmNhbGwodyw0Mjk0OTAxNzYwLGIrKDY1NTM2LWIlNjU1MzYpJTY1NTM2KS1zZS5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e3NlLmdyb3codykseWUoKTt2YXIgST0xO2JyZWFrIGV9Y2F0Y2h7fUk9dm9pZCAwfWlmKEkpcmV0dXJuITB9cmV0dXJuITF9dmFyIGNyPSgpPT4oY3QoXCJDYW5ub3QgdXNlIGNvbnZlcnRGcmFtZVRvUEMgKG5lZWRlZCBieSBfX2J1aWx0aW5fcmV0dXJuX2FkZHJlc3MpIHdpdGhvdXQgLXNVU0VfT0ZGU0VUX0NPTlZFUlRFUlwiKSwwKSxCdD17fSxBaT1zPT57cy5mb3JFYWNoKGM9Pnt2YXIgZj1jcigpO2YmJihCdFtmXT1jKX0pfTtmdW5jdGlvbiBEcCgpe3ZhciBzPUVycm9yKCkuc3RhY2sudG9TdHJpbmcoKS5zcGxpdChgXG5gKTtyZXR1cm4gc1swXT09XCJFcnJvclwiJiZzLnNoaWZ0KCksQWkocyksQnQuUWI9Y3IoKSxCdC5mYz1zLEJ0LlFifWZ1bmN0aW9uIEJwKHMsYyxmKXtpZihzPj4+PTAsYz4+Pj0wLEJ0LlFiPT1zKXZhciBiPUJ0LmZjO2Vsc2UoYj1FcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoYFxuYCkpWzBdPT1cIkVycm9yXCImJmIuc2hpZnQoKSxBaShiKTtmb3IodmFyIHc9MztiW3ddJiZjcigpIT1zOykrK3c7Zm9yKHM9MDtzPGYmJmJbcyt3XTsrK3MpaSgpW2MrNCpzPj4+Mj4+PjBdPWNyKCk7cmV0dXJuIHN9dmFyIHpuLE9uPXt9LGtpPSgpPT57aWYoIXpuKXt2YXIgcyxjPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOkF8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHMgaW4gT24pT25bc109PT12b2lkIDA/ZGVsZXRlIGNbc106Y1tzXT1PbltzXTt2YXIgZj1bXTtmb3IocyBpbiBjKWYucHVzaChgJHtzfT0ke2Nbc119YCk7em49Zn1yZXR1cm4gem59O2Z1bmN0aW9uIEVpKHMsYyl7aWYoZylyZXR1cm4geGUoMTgsMSxzLGMpO3M+Pj49MCxjPj4+PTA7dmFyIGY9MDtyZXR1cm4ga2koKS5mb3JFYWNoKChiLHcpPT57dmFyIEk9YytmO2Zvcih3PWEoKVtzKzQqdz4+PjI+Pj4wXT1JLEk9MDtJPGIubGVuZ3RoOysrSSl0KClbdysrPj4+MF09Yi5jaGFyQ29kZUF0KEkpO3QoKVt3Pj4+MF09MCxmKz1iLmxlbmd0aCsxfSksMH1mdW5jdGlvbiBQaShzLGMpe2lmKGcpcmV0dXJuIHhlKDE5LDEscyxjKTtzPj4+PTAsYz4+Pj0wO3ZhciBmPWtpKCk7YSgpW3M+Pj4yPj4+MF09Zi5sZW5ndGg7dmFyIGI9MDtyZXR1cm4gZi5mb3JFYWNoKHc9PmIrPXcubGVuZ3RoKzEpLGEoKVtjPj4+Mj4+PjBdPWIsMH1mdW5jdGlvbiB6aShzKXtyZXR1cm4gZz94ZSgyMCwxLHMpOjUyfWZ1bmN0aW9uIE9pKHMsYyxmLGIpe3JldHVybiBnP3hlKDIxLDEscyxjLGYsYik6NTJ9ZnVuY3Rpb24gRGkocyxjLGYsYil7cmV0dXJuIGc/eGUoMjIsMSxzLGMsZixiKTo3MH12YXIgTXA9W251bGwsW10sW11dO2Z1bmN0aW9uIEJpKHMsYyxmLGIpe2lmKGcpcmV0dXJuIHhlKDIzLDEscyxjLGYsYik7Yz4+Pj0wLGY+Pj49MCxiPj4+PTA7Zm9yKHZhciB3PTAsST0wO0k8ZjtJKyspe3ZhciBPPWEoKVtjPj4+Mj4+PjBdLEI9YSgpW2MrND4+PjI+Pj4wXTtjKz04O2Zvcih2YXIgTD0wO0w8QjtMKyspe3ZhciBIPXIoKVtPK0w+Pj4wXSxYPU1wW3NdO0g9PT0wfHxIPT09MTA/KChzPT09MT9LOmopKFpvKFgsMCkpLFgubGVuZ3RoPTApOlgucHVzaChIKX13Kz1CfXJldHVybiBhKClbYj4+PjI+Pj4wXT13LDB9dmFyIE1pPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sUmk9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxScD0ocyxjKT0+e3QoKS5zZXQocyxjPj4+MCl9O2Z1bmN0aW9uIFVpKHMsYyxmLGIpe2Z1bmN0aW9uIHcoeixkZSxUZSl7Zm9yKHo9dHlwZW9mIHo9PVwibnVtYmVyXCI/ei50b1N0cmluZygpOnp8fFwiXCI7ei5sZW5ndGg8ZGU7KXo9VGVbMF0rejtyZXR1cm4gen1mdW5jdGlvbiBJKHosZGUpe3JldHVybiB3KHosZGUsXCIwXCIpfWZ1bmN0aW9uIE8oeixkZSl7ZnVuY3Rpb24gVGUoWGkpe3JldHVybiAwPlhpPy0xOjA8WGk/MTowfXZhciAkdDtyZXR1cm4oJHQ9VGUoei5nZXRGdWxsWWVhcigpLWRlLmdldEZ1bGxZZWFyKCkpKT09PTAmJigkdD1UZSh6LmdldE1vbnRoKCktZGUuZ2V0TW9udGgoKSkpPT09MCYmKCR0PVRlKHouZ2V0RGF0ZSgpLWRlLmdldERhdGUoKSkpLCR0fWZ1bmN0aW9uIEIoeil7c3dpdGNoKHouZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gejtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gTCh6KXt2YXIgZGU9ei5DYjtmb3Ioej1uZXcgRGF0ZShuZXcgRGF0ZSh6LkRiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZGU7KXt2YXIgVGU9ei5nZXRNb250aCgpLCR0PShEdCh6LmdldEZ1bGxZZWFyKCkpP01pOlJpKVtUZV07aWYoIShkZT4kdC16LmdldERhdGUoKSkpe3ouc2V0RGF0ZSh6LmdldERhdGUoKStkZSk7YnJlYWt9ZGUtPSR0LXouZ2V0RGF0ZSgpKzEsei5zZXREYXRlKDEpLDExPlRlP3ouc2V0TW9udGgoVGUrMSk6KHouc2V0TW9udGgoMCksei5zZXRGdWxsWWVhcih6LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBUZT1uZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGRlPUIobmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsNCkpLFRlPUIoVGUpLDA+PU8oZGUseik/MD49TyhUZSx6KT96LmdldEZ1bGxZZWFyKCkrMTp6LmdldEZ1bGxZZWFyKCk6ei5nZXRGdWxsWWVhcigpLTF9cz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wO3ZhciBIPWEoKVtiKzQwPj4+Mj4+PjBdO2Zvcih2YXIgWCBpbiBiPXtsYzppKClbYj4+PjI+Pj4wXSxrYzppKClbYis0Pj4+Mj4+PjBdLEliOmkoKVtiKzg+Pj4yPj4+MF0sTWI6aSgpW2IrMTI+Pj4yPj4+MF0sSmI6aSgpW2IrMTY+Pj4yPj4+MF0sRGI6aSgpW2IrMjA+Pj4yPj4+MF0sdmI6aSgpW2IrMjQ+Pj4yPj4+MF0sQ2I6aSgpW2IrMjg+Pj4yPj4+MF0sc2M6aSgpW2IrMzI+Pj4yPj4+MF0samM6aSgpW2IrMzY+Pj4yPj4+MF0sbWM6SD9DZShIKTpcIlwifSxmPUNlKGYpLEg9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEhbWF0pO3ZhciBjZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGdlPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoWCBpbiBIPXtcIiVhXCI6ej0+Y2Vbei52Yl0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOno9PmNlW3oudmJdLFwiJWJcIjp6PT5nZVt6LkpiXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6ej0+Z2Vbei5KYl0sXCIlQ1wiOno9PkkoKHouRGIrMTkwMCkvMTAwfDAsMiksXCIlZFwiOno9Pkkoei5NYiwyKSxcIiVlXCI6ej0+dyh6Lk1iLDIsXCIgXCIpLFwiJWdcIjp6PT5MKHopLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpMLFwiJUhcIjp6PT5JKHouSWIsMiksXCIlSVwiOno9Pigoej16LkliKT09MD96PTEyOjEyPHomJih6LT0xMiksSSh6LDIpKSxcIiVqXCI6ej0+e2Zvcih2YXIgZGU9MCxUZT0wO1RlPD16LkpiLTE7ZGUrPShEdCh6LkRiKzE5MDApP01pOlJpKVtUZSsrXSk7cmV0dXJuIEkoei5NYitkZSwzKX0sXCIlbVwiOno9Pkkoei5KYisxLDIpLFwiJU1cIjp6PT5JKHoua2MsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjp6PT4wPD16LkliJiYxMj56LkliP1wiQU1cIjpcIlBNXCIsXCIlU1wiOno9Pkkoei5sYywyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6ej0+ei52Ynx8NyxcIiVVXCI6ej0+SShNYXRoLmZsb29yKCh6LkNiKzctei52YikvNyksMiksXCIlVlwiOno9Pnt2YXIgZGU9TWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpO2lmKDI+PSh6LnZiKzM3MS16LkNiLTIpJTcmJmRlKyssZGUpZGU9PTUzJiYoKFRlPSh6LnZiKzM3MS16LkNiKSU3KT09NHx8VGU9PTMmJkR0KHouRGIpfHwoZGU9MSkpO2Vsc2V7ZGU9NTI7dmFyIFRlPSh6LnZiKzctei5DYi0xKSU3OyhUZT09NHx8VGU9PTUmJkR0KHouRGIlNDAwLTEpKSYmZGUrK31yZXR1cm4gSShkZSwyKX0sXCIld1wiOno9PnoudmIsXCIlV1wiOno9PkkoTWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpLDIpLFwiJXlcIjp6PT4oei5EYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6ej0+ei5EYisxOTAwLFwiJXpcIjp6PT57dmFyIGRlPTA8PSh6PXouamMpO3JldHVybiB6PU1hdGguYWJzKHopLzYwLChkZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyh6LzYwKjEwMCt6JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ej0+ei5tYyxcIiUlXCI6KCk9PlwiJVwifSxmPWYucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxIKWYuaW5jbHVkZXMoWCkmJihmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEhbWF0oYikpKTtyZXR1cm4gWD1mdW5jdGlvbih6KXt2YXIgZGU9QXJyYXkoJG4oeikrMSk7cmV0dXJuIEpvKHosZGUsMCxkZS5sZW5ndGgpLGRlfShmPWYucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxYLmxlbmd0aD5jPzA6KFJwKFgscyksWC5sZW5ndGgtMSl9ZnVuY3Rpb24gVXAocyxjLGYsYil7cmV0dXJuIFVpKHM+Pj4wLGM+Pj4wLGY+Pj4wLGI+Pj4wKX1nfHxmdW5jdGlvbigpe2Zvcih2YXIgcz11Lm51bVRocmVhZHMtMTtzLS07KXFvKCk7WWUudW5zaGlmdCgoKT0+e0d0KyssZnVuY3Rpb24oYyl7Zz9jKCk6UHJvbWlzZS5hbGwocHQubWFwKEZvKSkudGhlbihjKX0oKCk9PkRvKCkpfSl9KCk7Zm9yKHZhciBOaT1BcnJheSgyNTYpLHByPTA7MjU2PnByOysrcHIpTmlbcHJdPVN0cmluZy5mcm9tQ2hhckNvZGUocHIpO2NpPU5pLG10PXUuQmluZGluZ0Vycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3Iocyl7c3VwZXIocyksdGhpcy5uYW1lPVwiQmluZGluZ0Vycm9yXCJ9fSx1LkludGVybmFsRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihzKXtzdXBlcihzKSx0aGlzLm5hbWU9XCJJbnRlcm5hbEVycm9yXCJ9fSx1dC5wdXNoKDAsMSx2b2lkIDAsMSxudWxsLDEsITAsMSwhMSwxKSx1LmNvdW50X2VtdmFsX2hhbmRsZXM9KCk9PnV0Lmxlbmd0aC8yLTUtVG4ubGVuZ3RoO3ZhciBOcD1bd24sV28sS28sUW8sWG8sZWksdGkscmksbmksb2ksaWksYWksc2ksdWksZGksbGksU2ksVGksRWksUGksemksT2ksRGksQmldLFo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBzKGYsYil7cmV0dXJuIFo9Zi5leHBvcnRzLFo9ZnVuY3Rpb24oKXt2YXIgdz1aLEk9e307Zm9yKGxldFtPLEJdb2YgT2JqZWN0LmVudHJpZXModykpSVtPXT10eXBlb2YgQj09XCJmdW5jdGlvblwiPyguLi5MKT0+e3VyLnB1c2goTyk7dHJ5e3JldHVybiBCKC4uLkwpfWZpbmFsbHl7d2V8fCh1ci5wb3AoKSxYZSYmaHQ9PT0xJiZ1ci5sZW5ndGg9PT0wJiYoaHQ9MCx3dCs9MSxzcihqaSksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLnRjKCkpKX19OkI7cmV0dXJuIEl9KCksWj1mdW5jdGlvbigpe3ZhciB3PVosST1CPT5MPT5CKEwpPj4+MCxPPUI9PigpPT5CKCk+Pj4wO3JldHVybih3PU9iamVjdC5hc3NpZ24oe30sdykpLkRhPUkody5EYSksdy5nYj1PKHcuZ2IpLHcuaWI9SSh3LmliKSx3LmVtc2NyaXB0ZW5fbWFpbl9ydW50aW1lX3RocmVhZF9pZD1PKHcuZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkKSx3LnRiPUkody50Yiksdy51Yj1PKHcudWIpLHd9KCksTG8ucHVzaChaLmpiKSxMdC51bnNoaWZ0KFouQ2EpLFk9YixEbygpLFp9dmFyIGM9Tm8oKTtpZihHdCsrLHUuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gdS5pbnN0YW50aWF0ZVdhc20oYyxzKX1jYXRjaChmKXtqKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2Z9YCksbShmKX1yZXR1cm4gZ258fD11LmxvY2F0ZUZpbGU/Qm8oXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiKT9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6dS5sb2NhdGVGaWxlP3UubG9jYXRlRmlsZShcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsUCk6UCtcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmLGZ1bmN0aW9uKGYsYil7dmFyIHc9Z247cmV0dXJuIER8fHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxCbyh3KXx8TW8odyl8fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP1VvKHcsZixiKTpmZXRjaCh3LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKEk9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEksZikudGhlbihiLGZ1bmN0aW9uKE8pe3JldHVybiBqKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHtPfWApLGooXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxVbyh3LGYsYil9KSl9KGMsZnVuY3Rpb24oZil7cyhmLmluc3RhbmNlLGYubW9kdWxlKX0pLmNhdGNoKG0pLHt9fSgpLFZpPXM9PihWaT1aLkRhKShzKSxXaT0oKT0+KFdpPVouRWEpKCk7dS5fT3J0SW5pdD0ocyxjKT0+KHUuX09ydEluaXQ9Wi5GYSkocyxjKSx1Ll9PcnRHZXRMYXN0RXJyb3I9KHMsYyk9Pih1Ll9PcnRHZXRMYXN0RXJyb3I9Wi5HYSkocyxjKSx1Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0ocyxjLGYsYix3LEksTyxCLEwsSCk9Pih1Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1aLkhhKShzLGMsZixiLHcsSSxPLEIsTCxIKSx1Ll9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0ocyxjKT0+KHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPVouSWEpKHMsYyksdS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShzLGMsZik9Pih1Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9Wi5KYSkocyxjLGYpLHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0ocyxjLGYpPT4odS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PVouS2EpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9cz0+KHUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1aLkxhKShzKSx1Ll9PcnRDcmVhdGVTZXNzaW9uPShzLGMsZik9Pih1Ll9PcnRDcmVhdGVTZXNzaW9uPVouTWEpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbj1zPT4odS5fT3J0UmVsZWFzZVNlc3Npb249Wi5OYSkocyksdS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0ocyxjLGYpPT4odS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1aLk9hKShzLGMsZiksdS5fT3J0R2V0SW5wdXROYW1lPShzLGMpPT4odS5fT3J0R2V0SW5wdXROYW1lPVouUGEpKHMsYyksdS5fT3J0R2V0T3V0cHV0TmFtZT0ocyxjKT0+KHUuX09ydEdldE91dHB1dE5hbWU9Wi5RYSkocyxjKSx1Ll9PcnRGcmVlPXM9Pih1Ll9PcnRGcmVlPVouUmEpKHMpLHUuX09ydENyZWF0ZVRlbnNvcj0ocyxjLGYsYix3LEkpPT4odS5fT3J0Q3JlYXRlVGVuc29yPVouU2EpKHMsYyxmLGIsdyxJKSx1Ll9PcnRHZXRUZW5zb3JEYXRhPShzLGMsZixiLHcpPT4odS5fT3J0R2V0VGVuc29yRGF0YT1aLlRhKShzLGMsZixiLHcpLHUuX09ydFJlbGVhc2VUZW5zb3I9cz0+KHUuX09ydFJlbGVhc2VUZW5zb3I9Wi5VYSkocyksdS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0ocyxjLGYsYik9Pih1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPVouVmEpKHMsYyxmLGIpLHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShzLGMsZik9Pih1Ll9PcnRBZGRSdW5Db25maWdFbnRyeT1aLldhKShzLGMsZiksdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9cz0+KHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPVouWGEpKHMpLHUuX09ydENyZWF0ZUJpbmRpbmc9cz0+KHUuX09ydENyZWF0ZUJpbmRpbmc9Wi5ZYSkocyksdS5fT3J0QmluZElucHV0PShzLGMsZik9Pih1Ll9PcnRCaW5kSW5wdXQ9Wi5aYSkocyxjLGYpLHUuX09ydEJpbmRPdXRwdXQ9KHMsYyxmLGIpPT4odS5fT3J0QmluZE91dHB1dD1aLl9hKShzLGMsZixiKSx1Ll9PcnRDbGVhckJvdW5kT3V0cHV0cz1zPT4odS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9Wi4kYSkocyksdS5fT3J0UmVsZWFzZUJpbmRpbmc9cz0+KHUuX09ydFJlbGVhc2VCaW5kaW5nPVouYWIpKHMpLHUuX09ydFJ1bldpdGhCaW5kaW5nPShzLGMsZixiLHcpPT4odS5fT3J0UnVuV2l0aEJpbmRpbmc9Wi5iYikocyxjLGYsYix3KSx1Ll9PcnRSdW49KHMsYyxmLGIsdyxJLE8sQik9Pih1Ll9PcnRSdW49Wi5jYikocyxjLGYsYix3LEksTyxCKSx1Ll9PcnRFbmRQcm9maWxpbmc9cz0+KHUuX09ydEVuZFByb2ZpbGluZz1aLmRiKShzKSx1Ll9Kc2VwT3V0cHV0PShzLGMsZik9Pih1Ll9Kc2VwT3V0cHV0PVouZWIpKHMsYyxmKSx1Ll9Kc2VwR2V0Tm9kZU5hbWU9cz0+KHUuX0pzZXBHZXROb2RlTmFtZT1aLmZiKShzKTt2YXIgbXIsTXQ9KCk9PihNdD1aLmdiKSgpLEplPXUuX2ZyZWU9cz0+KEplPXUuX2ZyZWU9Wi5oYikocyksZnI9dS5fbWFsbG9jPXM9Pihmcj11Ll9tYWxsb2M9Wi5pYikocyksRG49KHMsYyxmLGIsdyxJKT0+KERuPVoubGIpKHMsYyxmLGIsdyxJKSxMaT0oKT0+KExpPVoubWIpKCksR2k9KHMsYyxmLGIsdyk9PihHaT1aLm5iKShzLGMsZixiLHcpLEJuPXM9PihCbj1aLm9iKShzKSxocj1zPT4oaHI9Wi5wYikocyksSGk9KCk9PihIaT1aLnFiKSgpLEZpPShzLGMpPT4oRmk9Wi5yYikocyxjKSxncj1zPT4oZ3I9Wi5zYikocyksTW49cz0+KE1uPVoudGIpKHMpLFJuPSgpPT4oUm49Wi51YikoKSxxaT11LmR5bkNhbGxfaWk9KHMsYyk9PihxaT11LmR5bkNhbGxfaWk9Wi53YikocyxjKSxLaT1zPT4oS2k9Wi54Yikocyksamk9KCk9PihqaT1aLnliKSgpLFlpPXM9PihZaT1aLnpiKShzKSxaaT0oKT0+KFppPVouQWIpKCk7ZnVuY3Rpb24gUWkoKXswPEd0fHwoZz8ocCh1KSxnfHxvcihMdCksc3RhcnRXb3JrZXIodSkpOihvcihZZSksMDxHdHx8bXJ8fChtcj0hMCx1LmNhbGxlZFJ1bj0hMCx3ZXx8KGd8fG9yKEx0KSxwKHUpLGd8fG9yKGZuKSkpKSl9cmV0dXJuIHUuX19fc3RhcnRfZW1fanM9OTI5MzAxLHUuX19fc3RvcF9lbV9qcz05Mjk1NDcsdS5zdGFja1NhdmU9KCk9PlJuKCksdS5zdGFja1Jlc3RvcmU9cz0+Z3IocyksdS5zdGFja0FsbG9jPXM9Pk1uKHMpLHUuc2V0VmFsdWU9ZnVuY3Rpb24ocyxjLGY9XCJpOFwiKXtzd2l0Y2goZi5lbmRzV2l0aChcIipcIikmJihmPVwiKlwiKSxmKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6dCgpW3M+Pj4wXT1jO2JyZWFrO2Nhc2VcImkxNlwiOm4oKVtzPj4+MT4+PjBdPWM7YnJlYWs7Y2FzZVwiaTMyXCI6aSgpW3M+Pj4yPj4+MF09YzticmVhaztjYXNlXCJpNjRcIjpxW3M+Pj4zXT1CaWdJbnQoYyk7YnJlYWs7Y2FzZVwiZmxvYXRcIjpkKClbcz4+PjI+Pj4wXT1jO2JyZWFrO2Nhc2VcImRvdWJsZVwiOmwoKVtzPj4+Mz4+PjBdPWM7YnJlYWs7Y2FzZVwiKlwiOmEoKVtzPj4+Mj4+PjBdPWM7YnJlYWs7ZGVmYXVsdDpjdChgaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJHtmfWApfX0sdS5nZXRWYWx1ZT1mdW5jdGlvbihzLGM9XCJpOFwiKXtzd2l0Y2goYy5lbmRzV2l0aChcIipcIikmJihjPVwiKlwiKSxjKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6cmV0dXJuIHQoKVtzPj4+MF07Y2FzZVwiaTE2XCI6cmV0dXJuIG4oKVtzPj4+MT4+PjBdO2Nhc2VcImkzMlwiOnJldHVybiBpKClbcz4+PjI+Pj4wXTtjYXNlXCJpNjRcIjpyZXR1cm4gcVtzPj4+M107Y2FzZVwiZmxvYXRcIjpyZXR1cm4gZCgpW3M+Pj4yPj4+MF07Y2FzZVwiZG91YmxlXCI6cmV0dXJuIGwoKVtzPj4+Mz4+PjBdO2Nhc2VcIipcIjpyZXR1cm4gYSgpW3M+Pj4yPj4+MF07ZGVmYXVsdDpjdChgaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJHtjfWApfX0sdS5VVEY4VG9TdHJpbmc9Q2UsdS5zdHJpbmdUb1VURjg9T3QsdS5sZW5ndGhCeXRlc1VURjg9JG4sSHQ9ZnVuY3Rpb24gcygpe21yfHxRaSgpLG1yfHwoSHQ9cyl9LFFpKCksdS5QVFJfU0laRT00LGh9KSxLcD16YTtnbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1cImVtLXB0aHJlYWRcIiYmemEoKX0pO3ZhciBSYSxqcCxOZSxVYSxqbixZcCxacCxOYSxRcCxCYSxWYSxNYSxXYSx4cj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHIoKTtSYT0hMXx8dHlwZW9mIGxvY2F0aW9uPlwidVwiP3ZvaWQgMDpsb2NhdGlvbi5vcmlnaW4sanA9KCk9PntpZighITEpcmV0dXJuIGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwobmV3IFVSTChcIm9ydC53ZWJncHUuYnVuZGxlLm1pbi5tanNcIixpbXBvcnQubWV0YS51cmwpLmhyZWYsUmEpLmhyZWY6aW1wb3J0Lm1ldGEudXJsfSxOZT1qcCgpLFVhPSgpPT57aWYoTmUmJiFOZS5zdGFydHNXaXRoKFwiYmxvYjpcIikpcmV0dXJuIE5lLnN1YnN0cmluZygwLE5lLmxhc3RJbmRleE9mKFwiL1wiKSsxKX0sam49KGUsdCk9Pnt0cnl7bGV0IHI9dD8/TmU7cmV0dXJuKHI/bmV3IFVSTChlLHIpOm5ldyBVUkwoZSkpLm9yaWdpbj09PVJhfWNhdGNoe3JldHVybiExfX0sWXA9KGUsdCk9PntsZXQgcj10Pz9OZTt0cnl7cmV0dXJuKHI/bmV3IFVSTChlLHIpOm5ldyBVUkwoZSkpLmhyZWZ9Y2F0Y2h7cmV0dXJufX0sWnA9KGUsdCk9PmAke3Q/P1wiLi9cIn0ke2V9YCxOYT1hc3luYyBlPT57bGV0IHI9YXdhaXQoYXdhaXQgZmV0Y2goZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkpLmJsb2IoKTtyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChyKX0sUXA9YXN5bmMgZT0+KGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6dHJ1ZSovZSkpLmRlZmF1bHQsQmE9KFBhKCksYnIoRWEpKS5kZWZhdWx0LFZhPWFzeW5jKCk9PntpZighTmUpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcHJveHkgd29ya2VyOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC5cIik7aWYoam4oTmUpKXJldHVyblt2b2lkIDAsQmEoKV07bGV0IGU9YXdhaXQgTmEoTmUpO3JldHVybltlLEJhKGUpXX0sTWE9KERhKCksYnIoT2EpKS5kZWZhdWx0LFdhPWFzeW5jKGUsdCxyKT0+e2lmKCFlJiYhdCYmTWEmJk5lJiZqbihOZSkpcmV0dXJuW3ZvaWQgMCxNYV07e2xldCBuPVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qc1wiLG89ZT8/WXAobix0KSxpPSEhMSYmciYmbyYmIWpuKG8sdCksYT1pP2F3YWl0IE5hKG8pOm8/P1pwKG4sdCk7cmV0dXJuW2k/YTp2b2lkIDAsYXdhaXQgUXAoYSldfX19KTt2YXIgWW4sWm4senIsTGEsWHAsSnAsU3IsSWUsZ3Q9VSgoKT0+e1widXNlIHN0cmljdFwiO3hyKCk7Wm49ITEsenI9ITEsTGE9ITEsWHA9KCk9PntpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuITE7dHJ5e3JldHVybiB0eXBlb2YgTWVzc2FnZUNoYW5uZWw8XCJ1XCImJm5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LEpwPSgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LFNyPWFzeW5jIGU9PntpZihabilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoenIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoTGEpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7enI9ITA7bGV0IHQ9ZS5pbml0VGltZW91dCxyPWUubnVtVGhyZWFkcztpZighSnAoKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXCIpO2xldCBuPVhwKCk7cj4xJiYhbiYmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkJiZjb25zb2xlLndhcm4oXCJlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byBcIityK1wiLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLlwiKSxjb25zb2xlLndhcm4oXCJXZWJBc3NlbWJseSBtdWx0aS10aHJlYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuXCIpLGUubnVtVGhyZWFkcz1yPTEpO2xldCBvPWUud2FzbVBhdGhzLGk9dHlwZW9mIG89PVwic3RyaW5nXCI/bzp2b2lkIDAsYT1vPy5tanMsZD1hPy5ocmVmPz9hLGw9bz8ud2FzbSxwPWw/LmhyZWY/P2wsbT1lLndhc21CaW5hcnksW3UsaF09YXdhaXQgV2EoZCxpLHI+MSksXz0hMSx5PVtdO2lmKHQ+MCYmeS5wdXNoKG5ldyBQcm9taXNlKGc9PntzZXRUaW1lb3V0KCgpPT57Xz0hMCxnKCl9LHQpfSkpLHkucHVzaChuZXcgUHJvbWlzZSgoZyx4KT0+e2xldCAkPXtudW1UaHJlYWRzOnJ9O2lmKG0pJC53YXNtQmluYXJ5PW07ZWxzZSBpZihwfHxpKSQubG9jYXRlRmlsZT12PT5wPz9pK3Y7ZWxzZSBpZihkJiZkLmluZGV4T2YoXCJibG9iOlwiKSE9PTApJC5sb2NhdGVGaWxlPXY9Pm5ldyBVUkwodixkKS5ocmVmO2Vsc2UgaWYodSl7bGV0IHY9VWEoKTt2JiYoJC5sb2NhdGVGaWxlPVM9PnYrUyl9aCgkKS50aGVuKHY9Pnt6cj0hMSxabj0hMCxZbj12LGcoKSx1JiZVUkwucmV2b2tlT2JqZWN0VVJMKHUpfSx2PT57enI9ITEsTGE9ITAseCh2KX0pfSkpLGF3YWl0IFByb21pc2UucmFjZSh5KSxfKXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sSWU9KCk9PntpZihabiYmWW4pcmV0dXJuIFluO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfX0pO3ZhciBrZSxqdCxwZSxPcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z3QoKTtrZT0oZSx0KT0+e2xldCByPUllKCksbj1yLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG89ci5fbWFsbG9jKG4pO3JldHVybiByLnN0cmluZ1RvVVRGOChlLG8sbiksdC5wdXNoKG8pLG99LGp0PShlLHQscixuKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYoci5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW28saV0pPT57bGV0IGE9dD90K286bztpZih0eXBlb2YgaT09XCJvYmplY3RcIilqdChpLGErXCIuXCIscixuKTtlbHNlIGlmKHR5cGVvZiBpPT1cInN0cmluZ1wifHx0eXBlb2YgaT09XCJudW1iZXJcIiluKGEsaS50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiBpPT1cImJvb2xlYW5cIiluKGEsaT9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgaX1gKX0pfSxwZT1lPT57bGV0IHQ9SWUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBuPXQuUFRSX1NJWkUsbz10LnN0YWNrQWxsb2MoMipuKTt0Ll9PcnRHZXRMYXN0RXJyb3IobyxvK24pO2xldCBpPU51bWJlcih0LmdldFZhbHVlKG8sbj09PTQ/XCJpMzJcIjpcImk2NFwiKSksYT10LmdldFZhbHVlKG8rbixcIipcIiksZD1hP3QuVVRGOFRvU3RyaW5nKGEpOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7aX0sIEVSUk9SX01FU1NBR0U6ICR7ZH1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX19KTt2YXIgR2EsSGE9VSgoKT0+e1widXNlIHN0cmljdFwiO2d0KCk7T3IoKTtHYT1lPT57bGV0IHQ9SWUoKSxyPTAsbj1bXSxvPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKW8ubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKGU/LmxvZ1ZlcmJvc2l0eUxldmVsPT09dm9pZCAwKW8ubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKHR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7ZT8udGVybWluYXRlPT09dm9pZCAwJiYoby50ZXJtaW5hdGU9ITEpO2xldCBpPTA7cmV0dXJuIGU/LnRhZyE9PXZvaWQgMCYmKGk9a2UoZS50YWcsbikpLHI9dC5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhvLmxvZ1NldmVyaXR5TGV2ZWwsby5sb2dWZXJib3NpdHlMZXZlbCwhIW8udGVybWluYXRlLGkpLHI9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIiksZT8uZXh0cmEhPT12b2lkIDAmJmp0KGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoYSxkKT0+e2xldCBsPWtlKGEsbikscD1rZShkLG4pO3QuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHIsbCxwKSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke2F9IC0gJHtkfS5gKX0pLFtyLG5dfWNhdGNoKGkpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhyKSxuLmZvckVhY2goYT0+dC5fZnJlZShhKSksaX19fSk7dmFyIGVtLHRtLHJtLG5tLEZhLHFhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtndCgpO09yKCk7ZW09ZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0sdG09ZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19LHJtPWU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShyPT4odHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyLm5hbWUpPT09XCJ3ZWJncHVcIikmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSxubT0oZSx0LHIpPT57Zm9yKGxldCBuIG9mIHQpe2xldCBvPXR5cGVvZiBuPT1cInN0cmluZ1wiP246bi5uYW1lO3N3aXRjaChvKXtjYXNlXCJ3ZWJublwiOmlmKG89XCJXRUJOTlwiLHR5cGVvZiBuIT1cInN0cmluZ1wiKXtsZXQgZD1uPy5kZXZpY2VUeXBlO2lmKGQpe2xldCBsPWtlKFwiZGV2aWNlVHlwZVwiLHIpLHA9a2UoZCxyKTtJZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxsLHApIT09MCYmcGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZGV2aWNlVHlwZScgLSAke2R9LmApfX1icmVhaztjYXNlXCJ3ZWJncHVcIjppZihvPVwiSlNcIix0eXBlb2YgbiE9XCJzdHJpbmdcIil7bGV0IGE9bjtpZihhPy5wcmVmZXJyZWRMYXlvdXQpe2lmKGEucHJlZmVycmVkTGF5b3V0IT09XCJOQ0hXXCImJmEucHJlZmVycmVkTGF5b3V0IT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHthLnByZWZlcnJlZExheW91dH1gKTtsZXQgZD1rZShcInByZWZlcnJlZExheW91dFwiLHIpLGw9a2UoYS5wcmVmZXJyZWRMYXlvdXQscik7SWUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsZCxsKSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke2EucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtvfWApfWxldCBpPWtlKG8scik7SWUoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxpKSE9PTAmJnBlKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299LmApfX0sRmE9ZT0+e2xldCB0PUllKCkscj0wLG49W10sbz1lfHx7fTtybShvKTt0cnl7bGV0IGk9ZW0oby5ncmFwaE9wdGltaXphdGlvbkxldmVsPz9cImFsbFwiKSxhPXRtKG8uZXhlY3V0aW9uTW9kZT8/XCJzZXF1ZW50aWFsXCIpLGQ9dHlwZW9mIG8ubG9nSWQ9PVwic3RyaW5nXCI/a2Uoby5sb2dJZCxuKTowLGw9by5sb2dTZXZlcml0eUxldmVsPz8yO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGwpfHxsPDB8fGw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2x9YCk7bGV0IHA9by5sb2dWZXJib3NpdHlMZXZlbD8/MDtpZighTnVtYmVyLmlzSW50ZWdlcihwKXx8cDwwfHxwPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtwfWApO2xldCBtPXR5cGVvZiBvLm9wdGltaXplZE1vZGVsRmlsZVBhdGg9PVwic3RyaW5nXCI/a2Uoby5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLG4pOjA7aWYocj10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhpLCEhby5lbmFibGVDcHVNZW1BcmVuYSwhIW8uZW5hYmxlTWVtUGF0dGVybixhLCEhby5lbmFibGVQcm9maWxpbmcsMCxkLGwscCxtKSxyPT09MCYmcGUoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxvLmV4ZWN1dGlvblByb3ZpZGVycyYmbm0ocixvLmV4ZWN1dGlvblByb3ZpZGVycyxuKSxvLmVuYWJsZUdyYXBoQ2FwdHVyZSE9PXZvaWQgMCl7aWYodHlwZW9mIG8uZW5hYmxlR3JhcGhDYXB0dXJlIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYGVuYWJsZUdyYXBoQ2FwdHVyZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZTogJHtvLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtsZXQgdT1rZShcImVuYWJsZUdyYXBoQ2FwdHVyZVwiLG4pLGg9a2Uoby5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSxuKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkocix1LGgpIT09MCYmcGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZW5hYmxlR3JhcGhDYXB0dXJlJyAtICR7by5lbmFibGVHcmFwaENhcHR1cmV9LmApfWlmKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W3UsaF1vZiBPYmplY3QuZW50cmllcyhvLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgdSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHt1fWApO2lmKHR5cGVvZiBoIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihoKXx8aDwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke2h9YCk7bGV0IF89a2UodSxuKTt0Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUocixfLGgpIT09MCYmcGUoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke3V9IC0gJHtofS5gKX1yZXR1cm4gby5leHRyYSE9PXZvaWQgMCYmanQoby5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCh1LGgpPT57bGV0IF89a2UodSxuKSx5PWtlKGgsbik7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHIsXyx5KSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHt1fSAtICR7aH0uYCl9KSxbcixuXX1jYXRjaChpKXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHIpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksbi5mb3JFYWNoKGE9PnQuX2ZyZWUoYSkpLGl9fX0pO3ZhciBZdCxidCxDdCxEcixadCxCcixNcixRbix0ZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WXQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2Nhc2VcImludDRcIjpyZXR1cm4gMjI7Y2FzZVwidWludDRcIjpyZXR1cm4gMjE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sYnQ9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2Nhc2UgMjI6cmV0dXJuXCJpbnQ0XCI7Y2FzZSAyMTpyZXR1cm5cInVpbnQ0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sQ3Q9KGUsdCk9PntsZXQgcj1bLTEsNCwxLDEsMiwyLDQsOCwtMSwxLDIsOCw0LDgsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLjUsLjVdW2VdLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LnJlZHVjZSgobyxpKT0+byppLDEpO3JldHVybiByPjA/TWF0aC5jZWlsKG4qcik6dm9pZCAwfSxEcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxadD1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sQnI9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixNcj1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ2NFwifHxlPT09XCJpbnQ4XCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLFFuPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiA1O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBRdCxYbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHIoKTtRdD1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYoITEpdHJ5e2xldHtyZWFkRmlsZTp0fT1ObihcIm5vZGU6ZnMvcHJvbWlzZXNcIik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQoZSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldHtjcmVhdGVSZWFkU3RyZWFtOnJ9PU5uKFwibm9kZTpmc1wiKSxuPXIoZSksbz1bXTtmb3IgYXdhaXQobGV0IGkgb2YgbilvLnB1c2goaSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQobykpfXRocm93IHR9ZWxzZXtsZXQgdD1hd2FpdCBmZXRjaChlKTtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfWApO2xldCByPXQuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSxuPXI/cGFyc2VJbnQociwxMCk6MDtpZihuPDEwNzM3NDE4MjQpcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQuYXJyYXlCdWZmZXIoKSk7e2lmKCF0LmJvZHkpdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7bGV0IG89dC5ib2R5LmdldFJlYWRlcigpLGk7dHJ5e2k9bmV3IEFycmF5QnVmZmVyKG4pfWNhdGNoKGQpe2lmKGQgaW5zdGFuY2VvZiBSYW5nZUVycm9yKXtsZXQgbD1NYXRoLmNlaWwobi82NTUzNik7aT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmwsbWF4aW11bTpsfSkuYnVmZmVyfWVsc2UgdGhyb3cgZH1sZXQgYT0wO2Zvcig7Oyl7bGV0e2RvbmU6ZCx2YWx1ZTpsfT1hd2FpdCBvLnJlYWQoKTtpZihkKWJyZWFrO2xldCBwPWwuYnl0ZUxlbmd0aDtuZXcgVWludDhBcnJheShpLGEscCkuc2V0KGwpLGErPXB9cmV0dXJuIG5ldyBVaW50OEFycmF5KGksMCxuKX19ZWxzZSByZXR1cm4gZSBpbnN0YW5jZW9mIEJsb2I/bmV3IFVpbnQ4QXJyYXkoYXdhaXQgZS5hcnJheUJ1ZmZlcigpKTplIGluc3RhbmNlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfX0pO3ZhciBvbSxpbSxLYSxqYSxScixhbSx1ZSxldD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvbT1bXCJWXCIsXCJJXCIsXCJXXCIsXCJFXCIsXCJGXCJdLGltPShlLHQpPT57Y29uc29sZS5sb2coYFske29tW2VdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHt0fWApfSxScj0oZSx0KT0+e0thPWUsamE9dH0sYW09KGUsdCk9PntsZXQgcj1adChlKSxuPVp0KEthKTtyPj1uJiZpbShyLHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dCgpOnQpfSx1ZT0oLi4uZSk9PntqYSYmYW0oLi4uZSl9fSk7dmFyIFVyLEpuPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO1VyPShlLHQpPT5uZXcoRHIodCkpKGUpfSk7dmFyIE5yPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBZYSxlbyx0byxzbSx1bSxaYSxubyxybyxYYSxKYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZXQoKTtOcigpO1lhPW5ldyBNYXAoW1s2NCwyNTBdLFsxMjgsMjAwXSxbMjU2LDIwMF0sWzUxMiwyMDBdLFsyMDQ4LDIzMF0sWzQwOTYsMjAwXSxbODE5Miw1MF0sWzE2Mzg0LDUwXSxbMzI3NjgsNTBdLFs2NTUzNiw1MF0sWzEzMTA3Miw1MF0sWzI2MjE0NCw1MF0sWzUyNDI4OCw1MF0sWzEwNDg1NzYsNTBdLFsyMDk3MTUyLDMwXSxbNDE5NDMwNCwyMF0sWzgzODg2MDgsMTBdLFsxMjU4MjkxMiwxMF0sWzE2Nzc3MjE2LDEwXSxbMjYyMTQ0MDAsMTVdLFszMzU1NDQzMiwyMl0sWzQ0MjM2ODAwLDJdLFs1ODk4MjQwMCw2XSxbNjcxMDg4NjQsNl0sWzEzNDIxNzcyOCw2XSxbMTY3NzcyMTYwLDZdXSksZW89W10sdG89ZT0+TWF0aC5jZWlsKE51bWJlcihlKS8xNikqMTYsc209ZT0+e2ZvcihsZXQgdD0wO3Q8ZW8ubGVuZ3RoO3QrKyl7bGV0IHI9ZW9bdF07aWYoZTw9cilyZXR1cm4gcn1yZXR1cm4gTWF0aC5jZWlsKGUvMTYpKjE2fSx1bT0xLFphPSgpPT51bSsrLG5vPWFzeW5jKGUsdCxyLG4pPT57bGV0IG89dG8ociksaT1lLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6byx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO3RyeXtsZXQgYT1lLmdldENvbW1hbmRFbmNvZGVyKCk7ZS5lbmRDb21wdXRlUGFzcygpLGEuY29weUJ1ZmZlclRvQnVmZmVyKHQsMCxpLDAsbyksZS5mbHVzaCgpLGF3YWl0IGkubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtsZXQgZD1pLmdldE1hcHBlZFJhbmdlKCk7aWYobil7bGV0IGw9bigpO3JldHVybiBsLnNldChuZXcgVWludDhBcnJheShkLDAscikpLGx9ZWxzZSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZC5zbGljZSgwLHIpKX1maW5hbGx5e2kuZGVzdHJveSgpfX0scm89Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwO2ZvcihsZXRbcl1vZiBZYSllby5wdXNoKHIpLHRoaXMuZnJlZUJ1ZmZlcnMuc2V0KHIsW10pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLnNldChyLFtdKTt0aGlzLnNlc3Npb25Db3VudD0wfXVwbG9hZCh0LHIpe2xldCBuPXIuYnVmZmVyLG89ci5ieXRlT2Zmc2V0LGk9ci5ieXRlTGVuZ3RoLGE9dG8oaSksZD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdFwiKTtpZihOdW1iZXIoZC5vcmlnaW5hbFNpemUpIT09aSl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtkLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke2l9YCk7bGV0IGw9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe21hcHBlZEF0Q3JlYXRpb246ITAsc2l6ZTphLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pLHA9bC5nZXRNYXBwZWRSYW5nZSgpO25ldyBVaW50OEFycmF5KHApLnNldChuZXcgVWludDhBcnJheShuLG8saSkpLGwudW5tYXAoKTtsZXQgbT10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7bS5jb3B5QnVmZmVyVG9CdWZmZXIobCwwLGQuZ3B1RGF0YS5idWZmZXIsMCxhKSx0aGlzLmJhY2tlbmQuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbbS5maW5pc2goKV0pLGwuZGVzdHJveSgpLHVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7dH0pYCl9bWVtY3B5KHQscil7bGV0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2xldCBvPXRoaXMuc3RvcmFnZUNhY2hlLmdldChyKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2lmKG4ub3JpZ2luYWxTaXplIT09by5vcmlnaW5hbFNpemUpdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZVwiKTtsZXQgaT10byhuLm9yaWdpbmFsU2l6ZSksYT10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSxhLmNvcHlCdWZmZXJUb0J1ZmZlcihuLmdwdURhdGEuYnVmZmVyLDAsby5ncHVEYXRhLmJ1ZmZlciwwLGkpfXJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCxyLG4pe2xldCBvO2lmKG4pe2lmKG89blswXSx0PT09blsxXSlyZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtvfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmApLG87aWYodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKSl0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyaW5nIGEgZGlmZmVyZW50IGV4dGVybmFsIGJ1ZmZlciB1bmRlciBncmFwaCBjYXB0dXJlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAgICAgICAgUGxlYXNlIHVzZSB0aGUgcHJldmlvdXMgZXh0ZXJuYWwgYnVmZmVyIWApfWVsc2Ugbz1aYSgpO3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQobyx7Z3B1RGF0YTp7aWQ6byx0eXBlOjAsYnVmZmVyOnR9LG9yaWdpbmFsU2l6ZTpyfSksdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtvfSwgcmVnaXN0ZXJlZC5gKSxvfXVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0KXt0IT09dm9pZCAwJiYodGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHQpLHVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHt0fWApKX1jcmVhdGUodCxyPUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1Qpe2xldCBuPXNtKHQpLG8saT0ociZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UsYT0ociZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07aWYoaXx8YSl7bGV0IHA9KGk/dGhpcy5mcmVlQnVmZmVyczp0aGlzLmZyZWVVbmlmb3JtQnVmZmVycykuZ2V0KG4pO3A/cC5sZW5ndGg+MD9vPXAucG9wKCk6bz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOnJ9KTpvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6cn0pfWVsc2Ugbz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOnJ9KTtsZXQgZD17aWQ6WmEoKSx0eXBlOjAsYnVmZmVyOm99O3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoZC5pZCx7Z3B1RGF0YTpkLG9yaWdpbmFsU2l6ZTpOdW1iZXIodCl9KSx1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7dH0pID0+IGlkPSR7ZC5pZH1gKSxkfWdldCh0KXtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpPy5ncHVEYXRhfXJlbGVhc2UodCl7bGV0IHI9dHlwZW9mIHQ9PVwiYmlnaW50XCI/TnVtYmVyKHQpOnQsbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQocik7aWYoIW4pe2lmKHRoaXMuc3RvcmFnZUNhY2hlLnNpemU9PT0wKXJldHVybiAwO3Rocm93IG5ldyBFcnJvcihcInJlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0XCIpfXJldHVybiB1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHtyfSksIGdwdURhdGFJZD0ke24uZ3B1RGF0YS5pZH1gKSx0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUociksdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKG4uZ3B1RGF0YS5idWZmZXIpLG4ub3JpZ2luYWxTaXplfWFzeW5jIGRvd25sb2FkKHQscil7bGV0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KE51bWJlcih0KSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTthd2FpdCBubyh0aGlzLmJhY2tlbmQsbi5ncHVEYXRhLmJ1ZmZlcixuLm9yaWdpbmFsU2l6ZSxyKX1yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKXtpZih0aGlzLmJ1ZmZlcnNQZW5kaW5nLmxlbmd0aCE9PTApaWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImRlZmF1bHRcIil7Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpe2xldCByPVlhLmdldCh0LnNpemUpO2lmKCh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSl7bGV0IG49dGhpcy5mcmVlQnVmZmVycy5nZXQodC5zaXplKXx8W107cj09PXZvaWQgMHx8bi5sZW5ndGg+PXI/dC5kZXN0cm95KCk6bi5wdXNoKHQpfWVsc2UgaWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNKXtsZXQgbj10aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQodC5zaXplKXx8W107cj09PXZvaWQgMHx8bi5sZW5ndGg+PXI/dC5kZXN0cm95KCk6bi5wdXNoKHQpfWVsc2UgdC5kZXN0cm95KCl9dGhpcy5idWZmZXJzUGVuZGluZz1bXX1lbHNle2xldCB0PXRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpO3R8fCh0PVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5zZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQsdCkpO2ZvcihsZXQgciBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKXQucHVzaChyKTt0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfX1kaXNwb3NlKCl7dGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHQ9Pnt0LmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwfW9uQ3JlYXRlU2Vzc2lvbigpe3RoaXMuc2Vzc2lvbkNvdW50Kz0xfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IHI9dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0KTtyJiYoci5mb3JFYWNoKG49PntuLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5kZWxldGUodCkpLHRoaXMuc2Vzc2lvbkNvdW50LT0xLHRoaXMuc2Vzc2lvbkNvdW50PT09MCYmKHVlKFwid2FybmluZ1wiLCgpPT5cIltXZWJHUFVdIENsZWFyaW5nIHdlYmdwdSBidWZmZXIgY2FjaGVcIiksdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaChuPT57bi5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwKX19LFhhPSguLi5lKT0+bmV3IHJvKC4uLmUpfSk7dmFyIG9vLHJlLFNlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtvbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMua2V5fHwodGhpcy5rZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLmtleX19LHJlPWU9Pm5ldyBvbyhlKX0pO3ZhciBpbyx0dCxDLEF0LFZyLGVzLHRzLG9lPVUoKCk9PntcInVzZSBzdHJpY3RcIjtpbz1jbGFzc3tzdGF0aWMgY2FsY01hdE11bFNoYXBlKHQscil7cmV0dXJuIHRbMV0hPT1yWzBdP3ZvaWQgMDpbdFswXSxyWzFdXX19LHR0PWNsYXNze3N0YXRpYyBjYWxjU2hhcGUodCxyLG49ITEpe2xldCBvPXQubGVuZ3RoLGk9ci5sZW5ndGg7aWYobz09PTApcmV0dXJuIHI7aWYoaT09PTApcmV0dXJuIHQ7bGV0IGE9TWF0aC5tYXgodC5sZW5ndGgsci5sZW5ndGgpLGQ9bmV3IEFycmF5KGEpO2lmKG4pe2lmKG88Mnx8aTwyKXJldHVybjtsZXQgbD1pby5jYWxjTWF0TXVsU2hhcGUoW3Rbby0yXSx0W28tMV1dLFtyW2ktMl0scltpLTFdXSk7aWYobD09PXZvaWQgMClyZXR1cm47W2RbYS0yXSxkW2EtMV1dPWx9Zm9yKGxldCBsPW4/MzoxO2w8PWE7bCsrKXtsZXQgcD1vLWw8MD8xOnRbby1sXSxtPWktbDwwPzE6cltpLWxdO2lmKHAhPT1tJiZwPjEmJm0+MSlyZXR1cm47bGV0IHU9TWF0aC5tYXgocCxtKTtpZihwJiZtKWRbYS1sXT1NYXRoLm1heChwLG0pO2Vsc2V7aWYodT4xKXJldHVybjtkW2EtbF09MH19cmV0dXJuIGR9c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QodCxyKXtsZXQgbj10Lmxlbmd0aCxvPXIubGVuZ3RoO2lmKG4+bylyZXR1cm4hMTtmb3IobGV0IGk9MTtpPD1uO2krKylpZih0W24taV0hPT0xJiZ0W24taV0hPT1yW28taV0pcmV0dXJuITE7cmV0dXJuITB9fSxDPWNsYXNzIGV7c3RhdGljIHNpemUodCl7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBjb252ZXJ0U2hhcGUodCxyPTQpe2xldCBuPXQubGVuZ3RoO2lmKG49PT0wKXJldHVybltdO2xldCBvPW5ldyBBcnJheShuKSxpPW4tMTtmb3IoO2k+PTA7KXtpZih0W2ldJXI9PT0wKXtvW2ldPXRbaV0vcjticmVha31pZihyJXRbaV0hPT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb252ZXJ0IHNoYXBlXCIpO29baV09MSxyLz10W2ldLGktLX1mb3IoaS0tO2k+PTA7aS0tKW9baV09dFtpXTtyZXR1cm4gb31zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHIpfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscixuKXtsZXQgbz0xO2ZvcihsZXQgaT1yO2k8bjtpKyspe2lmKHRbaV08MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO28qPU51bWJlcih0W2ldKX1yZXR1cm4gb31zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7bGV0IHI9dC5sZW5ndGg7aWYocj09PTApcmV0dXJuW107aWYocj09PTEpcmV0dXJuWzFdO2xldCBuPW5ldyBBcnJheShyKTtuW3ItMV09MSxuW3ItMl09dFtyLTFdO2ZvcihsZXQgbz1yLTM7bz49MDstLW8pbltvXT1uW28rMV0qdFtvKzFdO3JldHVybiBufXN0YXRpYyBub3JtYWxpemVBeGlzKHQscil7aWYodDwtciYmdD49cil0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIHQ8MD90K3I6dH1zdGF0aWMgbm9ybWFsaXplQXhlcyh0LHIpe3JldHVybiB0Lm1hcChuPT50aGlzLm5vcm1hbGl6ZUF4aXMobixyPz90Lmxlbmd0aCkpfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxyKXtyZXR1cm4gcj9yLm1hcChuPT50W25dKTp0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZSh0LHIpe2xldCBuPXQubGVuZ3RoO3JldHVybiB0Lm1hcCgobyxpKT0+bytyW2ldK3JbaStuXSl9c3RhdGljIGFyZUVxdWFsKHQscil7cmV0dXJuIHQubGVuZ3RoIT09ci5sZW5ndGg/ITE6dC5ldmVyeSgobixvKT0+bj09PXJbb10pfX0sQXQ9Y2xhc3MgZXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxyLG4sbyxpLGEpe2lmKCF0JiZuLmxlbmd0aCE9PXIubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgZD0wO2Q8ci5sZW5ndGgtMjtkKyspZD49bi5sZW5ndGg/bi5wdXNoKHJbZCsyXSk6bltkXT1yW2QrMl07Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspaWYoZDxvLmxlbmd0aCl7aWYob1tkXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGg7ZCsrKWlmKGQ8aS5sZW5ndGgpe2lmKGlbZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgaS5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGgqMjtkKyspaWYoZDxhLmxlbmd0aCl7aWYoYVtkXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBhLnB1c2goMCk7Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspe2lmKG5bZF08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKGFbZF0+PW5bZF18fGFbZCtuLmxlbmd0aF0+PW5bZF0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LHIsbixvLGksYSxkKXtpZihkKXtpZihpLmxlbmd0aCE9PTIqKHQubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihyLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKG8ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCBsPTA7bDx0Lmxlbmd0aC0yO2wrKyllLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbbCsoYT8xOjIpXSxyW2xdLG5bbF0sb1tsXSxpLGwsbCt0Lmxlbmd0aC0yLGQpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSh0LHIsbixvLGksYSxkKXtpZihyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7bGV0IGw9W3JbMF0sclsxXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKHQscixsLG4sbyxpLGEsZCksbH1zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSh0LHIsbixvLGksYSxkKXtpZih0Lmxlbmd0aDw9MHx8ci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtsZXQgbD1bdFswXSxyWzBdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxsLG4sbyxpLGEsZCksbH1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQscixuLG8saSxhLGQsbCl7aWYodClmb3IobGV0IHA9MDtwPHIubGVuZ3RoLTI7cCsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgcD0wO3A8ci5sZW5ndGgtMjtwKyspbi5wdXNoKGUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUocltwKzJdLG9bcF0saVtwXSxhW3BdLGQscCxwK3IubGVuZ3RoLTIsbCkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LHIsbixvLGksYSxkLGwpe2xldCBwPW4qKG8tMSkrMTtpZihsJiZsIT09XCJOT1RTRVRcIilzd2l0Y2gobCl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVthXT0wLGlbZF09MCxNYXRoLmZsb29yKCh0LXApL3IrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZihuIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2xldCB1PSgodCtyLTEpL3ItMSkqcitvLXQ7cmV0dXJuIGlbYV09TWF0aC5mbG9vcihsPT09XCJTQU1FX0xPV0VSXCI/KHUrMSkvMjp1LzIpLGlbZF09dS1pW2FdLE1hdGguZmxvb3IoKHQrdS1vKS9yKzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfWVsc2UgcmV0dXJuIE1hdGguZmxvb3IoKHQraVthXStpW2RdLXApL3IrMSl9fSxWcj1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQodCxyLG4sbyxpKXtpZih0Lmxlbmd0aCE9PTJ8fG4ubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgYSxkLGw7cj8oYT10WzFdLGQ9dFswXSk6KGE9dFswXSxkPXRbMV0pO2xldCBwPS0xO2lmKG8/KGw9blswXSxwPTEpOihsPW5bMV0scD0wKSxuW3BdIT09ZCl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYoYTw9MHx8bDw9MHx8ZDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihpJiYhdHQuaXNWYWxpZEJyb2FkY2FzdChpLFthLGxdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bYSxsLGRdfX0sZXM9LTM0MDI4MjM0NjYzODUyODg2ZTIyLHRzPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7dmFyIGt0LHNvLF9lLEVlLE4sbWUsdW8sRXQsRmUsRixXcixFLE0scnMsTHIsYW8sbnMsYWU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtrdD02NCxzbz0oZSx0KT0+e2lmKHQ9PT0zKXRocm93IG5ldyBFcnJvcihcInZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWRcIik7c3dpdGNoKE51bWJlcihlKSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2Nhc2UgMjI6cmV0dXJuXCJpMzJcIjtjYXNlIDIxOnJldHVyblwidTMyXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSxfZT0oZSx0PTEpPT57bGV0IHI9c28oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzBdfSxFZT0oZSx0PTEpPT57bGV0IHI9c28oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzFdfSxOPSguLi5lKT0+e2xldCB0PVtdO3JldHVybiBlLmZvckVhY2gocj0+e3IubGVuZ3RoIT09MCYmdC5wdXNoKHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpDLmNvbXB1dGVTdHJpZGVzKHIpfSl9KSx0fSxtZT1lPT5lJTQ9PT0wPzQ6ZSUyPT09MD8yOjEsdW89KGU9XCJmMzJcIix0LHI9XCIwXCIpPT4hdHx8dD09PTE/YCR7ZX0oJHtyfSlgOmB2ZWMke3R9PCR7ZX0+KCR7cn0pYCxFdD0oZSx0LHIpPT5lPT09XCJmMzJcIj9yOnQ9PT0xP2BmMzIoJHtyfSlgOmB2ZWMke3R9PGYzMj4oJHtyfSlgLEZlPShlLHQpPT50PT09ND9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueiArICR7ZX0udylgOnQ9PT0yP2AoJHtlfS54ICsgJHtlfS55KWA6dD09PTM/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnopYDplLEY9KGUsdCxyLG4pPT5lLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnI+ND90eXBlb2YgdD09XCJzdHJpbmdcIj9uPT09XCJmMTZcIj9gJHtlfVsoJHt0fSkgLyA4XVsoJHt0fSkgJSA4IC8gNF1bKCR7dH0pICUgOCAlIDRdYDpgJHtlfVsoJHt0fSkgLyA0XVsoJHt0fSkgJSA0XWA6bj09PVwiZjE2XCI/YCR7ZX1bJHtNYXRoLmZsb29yKHQvOCl9XVske01hdGguZmxvb3IodCU4LzQpfV1bJHt0JTglNH1dYDpgJHtlfVske01hdGguZmxvb3IodC80KX1dWyR7dCU0fV1gOnI+MT9gJHtlfVske3R9XWA6ZSxXcj0oZSx0LHIsbixvKT0+e2xldCBpPXR5cGVvZiByPT1cIm51bWJlclwiLGE9aT9yOnIubGVuZ3RoLGQ9Wy4uLm5ldyBBcnJheShhKS5rZXlzKCldLGw9YTwyP1widTMyXCI6YTw9ND9gdmVjJHthfTx1MzI+YDpgYXJyYXk8dTMyLCAke2F9PmAscD1zbyh0LG8pLG09dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzFdLHU9dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzBdLGg9e2luZGljZXM6bCx2YWx1ZTptLHN0b3JhZ2U6dSx0ZW5zb3I6dH0sXz1XPT50eXBlb2YgVz09XCJzdHJpbmdcIj9XOmAke1d9dWAseT17b2Zmc2V0VG9JbmRpY2VzOiExLGluZGljZXNUb09mZnNldDohMSxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDohMSxzZXQ6ITEsc2V0QnlJbmRpY2VzOiExLGdldDohMSxnZXRCeUluZGljZXM6ITF9LGc9aT9cInVuaWZvcm1zLlwiOlwiXCIseD1gJHtnfSR7ZX1fc2hhcGVgLCQ9YCR7Z30ke2V9X3N0cmlkZXNgLHY9XCJcIjtmb3IobGV0IFc9MDtXPGEtMTtXKyspdis9YFxuICAgIGxldCBkaW0ke1d9ID0gY3VycmVudCAvICR7RigkLFcsYSl9O1xuICAgIGxldCByZXN0JHtXfSA9IGN1cnJlbnQgJSAke0YoJCxXLGEpfTtcbiAgICBpbmRpY2VzWyR7V31dID0gZGltJHtXfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7V307XG4gICAgYDt2Kz1gaW5kaWNlc1ske2EtMX1dID0gY3VycmVudDtgO2xldCBTPWE8Mj9cIlwiOmBcbiAgZm4gbzJpXyR7ZX0ob2Zmc2V0OiB1MzIpIC0+ICR7aC5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7aC5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke3Z9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gLFQ9Vz0+KHkub2Zmc2V0VG9JbmRpY2VzPSEwLGE8Mj9XOmBvMmlfJHtlfSgke1d9KWApLEE9W107aWYoYT49Milmb3IobGV0IFc9YS0xO1c+PTA7Vy0tKUEucHVzaChgJHtGKCQsVyxhKX0gKiAoaW5kaWNlc1ske1d9XSlgKTtsZXQgaz1hPDI/XCJcIjpgXG4gIGZuIGkyb18ke2V9KGluZGljZXM6ICR7aC5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICByZXR1cm4gJHtBLmpvaW4oXCIrXCIpfTtcbiAgfWAsUD1XPT4oeS5pbmRpY2VzVG9PZmZzZXQ9ITAsYTwyP1c6YGkyb18ke2V9KCR7V30pYCksRD0oLi4uVyk9PmE9PT0wP1wiMHVcIjpgJHtoLmluZGljZXN9KCR7Vy5tYXAoXykuam9pbihcIixcIil9KWAsUj0oVyxxKT0+YTwyP2Ake1d9YDpgJHtGKFcscSxhKX1gLEc9KFcscSxoZSk9PmE8Mj9gJHtXfT0ke2hlfTtgOmAke0YoVyxxLGEpfT0ke2hlfTtgLEs9e30saj0oVyxxKT0+e3kuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ9ITA7bGV0IGhlPWAke3EubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7ZX1PZmZzZXRgO2lmKGhlIGluIEspcmV0dXJuYCR7aGV9KCR7V30pYDtsZXQgR2U9W107Zm9yKGxldCB3ZT1hLTE7d2U+PTA7d2UtLSl7bGV0IHllPXEuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIix3ZStxLnJhbmstYSk7R2UucHVzaChgJHtSKCQsd2UpfSAqICgke3llfSAlICR7Uih4LHdlKX0pYCl9cmV0dXJuIEtbaGVdPWBmbiAke2hlfShvdXRwdXRJbmRpY2VzOiAke3EudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgICByZXR1cm4gJHtHZS5sZW5ndGg+MD9HZS5qb2luKFwiK1wiKTpcIjB1XCJ9O1xuICAgICAgICAgICB9YCxgJHtoZX0oJHtXfSlgfSxWPShXLHEpPT4oKCk9PntpZihoLnN0b3JhZ2U9PT1oLnZhbHVlKXJldHVybmAke2V9WyR7V31dPSR7cX07YDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gJHtlfVske1d9XT12ZWMyPHUzMj4odTMyKCR7cX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke3F9IDwgMCkpO2A7aWYoaC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmaC52YWx1ZT09PVwidTMyXCIpcmV0dXJuYCR7ZX1bJHtXfV09dmVjMjx1MzI+KHUzMigke3F9KSwgMHUpO2A7aWYoaC5zdG9yYWdlPT09XCJ1MzJcIiYmaC52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmAke2V9WyR7V31dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7cX0pKTtgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtoLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7aC52YWx1ZX0geWV0YCl9KSgpLFE9Vz0+KCgpPT57aWYoaC5zdG9yYWdlPT09aC52YWx1ZSlyZXR1cm5gJHtlfVske1d9XWA7aWYoaC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmaC52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYGkzMigke2V9WyR7V31dLngpYDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gdTMyKCR7ZX1bJHtXfV0ueClgO2lmKGguc3RvcmFnZT09PVwidTMyXCImJmgudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gdmVjNDxib29sPihib29sKCR7ZX1bJHtXfV0gJiAweEZGdSksIGJvb2woJHtlfVske1d9XSAmIDB4RkYwMHUpLCBib29sKCR7ZX1bJHtXfV0gJiAweEZGMDAwMHUpLCBib29sKCR7ZX1bJHtXfV0gJiAweEZGMDAwMDAwdSkpYDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7aC5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2gudmFsdWV9IHlldGApfSkoKSxzZT1hPDI/XCJcIjpgXG4gIGZuIGdldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7aC5pbmRpY2VzfSkgLT4gJHttfSB7XG4gICAgcmV0dXJuICR7UShgaTJvXyR7ZX0oaW5kaWNlcylgKX07XG4gIH1gLFk9YTwyP1wiXCI6KCgpPT57bGV0IFc9ZC5tYXAoaGU9PmBkJHtoZX06IHUzMmApLmpvaW4oXCIsIFwiKSxxPWQubWFwKGhlPT5gZCR7aGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gZ2V0XyR7ZX0oJHtXfSkgLT4gJHttfSB7XG4gICAgcmV0dXJuIGdldF8ke2V9QnlJbmRpY2VzKCR7RChxKX0pO1xuICB9YH0pKCksZWU9KC4uLlcpPT57aWYoVy5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke2F9YCk7bGV0IHE9Vy5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIGE9PT0wP1EoXCIwdVwiKTphPT09MT9RKHFbMF0pOih5LmdldD0hMCx5LmdldEJ5SW5kaWNlcz0hMCx5LmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX0oJHtxfSlgKX0sSj1XPT5hPDI/UShXKTooeS5nZXRCeUluZGljZXM9ITAseS5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9QnlJbmRpY2VzKCR7V30pYCksbmU9YTwyP1wiXCI6YFxuICBmbiBzZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke2guaW5kaWNlc30sIHZhbHVlOiAke219KSB7XG4gICAgJHtWKGBpMm9fJHtlfShpbmRpY2VzKWAsXCJ2YWx1ZVwiKX1cbiAgfWAsYmU9YTwyP1wiXCI6KCgpPT57bGV0IFc9ZC5tYXAoaGU9PmBkJHtoZX06IHUzMmApLmpvaW4oXCIsIFwiKSxxPWQubWFwKGhlPT5gZCR7aGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gc2V0XyR7ZX0oJHtXfSwgdmFsdWU6ICR7bX0pIHtcbiAgICBzZXRfJHtlfUJ5SW5kaWNlcygke0QocSl9LCB2YWx1ZSk7XG4gIH1gfSkoKTtyZXR1cm57aW1wbDooKT0+e2xldCBXPVtdLHE9ITE7cmV0dXJuIHkub2Zmc2V0VG9JbmRpY2VzJiYoVy5wdXNoKFMpLHE9ITApLHkuaW5kaWNlc1RvT2Zmc2V0JiYoVy5wdXNoKGspLHE9ITApLHkuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQmJihPYmplY3QudmFsdWVzKEspLmZvckVhY2goaGU9PlcucHVzaChoZSkpLHE9ITApLHkuc2V0JiYoVy5wdXNoKGJlKSxxPSEwKSx5LnNldEJ5SW5kaWNlcyYmKFcucHVzaChuZSkscT0hMCkseS5nZXQmJihXLnB1c2goWSkscT0hMCkseS5nZXRCeUluZGljZXMmJihXLnB1c2goc2UpLHE9ITApLCFpJiZxJiZXLnVuc2hpZnQoYGNvbnN0ICR7eH0gPSAke2guaW5kaWNlc30oJHtyLmpvaW4oXCIsXCIpfSk7YCxgY29uc3QgJHskfSA9ICR7aC5pbmRpY2VzfSgke0MuY29tcHV0ZVN0cmlkZXMocikuam9pbihcIixcIil9KTtgKSxXLmpvaW4oYFxuYCl9LHR5cGU6aCxvZmZzZXRUb0luZGljZXM6VCxpbmRpY2VzVG9PZmZzZXQ6UCxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDpqLGluZGljZXM6RCxpbmRpY2VzR2V0OlIsaW5kaWNlc1NldDpHLHNldDooLi4uVyk9PntpZihXLmxlbmd0aCE9PWErMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHthfWApO2xldCBxPVdbYV07aWYodHlwZW9mIHEhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7bGV0IGhlPVcuc2xpY2UoMCxhKS5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIGE9PT0wP1YoXCIwdVwiLHEpOmE9PT0xP1YoaGVbMF0scSk6KHkuc2V0PSEwLHkuc2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke2hlfSwgJHtxfSlgKX0sc2V0QnlPZmZzZXQ6VixzZXRCeUluZGljZXM6KFcscSk9PmE8Mj9WKFcscSk6KHkuc2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfUJ5SW5kaWNlcygke1d9LCAke3F9KTtgKSxnZXQ6ZWUsZ2V0QnlPZmZzZXQ6USxnZXRCeUluZGljZXM6Six1c2FnZTpuLG5hbWU6ZSxzdHJpZGVzOiQsc2hhcGU6eCxyYW5rOmF9fSxFPShlLHQscixuPTEpPT5XcihlLHQscixcImlucHV0XCIsbiksTT0oZSx0LHIsbj0xKT0+V3IoZSx0LHIsXCJvdXRwdXRcIixuKSxycz0oZSx0LHIpPT5XcihlLHQscixcImF0b21pY091dHB1dFwiLDEpLExyPShlLHQscixuPTEpPT5XcihlLHQscixcImludGVybmFsXCIsbiksYW89Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwPXQ7dGhpcy5saW1pdHM9cjt0aGlzLmludGVybmFsVmFyaWFibGVzPVtdO3RoaXMudmFyaWFibGVzPVtdO3RoaXMudW5pZm9ybXM9W107dGhpcy52YXJpYWJsZUluZGV4PTB9Z3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh0KXtyZXR1cm5gaWYgKGdsb2JhbF9pZHggPj0gJHt0eXBlb2YgdD09XCJudW1iZXJcIj9gJHt0fXVgOnR9KSB7IHJldHVybjsgfWB9bWFpblN0YXJ0KHQ9a3Qpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dFswXSxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsxXSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsyXTtpZihyPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWHx8bj50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl8fG8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7cn0sICR7bn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIHNpemUgWyR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn1dLmApO2lmKHIqbipvPnRoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCl0aHJvdyBuZXcgRXJyb3IoYHdvcmtncm91cCBzaXplIFske3J9LCAke259LCAke299XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBpbnZvY2F0aW9ucyAke3RoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cH0uYCk7bGV0IGk9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLGE9aT9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gOmBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmAsZD1pP2BsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1xuICAgICAgICAgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC54O2A6YGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueiAqIG51bV93b3JrZ3JvdXBzWzBdICogbnVtX3dvcmtncm91cHNbMV0gK1xuICAgICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueDtcbiAgICAgICAgIGxldCBnbG9iYWxfaWR4ID0gd29ya2dyb3VwX2luZGV4ICogJHtyKm4qb311ICsgbG9jYWxfaWR4O2A7cmV0dXJuYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3J9LCAke259LCAke299KVxuICBmbiBtYWluKCR7YX0pIHtcbiAgICAke2R9XG4gIGB9YXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KXt0LnJhbmshPT0wJiYodC5zaGFwZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zaGFwZS5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSx0LnN0cmlkZXMuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc3RyaWRlcy5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSl9ZGVjbGFyZVZhcmlhYmxlKHQscil7aWYodC51c2FnZT09PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGludGVybmFsIHZhcmlhYmxlIHdpdGggZGVjbGFyZVZhcmlhYmxlKCkuIHVzZSByZWdpc3RlckludGVybmFsVmFyaWFibGVzKCkgaW5zdGVhZC5cIik7dGhpcy52YXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCk7bGV0IG49dC51c2FnZT09PVwiaW5wdXRcIj9cInJlYWRcIjpcInJlYWRfd3JpdGVcIixvPXQudXNhZ2U9PT1cImF0b21pY091dHB1dFwiP1wiYXRvbWljPGkzMj5cIjp0LnR5cGUuc3RvcmFnZTtyZXR1cm5gQGdyb3VwKDApIEBiaW5kaW5nKCR7cn0pIHZhcjxzdG9yYWdlLCAke259PiAke3QubmFtZX06IGFycmF5PCR7b30+O2B9ZGVjbGFyZVZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5tYXAocj0+dGhpcy5kZWNsYXJlVmFyaWFibGUocix0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oYFxuYCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHQpe2lmKHQudXNhZ2UhPT1cImludGVybmFsXCIpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLmludGVybmFsVmFyaWFibGVzLnB1c2godCksdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpfXJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQuZm9yRWFjaChyPT50aGlzLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZShyKSksdGhpc31yZWdpc3RlclVuaWZvcm0odCxyLG49MSl7cmV0dXJuIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LHR5cGU6cixsZW5ndGg6bn0pLHRoaXN9cmVnaXN0ZXJVbmlmb3Jtcyh0KXtyZXR1cm4gdGhpcy51bmlmb3Jtcz10aGlzLnVuaWZvcm1zLmNvbmNhdCh0KSx0aGlzfXVuaWZvcm1EZWNsYXJhdGlvbigpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCB0PVtdO2ZvcihsZXR7bmFtZTpyLHR5cGU6bixsZW5ndGg6b31vZiB0aGlzLnVuaWZvcm1zKWlmKG8mJm8+NCluPT09XCJmMTZcIj90LnB1c2goYEBhbGlnbigxNikgJHtyfTphcnJheTxtYXQyeDQ8JHtufT4sICR7TWF0aC5jZWlsKG8vOCl9PmApOnQucHVzaChgJHtyfTphcnJheTx2ZWM0PCR7bn0+LCAke01hdGguY2VpbChvLzQpfT5gKTtlbHNle2xldCBpPW89PW51bGx8fG89PT0xP246YHZlYyR7b308JHtufT5gO3QucHVzaChgJHtyfToke2l9YCl9cmV0dXJuYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt0LmpvaW4oXCIsIFwiKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YH1nZXQgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucygpe3JldHVybiB0aGlzLnVuaWZvcm1EZWNsYXJhdGlvbigpK3RoaXMudmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKSt0aGlzLmludGVybmFsVmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKX1nZXQgdmFyaWFibGVzSW5mbygpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm47bGV0IHQ9cj0+WzEyLDEwLDEsNl1bW1widTMyXCIsXCJmMTZcIixcImYzMlwiLFwiaTMyXCJdLmluZGV4T2YocildO3JldHVybiB0aGlzLnVuaWZvcm1zLm1hcChyPT5bdChyLnR5cGUpLHIubGVuZ3RoPz8xXSl9fSxucz0oZSx0KT0+bmV3IGFvKGUsdCl9KTt2YXIgZG0sb3MsbG0sY20scG0sbW0sUGUsaXMsYXMsZHQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7ZG09KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZih0Lmxlbmd0aCE9PTAmJnQubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYHBlcm0gc2l6ZSAke3QubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCBpbnB1dCByYW5rICR7ZVswXS5kaW1zLmxlbmd0aH1gKX0sb3M9KGUsdCk9PnQubGVuZ3RoIT09MD90OlsuLi5uZXcgQXJyYXkoZSkua2V5cygpXS5yZXZlcnNlKCksbG09KGUsdCk9PkMuc29ydEJhc2VkT25QZXJtKGUsb3MoZS5sZW5ndGgsdCkpLGNtPShlLHQscixuKT0+e2xldCBvPWBmbiBwZXJtKGk6ICR7bi50eXBlLmluZGljZXN9KSAtPiAke3IudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7ci50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBpPTA7aTx0OysraSlvKz1gYVske2VbaV19XT1pWyR7aX1dO2A7cmV0dXJuIG8rPVwicmV0dXJuIGE7fVwifSxwbT0oZSx0KT0+e2xldCByPVtdLG49W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pZVtvXSE9PTEmJnIucHVzaChlW29dKSxlW3Rbb11dIT09MSYmbi5wdXNoKHRbb10pO3JldHVybntuZXdTaGFwZTpyLG5ld1Blcm06bn19LG1tPShlLHQpPT57bGV0IHI9MDtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZih0W2Vbbl1dIT09MSl7aWYoZVtuXTxyKXJldHVybiExO3I9ZVtuXX1yZXR1cm4hMH0sUGU9KGUsdCk9PntsZXQgcj1lLmRhdGFUeXBlLG49ZS5kaW1zLmxlbmd0aCxvPW9zKG4sdCksaT1sbShlLmRpbXMsbyksYT1lLmRpbXMsZD1pLGw9bjwyfHxtbShvLGUuZGltcykscDtpZihsKXJldHVybiBwPWc9PntsZXQgeD1FKFwiaW5wdXRcIixyLGEsNCksJD1NKFwib3V0cHV0XCIscixkLDQpO3JldHVybmBcbiAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh4LCQpfVxuICAke2cubWFpblN0YXJ0KCl9XG4gICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlQ29weVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IGc9Qy5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChnLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKGcvNCl9XX19LGdldFNoYWRlclNvdXJjZTpwfTtsZXR7bmV3U2hhcGU6bSxuZXdQZXJtOnV9PXBtKGUuZGltcyxvKSxoPUMuYXJlRXF1YWwodSxbMiwzLDFdKSxfPUMuYXJlRXF1YWwodSxbMywxLDJdKTtpZihtLmxlbmd0aD09PTJ8fGh8fF8pe2E9aD9bbVswXSxtWzFdKm1bMl1dOl8/W21bMF0qbVsxXSxtWzJdXTptLGQ9W2FbMV0sYVswXV07bGV0IGc9MTY7cmV0dXJuIHA9eD0+e2xldCAkPUUoXCJhXCIscixhLmxlbmd0aCksdj1NKFwib3V0cHV0XCIscixkLmxlbmd0aCk7cmV0dXJuYFxuICAke3gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKCQsdil9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGUgOiBhcnJheTxhcnJheTwke3YudHlwZS52YWx1ZX0sICR7ZysxfT4sICR7Z30+O1xuICAke3gubWFpblN0YXJ0KFtnLGcsMV0pfVxuICAgIGxldCBzdHJpZGUgPSAodW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdIC0gMSkgLyAke2d9ICsgMTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3ggPSB3b3JrZ3JvdXBfaW5kZXggJSBzdHJpZGU7XG4gICAgbGV0IHdvcmtncm91cF9pZF95ID0gd29ya2dyb3VwX2luZGV4IC8gc3RyaWRlO1xuICAgIGxldCBpbnB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeSAqICR7Z311ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgaW5wdXRfcm93ID0gd29ya2dyb3VwX2lkX3ggKiAke2d9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKGlucHV0X3JvdyA8IHVuaWZvcm1zLmFfc2hhcGVbMF0gJiYgaW5wdXRfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsxXSkge1xuICAgICAgdGlsZVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7JC5nZXRCeUluZGljZXMoYCR7JC50eXBlLmluZGljZXN9KGlucHV0X3JvdywgaW5wdXRfY29sKWApfTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgbGV0IG91dHB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeCAqICR7Z311ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgb3V0cHV0X3JvdyA9IHdvcmtncm91cF9pZF95ICogJHtnfXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChvdXRwdXRfcm93IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzBdICYmIG91dHB1dF9jb2wgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0pIHtcbiAgICAgICR7di5zZXRCeUluZGljZXMoYCR7di50eXBlLmluZGljZXN9KG91dHB1dF9yb3csIG91dHB1dF9jb2wpYCxcInRpbGVbbG9jYWxfaWQueF1bbG9jYWxfaWQueV1cIil9XG4gICAgfVxuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VTaGFyZWRcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCB4PUMuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZFsxXS9nKSx5Ok1hdGguY2VpbChkWzBdL2cpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6eH0sLi4uTihhLGQpXX19LGdldFNoYWRlclNvdXJjZTpwfX1yZXR1cm4gcD1nPT57bGV0IHg9RShcImFcIixyLGEubGVuZ3RoKSwkPU0oXCJvdXRwdXRcIixyLGQubGVuZ3RoKTtyZXR1cm5gXG4gICR7Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeCwkKX1cblxuICAke2NtKG8sbix4LCQpfVxuXG4gICR7Zy5tYWluU3RhcnQoKX1cbiAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix4LmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgZz1DLnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGcvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6Z30sLi4uTihhLGQpXX19LGdldFNoYWRlclNvdXJjZTpwfX0saXM9KGUsdCk9PntkbShlLmlucHV0cyx0LnBlcm0pLGUuY29tcHV0ZShQZShlLmlucHV0c1swXSx0LnBlcm0pKX0sYXM9ZT0+cmUoe3Blcm06ZS5wZXJtfSl9KTt2YXIgZm0saG0sZ20sYm0seW0sX20sd20sdm0sJG0seG0scnQsc3MsdXMsZHMsbHMsY3MscHMsbXMsZnMsaHMsZ3MsYnM9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0dyKCk7ZHQoKTtmbT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxobT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LGdtPXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LGJtPXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0seW09KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG49dC1lO248dDsrK24pci5wdXNoKG4pO3JldHVybiByfSxfbT0oZSx0KT0+e2xldCByPVtdLG49ZS5sZW5ndGg7Zm9yKGxldCBpPTA7aTxuO2krKyl0LmluZGV4T2YoaSk9PT0tMSYmci5wdXNoKGVbaV0pO2xldCBvPXQubWFwKGk9PmVbaV0pO3JldHVybltyLG9dfSx3bT0oZSx0KT0+e2xldCByPWUubGVuZ3RoK3QubGVuZ3RoLG49W10sbz0wO2ZvcihsZXQgaT0wO2k8cjtpKyspdC5pbmRleE9mKGkpPT09LTE/bi5wdXNoKGVbbysrXSk6bi5wdXNoKDEpO3JldHVybiBufSx2bT0oZSx0KT0+e2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKGVbZS5sZW5ndGgtci0xXSE9PXQtMS1yKXJldHVybiExO3JldHVybiEwfSwkbT0oZSx0KT0+e2xldCByPVtdO2lmKCF2bShlLHQpKXtmb3IobGV0IG49MDtuPHQ7KytuKWUuaW5kZXhPZihuKT09PS0xJiZyLnB1c2gobik7ZS5mb3JFYWNoKG49PnIucHVzaChuKSl9cmV0dXJuIHJ9LHhtPShlLHQscixuLG8saSxhKT0+e2xldCBkPXJbMF0uZGltcyxsPUMuc2l6ZShpKSxwPUMuc2l6ZShhKSxtPUUoXCJfQVwiLHJbMF0uZGF0YVR5cGUsZCksdT1NKFwib3V0cHV0XCIsbyxpKSxoPTY0O2w9PT0xJiYoaD0yNTYpO2xldCBfPWBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHtofT47XG4gICAgICAgYCx5PWc9PmBcbiAgICAgICAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0sdSl9XG4gICAgICAgICR7X31cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7Zy5tYWluU3RhcnQoaCl9XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHtofTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IGYzMigke2dtW25dfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke2h9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHttLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke2ZtW25dfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHtofXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7aG1bbl19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7dS5zZXRCeU9mZnNldChcIm91dHB1dEluZGV4XCIsYCR7bj09PVwibWVhblwiP2Ake3UudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYDpgJHt1LnR5cGUuc3RvcmFnZX0oJHtibVtuXX0pYH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH07JHtofWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Omx9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpwfV19KX19LHJ0PShlLHQscixuKT0+e2xldCBvPWUuaW5wdXRzLmxlbmd0aD09PTE/cjpsbyhlLmlucHV0cyxyKSxpPW8uYXhlcztpLmxlbmd0aD09PTAmJiFvLm5vb3BXaXRoRW1wdHlBeGVzJiYoaT1lLmlucHV0c1swXS5kaW1zLm1hcCgoXyx5KT0+eSkpO2xldCBhPUMubm9ybWFsaXplQXhlcyhpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSxkPWEsbD1lLmlucHV0c1swXSxwPSRtKGQsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO3AubGVuZ3RoPjAmJihsPWUuY29tcHV0ZShQZShlLmlucHV0c1swXSxwKSx7aW5wdXRzOlswXSxvdXRwdXRzOlstMV19KVswXSxkPXltKGQubGVuZ3RoLGwuZGltcy5sZW5ndGgpKTtsZXRbbSx1XT1fbShsLmRpbXMsZCksaD1tO28ua2VlcERpbXMmJihoPXdtKG0sYSkpLGUuY29tcHV0ZSh4bSh0LG8uY2FjaGVLZXksW2xdLG4sZS5pbnB1dHNbMF0uZGF0YVR5cGUsaCx1KSx7aW5wdXRzOltsXX0pfSxzcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VNZWFuU2hhcmVkXCIsdCxcIm1lYW5cIil9LHVzPShlLHQpPT57cnQoZSxcIlJlZHVjZUwxU2hhcmVkXCIsdCxcImwxXCIpfSxkcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMMlNoYXJlZFwiLHQsXCJsMlwiKX0sbHM9KGUsdCk9PntydChlLFwiUmVkdWNlTG9nU3VtRXhwU2hhcmVkXCIsdCxcImxvZ1N1bUV4cFwiKX0sY3M9KGUsdCk9PntydChlLFwiUmVkdWNlTWF4U2hhcmVkXCIsdCxcIm1heFwiKX0scHM9KGUsdCk9PntydChlLFwiUmVkdWNlTWluU2hhcmVkXCIsdCxcIm1pblwiKX0sbXM9KGUsdCk9PntydChlLFwiUmVkdWNlUHJvZFNoYXJlZFwiLHQsXCJwcm9kXCIpfSxmcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VTdW1TaGFyZWRcIix0LFwic3VtXCIpfSxocz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VTdW1TcXVhcmVTaGFyZWRcIix0LFwic3VtU3F1YXJlXCIpfSxncz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMb2dTdW1TaGFyZWRcIix0LFwibG9nU3VtXCIpfX0pO3ZhciBudCxTbSxIcixsbyxvdCxUbSxJbSxDbSxBbSxrbSxFbSxQbSx6bSxPbSxEbSxpdCx5cyxfcyx3cyx2cywkcyx4cyxTcyxUcyxJcyxDcyxHcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTticygpO250PWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTImJmVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhlcyBpbnB1dCBkaW1zLlwiKX0sU209ZT0+W1wiXCIsXCJcIixgdmFyIHZhbHVlID0gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0sSHI9KGUsdCxyLG4sbyxpLGE9ITEsZD0hMSk9PntsZXQgbD1bXSxwPXJbMF0uZGltcyxtPXAubGVuZ3RoLHU9Qy5ub3JtYWxpemVBeGVzKG8sbSksaD0hZCYmdS5sZW5ndGg9PT0wO3AuZm9yRWFjaCgoeCwkKT0+e2h8fHUuaW5kZXhPZigkKT49MD9hJiZsLnB1c2goMSk6bC5wdXNoKHgpfSk7bGV0IF89bC5sZW5ndGgseT1DLnNpemUobCk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTp4PT57bGV0ICQ9W10sdj1FKFwiX0FcIixyWzBdLmRhdGFUeXBlLG0pLFM9TShcIm91dHB1dFwiLGksXyksVD1uKHYsUyx1KSxBPVRbMl07Zm9yKGxldCBrPTAsUD0wO2s8bTtrKyspaHx8dS5pbmRleE9mKGspPj0wPyhhJiZQKyssQT1gZm9yKHZhciBqJHtrfTogdTMyID0gMDsgaiR7a30gPCAke3Bba119OyBqJHtrfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke1RbMl0uaW5jbHVkZXMoXCJsYXN0X2luZGV4XCIpP2BsZXQgbGFzdF9pbmRleCA9IGoke2t9O2A6XCJcIn1cbiAgICAgICAgICAgICAgICAgICR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGssYGoke2t9YCl9XG4gICAgICAgICAgICAgICAgICAke0F9XG4gICAgICAgICAgICAgICAgfWApOigkLnB1c2goYCR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGssUy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixQKSl9O2ApLFArKyk7cmV0dXJuYFxuXG4gICAgICAgICR7eC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModixTKX1cblxuICAgICAgICAke3gubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHt4Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHt2LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgJHskLmpvaW4oYFxuYCl9XG4gICAgICAgICAgJHtUWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke1RbMV19XG4gICAgICAgICAgJHtBfVxuICAgICAgICAgICR7VFszXX1cbiAgICAgICAgICAke1QubGVuZ3RoPT09ND9TLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6VC5zbGljZSg0KS5qb2luKGBcbmApfVxuICAgICAgICB9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnl9LC4uLk4ocCxsKV19KX19LGxvPShlLHQpPT57bGV0IHI9W107cmV0dXJuIGVbMV0uZGltc1swXT4wJiZlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKSxyZSh7YXhlczpyLGtlZXBEaW1zOnQua2VlcERpbXMsbm9vcFdpdGhFbXB0eUF4ZXM6dC5ub29wV2l0aEVtcHR5QXhlc30pfSxvdD0oZSx0LHIsbik9PntsZXQgbz1lLmlucHV0cyxpPW8ubGVuZ3RoPT09MT9yOmxvKG8scik7ZS5jb21wdXRlKEhyKHQse2hpbnQ6aS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbb1swXV0saS5ub29wV2l0aEVtcHR5QXhlcyYmaS5heGVzLmxlbmd0aD09PTA/U206bixpLmF4ZXMsb1swXS5kYXRhVHlwZSxpLmtlZXBEaW1zLGkubm9vcFdpdGhFbXB0eUF4ZXMpLHtpbnB1dHM6WzBdfSl9LFRtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMb2dTdW1cIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sSW09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZUwxXCIsdCwobixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGFicygke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl0pfSxDbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTDJcIix0LChuLG8pPT5bYHZhciB0ID0gJHtvLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9OyB2YWx1ZSArPSAodCAqIHQpO2AsXCJ2YWx1ZSA9IHNxcnQodmFsdWUpO1wiXSl9LEFtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMb2dTdW1FeHBcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gZXhwKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxrbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWF4XCIsdCwobixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChuLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCwwKSk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtYXgodmFsdWUsICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSxFbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWVhblwiLHQsKG4sbyxpKT0+e2xldCBhPTE7Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJihhKj1lLmlucHV0c1swXS5kaW1zW2RdKTtyZXR1cm5bXCJ2YXIgc3VtID0gZjMyKDApO1wiLFwiXCIsYHN1bSArPSBmMzIoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLGBsZXQgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oc3VtIC8gJHthfSk7YF19KX0sUG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZU1pblwiLHQsKG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sem09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZVByb2RcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSxPbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlU3VtXCIsdCwobixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0sRG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKG4sbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSxpdD0oZSx0LHIpPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiByO2xldCBuPTEsbz0xO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXQuaW5kZXhPZihpKT09PS0xP24qPWVbaV06byo9ZVtpXTtyZXR1cm4gbzwzMiYmbj4xMDI0fSx5cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0VtKGUsdCk6c3MoZSx0KX0sX3M9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9JbShlLHQpOnVzKGUsdCl9LHdzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Q20oZSx0KTpkcyhlLHQpfSx2cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0FtKGUsdCk6bHMoZSx0KX0sJHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9rbShlLHQpOmNzKGUsdCl9LHhzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/UG0oZSx0KTpwcyhlLHQpfSxTcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3ptKGUsdCk6bXMoZSx0KX0sVHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9PbShlLHQpOmZzKGUsdCl9LElzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/RG0oZSx0KTpocyhlLHQpfSxDcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP1RtKGUsdCk6Z3MoZSx0KX19KTt2YXIgQXMsa3MsRXMsY28sUHM9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7U2UoKTtHcigpO0FzPWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkFyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LGtzPShlLHQpPT57QXMoZS5pbnB1dHMpO2xldCByPShuLG8saSk9PntsZXQgYT1bXTtmb3IobGV0IGQ9MDtkPG4ucmFuaztkKyspKGkuaW5kZXhPZihkKT49MHx8aS5sZW5ndGg9PT0wKSYmYS5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7ZH1dID0gMDtgKTtyZXR1cm5bYCR7YS5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIjw9XCI6XCI8XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXCJcIixvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShIcihcIkFyZ01pblwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxyLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sRXM9KGUsdCk9PntBcyhlLmlucHV0cyk7bGV0IHI9KG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPj1cIjpcIj5cIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcIlwiLG8uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKEhyKFwiYXJnTWF4XCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLHIsW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxjbz1lPT5yZShlKX0pO3ZhciBCbSxwbyxNbSxSbSxVbSxSdCxObSx6cyxGcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO05yKCk7YWUoKTtCbT0oZSx0KT0+e2xldCByPWVbMF0sbj1lWzFdLG89ZVsyXSxpPWVbM10sYT1lWzRdLGQ9ZVs1XTtpZihhJiZkKXRocm93IG5ldyBFcnJvcihcIkF0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtsZXQgbD1yLmRpbXNbMF0scD1yLmRpbXNbMV0sbT1yLmRpbXNbMl07aWYoby5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO2lmKG4uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ3ZWlnaHRzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1tKXRocm93IG5ldyBFcnJvcihcIklucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMFwiKTtpZihvLmRpbXNbMF0hPT1uLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO2xldCB1PW8uZGltc1swXS8zLGg9dSxfPWg7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGg+MCl7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHNcIik7Zm9yKGxldCBTIG9mIHQucWt2SGlkZGVuU2l6ZXMpaWYoUyV0Lm51bUhlYWRzIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzXCIpO3U9dC5xa3ZIaWRkZW5TaXplc1swXSxoPXQucWt2SGlkZGVuU2l6ZXNbMV0sXz10LnFrdkhpZGRlblNpemVzWzJdfWxldCB5PXA7aWYodSE9PWgpdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmRcIik7aWYoby5kaW1zWzBdIT09dStoK18pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7bGV0IGc9MDtpZihhKXtpZihoIT09Xyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtpZihhLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnMnKTtpZihhLmRpbXNbMF0hPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO2lmKGEuZGltc1sxXSE9PWwpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBzZWNvbmQgZGltZW5zaW9uIG11c3QgYmUgYmF0Y2hfc2l6ZScpO2lmKGEuZGltc1syXSE9PXQubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtpZihhLmRpbXNbNF0hPT1oL3QubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7dC5wYXN0UHJlc2VudFNoYXJlQnVmZmVyfHwoZz1hLmRpbXNbM10pfWxldCB4PXkrZywkPS0xLHY9MDtpZihpKXRocm93IG5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKTtpZihhKXRocm93IG5ldyBFcnJvcihcInBhc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihkKXtpZihkLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBtdXN0IGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoZC5kaW1zWzBdIT09bHx8ZC5kaW1zWzFdIT09dC5udW1IZWFkc3x8ZC5kaW1zWzJdIT09cHx8ZC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTpsLHNlcXVlbmNlTGVuZ3RoOnAscGFzdFNlcXVlbmNlTGVuZ3RoOmcsa3ZTZXF1ZW5jZUxlbmd0aDp5LHRvdGFsU2VxdWVuY2VMZW5ndGg6eCxtYXhTZXF1ZW5jZUxlbmd0aDokLGlucHV0SGlkZGVuU2l6ZTptLGhpZGRlblNpemU6dSx2SGlkZGVuU2l6ZTpfLGhlYWRTaXplOk1hdGguZmxvb3IodS90Lm51bUhlYWRzKSx2SGVhZFNpemU6TWF0aC5mbG9vcihfL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTp2LHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6ITEscWt2Rm9ybWF0OjF9fSxwbz0oZSx0LHIpPT50JiZlP2BcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0LmdldEJ5T2Zmc2V0KFwiMFwiKX0pO1xuICAgICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gbWF4KHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpO1xuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtlPy5nZXRCeU9mZnNldChcImJhdGNoSWR4XCIpfSkgKyAxO1xuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xuICAgICAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCAtIHNlcXVlbmNlX2xlbmd0aDtcbiAgICAgIH1cbiAgICAgICBgOmBcbiAgICAke3I/XCJsZXQgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aFwiOlwiXCJ9O1xuICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBgLE1tPShlLHQscixuLG8saSxhLGQpPT57bGV0IGw9bWUoYT8xOmkpLHA9NjQsbT1pL2w7bTxwJiYocD0zMik7bGV0IHU9TWF0aC5jZWlsKGkvbC9wKSxoPVt7dHlwZToxMixkYXRhOnR9LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6bX0se3R5cGU6MTIsZGF0YTp1fV0sXz1fZShlLmRhdGFUeXBlLGwpLHk9RWUoMSxsKSxnPVtcInR5cGVcIl07YSYmZy5wdXNoKFwidHlwZVwiKSxkJiZnLnB1c2goXCJ0eXBlXCIpO2xldCB4PSQ9PntsZXQgdj1NKFwieFwiLGUuZGF0YVR5cGUsZS5kaW1zLGwpLFM9W3ZdLFQ9YT9FKFwic2VxX2xlbnNcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO1QmJlMucHVzaChUKTtsZXQgQT1kP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO0EmJlMucHVzaChBKTtsZXQgaz1FZShlLmRhdGFUeXBlKSxQPVt7bmFtZTpcImJhdGNoX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInNlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZWxlbWVudHNfcGVyX3RocmVhZFwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX21heDogYXJyYXk8ZjMyLCAke3B9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke3B9PjtcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5TKX1cbiAgJHskLm1haW5TdGFydChbcCwxLDFdKX1cbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICAke3BvKFQsQSwhMSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtwfSkgKiB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGggKyBsb2NhbF9vZmZzZXQ7XG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHthP1widTMyKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgd29ya2dyb3VwX2lkLnkgKyAxKVwiOlwidG90YWxfc2VxdWVuY2VfbGVuZ3RoXCJ9O1xuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7eX0oLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke3l9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpPT57c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5cInRocmVhZF9tYXhfdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwibWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpXCI7Y2FzZSA0OnJldHVyblwibWF4KG1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSwgbWF4KHRocmVhZF9tYXhfdmVjdG9yLnosIHRocmVhZF9tYXhfdmVjdG9yLncpKVwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIG1heF92YWx1ZSA9ICBmMzIoLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7cH07IGkrKykge1xuICAgICAgbWF4X3ZhbHVlID0gbWF4KHRocmVhZF9tYXhbaV0sIG1heF92YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bV92ZWN0b3IgPSAke3l9KDApO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke3l9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwic3VtX3ZlY3RvclwiO2Nhc2UgMjpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueVwiO2Nhc2UgNDpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSArIHN1bV92ZWN0b3IueiArIHN1bV92ZWN0b3Iud1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgIHN1bSArPSB0aHJlYWRfc3VtW2ldO1xuICAgIH1cblxuICAgIGlmIChzdW0gPT0gMCkge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7di50eXBlLnZhbHVlfSgke2t9KDEuMCkgLyAke2t9KHNlcV9jYXVzYWxfbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmMzJpbnB1dCA9ICR7eX0oeFtvZmZzZXQgKyBpXSk7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke3YudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICAgICAgJHthP2BcbiAgICAgICAgZm9yICh2YXIgdG90YWxfc2VxX2lkOiB1MzIgPSBzZXFfY2F1c2FsX2xlbmd0aDsgdG90YWxfc2VxX2lkICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoOyB0b3RhbF9zZXFfaWQrKykge1xuICAgICAgICAgIHhbb2Zmc2V0ICsgdG90YWxfc2VxX2lkXSA9ICR7di50eXBlLnZhbHVlfSgke2t9KDApKTtcbiAgICAgICAgfWA6XCJcIn07XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9OyR7X307JHtsfWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0U2hhZGVyU291cmNlOngsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltdLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvcCkseTpvLHo6dCpyfSxwcm9ncmFtVW5pZm9ybXM6aH0pfX0sUm09KGUsdCxyLG4sbyxpLGEsZCxsKT0+e2xldCBwPWEraS5rdlNlcXVlbmNlTGVuZ3RoLG09W2kuYmF0Y2hTaXplLGkubnVtSGVhZHMsaS5zZXF1ZW5jZUxlbmd0aCxwXSx1PWU+MSYmbixoPWkua3ZOdW1IZWFkcz9pLmt2TnVtSGVhZHM6aS5udW1IZWFkcyxfPXU/W2kuYmF0Y2hTaXplLGgscCxpLmhlYWRTaXplXTp2b2lkIDAseT1pLm5SZXBzP2kublJlcHM6MSxnPWkuc2NhbGU9PT0wPzEvTWF0aC5zcXJ0KGkuaGVhZFNpemUpOmkuc2NhbGUseD1tZShpLmhlYWRTaXplKSwkPWkuaGVhZFNpemUveCx2PTEyLFM9e3g6TWF0aC5jZWlsKHAvdikseTpNYXRoLmNlaWwoaS5zZXF1ZW5jZUxlbmd0aC92KSx6OmkuYmF0Y2hTaXplKmkubnVtSGVhZHN9LFQ9W3t0eXBlOjEyLGRhdGE6aS5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6aS5udW1IZWFkc30se3R5cGU6MTIsZGF0YTppLmhlYWRTaXplfSx7dHlwZToxLGRhdGE6Z30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOmkua3ZTZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTp5fV0sQT11JiZuJiZDLnNpemUobi5kaW1zKT4wLGs9W1widHlwZVwiLFwidHlwZVwiXTtBJiZrLnB1c2goXCJ0eXBlXCIpLG8mJmsucHVzaChcInR5cGVcIiksZCYmay5wdXNoKFwidHlwZVwiKSxsJiZrLnB1c2goXCJ0eXBlXCIpO2xldCBQPVt7ZGltczptLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO3UmJlAucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBEPVI9PntsZXQgRz1FKFwicVwiLHQuZGF0YVR5cGUsdC5kaW1zLHgpLEs9RShcImtleVwiLHIuZGF0YVR5cGUsci5kaW1zLHgpLGo9W0csS107aWYoQSl7bGV0IG5lPUUoXCJwYXN0X2tleVwiLG4uZGF0YVR5cGUsbi5kaW1zLHgpO2oucHVzaChuZSl9byYmai5wdXNoKEUoXCJhdHRlbnRpb25fYmlhc1wiLG8uZGF0YVR5cGUsby5kaW1zKSk7bGV0IFY9ZD9FKFwic2VxX2xlbnNcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO1YmJmoucHVzaChWKTtsZXQgUT1sP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixsLmRhdGFUeXBlLGwuZGltcyk6dm9pZCAwO1EmJmoucHVzaChRKTtsZXQgc2U9TShcIm91dHB1dFwiLHQuZGF0YVR5cGUsbSksWT1bc2VdO3UmJlkucHVzaChNKFwicHJlc2VudF9rZXlcIix0LmRhdGFUeXBlLF8seCkpO2xldCBlZT1FZSgxLHgpLEo9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3Z9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtHLnR5cGUuc3RvcmFnZX0sICR7dip2fT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke0cudHlwZS5zdG9yYWdlfSwgJHt2KnZ9PjtcbiAgJHtSLnJlZ2lzdGVyVW5pZm9ybXMoSikuZGVjbGFyZVZhcmlhYmxlcyguLi5qLC4uLlkpfVxuICAke1IubWFpblN0YXJ0KFt2LHYsMV0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBrdkhlYWRJZHggPSAke3k9PT0xP1wiaGVhZElkeFwiOlwiaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgICBsZXQga3ZfbnVtX2hlYWRzID0gJHt5PT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTjtcbiAgICAke3BvKFYsUSwhMCl9XG4gICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4O1xuICAgIGxldCBxT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgICR7QSYmdT9cImxldCBwYXN0S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9O1xuICAgIGxldCBrT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcbiAgICAke3U/XCJsZXQgcHJlc2VudEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9XG4gICAgdmFyIHZhbHVlID0gJHtlZX0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAkeygoKT0+QSYmdT9gXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA6YFxuICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgfWApKCl9XG4gICAgICAke3U/YGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgIHByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07XG4gICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSArPSAke2VlfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgbGV0IGhlYWRPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpPT57c3dpdGNoKHgpe2Nhc2UgMTpyZXR1cm5cInZhbHVlXCI7Y2FzZSAyOnJldHVyblwidmFsdWUueCArIHZhbHVlLnlcIjtjYXNlIDQ6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7eH1gKX19KSgpfTtcbiAgICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke3NlLnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke28/XCJhdHRlbnRpb25fYmlhc1tvdXRwdXRJZHhdXCI6XCIwLjBcIn07XG4gICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25Qcm9ic1wiLHNoYWRlckNhY2hlOntoaW50OmAke3h9OyR7byE9PXZvaWQgMH07JHtuIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczprfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6UCxkaXNwYXRjaEdyb3VwOlMscHJvZ3JhbVVuaWZvcm1zOlR9KSxnZXRTaGFkZXJTb3VyY2U6RH19LFVtPShlLHQscixuLG8saSxhPXZvaWQgMCxkPXZvaWQgMCk9PntsZXQgbD1pK28ua3ZTZXF1ZW5jZUxlbmd0aCxwPW8ublJlcHM/by5uUmVwczoxLG09by52SGlkZGVuU2l6ZSpwLHU9ZT4xJiZuLGg9by5rdk51bUhlYWRzP28ua3ZOdW1IZWFkczpvLm51bUhlYWRzLF89dT9bby5iYXRjaFNpemUsaCxsLG8uaGVhZFNpemVdOnZvaWQgMCx5PVtvLmJhdGNoU2l6ZSxvLnNlcXVlbmNlTGVuZ3RoLG1dLGc9MTIseD17eDpNYXRoLmNlaWwoby52SGVhZFNpemUvZykseTpNYXRoLmNlaWwoby5zZXF1ZW5jZUxlbmd0aC9nKSx6Om8uYmF0Y2hTaXplKm8ubnVtSGVhZHN9LCQ9W3t0eXBlOjEyLGRhdGE6by5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOm8udkhlYWRTaXplfSx7dHlwZToxMixkYXRhOm8ubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6by5oZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTptfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6by5rdlNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOnB9XSx2PXUmJm4mJkMuc2l6ZShuLmRpbXMpPjAsUz1bXCJ0eXBlXCIsXCJ0eXBlXCJdO3YmJlMucHVzaChcInR5cGVcIiksYSYmUy5wdXNoKFwidHlwZVwiKSxkJiZTLnB1c2goXCJ0eXBlXCIpO2xldCBUPVt7ZGltczp5LGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO3UmJlQucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBBPWs9PntsZXQgUD1FKFwicHJvYnNcIix0LmRhdGFUeXBlLHQuZGltcyksRD1FKFwidlwiLHIuZGF0YVR5cGUsci5kaW1zKSxSPVtQLERdO3YmJlIucHVzaChFKFwicGFzdF92YWx1ZVwiLG4uZGF0YVR5cGUsbi5kaW1zKSk7bGV0IEc9YT9FKFwic2VxX2xlbnNcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO2EmJlIucHVzaChHKTtsZXQgSz1kP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO2QmJlIucHVzaChLKTtsZXQgVj1bTShcIm91dHB1dFwiLHQuZGF0YVR5cGUseSldO3UmJlYucHVzaChNKFwicHJlc2VudF92YWx1ZVwiLHQuZGF0YVR5cGUsXykpO2xldCBRPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwidl9oaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2d9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7UC50eXBlLnZhbHVlfSwgJHtnKmd9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVY6IGFycmF5PCR7UC50eXBlLnZhbHVlfSwgJHtnKmd9PjtcbiAgJHtrLnJlZ2lzdGVyVW5pZm9ybXMoUSkuZGVjbGFyZVZhcmlhYmxlcyguLi5SLC4uLlYpfVxuICAke2subWFpblN0YXJ0KFtnLGcsMV0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGt2SGVhZElkeCA9ICR7cD09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IGt2X251bV9oZWFkcyA9ICR7cD09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcbiAgICR7cG8oRyxLLCEwKX1cbiAgIGxldCBvZmZzZXRBID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXG4gICAke3YmJnU/XCJsZXQgcGFzdFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgbjtcIjpcIlwifTtcbiAgIGxldCB2T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCArIG47XG4gICAke3U/XCJsZXQgcHJlc2VudFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKyBuO1wiOlwiXCJ9XG4gICB2YXIgdmFsdWUgPSAke1AudHlwZS5zdG9yYWdlfSgwKTtcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgICAkeygoKT0+diYmdT9gXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2UgaWYgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH1cbiAgICAgIGA6YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgICAgICB9YCkoKX1cbiAgICAgICAgJHt1P2BcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgcHJlc2VudF92YWx1ZVtwcmVzZW50VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl0gPSB0aWxlVltpZHhdO1xuICAgICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZVZbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uU2NvcmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtuIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczpTfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOngscHJvZ3JhbVVuaWZvcm1zOiR9KSxnZXRTaGFkZXJTb3VyY2U6QX19LFJ0PShlLHQscixuLG8saSxhLGQsbCxwLG09dm9pZCAwLHU9dm9pZCAwKT0+e2xldCBoPU1hdGgubWluKGUub3V0cHV0Q291bnQsMSsoYT8xOjApKyhkPzE6MCkpLF89aD4xP3AucGFzdFNlcXVlbmNlTGVuZ3RoOjAseT1fK3Aua3ZTZXF1ZW5jZUxlbmd0aCxnPWwmJkMuc2l6ZShsLmRpbXMpPjA/bDp2b2lkIDAseD1bdCxyXTtoPjEmJmEmJkMuc2l6ZShhLmRpbXMpPjAmJngucHVzaChhKSxnJiZ4LnB1c2goZyksbSYmeC5wdXNoKG0pLHUmJngucHVzaCh1KTtsZXQgJD1lLmNvbXB1dGUoUm0oaCx0LHIsYSxnLHAsXyxtLHUpLHtpbnB1dHM6eCxvdXRwdXRzOmg+MT9bLTEsMV06Wy0xXX0pWzBdO2UuY29tcHV0ZShNbSgkLHAuYmF0Y2hTaXplLHAubnVtSGVhZHMsXyxwLnNlcXVlbmNlTGVuZ3RoLHksbSx1KSx7aW5wdXRzOm0mJnU/WyQsbSx1XTpbJF0sb3V0cHV0czpbXX0pO2xldCB2PVskLG5dO2g+MSYmZCYmQy5zaXplKGQuZGltcyk+MCYmdi5wdXNoKGQpLG0mJnYucHVzaChtKSx1JiZ2LnB1c2godSksZS5jb21wdXRlKFVtKGgsJCxuLGQscCxfLG0sdSkse2lucHV0czp2LG91dHB1dHM6aD4xP1swLDJdOlswXX0pfSxObT0oZSx0KT0+e2xldCByPVt0LmJhdGNoU2l6ZSx0Lm51bUhlYWRzLHQuc2VxdWVuY2VMZW5ndGgsdC5oZWFkU2l6ZV0sbj10LnNlcXVlbmNlTGVuZ3RoLG89dC5pbnB1dEhpZGRlblNpemUsaT10LmhlYWRTaXplLGE9MTIsZD17eDpNYXRoLmNlaWwodC5oZWFkU2l6ZS9hKSx5Ok1hdGguY2VpbCh0LnNlcXVlbmNlTGVuZ3RoL2EpLHo6dC5iYXRjaFNpemUqdC5udW1IZWFkc30sbD1bZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLHA9W3t0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6dC5udW1IZWFkc30se3R5cGU6MTIsZGF0YTp0LmhlYWRTaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZX0se3R5cGU6MTIsZGF0YTp0LmhpZGRlblNpemUrdC5oaWRkZW5TaXplK3QudkhpZGRlblNpemV9XSxtPXU9PntsZXQgaD1NKFwib3V0cHV0X3FcIixsWzBdLmRhdGFUeXBlLHIpLF89TShcIm91dHB1dF9rXCIsbFswXS5kYXRhVHlwZSxyKSx5PU0oXCJvdXRwdXRfdlwiLGxbMF0uZGF0YVR5cGUsciksZz1FKFwiaW5wdXRcIixsWzBdLmRhdGFUeXBlLGxbMF0uZGltcykseD1FKFwid2VpZ2h0XCIsbFsxXS5kYXRhVHlwZSxsWzFdLmRpbXMpLCQ9RShcImJpYXNcIixsWzJdLmRhdGFUeXBlLGxbMl0uZGltcyksdj1nLnR5cGUuc3RvcmFnZSxTPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibGRiXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2F9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHt2fSwgJHthKmF9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7dn0sICR7YSphfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICAke3UucmVnaXN0ZXJVbmlmb3JtcyhTKS5kZWNsYXJlVmFyaWFibGVzKGcseCwkLGgsXyx5KX1cbiAgJHt1Lm1haW5TdGFydChbYSxhLDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZUsgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke3Z9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkF0dGVudGlvblByZXBhcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOnIsZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6cixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDpkLHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOm19LHtpbnB1dHM6bCxvdXRwdXRzOlstMSwtMSwtMV19KX0senM9KGUsdCk9PntsZXQgcj1CbShlLmlucHV0cyx0KSxbbixvLGldPU5tKGUscik7cmV0dXJuIFJ0KGUsbixvLGksZS5pbnB1dHNbNF0sdm9pZCAwLHZvaWQgMCx2b2lkIDAsZS5pbnB1dHNbNV0scil9fSk7dmFyIFZtLFdtLExtLE9zLERzPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7b2UoKTtTZSgpO2FlKCk7Vm09KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0c1wiKTtsZXQgcj0obixvLGkpPT57bGV0IGE9by5sZW5ndGg7aWYoYSE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgJHtpfTogbnVtIGRpbWVuc2lvbnMgIT0gJHthfWApO28uZm9yRWFjaCgoZCxsKT0+e2lmKGQhPT1uW2xdKXRocm93IG5ldyBFcnJvcihgJHtpfTogZGltWyR7bH1dIGRvIG5vdCBtYXRjaGApfSl9O2lmKGVbMF0uZGltcy5sZW5ndGg+MSl7bGV0IG49dC5mb3JtYXQ9PT1cIk5IV0NcIj90LnNwYXRpYWw/ZVswXS5kaW1zLnNsaWNlKC0xKTplWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChlWzBdLmRpbXMuc2xpY2UoMSxlWzBdLmRpbXMubGVuZ3RoLTEpKTplWzBdLmRpbXMuc2xpY2UoMSx0LnNwYXRpYWw/Mjp2b2lkIDApO3IoZVsxXS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLHIoZVsyXS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IEJcIikscihlWzNdLmRpbXMsbixcIkludmFsaWQgaW5wdXQgbWVhblwiKSxyKGVbNF0uZGltcyxuLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9ZWxzZSByKGVbMV0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLHIoZVsyXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgQlwiKSxyKGVbM10uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IG1lYW5cIikscihlWzRdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9LFdtPShlLHQpPT57bGV0e2Vwc2lsb246cixzcGF0aWFsOm4sZm9ybWF0Om99PXQsaT1lWzBdLmRpbXMsYT1uP21lKGlbaS5sZW5ndGgtMV0pOjEsZD1vPT09XCJOSFdDXCImJmkubGVuZ3RoPjE/YToxLGw9Qy5zaXplKGkpL2EscD1uLG09cD9pLmxlbmd0aDppLHU9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyxhKSxoPUUoXCJzY2FsZVwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLGQpLF89RShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxkKSx5PUUoXCJpbnB1dE1lYW5cIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyxkKSxnPUUoXCJpbnB1dFZhclwiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLGQpLHg9TShcInlcIixlWzBdLmRhdGFUeXBlLG0sYSksJD0oKT0+e2xldCBTPVwiXCI7aWYobilTPWBsZXQgY09mZnNldCA9ICR7aS5sZW5ndGg9PT0xP1wiMHVcIjpvPT09XCJOSFdDXCI/YG91dHB1dEluZGljZXNbJHtpLmxlbmd0aC0xfV0gLyAke2F9YDpcIm91dHB1dEluZGljZXNbMV1cIn07YDtlbHNlIGlmKG89PT1cIk5DSFdcIilTPWBcbiAgICAgICAgICAgICR7eC5pbmRpY2VzU2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiMFwiLFwiMFwiKX1cbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHt4LmluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIil9O2A7ZWxzZXtTPWB2YXIgY0luZGljZXMgPSAke2gudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7aS5sZW5ndGgtMX1dO2A7Zm9yKGxldCBUPTE7VDxoLnJhbms7VCsrKVMrPWBjSW5kaWNlc1ske1R9XSA9IG91dHB1dEluZGljZXNbJHtUfV07YDtTKz1gbGV0IGNPZmZzZXQgPSAke2guaW5kaWNlc1RvT2Zmc2V0KFwiY0luZGljZXNcIil9O2B9cmV0dXJuIFN9LHY9Uz0+YFxuICBjb25zdCBlcHNpbG9uID0gJHtyfTtcbiAgJHtTLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHUsaCxfLHksZyx4KX1cbiAgJHtTLm1haW5TdGFydCgpfVxuICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgdmFyIG91dHB1dEluZGljZXMgPSAke3gub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHthfWApfTtcbiAgICAkeyQoKX1cbiAgICBsZXQgc2NhbGUgPSAke2guZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgYmlhcyA9ICR7Xy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dE1lYW4gPSAke3kuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgaW5wdXRWYXIgPSAke2cuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgeCA9ICR7dS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XG4gICAgJHt4LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gO3JldHVybntuYW1lOlwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5lcHNpbG9ufV8ke3QuZm9ybWF0fV8ke259XyR7YX1gLGlucHV0RGVwZW5kZW5jaWVzOnA/W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXTp2b2lkIDB9LGdldFNoYWRlclNvdXJjZTp2LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnA/W3t0eXBlOjEyLGRhdGE6bH0sLi4uTihpKV06W3t0eXBlOjEyLGRhdGE6bH1dfSl9fSxMbT1lPT5yZShlKSxPcz0oZSx0KT0+e2xldHtpbnB1dHM6cixvdXRwdXRDb3VudDpufT1lLG89TG0oey4uLnQsb3V0cHV0Q291bnQ6bn0pO2lmKHZlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmVm0ocixvKSx0LnRyYWluaW5nTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gdHJhaW5pbmdNb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtlLmNvbXB1dGUoV20ocixvKSl9fSk7dmFyIEdtLEhtLEJzLE1zPVUoKCk9PntcInVzZSBzdHJpY3RcIjtvZSgpO2FlKCk7R209ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzMyMCw2NDAsMTI4MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sSG09ZT0+e2xldCB0PWVbMF0uZGltcyxyPWVbMF0uZGltc1syXSxuPUMuc2l6ZSh0KS80LG89ZVswXS5kYXRhVHlwZSxpPUUoXCJpbnB1dFwiLG8sdCw0KSxhPUUoXCJiaWFzXCIsbyxbcl0sNCksZD1FKFwicmVzaWR1YWxcIixvLHQsNCksbD1NKFwib3V0cHV0XCIsbyx0LDQpO3JldHVybntuYW1lOlwiQmlhc0FkZFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9fSksZ2V0U2hhZGVyU291cmNlOm09PmBcbiAgY29uc3QgY2hhbm5lbHMgPSAke3J9dSAvIDQ7XG4gICR7bS5kZWNsYXJlVmFyaWFibGVzKGksYSxkLGwpfVxuXG4gICR7bS5tYWluU3RhcnQoKX1cbiAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhuKX1cbiAgICBsZXQgdmFsdWUgPSAke2kuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfVxuICAgICAgKyAke2EuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgY2hhbm5lbHNcIil9ICsgJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfX0sQnM9ZT0+e0dtKGUuaW5wdXRzKSxlLmNvbXB1dGUoSG0oZS5pbnB1dHMpKX19KTt2YXIgRm0sZmUsUnMsVXMsTnMsVnMsV3MsTHMsR3MsSHMsRnMscW0scXMsS3MsanMsWXMsWHQsWnMscXIsUXMsWHMsSnMsZXUsdHUscnUsbnUsb3UsaXUsYXUsc3UsdXUsZHUsbHUsY3UscHUsbXUsZnUsbW8sZm8saHUsZ3UsYnUsS20sam0seXUsS3I9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7Rm09KGUsdCxyLG4sbyxpLGEpPT57bGV0IGQ9TWF0aC5jZWlsKHQvNCksbD1cIlwiO3R5cGVvZiBvPT1cInN0cmluZ1wiP2w9YCR7b30oYSlgOmw9byhcImFcIik7bGV0IHA9RShcImlucHV0RGF0YVwiLHIsW2RdLDQpLG09TShcIm91dHB1dERhdGFcIixuLFtkXSw0KSx1PVt7bmFtZTpcInZlY19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuIGEmJnUucHVzaCguLi5hKSxgXG4gICAgICAke2UucmVnaXN0ZXJVbmlmb3Jtcyh1KS5kZWNsYXJlVmFyaWFibGVzKHAsbSl9XG5cbiAgJHtpPz9cIlwifVxuXG4gICR7ZS5tYWluU3RhcnQoKX1cbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuXG4gICAgbGV0IGEgPSAke3AuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke20uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbCl9XG4gIH1gfSxmZT0oZSx0LHIsbixvLGk9ZS5kYXRhVHlwZSxhLGQpPT57bGV0IGw9W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKEMuc2l6ZShlLmRpbXMpLzQpfV07cmV0dXJuIGEmJmwucHVzaCguLi5hKSx7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50Om8saW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnA9PkZtKHAsQy5zaXplKGUuZGltcyksZS5kYXRhVHlwZSxpLHIsbixkKSxnZXRSdW5EYXRhOnA9Pih7b3V0cHV0czpbe2RpbXM6ZS5kaW1zLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUocFswXS5kaW1zKS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOmx9KX19LFJzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LFVzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBY29zXCIsXCJhY29zXCIpKX0sTnM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LFZzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sV3M9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFzaW5oXCIsXCJhc2luaFwiKSl9LExzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBdGFuXCIsXCJhdGFuXCIpKX0sR3M9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LEhzPWU9PnJlKGUpLEZzPShlLHQpPT57bGV0IHI7c3dpdGNoKHQudG8pe2Nhc2UgMTA6cj1cInZlYzQ8ZjE2PlwiO2JyZWFrO2Nhc2UgMTpyPVwidmVjNDxmMzI+XCI7YnJlYWs7Y2FzZSAxMjpyPVwidmVjNDx1MzI+XCI7YnJlYWs7Y2FzZSA2OnI9XCJ2ZWM0PGkzMj5cIjticmVhaztjYXNlIDk6cj1cInZlYzQ8Ym9vbD5cIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBSYW5nZUVycm9yKGBub3Qgc3VwcG9ydGVkIHR5cGUgKHNwZWNpZmllZCBpbiBhdHRyaWJ1dGUgJ3RvJyBmcm9tICdDYXN0JyBvcGVyYXRvcik6ICR7dC50b31gKX1lLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDYXN0XCIscix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LHFtPWU9PntsZXQgdCxyLG49ZS5sZW5ndGg+PTImJmVbMV0uZGF0YSE9PTAsbz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhIT09MDtzd2l0Y2goZVswXS5kYXRhVHlwZSl7Y2FzZSAxOnQ9bj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOi0zNDAyODIzNDY2Mzg1Mjg4NmUyMixyPW8/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTozNDAyODIzNDY2Mzg1Mjg4NmUyMjticmVhaztjYXNlIDEwOnQ9bj9lWzFdLmdldFVpbnQxNkFycmF5KClbMF06NjQ1MTEscj1vP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTozMTc0MzticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydCBkYXRhIHR5cGVcIil9cmV0dXJuIHJlKHttaW46dCxtYXg6cn0pfSxxcz0oZSx0KT0+e2xldCByPXR8fHFtKGUuaW5wdXRzKSxuPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDbGlwXCIsbz0+YGNsYW1wKCR7b30sIHZlYzQ8JHtufT4odW5pZm9ybXMubWluKSwgdmVjNDwke259Pih1bmlmb3Jtcy5tYXgpKWAsdm9pZCAwLHIuY2FjaGVLZXksdm9pZCAwLFt7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOnIubWlufSx7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOnIubWF4fV0sW3tuYW1lOlwibWluXCIsdHlwZTpufSx7bmFtZTpcIm1heFwiLHR5cGU6bn1dKSx7aW5wdXRzOlswXX0pfSxLcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LGpzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LFlzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0sWHQ9ZT0+cmUoZSksWnM9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiRWx1XCIsbj0+YGVsdV92ZjMyKCR7bn0pYCxgXG4gIGNvbnN0IGVsdV9hbHBoYV8gPSAke3J9KCR7dC5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtyfSkgLT4gJHtyfSB7XG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XG4gIH1cblxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PCR7cn0+KSAtPiB2ZWM0PCR7cn0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsdC5jYWNoZUtleSkpfSxxcj0oZT1cImYzMlwiKT0+YFxuY29uc3QgcjA6ICR7ZX0gPSAwLjMyNzU5MTE7XG5jb25zdCByMTogJHtlfSA9IDAuMjU0ODI5NTkyO1xuY29uc3QgcjI6ICR7ZX0gPSAtMC4yODQ0OTY3MzY7XG5jb25zdCByMzogJHtlfSA9IDEuNDIxNDEzNzQxO1xuY29uc3QgcjQ6ICR7ZX0gPSAtMS40NTMxNTIwMjc7XG5jb25zdCByNTogJHtlfSA9IDEuMDYxNDA1NDI5O1xuXG5mbiBlcmZfdmYzMih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IGFic3YgPSBhYnModik7XG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xufWAsUXM9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFcmZcIixyPT5gZXJmX3ZmMzIoJHtyfSlgLHFyKHQpKSl9LFhzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LEpzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSxldT1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkdlbHVcIixyPT5gMC41ICogJHtyfSAqICgxLjAgKyBlcmZfdmYzMigke3J9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLHFyKHQpKSl9LHR1PShlLHQpPT57bGV0IHI9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLG49PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke259LCAke259LCAke259ID49IHZlYzQ8JHtyfT4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7cn0oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LHJ1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LG51PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJOZWdcIix0PT5gLSR7dH1gKSl9LG91PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxpdT1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8JHt0fT4oMC4wKSwgJHtyfSwgJHtyfSA+IHZlYzQ8JHt0fT4oMC4wKSlgKSl9LGF1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsdD0+YCgxLjAgLyAoMS4wICsgZXhwKC0ke3R9KSkpYCkpfSxzdT1lPT5yZShlKSx1dT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJIYXJkU2lnbW9pZFwiLG49PmBtYXgodmVjNDwke3J9PigwLjApLCBtaW4odmVjNDwke3J9PigxLjApLCAke3QuYWxwaGF9ICogJHtufSArIHZlYzQ8JHtyfT4oJHt0LmJldGF9KSkpYCx2b2lkIDAsdC5jYWNoZUtleSkpfSxkdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2luXCIsXCJzaW5cIikpfSxsdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LGN1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0scHU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0sbXU9ZT0+YHNpZ24oJHtlfSkgKiAoMSAtIGV4cCgtMiAqIGFicygke2V9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHtlfSkpKWAsZnU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRhbmhcIixtdSkpfSxtbz0oZT1cImYzMlwiKT0+YFxuY29uc3QgZmFzdF9nZWx1X2E6ICR7ZX0gPSAwLjU7XG5jb25zdCBmYXN0X2dlbHVfYjogJHtlfSA9IDAuNzk3ODg0NTYwODAyODY1NDtcbmNvbnN0IGZhc3RfZ2VsdV9jOiAke2V9ID0gMC4wMzU2Nzc0MDgxMzYzMDAxMjU7XG5cbmZuIHRhbmhfdih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgcmV0dXJuICR7bXUoXCJ2XCIpfTtcbn1cbmAsZm89ZT0+YChmYXN0X2dlbHVfYSArIGZhc3RfZ2VsdV9hICogdGFuaF92KCR7ZX0gKiAoZmFzdF9nZWx1X2MgKiAke2V9ICogJHtlfSArIGZhc3RfZ2VsdV9iKSkpICogJHtlfWAsaHU9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJGYXN0R2VsdVwiLGZvLG1vKHQpLHZvaWQgMCxlLmlucHV0c1swXS5kYXRhVHlwZSkpfSxndT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtyZXR1cm4gZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIsbj0+YHNlbGVjdCh2ZWM0PCR7cn0+KDAuMCksICR7bn0sICR7bn0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtyfT4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMH0sYnU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX0sS209KGUsdCk9PmBcbmNvbnN0IGFscGhhID0gdmVjNDwke2V9Pigke3R9KTtcbmNvbnN0IG9uZSA9ICR7ZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke2V9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke2V9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmAsam09ZT0+YHF1aWNrX2dlbHVfaW1wbCgke2V9KWAseXU9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiUXVpY2tHZWx1XCIsam0sS20ocix0LmFscGhhKSx0LmNhY2hlS2V5LGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9fSk7dmFyIFltLFptLHd1LHZ1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtvZSgpO2FlKCk7S3IoKTtZbT1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxabT1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IHI9RShcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCksbj1FKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksbz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLGk9Qy5zaXplKHQpLzQsYT1fZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpsPT5gXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7ZVswXS5kaW1zWzJdLzQvMn11O1xuXG4gICR7bC5kZWNsYXJlVmFyaWFibGVzKHIsbixvKX1cblxuICAke3FyKGEpfVxuXG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhpKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke28uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XG4gIH1gfX0sd3U9ZT0+e1ltKGUuaW5wdXRzKSxlLmNvbXB1dGUoWm0oZS5pbnB1dHMpKX19KTt2YXIgUW0sWG0sYXQsJHUseHUsU3UsVHUsSXUsQ3UsQXUsa3UsRXUsUHUsenU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO1FtPShlLHQscixuLG8saSxhLGQsbCxwLG0sdSk9PntsZXQgaCxfO3R5cGVvZiBkPT1cInN0cmluZ1wiP2g9Xz0odixTKT0+YCR7ZH0oKCR7dn0pLCgke1N9KSlgOnR5cGVvZiBkPT1cImZ1bmN0aW9uXCI/aD1fPWQ6KGg9ZC5zY2FsYXIsXz1kLnZlY3Rvcik7bGV0IHk9TShcIm91dHB1dERhdGFcIixtLG4ubGVuZ3RoLDQpLGc9RShcImFEYXRhXCIsbCx0Lmxlbmd0aCw0KSx4PUUoXCJiRGF0YVwiLHAsci5sZW5ndGgsNCksJDtpZihvKWlmKGkpe2xldCB2PUMuc2l6ZSh0KT09PTEsUz1DLnNpemUocik9PT0xLFQ9dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MCxBPXIubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0lND09PTA7dnx8Uz8kPXkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyh2P2Ake2cudHlwZS52YWx1ZX0oJHtnLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOmcuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLFM/YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6eC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTokPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7Zy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhhfHxUP2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIik6YCR7Zy50eXBlLnZhbHVlfSgke2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIil9W29mZnNldEEgJSA0dV0pYCxhfHxBP3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIik6YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIil9W29mZnNldEIgJSA0dV0pYCkpfVxuICAgICAgICAgIGB9ZWxzZSAkPXkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhnLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSx4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCB2PShTLFQsQT1cIlwiKT0+e2xldCBrPWBhRGF0YVtpbmRleEEke1R9XVtjb21wb25lbnRBJHtUfV1gLFA9YGJEYXRhW2luZGV4QiR7VH1dW2NvbXBvbmVudEIke1R9XWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke1R9ID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtUfXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7VH0gPSAke2cuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke1R9YCx5KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7VH0gPSAke3guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke1R9YCx5KX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtUfSA9IG9mZnNldEEke1R9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtUfSA9IG9mZnNldEIke1R9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7VH0gPSBvZmZzZXRBJHtUfSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke1R9ID0gb2Zmc2V0QiR7VH0gJSA0dTtcbiAgICAgICAgICAgICR7U31bJHtUfV0gPSAke0F9KCR7aChrLFApfSk7XG4gICAgICAgICAgYH07bT09PTk/JD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dihcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOiQ9YFxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGcseCx5KX1cblxuICAgICAgICAke3U/P1wiXCJ9XG5cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAkeyR9XG4gICAgICB9YH0sWG09KGUsdCxyLG4sbyxpLGE9ci5kYXRhVHlwZSk9PntsZXQgZD1yLmRpbXMubWFwKGc9Pk51bWJlcihnKT8/MSksbD1uLmRpbXMubWFwKGc9Pk51bWJlcihnKT8/MSkscD0hQy5hcmVFcXVhbChkLGwpLG09ZCx1PUMuc2l6ZShkKSxoPSExLF89ITEseT1bcF07aWYocCl7bGV0IGc9dHQuY2FsY1NoYXBlKGQsbCwhMSk7aWYoIWcpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bT1nLnNsaWNlKCksdT1DLnNpemUobSk7bGV0IHg9Qy5zaXplKGQpPT09MSwkPUMuc2l6ZShsKT09PTEsdj1kLmxlbmd0aD4wJiZkW2QubGVuZ3RoLTFdJTQ9PT0wLFM9bC5sZW5ndGg+MCYmbFtsLmxlbmd0aC0xXSU0PT09MDt5LnB1c2goeCkseS5wdXNoKCQpLHkucHVzaCh2KSx5LnB1c2goUyk7bGV0IFQ9MTtmb3IobGV0IEE9MTtBPG0ubGVuZ3RoO0ErKyl7bGV0IGs9ZFtkLmxlbmd0aC1BXSxQPWxbbC5sZW5ndGgtQV07aWYoaz09PVApVCo9aztlbHNlIGJyZWFrfVQlND09PTA/KF89ITAsaD0hMCk6KHh8fCR8fHZ8fFMpJiYoaD0hMCl9ZWxzZSBoPSEwO3JldHVybiB5LnB1c2goaCkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDp0K3kubWFwKGc9PmcudG9TdHJpbmcoKSkuam9pbihcIl9cIiksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmc9PlFtKGcsZCxsLG0saCxwLF8sbyxyLmRhdGFUeXBlLG4uZGF0YVR5cGUsYSxpKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoQy5zaXplKG0pLzQpfSwuLi5OKGQsbCxtKV19KX19LGF0PShlLHQscixuLG8saSk9PntlLmNvbXB1dGUoWG0odCxvPz9cIlwiLGUuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLHIsbixpKSl9LCR1PWU9PnthdChlLFwiQWRkXCIsKHQscik9PmAke3R9KyR7cn1gKX0seHU9ZT0+e2F0KGUsXCJEaXZcIiwodCxyKT0+YCR7dH0vJHtyfWApfSxTdT1lPT57YXQoZSxcIkVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PT0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH09PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sVHU9ZT0+e2F0KGUsXCJNdWxcIiwodCxyKT0+YCR7dH0qJHtyfWApfSxJdT1lPT57bGV0IHQ9RShcImlucHV0XCIsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZS5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTthdChlLFwiUG93XCIse3NjYWxhcjoobixvKT0+YHBvd19jdXN0b20oJHtufSwke299KWAsdmVjdG9yOihuLG8pPT5gcG93X3ZlY3Rvcl9jdXN0b20oJHtufSwke299KWB9LGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XG4gICAgICBpZiAoYiA9PSAke3R9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0fShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R9PiwgYiA6IHZlYzQ8JHt0fT4pIC0+IHZlYzQ8JHt0fT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCl9LEN1PWU9PnthdChlLFwiU3ViXCIsKHQscik9PmAke3R9LSR7cn1gKX0sQXU9ZT0+e2F0KGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PiR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT4ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGt1PWU9PnthdChlLFwiTGVzc1wiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTwke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxFdT1lPT57YXQoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9Pj0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sUHU9ZT0+e2F0KGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTw9JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PD0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIGVmLHRmLHJmLG5mLE91LER1LEJ1PVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO2VmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7bGV0IHI9MCxuPWVbcl0sbz1uLmRhdGFUeXBlLGk9bi5kaW1zLmxlbmd0aDtlLmZvckVhY2goKGEsZCk9PntpZihkIT09cil7aWYoYS5kYXRhVHlwZSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYoYS5kaW1zLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTthLmRpbXMuZm9yRWFjaCgobCxwKT0+e2lmKHAhPT10JiZsIT09bi5kaW1zW3BdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfSl9fSl9LHRmPShlLHQpPT5gXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtlfXU+KCR7dH0pO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfTsgaSArPSAxdSApIHtcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbiAgfWAscmY9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxuPVtdO2ZvcihsZXQgbz0wO288cjsrK28pe2xldCBpPXQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZVtvXS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpKTtyPT09MT9uLnB1c2goaSk6bz09PTA/bi5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke299dSkgeyAke2l9IH1gKTpvPT09ci0xP24ucHVzaChgZWxzZSB7ICR7aX0gfWApOm4ucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke299KSB7ICR7aX0gfWApfXJldHVybiBuLmpvaW4oYFxuYCl9LG5mPShlLHQscixuKT0+e2xldCBvPUMuc2l6ZShyKSxpPW5ldyBBcnJheShlLmxlbmd0aCksYT1uZXcgQXJyYXkoZS5sZW5ndGgpLGQ9MCxsPVtdLHA9W10sbT1be3R5cGU6MTIsZGF0YTpvfV07Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDsrK2cpZCs9ZVtnXS5kaW1zW3RdLGlbZ109ZCxwLnB1c2goZVtnXS5kaW1zLmxlbmd0aCksYVtnXT1FKGBpbnB1dCR7Z31gLG4scFtnXSksbC5wdXNoKFwicmFua1wiKSxtLnB1c2goe3R5cGU6MTIsZGF0YTppW2ddfSk7Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDsrK2cpbS5wdXNoKC4uLk4oZVtnXS5kaW1zKSk7bS5wdXNoKC4uLk4ocikpO2xldCB1PU0oXCJvdXRwdXRcIixuLHIubGVuZ3RoKSxoPXUuaW5kaWNlc0dldChcImluZGljZXNcIix0KSxfPUFycmF5LmZyb20oQXJyYXkoaS5sZW5ndGgpLmtleXMoKSkubWFwKGc9PmB1bmlmb3Jtcy5zaXplSW5Db25jYXRBeGlzJHtnfWApLmpvaW4oXCIsXCIpLHk9Zz0+YFxuXG4gICR7KCgpPT57Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIik7Zm9yKGxldCB4PTA7eDxlLmxlbmd0aDt4KyspZy5yZWdpc3RlclVuaWZvcm0oYHNpemVJbkNvbmNhdEF4aXMke3h9YCxcInUzMlwiKTtyZXR1cm4gZy5kZWNsYXJlVmFyaWFibGVzKC4uLmEsdSl9KSgpfVxuXG4gICR7dGYoaS5sZW5ndGgsXyl9XG5cbiAgJHtnLm1haW5TdGFydCgpfVxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHt1Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7aH0pO1xuICAgIGlmIChpbnB1dEluZGV4ICE9IDB1KSB7XG4gICAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtpLmxlbmd0aH11Pigke199KTtcbiAgICAgICR7aH0gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7cmYoYSx1KX1cbiAgfWA7cmV0dXJue25hbWU6XCJDb25jYXRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6bH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6eX19LE91PShlLHQpPT57bGV0IHI9ZS5pbnB1dHMsbj1yWzBdLmRpbXMsbz1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG4ubGVuZ3RoKTtlZihyLG8pO2xldCBpPW4uc2xpY2UoKTtpW29dPXIucmVkdWNlKChkLGwpPT5kKyhsLmRpbXMubGVuZ3RoPm8/bC5kaW1zW29dOjApLDApO2xldCBhPXIuZmlsdGVyKGQ9PkMuc2l6ZShkLmRpbXMpPjApO2UuY29tcHV0ZShuZihhLG8saSxyWzBdLmRhdGFUeXBlKSx7aW5wdXRzOmF9KX0sRHU9ZT0+cmUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgcWUsS2UsamUsanIseXQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtxZT0oZSx0LHI9XCJmMzJcIik9Pntzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6cmV0dXJuYHZhbHVlID0gbWF4KHZhbHVlLCAke3R9KDAuMCkpO2A7Y2FzZVwiU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9ICgke3R9KDEuMCkgLyAoJHt0fSgxLjApICsgZXhwKC12YWx1ZSkpKTtgO2Nhc2VcIkNsaXBcIjpyZXR1cm5gdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt0fSgke3J9KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dH0oJHtyfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO2Nhc2VcIkhhcmRTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gbWF4KCR7dH0oMC4wKSwgbWluKCR7dH0oMS4wKSwgJHtyfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7cn0odW5pZm9ybXMuYmV0YSkpKTtgO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVybmB2YWx1ZSA9IHNlbGVjdCgke3J9KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlLCB2YWx1ZSwgdmFsdWUgPj0gJHt0fSgwLjApKTtgO2Nhc2VcIlRhbmhcIjpyZXR1cm5gbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO2Nhc2VcIlwiOnJldHVyblwiXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHtlLmFjdGl2YXRpb259YCl9fSxLZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5jbGlwTWF4fSx7dHlwZToxLGRhdGE6ZS5jbGlwTWlufSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0se3R5cGU6MSxkYXRhOmUuYmV0YX0pOmUuYWN0aXZhdGlvbj09PVwiTGVha3lSZWx1XCImJnQucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0pfSxqZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7bmFtZTpcImNsaXBfbWF4XCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImNsaXBfbWluXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0pfSxqcj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJIYXJkU2lnbW9pZFwiKXtsZXRbcixuXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8Wy4yLC41XTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOnIsYmV0YTpufX1lbHNlIGlmKHQ9PT1cIkNsaXBcIil7bGV0W3Isbl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFtlcyx0c107cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4Om4sY2xpcE1pbjpyfX1lbHNlIGlmKHQ9PT1cIkxlYWt5UmVsdVwiKXtsZXRbcl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMDFdO3JldHVybnthY3RpdmF0aW9uOnQsYWxwaGE6cn19cmV0dXJue2FjdGl2YXRpb246dH19fSk7dmFyIEFlLE11LFlyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtBZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxNdT1lPT5gXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIGB9KTt2YXIgUnUsVXU9VSgoKT0+e1widXNlIHN0cmljdFwiO1J1PWU9PmBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke2V9LngpLCBpMzIoJHtlfS55KSwgaTMyKCR7ZX0ueiksIDEpKTtcbn1cbmB9KTt2YXIgSnQsWnIsUXI9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3l0KCk7SnQ9KGUsdCxyLG4sbyk9PntsZXQgaT1uLXI7cmV0dXJuYFxuICAgICAgJHtBcnJheS5mcm9tKHtsZW5ndGg6cn0pLm1hcCgoYSxkKT0+YFxuICAgICAgaWYgKCR7Rih0LnNoYXBlLGQsdC5yYW5rKX0gIT0gMSkge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsRihvLGQraSxuKSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsMCl9XG4gICAgICB9YCkuam9pbihcIlwiKX1cbmB9LFpyPShlLHQscixuLG89ITEsaSk9PntsZXQgYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1hW2EubGVuZ3RoLTJdLHA9ZFtkLmxlbmd0aC0xXSxtPWFbYS5sZW5ndGgtMV0sdT1tZShwKSxoPW1lKG0pLF89bWUobCkseT1DLnNpemUocikvdS9fLGc9ZS5sZW5ndGg+Mix4PW4/bi5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLHY9W0Muc2l6ZSh4KSxsLHBdLFM9W3t0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6bX1dO0tlKHQsUyksUy5wdXNoKC4uLk4oeCxhLGQpKSxnJiZTLnB1c2goLi4uTihlWzJdLmRpbXMpKSxTLnB1c2goLi4uTih2KSk7bGV0IFQ9QT0+e2xldCBrPUxyKFwiYmF0Y2hfZGltc1wiLGVbMF0uZGF0YVR5cGUseC5sZW5ndGgpLFA9RShcImFcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoLGgpLEQ9RShcImJcIixlWzFdLmRhdGFUeXBlLGQubGVuZ3RoLHUpLFI9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdi5sZW5ndGgsdSksRz1fZShSLnR5cGUudGVuc29yKSxLPXFlKHQsUi50eXBlLnZhbHVlLEcpLGo9W1AsRF0sVj1cIlwiO2lmKGcpe2xldCBZPW8/dToxO2oucHVzaChFKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxZKSksVj1gJHtvP2B2YWx1ZSArPSBiaWFzW2NvbCAvICR7WX1dO2A6YHZhbHVlICs9ICR7Ui50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgfWB9bGV0IFE9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9XTtqZSh0LFEpO2xldCBzZT0oKT0+e2xldCBZPWB2YXIgYV9kYXRhOiAke1AudHlwZS52YWx1ZX07YDtmb3IobGV0IGVlPTA7ZWU8aDtlZSsrKVkrPWBcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7ZWV9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7ZWV9KSAqIHVuaWZvcm1zLk4gKyBjb2wpIC8gJHt1fV07YDtmb3IobGV0IGVlPTA7ZWU8XztlZSsrKXtZKz1gYV9kYXRhID0gYVsoYV9vZmZzZXQgKyAocm93ICsgJHtlZX0pICogdW5pZm9ybXMuSyArIGspIC8gJHtofV07YDtmb3IobGV0IEo9MDtKPGg7SisrKVkrPWBcbiAgICAgICAgICAgIHZhbHVlc1ske2VlfV0gPSBmbWEoJHtELnR5cGUudmFsdWV9KGFfZGF0YSR7aD09PTE/XCJcIjpgWyR7Sn1dYH0pLCBiX2RhdGEke0p9LCB2YWx1ZXNbJHtlZX1dKTtcbmB9cmV0dXJuIFl9O3JldHVybmBcbiAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoUSkucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLmosUil9XG4gICR7QS5tYWluU3RhcnQoKX1cbiAgICAke0EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBjb2wgPSAoZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5OIC8gJHt1fSkpICogJHt1fTtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHt1fSk7XG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtffTtcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtffTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyBzdHJpZGUxO1xuXG4gICAgJHtyLmxlbmd0aD09PTI/XCJcIjpgbGV0IGJhdGNoX2luZGljZXMgPSAke2sub2Zmc2V0VG9JbmRpY2VzKFwiYmF0Y2hcIil9O2B9XG5cbiAgICB2YXIgYV9pbmRpY2VzOiAke1AudHlwZS5pbmRpY2VzfTtcbiAgICAke0p0KFwiYV9pbmRpY2VzXCIsUCxQLnJhbmstMixrLnJhbmssXCJiYXRjaF9pbmRpY2VzXCIpfVxuICAgICR7UC5pbmRpY2VzU2V0KFwiYV9pbmRpY2VzXCIsUC5yYW5rLTIsMCl9XG4gICAgJHtQLmluZGljZXNTZXQoXCJhX2luZGljZXNcIixQLnJhbmstMSwwKX1cbiAgICBsZXQgYV9vZmZzZXQgPSAke1AuaW5kaWNlc1RvT2Zmc2V0KFwiYV9pbmRpY2VzXCIpfTtcblxuICAgIHZhciBiX2luZGljZXM6ICR7RC50eXBlLmluZGljZXN9O1xuICAgICR7SnQoXCJiX2luZGljZXNcIixELEQucmFuay0yLGsucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtELmluZGljZXNTZXQoXCJiX2luZGljZXNcIixELnJhbmstMiwwKX1cbiAgICAke0QuaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLEQucmFuay0xLDApfVxuICAgIGxldCBiX29mZnNldCA9ICR7RC5pbmRpY2VzVG9PZmZzZXQoXCJiX2luZGljZXNcIil9O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7Ui50eXBlLnZhbHVlfSwgJHtffT47XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrID0gayArICR7aH0pIHtcbiAgICAgICR7c2UoKX1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtffXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtWfVxuICAgICAgJHtLfVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtSLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gJHtSLmluZGljZXNUb09mZnNldChcImN1cl9pbmRpY2VzXCIpfTtcbiAgICAgICR7Ui5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHt1fWAsXCJ2YWx1ZVwiKX07XG4gICAgfVxuICB9XG4gIGB9O3JldHVybntuYW1lOlwiTWF0TXVsTmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmFjdGl2YXRpb259OyR7dX07JHtofTske199OyR7b31gLGlucHV0RGVwZW5kZW5jaWVzOmc/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmk/aShyKTpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlN9KSxnZXRTaGFkZXJTb3VyY2U6VH19fSk7dmFyIG9mLGFmLGhvLE51LHNmLGdvLHVmLGVyLFhyPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTt5dCgpO1FyKCk7WXIoKTtvZj0oZSx0KT0+ZT9gXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGA6YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcbiAgICAgICAgICBrU3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYCxhZj0oZSx0KT0+ZT9gXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQyID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW2xvY2FsUm93XTtcbiAgICAgICAgJHt0PT09Mz9cIlwiOlwibGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTtcIn1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gOmBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gLGhvPShlLHQscj1cImYzMlwiLG4sbz0hMSxpPTMyLGE9ITEsZD0zMik9PntsZXQgbD10WzFdKmVbMV0scD10WzBdKmVbMF0sbT1vP2w6aSx1PW8/aTpsLGg9bS90WzBdLF89aS90WzFdO2lmKCEoKG8mJmg9PT00JiZlWzFdPT09NHx8IW8mJihoPT09M3x8aD09PTQpKSYmbSV0WzBdPT09MCYmaSV0WzFdPT09MCYmZVswXT09PTQpKXRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke299IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHtofSBhbmQgd29ya1BlclRocmVhZFsxXSAke2VbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2h9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7bX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0uIHRpbGVJbm5lciAke2l9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt0WzFdfS4gY29sUGVyVGhyZWFkICR7ZVswXX0gbXVzdCBiZSA0LmApO3JldHVybmBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aH08JHtyfT4sICR7bS9ofT4sICR7dX0+O1xudmFyPHdvcmtncm91cD4gbW1fQnN1YjogYXJyYXk8YXJyYXk8dmVjNDwke3J9PiwgJHtwL2VbMF19PiwgJHtpfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7aH07XG5jb25zdCB0aWxlSW5uZXIgPSAke2l9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICBsZXQgdGlsZVJvdyA9IGxvY2FsUm93ICogcm93UGVyVGhyZWFkO1xuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xuXG4gIGxldCBnbG9iYWxSb3cgPWkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbiAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcbiAgbGV0IGJhdGNoID0gJHthP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAke24/YGxldCBiYXRjaEluZGljZXMgPSAke24ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke2x9O1xuXG4gIGxldCBudW1fdGlsZXMgPSAke2E/YCR7TWF0aC5jZWlsKGQvaSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gIHZhciBrU3RhcnQgPSAke2E/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7cn0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7X307XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHtvZihvLG4pfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtffTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke24/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xuICAgICAgICAgIGxldCBCQ2FjaGVkMCA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XG4gICAgICAgICAgJHtoPT09Mz9cIlwiOlwibGV0IEJDYWNoZWQzID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW3RpbGVDb2xdO1wifVxuXG4gICAgICAgICAgJHthZihvLGgpfVxuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gIH1cblxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wsIGFjY1tpbm5lclJvd10pO1xuICB9XG59YH0sTnU9KGUsdCk9PmU/YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgOmBcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYCxzZj1lPT5lP1wibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107XCI6XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTtcIixnbz0oZSx0LHI9XCJmMzJcIixuLG89ITEsaT0zMixhPSExLGQ9MzIsbD0hMSk9PntsZXQgcD1lWzFdKnRbMV0sbT1lWzBdKnRbMF0sdT1vP3A6aSxoPW8/aTpwO2lmKCEoaCV0WzFdPT09MCYmdSV0WzBdPT09MCYmaSV0WzFdPT09MCkpdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX0sIHRpbGVBV2lkdGggJHt1fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfSwgdGlsZUlubmVyICR7aX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX1gKTtsZXQgXz1oL3RbMV0seT11L3RbMF0sZz1pL3RbMV0seD1sP2BcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3B9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7bX07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7aH07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt1fTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICAke051KG8sbil9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtpfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHttfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7bj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt0WzBdfV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7bz9gbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV07YDpgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV1ba107YH1cbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19O1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3RbMF19O1xuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBgOmBcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xuXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG5cbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtffTtcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHt5fTtcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtnfTtcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke199OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke3l9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XG4gICAgICAke051KG8sbil9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtnfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke24/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICB9XG4gIH1cbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgJHtzZihvKX1cbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya2dyb3VwQmFycmllcigpO1xufVxuXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgfVxufVxuYDtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke3V9PiwgJHtofT47XG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke219PiwgJHtpfT47XG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7aX07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgYmF0Y2ggPSAke2E/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICAgJHtuP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtuLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgICBsZXQgbnVtX3RpbGVzID0gJHthP2Ake01hdGguY2VpbChkL2kpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICAgIHZhciBrU3RhcnQgPSAke2E/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuICAgICR7eH1cbiAgfVxuYH0sdWY9KGUsdCxyLG4sbz0hMSk9PntsZXRbaSxhLGQsbF09bixwPV9lKG5bMF0udHlwZS50ZW5zb3IpO3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2kudHlwZS5pbmRpY2VzfSkgLT4gJHtBZShlLHApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke0FlKGUscCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKVxuICAgICAge1xuICAgICAgICB2YXIgYUluZGljZXM6ICR7YS50eXBlLmluZGljZXN9O1xuICAgICAgICAke0p0KFwiYUluZGljZXNcIixhLGEucmFuay0yLGkucmFuayxcImJhdGNoSW5kaWNlc1wiKX1cbiAgICAgICAgJHthLmluZGljZXNTZXQoXCJhSW5kaWNlc1wiLGEucmFuay0yLFwidTMyKHJvdylcIil9XG4gICAgICAgICR7YS5pbmRpY2VzU2V0KFwiYUluZGljZXNcIixhLnJhbmstMSxcInUzMihjb2xJbilcIil9XG4gICAgICAgIHZhbHVlID0gJHthLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2kudHlwZS5pbmRpY2VzfSkgLT4gJHtBZShlLHApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke0FlKGUscCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgICB2YXIgYkluZGljZXM6ICR7ZC50eXBlLmluZGljZXN9O1xuICAgICAgICAke0p0KFwiYkluZGljZXNcIixkLGQucmFuay0yLGkucmFuayxcImJhdGNoSW5kaWNlc1wiKX1cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJiSW5kaWNlc1wiLGQucmFuay0yLFwidTMyKHJvdylcIil9XG4gICAgICAgICR7ZC5pbmRpY2VzU2V0KFwiYkluZGljZXNcIixkLnJhbmstMSxcInUzMihjb2xJbilcIil9XG4gICAgICAgIHZhbHVlID0gJHtkLmdldEJ5SW5kaWNlcyhcImJJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHtBZShlLHApfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcbiAgICAgICAgJHt0P2B2YWx1ZSA9IHZhbHVlICsgJHtvP1wiYmlhc1tjb2xJbl1cIjpgJHtBZShlLHApfShiaWFzW3Jvd10pYH07YDpcIlwifVxuICAgICAgICAke3J9XG4gICAgICAgICR7bC5zZXRCeUluZGljZXMoXCJ2ZWMzPHUzMj4oY29vcmRzKVwiLFwidmFsdWVcIil9XG4gICAgICB9XG4gICAgfVxuICAgIGB9LGVyPShlLHQscixuLG89ITEsaSk9PntsZXQgYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1hLnNsaWNlKDAsLTIpLHA9ZC5zbGljZSgwLC0yKSxtPW4/bi5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLHU9Qy5zaXplKG0pLGg9YVthLmxlbmd0aC0yXSxfPWFbYS5sZW5ndGgtMV0seT1kW2QubGVuZ3RoLTFdLGc9XyU0PT09MCYmeSU0PT09MCx4PWg8PTg/WzQsMSwxXTpbNCw0LDFdLCQ9WzgsOCwxXSx2PVtNYXRoLmNlaWwoeS8kWzBdL3hbMF0pLE1hdGguY2VpbChoLyRbMV0veFsxXSksTWF0aC5jZWlsKHUvJFsyXS94WzJdKV0sUz1nPzQ6MSxUPVsuLi5sLGgsXy9TXSxBPVQubGVuZ3RoLGs9Wy4uLnAsXyx5L1NdLFA9ay5sZW5ndGgsRD1bdSxoLHkvU10sUj1be3R5cGU6NixkYXRhOmh9LHt0eXBlOjYsZGF0YTp5fSx7dHlwZTo2LGRhdGE6X31dO0tlKHQsUiksUi5wdXNoKC4uLk4obSxULGspKTtsZXQgRz1bXCJyYW5rXCIsXCJyYW5rXCJdLEs9ZS5sZW5ndGg+MjtLJiYoUi5wdXNoKC4uLk4oZVsyXS5kaW1zKSksRy5wdXNoKFwicmFua1wiKSksUi5wdXNoKC4uLk4oRCkpO2xldCBqPVY9PntsZXQgUT1tLmxlbmd0aCxzZT1McihcImJhdGNoRGltc1wiLGVbMF0uZGF0YVR5cGUsUSwxKSxZPV9lKGVbMF0uZGF0YVR5cGUpLGVlPUUoXCJhXCIsZVswXS5kYXRhVHlwZSxBLFMpLEo9RShcImJcIixlWzFdLmRhdGFUeXBlLFAsUyksbmU9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsRC5sZW5ndGgsUyksYmU9W2VlLEpdO2lmKEspe2xldCBxPW8/UzoxO2JlLnB1c2goRShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgscSkpfWxldCBPZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9XTtqZSh0LE9lKTtsZXQgJGU9X2UobmUudHlwZS50ZW5zb3IpLGxlPXFlKHQsbmUudHlwZS52YWx1ZSwkZSksVz11ZihTLEssbGUsW3NlLGVlLEosbmVdLG8pO3JldHVybmBcbiAgJHtWLnJlZ2lzdGVyVW5pZm9ybXMoT2UpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoc2UpLmRlY2xhcmVWYXJpYWJsZXMoLi4uYmUsbmUpfVxuICAke1d9XG4gICR7Zz9obyh4LCQsWSxzZSk6Z28oeCwkLFksc2UpfVxuICAgICAgICAgICAgICAgICAgIGB9O3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eH07JHt0LmFjdGl2YXRpb259OyR7Z307JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6R30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppP2kocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDp2WzBdLHk6dlsxXSx6OnZbMl19LHByb2dyYW1Vbmlmb3JtczpSfSksZ2V0U2hhZGVyU291cmNlOmp9fX0pO3ZhciBkZixWdSxXdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtldCgpO2FlKCk7eXQoKTtZcigpO1V1KCk7WHIoKTtkZj0oZSx0LHIsbixvPSExLGksYT00LGQ9NCxsPTQscD1cImYzMlwiKT0+e2xldCBtPUc9Pntzd2l0Y2goRyl7Y2FzZSAxOnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4XTtcIjtjYXNlIDM6cmV0dXJuYHJlc0RhdGEgPSB2ZWMzPCR7cH0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtjYXNlIDQ6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXggLyA0XTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0d9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx1PUc9Pntzd2l0Y2goRyl7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pICsgY29sSW5dO1wiO2Nhc2UgNDpyZXR1cm5cInJldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtHfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0saD1lP2BcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xuICAgIGAsXz1lP2BcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgLHk9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCIsZz1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIix4PWU/XCJyb3dcIjpcImNvbFwiLCQ9ZT9cImNvbFwiOlwicm93XCIsdj1gXG4gICAgbGV0IGluQ2hhbm5lbHMgPSBpMzIodW5pZm9ybXMud19zaGFwZVsyXSk7XG4gICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgIGxldCBvdXRSb3cgPSAke3h9IC8gb3V0V2lkdGg7XG4gICAgbGV0IG91dENvbCA9ICR7eH0gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHskfSAvIChpMzIodW5pZm9ybXMud19zaGFwZVsxXSkgKiBpbkNoYW5uZWxzKTtcbiAgICBsZXQgV0NvbCA9ICR7JH0gLyBpbkNoYW5uZWxzICUgaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogdW5pZm9ybXMuc3RyaWRlWzBdICsgdW5pZm9ybXMuZGlsYXRpb25bMF0gKiBXUm93IC0gdW5pZm9ybXMucGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xuICAgIGxldCB4Q2ggPSAkeyR9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7QWUoYSxwKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eX0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke2d9KSB7XG4gICAgICAke2h9XG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy54X3NoYXBlKSk7XG4gICAgICAke20oYSl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2AsUz1lP3QmJm4/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgJHt2fWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgJHt2fVxuICAgIH1cbiAgICByZXR1cm4gJHtBZShhLHApfSgwLjApO2A6biYmcj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICAke3Z9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAke3Z9XG4gICAgfVxuICAgIHJldHVybiAke0FlKGEscCl9KDAuMCk7YCxUPWU/biYmcj91KGQpOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7dShkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoZCxwKX0oMC4wKTtgOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIpIHtcbiAgICAgICR7dShkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoZCxwKX0oMC4wKTtgLEE9QWUobCxwKSxrPWU/QWUoYSxwKTpBZShkLHApLFA9ZT9BZShkLHApOkFlKGEscCksRD1xZShpLEEscCk7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7a30ge1xuICAgICAgJHtlP1M6VH1cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke1B9IHtcbiAgICAgICR7ZT9UOlN9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7QX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgICAgJHtffVxuICAgICAgJHtNdShvKX1cbiAgICAgICR7RH1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gfSxWdT0oZSx0LHIsbixvLGksYSxkLGwpPT57bGV0IHA9dC5mb3JtYXQ9PT1cIk5IV0NcIixtPXA/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSx1PXJbMF0saD1wP3JbMl06clszXSxfPXA/clsxXTpyWzJdLHk9cD9yWzNdOnJbMV0sZz1wJiYobSU0PT09MHx8bSUzPT09MCkmJnklND09PTAseD1wP3k6aCpfLCQ9cD9oKl86eSx2PVs4LDgsMV0sUz1uPD04P1s0LDEsMV06WzQsNCwxXSxUPVtNYXRoLmNlaWwoeC92WzBdL1NbMF0pLE1hdGguY2VpbCgkL3ZbMV0vU1sxXSksTWF0aC5jZWlsKHUvdlsyXS9TWzJdKV07dWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke1R9YCk7bGV0IEE9Zz9wJiZtJTQhPT0wPzM6NDoxLGs9dlsxXSpTWzFdLFA9dlswXSpTWzBdLEQ9TWF0aC5tYXgodlswXSpBLHZbMV0pLFI9biVrPT09MCxHPW8lUD09PTAsSz1pJUQ9PT0wLGo9Zz9bQSw0LDRdOlsxLDEsMV0sVj1be3R5cGU6NixkYXRhOm59LHt0eXBlOjYsZGF0YTpvfSx7dHlwZTo2LGRhdGE6aX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6NixkYXRhOnQuc3RyaWRlc30se3R5cGU6NixkYXRhOnQuZGlsYXRpb25zfV07S2UodCxWKSxWLnB1c2goLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IFE9W1wicmFua1wiLFwicmFua1wiXTthJiYoVi5wdXNoKC4uLk4oZVsyXS5kaW1zKSksUS5wdXNoKFwicmFua1wiKSksVi5wdXNoKC4uLk4ocikpO2xldCBzZT1ZPT57bGV0IGVlPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJwYWRcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwic3RyaWRlXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07amUodCxlZSk7bGV0IEo9Zz80OjEsbmU9X2UoZVswXS5kYXRhVHlwZSksYmU9YFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHtnP2B2ZWM0PCR7bmV9PmA6bmV9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtnP2B2ZWM0PCR7bmV9PmA6bmV9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7Zz9gdmVjNDwke25lfT5gOm5lfSkge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke2c/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xuICAgICAgfWAsT2U9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsQT09PTM/MTpBKSwkZT1FKFwid1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxKKSxsZT1bT2UsJGVdLFc9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsSik7aWYoYSl7bGV0IHE9RShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsSik7bGUucHVzaChxKSxiZSs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke2c/YHZlYzQ8JHtuZX0+YDpuZX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke3A/XCJ3XCI6XCJ5XCJ9JHtnP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1yZXR1cm5gXG4gICAgICAgICR7UnUoXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7WS5yZWdpc3RlclVuaWZvcm1zKGVlKS5kZWNsYXJlVmFyaWFibGVzKC4uLmxlLFcpfVxuICAgICAgICAke2JlfVxuICAgICAgICAke2RmKHAsUixHLEssYSx0LGpbMF0salsxXSxqWzJdLG5lKX1cbiAgICAgICAgJHtnP2hvKFMsdixuZSx2b2lkIDAsIXAsRCk6Z28oUyx2LG5lLHZvaWQgMCwhcCxELCExLHZvaWQgMCxkKX1gfTtyZXR1cm57bmFtZTpcIkNvbnYyRE1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7QX07JHtnfTske1J9OyR7R307JHtLfTske2t9OyR7UH07JHtEfWAsaW5wdXREZXBlbmRlbmNpZXM6UX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsP2wocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpUWzBdLHk6VFsxXSx6OlRbMl19LHByb2dyYW1Vbmlmb3JtczpWfSksZ2V0U2hhZGVyU291cmNlOnNlfX19KTt2YXIgbGYsTHUsSnIsY2YsR3UscGYsSHUsRnUscXU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7ZXQoKTtvZSgpO2FlKCk7eXQoKTtZcigpO2xmPWU9PntsZXQgdD0xO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXQqPWVbcl07cmV0dXJuIHR9LEx1PWU9PnR5cGVvZiBlPT1cIm51bWJlclwiP1tlLGUsZV06ZSxKcj0oZSx0KT0+dDw9MT9lOmUrKGUtMSkqKHQtMSksY2Y9KGUsdCxyLG49MSk9PntsZXQgbz1Kcih0LG4pO3JldHVybiBNYXRoLmZsb29yKChlWzBdKihyLTEpLXIrbykvMil9LEd1PShlLHQscixuLG8pPT57bz09bnVsbCYmKG89Y2YoZSx0WzBdLG5bMF0pKTtsZXQgaT1bMCwwLDAscl07Zm9yKGxldCBhPTA7YTwzO2ErKyllW2FdKzIqbz49dFthXSYmKGlbYV09TWF0aC50cnVuYygoZVthXS10W2FdKzIqbykvblthXSsxKSk7cmV0dXJuIGl9LHBmPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtLHUsaCxfO2lmKGU9PT1cIlZBTElEXCImJihlPTApLHR5cGVvZiBlPT1cIm51bWJlclwiKXttPXt0b3A6ZSxib3R0b206ZSxsZWZ0OmUscmlnaHQ6ZSxmcm9udDplLGJhY2s6ZX07bGV0IHk9R3UoW3QscixuLDFdLFtkLGwscF0sMSxbbyxpLGFdLGUpO3U9eVswXSxoPXlbMV0sXz15WzJdfWVsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl7aWYoIWUuZXZlcnkoKGcseCwkKT0+Zz09PSRbMF0pKXRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO209e3RvcDplWzBdLGJvdHRvbTplWzFdLGxlZnQ6ZVsyXSxyaWdodDplWzNdLGZyb250OmVbNF0sYmFjazplWzVdfTtsZXQgeT1HdShbdCxyLG4sMV0sW2QsbCxwXSwxLFtvLGksYV0sZVswXSk7dT15WzBdLGg9eVsxXSxfPXlbMl19ZWxzZSBpZihlPT09XCJTQU1FX1VQUEVSXCIpe3U9TWF0aC5jZWlsKHQvbyksaD1NYXRoLmNlaWwoci9pKSxfPU1hdGguY2VpbChuL2EpO2xldCB5PSh1LTEpKm8rZC10LGc9KGgtMSkqaStsLXIseD0oXy0xKSphK3AtbiwkPU1hdGguZmxvb3IoeS8yKSx2PXktJCxTPU1hdGguZmxvb3IoZy8yKSxUPWctUyxBPU1hdGguZmxvb3IoeC8yKSxrPXgtQTttPXt0b3A6Uyxib3R0b206VCxsZWZ0OkEscmlnaHQ6ayxmcm9udDokLGJhY2s6dn19ZWxzZSB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO3JldHVybntwYWRJbmZvOm0sb3V0RGVwdGg6dSxvdXRIZWlnaHQ6aCxvdXRXaWR0aDpffX0sSHU9KGUsdCxyLG4sbyxpPSExLGE9XCJjaGFubmVsc0xhc3RcIik9PntsZXQgZCxsLHAsbSx1O2lmKGE9PT1cImNoYW5uZWxzTGFzdFwiKVtkLGwscCxtLHVdPWU7ZWxzZSBpZihhPT09XCJjaGFubmVsc0ZpcnN0XCIpW2QsdSxsLHAsbV09ZTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7YX1gKTtsZXRbaCwsXyx5LGddPXQsW3gsJCx2XT1MdShyKSxbUyxULEFdPUx1KG4pLGs9SnIoXyxTKSxQPUpyKHksVCksRD1KcihnLEEpLHtwYWRJbmZvOlIsb3V0RGVwdGg6RyxvdXRIZWlnaHQ6SyxvdXRXaWR0aDpqfT1wZihvLGwscCxtLHgsJCx2LGssUCxEKSxWPWk/aCp1OmgsUT1bMCwwLDAsMCwwXTtyZXR1cm4gYT09PVwiY2hhbm5lbHNGaXJzdFwiP1E9W2QsVixHLEssal06YT09PVwiY2hhbm5lbHNMYXN0XCImJihRPVtkLEcsSyxqLFZdKSx7YmF0Y2hTaXplOmQsZGF0YUZvcm1hdDphLGluRGVwdGg6bCxpbkhlaWdodDpwLGluV2lkdGg6bSxpbkNoYW5uZWxzOnUsb3V0RGVwdGg6RyxvdXRIZWlnaHQ6SyxvdXRXaWR0aDpqLG91dENoYW5uZWxzOlYscGFkSW5mbzpSLHN0cmlkZURlcHRoOngsc3RyaWRlSGVpZ2h0OiQsc3RyaWRlV2lkdGg6dixmaWx0ZXJEZXB0aDpfLGZpbHRlckhlaWdodDp5LGZpbHRlcldpZHRoOmcsZWZmZWN0aXZlRmlsdGVyRGVwdGg6ayxlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6UCxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpELGRpbGF0aW9uRGVwdGg6UyxkaWxhdGlvbkhlaWdodDpULGRpbGF0aW9uV2lkdGg6QSxpblNoYXBlOmUsb3V0U2hhcGU6USxmaWx0ZXJTaGFwZTp0fX0sRnU9KGUsdCxyLG4sbyxpKT0+e2xldCBhPWk9PT1cImNoYW5uZWxzTGFzdFwiLGQ9YT9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGw9ITEscD1bNjQsMSwxXSxtPXt4OnIubWFwKCh2LFMpPT5TKX0sdT1bTWF0aC5jZWlsKGxmKG0ueC5tYXAodj0+clt2XSkpL3BbMF0pLDEsMV07dWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke3V9YCk7bGV0IGg9bD9hJiZkJTQhPT0wPzM6NDoxLF89Qy5zaXplKHIpLHk9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfV07S2UodCx5KSx5LnB1c2goLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IGc9W1wicmFua1wiLFwicmFua1wiXSx4PWUubGVuZ3RoPT09Mzt4JiYoeS5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZy5wdXNoKFwicmFua1wiKSkseS5wdXNoKC4uLk4ocikpO2xldCAkPXY9PntsZXQgUz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6bi5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6by5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5zdHJpZGVzLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH1dO2plKHQsUyk7bGV0IFQ9bD80OjEsQT1fZShlWzBdLmRhdGFUeXBlKSxrPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGg9PT0zPzE6aCksUD1FKFwiV1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxUKSxEPVtrLFBdLFI9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsVCksRz1cIlwiO2lmKHgpe2xldCBWPUUoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLFQpO0QucHVzaChWKSxHKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiBhcnJheTx1MzIsIDU+KSAtPiAke2w/YHZlYzQ8JHtBfT5gOkF9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1ske2E/RihcImNvb3Jkc1wiLDQsNSk6RihcImNvb3Jkc1wiLDEsNSl9JHtsP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1sZXQgSz1BZShoLEEpLGo9cWUodCxLLEEpO3JldHVybmBcbiAgICAgICAgICAgICR7R31cbiAgICAgICAgICAgIGZuIGdldFgoZDAgOiB1MzIsIGQxIDogdTMyLCBkMiA6IHUzMiwgZDMgOiB1MzIsIGQ0IDogdTMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XG4gICAgICAgICAgICAgIHJldHVybiAke2suZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gZ2V0VyhkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7UC5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybXMoUykuZGVjbGFyZVZhcmlhYmxlcyguLi5ELFIpfVxuICAgICAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtSLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke0YoXCJjb29yZHNcIiwwLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgZDIgPSAke2E/RihcImNvb3Jkc1wiLGsucmFuay0xLGsucmFuayk6RihcImNvb3Jkc1wiLDEsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4RlJDQ29ybmVyID0gdmVjMzx1MzI+KCR7YT9GKFwiY29vcmRzXCIsMSxrLnJhbmspOkYoXCJjb29yZHNcIiwyLGsucmFuayl9LFxuICAgICAgICAgICAgICAke2E/RihcImNvb3Jkc1wiLDIsay5yYW5rKTpGKFwiY29vcmRzXCIsMyxrLnJhbmspfSxcbiAgICAgICAgICAgICAgJHthP0YoXCJjb29yZHNcIiwzLGsucmFuayk6RihcImNvb3Jkc1wiLDQsay5yYW5rKX0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHthP0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxrLnJhbmspOkYoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMixrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVogPSAke2E/RihcInVuaWZvcm1zLnhfc2hhcGVcIiwyLGsucmFuayk6RihcInVuaWZvcm1zLnhfc2hhcGVcIiwzLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVyA9ICR7YT9GKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsay5yYW5rKTpGKFwidW5pZm9ybXMueF9zaGFwZVwiLDQsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHthP0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCxrLnJhbmspOkYoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9ICh4U2hhcGVVIC8gNCkgKiA0O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSB4U2hhcGVVICUgNDtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0geFNoYXBlWSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFNoYXBlWikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHhTaGFwZVcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHthP2BsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDIsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAzLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke2E/YHZhbHVlICs9IGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2A6YHZhbHVlICs9IGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2B9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICR7YT9gbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke2E/YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHt4P1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpXCI6XCJcIn07XG4gICAgICAgICAgICAgICR7an1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDb252M0ROYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7YX07JHtofTske3h9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6dVswXSx5OnVbMV0sejp1WzJdfSxwcm9ncmFtVW5pZm9ybXM6eX0pLGdldFNoYWRlclNvdXJjZTokfX19KTt2YXIgS3UsanUsWXU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3l0KCk7S3U9KGUsdCxyLG4pPT57bGV0IG89ZS5sZW5ndGg+MixpPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLGE9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGw9dC5mb3JtYXQ9PT1cIk5IV0NcIixwPWw/clszXTpyWzFdLG09cC90Lmdyb3VwLHU9bCYmbT49ND9tZShwKToxLGg9Qy5zaXplKHIpL3UsXz1be3R5cGU6MTIsZGF0YTpofSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfSx7dHlwZToxMixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6MTIsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOjEyLGRhdGE6bX1dO0tlKHQsXyksXy5wdXNoKC4uLk4oYSxbZFswXSxkWzFdLGRbMl0sZFszXS91XSkpO2xldCB5PW8/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdO18ucHVzaCguLi5OKFtyWzBdLHJbMV0sclsyXSxyWzNdL3VdKSk7bGV0IGc9eD0+e2xldCAkPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLHUpLHY9X2UoJC50eXBlLnRlbnNvciksUz1xZSh0LCQudHlwZS52YWx1ZSx2KSxUPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCksQT1FKFwid1wiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsdSksaz1bVCxBXTtvJiZrLnB1c2goRShcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyx1KSk7bGV0IFA9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LmRpbGF0aW9ucy5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XTtqZSh0LFApO2xldCBEPWw/YFxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzBdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICAgICAgbGV0IHhWYWwgPSAke1QuZ2V0KFwiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7QS5nZXQoXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIixcIndJbkNoYW5uZWxcIixcIm91dHB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYDpgXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7VC5nZXQoXCJiYXRjaFwiLFwiaW5wdXRfY2hhbm5lbFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHtBLmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgO3JldHVybmBcbiAgJHt4LnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5rLCQpfVxuXG4gICR7eC5tYWluU3RhcnQoKX1cbiAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2w/MzoxfV07XG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtsPzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7bD8yOjN9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsICogJHt1fSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7bD8yOjF9XTtcblxuICAgIHZhciB2YWx1ZTogJHskLnR5cGUudmFsdWV9ID0gJHskLnR5cGUudmFsdWV9KDApO1xuICAgICR7RH1cbiAgICAke2l9XG4gICAgJHtTfVxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH07cmV0dXJue25hbWU6XCJHcm91cGVkQ29udlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dX1gLGlucHV0RGVwZW5kZW5jaWVzOnl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bj9uKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTpnfX0sanU9KGUsdCxyLG4pPT57bGV0IG89ZS5sZW5ndGg+MixpPW1lKHJbM10pLGE9bWUoclsyXSksZD1DLnNpemUocikvaS9hLGw9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVswXS5kaW1zWzJdLGVbMF0uZGltc1szXS9pXSxwPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXSxlWzFdLmRpbXNbM10vaV0sbT1bclswXSxyWzFdLHJbMl0sclszXS9pXSx1PVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjYsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19XTtLZSh0LHUpLHUucHVzaCguLi5OKGwscCxtKSk7bGV0IGg9KGEtMSkqdC5zdHJpZGVzWzFdK3BbMV0sXz15PT57bGV0IGc9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbS5sZW5ndGgsaSkseD1fZShnLnR5cGUudGVuc29yKSwkPXFlKHQsZy50eXBlLnZhbHVlLHgpLHY9RShcInhcIixlWzBdLmRhdGFUeXBlLGwubGVuZ3RoLGkpLFM9RShcIndcIixlWzFdLmRhdGFUeXBlLHAubGVuZ3RoLGkpLFQ9W3YsU107byYmVC5wdXNoKEUoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsaSkpO2xldCBBPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLGs9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07cmV0dXJuIGplKHQsayksYFxuICAke3kucmVnaXN0ZXJVbmlmb3JtcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQsZyl9XG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCB3aWR0aDAgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbM107XG4gICAgbGV0IG91dHB1dF9jaGFubmVsID0gZ2xvYmFsX2lkeCAlIHdpZHRoMDtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvIHdpZHRoMDtcbiAgICBsZXQgd2lkdGgxID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdIC8gJHthfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHthfXU7XG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcblxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7di50eXBlLnZhbHVlfSwgJHtofT47XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtnLnR5cGUudmFsdWV9LCAke2F9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3BbMF19OyB3X2hlaWdodCsrKSB7XG4gICAgICBsZXQgeF9oZWlnaHQgPSB4X2Nvcm5lci54ICsgaTMyKHdfaGVpZ2h0KTtcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtofTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHhfd2lkdGggPSB4X2Nvcm5lci55ICsgaTtcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7di5nZXQoXCJiYXRjaFwiLFwidTMyKHhfaGVpZ2h0KVwiLFwidTMyKHhfd2lkdGgpXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7cFsxXX07IHdfd2lkdGgrKykge1xuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7Uy5nZXQoXCJ3X2hlaWdodFwiLFwid193aWR0aFwiLFwiMFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7YX11OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke2F9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke0F9XG4gICAgICAkeyR9XG4gICAgICAke2cuc2V0KFwiYmF0Y2hcIixcInJvd1wiLFwiY29sICsgaVwiLFwib3V0cHV0X2NoYW5uZWxcIixcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252LVZlY3Rvcml6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7aX07JHthfTske2h9OyR7cFswXX07JHtwWzFdfWAsaW5wdXREZXBlbmRlbmNpZXM6bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJ0eXBlXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bj9uKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dX0pLGdldFNoYWRlclNvdXJjZTpffX19KTt2YXIgbWYsYm8sZmYseW8sX28sWnUsaGYsZ2Ysd28sUXU9VSgoKT0+e1widXNlIHN0cmljdFwiO29lKCk7V3UoKTtxdSgpO1hyKCk7WXUoKTt5dCgpO1FyKCk7ZHQoKTttZj0oZSx0LHIsbixvLGkpPT57bGV0IGE9ZVswXSxkPWUuc2xpY2UoaT8xOjIsaT8zOjQpLGw9ZC5sZW5ndGgscD10WzBdLHU9dC5zbGljZSgyKS5tYXAoKHksZyk9PnkrKHktMSkqKHJbZ10tMSkpLF89ZC5tYXAoKHksZyk9PnkrbltnXStuW2crbF0pLm1hcCgoeSxnKT0+TWF0aC5mbG9vcigoeS11W2ddK29bZ10pL29bZ10pKTtyZXR1cm4gXy5zcGxpY2UoMCwwLGEpLF8uc3BsaWNlKGk/MzoxLDAscCksX30sYm89WzIsMywxLDBdLGZmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFwiZ3JlYXRlciB0aGFuIDVEIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLG49ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYociE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsxXS5kaW1zWzBdIT09ZVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IG89ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke299RGApO2lmKHQucGFkcy5sZW5ndGghPT1vKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke28qMn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKX0seW89KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7ci5sZW5ndGg8dFsxXS5kaW1zLmxlbmd0aC0yJiZyLnB1c2goLi4uQXJyYXkodFsxXS5kaW1zLmxlbmd0aC0yLXIubGVuZ3RoKS5maWxsKDApKTtmb3IobGV0IGk9MjtpPHRbMV0uZGltcy5sZW5ndGg7KytpKXJbaS0yXT09PTAmJihyW2ktMl09dFsxXS5kaW1zW2ldKTtsZXQgbj1lLnBhZHMuc2xpY2UoKTtBdC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxyLG4sZS5mb3JtYXQ9PT1cIk5IV0NcIixlLmF1dG9QYWQpO2xldCBvPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obyx7a2VybmVsU2hhcGU6cixwYWRzOm59KSxvfSxfbz1lPT57bGV0IHQ9anIoZSkscj1lLmZvcm1hdCxuPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sbz1lLmRpbGF0aW9ucyxpPWUuZ3JvdXAsYT1lLmtlcm5lbF9zaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud19pc19jb25zdCgpO3JldHVybnthdXRvUGFkOm4sZm9ybWF0OnIsZGlsYXRpb25zOm8sZ3JvdXA6aSxrZXJuZWxTaGFwZTphLHBhZHM6ZCxzdHJpZGVzOmwsd0lzQ29uc3Q6cCwuLi50LGNhY2hlS2V5OmAke2UuZm9ybWF0fTske3QuYWN0aXZhdGlvbn07YH19LFp1PShlLHQscixuKT0+e2xldCBvPXIuZm9ybWF0PT09XCJOSFdDXCIsaT1tZih0WzBdLmRpbXMsdFsxXS5kaW1zLHIuZGlsYXRpb25zLHIucGFkcyxyLnN0cmlkZXMsbyk7aWYoci5ncm91cCE9PTEpe2xldCBrPVt0WzBdXTtpZihvKXtsZXQgRD1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShQZSh0WzFdLGJvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9RCksay5wdXNoKEQpfWVsc2Ugay5wdXNoKHRbMV0pO3QubGVuZ3RoPT09MyYmay5wdXNoKHRbMl0pLCFlLmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKFwiYW1wZXJlXCIpJiZvJiZ0WzFdLmRpbXNbMF09PT1yLmdyb3VwJiZ0WzFdLmRpbXNbMV09PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MT9lLmNvbXB1dGUoanUoayxyLGksbikse2lucHV0czprfSk6ZS5jb21wdXRlKEt1KGsscixpLG4pLHtpbnB1dHM6a30pO3JldHVybn1sZXQgYT10Lmxlbmd0aD09PTMsZD10WzBdLmRpbXNbbz8xOjJdLGw9dFswXS5kaW1zW28/MjozXSxwPXRbMF0uZGltc1tvPzM6MV0sbT10WzFdLmRpbXNbMl0sdT10WzFdLmRpbXNbM10saD1pW28/MToyXSxfPWlbbz8yOjNdLHk9aVtvPzM6MV0sZz1vJiZtPT09ZCYmdT09PWwmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTA7aWYoZ3x8bT09PTEmJnU9PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MSYmci5zdHJpZGVzWzBdPT09MSYmci5zdHJpZGVzWzFdPT09MSYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MCl7bGV0IGs9aVswXSxQLEQsUixHPVtdO2lmKG8pe2xldCBWPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sYm8pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07aWYoci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1WKSxnKXtsZXQgUT1kKmwqcDtQPXRbMF0ucmVzaGFwZShbMSxrLFFdKSxEPVYucmVzaGFwZShbMSxRLHldKSxSPVsxLGsseV19ZWxzZSBQPXRbMF0ucmVzaGFwZShbayxkKmwscF0pLEQ9Vi5yZXNoYXBlKFsxLHAseV0pLFI9W2ssaCpfLHldO0cucHVzaChQKSxHLnB1c2goRCl9ZWxzZSBQPXRbMF0ucmVzaGFwZShbayxwLGQqbF0pLEQ9dFsxXS5yZXNoYXBlKFsxLHkscF0pLFI9W2sseSxoKl9dLEcucHVzaChEKSxHLnB1c2goUCk7YSYmRy5wdXNoKHRbMl0pO2xldCBLPVJbMl0saj1HWzBdLmRpbXNbR1swXS5kaW1zLmxlbmd0aC0xXTtLPDgmJmo8OD9lLmNvbXB1dGUoWnIoRyxyLGksUixvLG4pLHtpbnB1dHM6R30pOmUuY29tcHV0ZShlcihHLHIsaSxSLG8sbikse2lucHV0czpHfSk7cmV0dXJufWxldCB4PSEwLCQ9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoUGUodFsxXSxibykse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPSQpO2xldCB2PVt0WzBdLCRdO2EmJnYucHVzaCh0WzJdKTtsZXQgUz1vP2gqXzp5LFQ9bz95OmgqXyxBPW0qdSpwO2UuY29tcHV0ZShWdSh2LHIsaSxTLFQsQSxhLHgsbikse2lucHV0czp2fSl9LGhmPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixuPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZuLnB1c2goZS5pbnB1dHNbMl0pO2xldCBvPVswLHQucGFkc1swXSwwLHQucGFkc1sxXV0saT1bMV0uY29uY2F0KHQuc3RyaWRlcyksYT1bMV0uY29uY2F0KHQuZGlsYXRpb25zKSxkPVsxXS5jb25jYXQodC5rZXJuZWxTaGFwZSksbD15byh7Li4udCxwYWRzOm8sc3RyaWRlczppLGRpbGF0aW9uczphLGtlcm5lbFNoYXBlOmR9LG4pO1p1KGUsbixsLHA9PnI/W3BbMF0scFsyXSxwWzNdXTpbcFswXSxwWzFdLHBbM11dKX0sZ2Y9KGUsdCxyKT0+e2xldCBuPXIuZm9ybWF0PT09XCJOSFdDXCI/XCJjaGFubmVsc0xhc3RcIjpcImNoYW5uZWxzRmlyc3RcIixvPXlvKHIsdCksaT1yLmF1dG9QYWQ9PT1cIk5PVFNFVFwiP3IucGFkczpyLmF1dG9QYWQsYT1IdSh0WzBdLmRpbXMsdFsxXS5kaW1zLHIuc3RyaWRlcyxyLmRpbGF0aW9ucyxpLCExLG4pO2UuY29tcHV0ZShGdSh0LG8sYS5vdXRTaGFwZSxbYS5maWx0ZXJEZXB0aCxhLmZpbHRlckhlaWdodCxhLmZpbHRlcldpZHRoXSxbYS5wYWRJbmZvLmZyb250LGEucGFkSW5mby50b3AsYS5wYWRJbmZvLmxlZnRdLG4pKX0sd289KGUsdCk9PntpZihmZihlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTMpaGYoZSx0KTtlbHNlIGlmKGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09NSlnZihlLGUuaW5wdXRzLHQpO2Vsc2V7bGV0IHI9eW8odCxlLmlucHV0cyk7WnUoZSxlLmlucHV0cyxyKX19fSk7dmFyIFh1LEp1PVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2V0KCk7b2UoKTthZSgpO1h1PShlLHQscik9PntsZXQgbj1lLmxlbmd0aD4yLG89dC5vdXRwdXRTaGFwZSxpPXQuZm9ybWF0PT09XCJOSFdDXCIsYT10Lmdyb3VwLGQ9ZVsxXS5kaW1zLGw9ZFsyXS9hLHA9ZFszXSxtPWk/bWUobCk6MSx1PWk/bWUocCk6MSxoPWk/cD09PTE/bTp1OjEsXz1DLnNpemUobykvdSx5PVtNYXRoLmNlaWwoXy82NCksMSwxXTt1ZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7eX1gKTtsZXQgZz1bXCJyYW5rXCIsXCJyYW5rXCJdLHg9W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dLCQ9W3Qua2VybmVsU2hhcGVbaT8xOjJdLHQua2VybmVsU2hhcGVbaT8yOjNdXSx2PVt0LmRpbGF0aW9uc1swXSx0LmRpbGF0aW9uc1sxXV0sUz1bJFswXSsodC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVtpPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpKSwkWzFdKyh0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2k/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSkpXSxUPVtTWzBdLTEtTWF0aC5mbG9vcigodC5wYWRzWzBdK3QucGFkc1syXSkvMiksU1sxXS0xLU1hdGguZmxvb3IoKHQucGFkc1sxXSt0LnBhZHNbM10pLzIpXSxBPVt7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6eH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnZ9LHt0eXBlOjEyLGRhdGE6U30se3R5cGU6NixkYXRhOlR9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMpXTtuJiYoQS5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZy5wdXNoKFwicmFua1wiKSksQS5wdXNoKC4uLk4obykpO2xldCBrPVA9PntsZXQgRD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp4Lmxlbmd0aH0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6JC5sZW5ndGh9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDokLmxlbmd0aH0se25hbWU6XCJlZmZlY3RpdmVfZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOlMubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOlQubGVuZ3RofSx7bmFtZTpcImlucHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV0sUj1fZShlWzBdLmRhdGFUeXBlKSxHPWk/MToyLEs9aT8yOjMsaj1pPzM6MSxWPUUoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLGgpLFE9RShcIkR5XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLG0pLHNlPVtRLFZdO24mJnNlLnB1c2goRShcImJpYXNcIixlWzJdLmRhdGFUeXBlLFtvW2pdXS5sZW5ndGgsdSkpO2xldCBZPU0oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoLHUpLGVlPSgpPT57bGV0IG5lPVwiXCI7aWYobT09PTEpbmUrPWBcbiAgICAgICAgbGV0IHdfb2Zmc2V0ID0gJHtWLmluZGljZXNUb09mZnNldChgJHtWLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfTtcbiAgICAgICAgbGV0IHdWYWx1ZSA9ICR7Vi5nZXRCeU9mZnNldChgd19vZmZzZXQgLyAke2h9YCl9O1xuICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtgO2Vsc2UgaWYocD09PTEpbmUrPWBcbiAgICAgICAgICBsZXQgd1ZhbHVlID0gJHtWLmdldEJ5T2Zmc2V0KGAke1YuaW5kaWNlc1RvT2Zmc2V0KGAke1YudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9IC8gJHtofWApfTtcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7YDtlbHNlIGZvcihsZXQgYmU9MDtiZTxtO2JlKyspbmUrPWBcbiAgICAgICAgICAgIGxldCB3VmFsdWUke2JlfSA9ICR7Vi5nZXRCeU9mZnNldChgJHtWLmluZGljZXNUb09mZnNldChgJHtWLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwgKyAke2JlfSwgd091dENoYW5uZWwpYCl9IC8gJHtofWApfTtcbiAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlWyR7YmV9XSAqIHdWYWx1ZSR7YmV9O2A7cmV0dXJuIG5lfSxKPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtZLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7dX1gKX07XG4gICAgICAgICAgICBsZXQgYmF0Y2ggPSAke1kuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIiwwKX07XG4gICAgICAgICAgICBsZXQgZDEgPSAke1kuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixqKX07XG4gICAgICAgICAgICBsZXQgciA9ICR7WS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEcpfTtcbiAgICAgICAgICAgIGxldCBjID0gJHtZLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsSyl9O1xuICAgICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtZLnR5cGUudmFsdWV9KDAuMCk7XG4gICAgICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueDsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkeVIgPSAoJHtSfShkeVJDb3JuZXIpICsgJHtSfSh3UikpIC8gJHtSfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnggLSAxIC0gd1IgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueDtcbiAgICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtSfSh1bmlmb3Jtcy5EeV9zaGFwZVske0d9XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxuICAgICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdSID0gd1IgKyB1bmlmb3Jtcy5zdHJpZGVzWzBdIC0gMTtcbiAgICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy55OyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7Un0oZHlDQ29ybmVyKSArICR7Un0od0MpKSAvICR7Un0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueSAtIDEgLSB3QyAvIHVuaWZvcm1zLmRpbGF0aW9ucy55O1xuICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7Un0odW5pZm9ybXMuRHlfc2hhcGVbJHtLfV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdDID0gd0MgKyB1bmlmb3Jtcy5zdHJpZGVzLnkgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gZ3JvdXBJZCAqIHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7IGQyID0gZDIgKyAke219KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHtpP1EuZ2V0QnlPZmZzZXQoYCR7US5pbmRpY2VzVG9PZmZzZXQoYCR7US50eXBlLmluZGljZXN9KGJhdGNoLCBpZHlSLCBpZHlDLCBpbnB1dENoYW5uZWwpYCl9IC8gJHttfWApOlEuZ2V0KFwiYmF0Y2hcIixcImlucHV0Q2hhbm5lbFwiLFwiaWR5UlwiLFwiaWR5Q1wiKX07XG4gICAgICAgICAgICAgICAgICAke2VlKCl9XG4gICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAke219O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCR7bj9gICsgYmlhc1tkMSAvICR7dX1dYDpcIlwifTtcbiAgICAgICAgICAgICR7WS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgICAgICBgO3JldHVybmBcbiAgICAke1AucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLnNlLFkpfVxuICAgICAgJHtQLm1haW5TdGFydCgpfVxuICAgICAgJHtQLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX07XG4gICAgJHtKfX1gfTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7bX0ke2h9JHt1fSR7cD09PTF9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe2Rpc3BhdGNoR3JvdXA6e3g6eVswXSx5OnlbMV0sejp5WzJdfSxvdXRwdXRzOlt7ZGltczpyP3Iobyk6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOkF9KSxnZXRTaGFkZXJTb3VyY2U6a319fSk7dmFyIGJmLHlmLF9mLGVkLHRkLHdmLHJkLHZmLG5kLG9kPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKdSgpO3l0KCk7ZHQoKTtiZj0oZSx0LHIsbixvLGkpPT4oZS0xKSp0K3IrKG4tMSkqbysxLWkseWY9KGUsdCxyLG4sbyk9PntsZXQgaT1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhyW25dPWkscltvXT1lLWkpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKHJbbl09ZS1pLHJbb109aSl9LF9mPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtPWUubGVuZ3RoLTIsdT1wLmxlbmd0aD09PTA7bC5sZW5ndGg8bSYmbC5wdXNoKC4uLkFycmF5KG0tbC5sZW5ndGgpLmZpbGwoMCkpO2xldCBoPWVbMF0sXz10W2Q/MzoxXSpvO2ZvcihsZXQgeT0wLGc9ZS5sZW5ndGgtbS0oZD8xOjApO3k8bTsrK3ksKytnKXtsZXQgeD1lW2ddLCQ9dT94KmFbeV06cFt5XSx2PWJmKHgsYVt5XSxpW3ldLHRbZ10sclt5XSwkKTt5Zih2LG4saSx5LHkrbSksdSYmcC5wdXNoKGFbeV0qKHgtMSkrbFt5XSsodFtnXS0xKSpyW3ldKzEtaVt5XS1pW3krbV0pfXAuc3BsaWNlKDAsMCxoKSxwLnNwbGljZShkPzM6MSwwLF8pfSxlZD0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKCh1LGgpPT51KmgsMSk9PT0wKXtyLmxlbmd0aD0wO2ZvcihsZXQgdT0yO3U8dFsxXS5kaW1zLmxlbmd0aDsrK3Upci5wdXNoKHRbMV0uZGltc1t1XSl9bGV0IG49ZS5mb3JtYXQ9PT1cIk5IV0NcIjtyLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxyLnNwbGljZShuPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IG89ZS5wYWRzLnNsaWNlKCksaT1lLm91dHB1dFNoYXBlLnNsaWNlKCksYT1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxkPXRbMF0uZGltcyxsPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYobC5yZWR1Y2UoKHUsaCk9PnUraCwwKT09PTApe2xldCB1PXRbMF0uZGltcy5sZW5ndGgtMjtsPW5ldyBBcnJheSh1KS5maWxsKDEpfWxldCBwPWUuc3RyaWRlcy5zbGljZSgpO2lmKHAucmVkdWNlKCh1LGgpPT51K2gsMCk9PT0wKXtsZXQgdT10WzBdLmRpbXMubGVuZ3RoLTI7cD1uZXcgQXJyYXkodSkuZmlsbCgxKX1fZihkLHIsbCxlLmF1dG9QYWQsZS5ncm91cCxvLHAsbixhLGkpO2xldCBtPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obSx7a2VybmVsU2hhcGU6cixwYWRzOm8sb3V0cHV0UGFkZGluZzphLG91dHB1dFNoYXBlOmksZGlsYXRpb25zOmwsc3RyaWRlczpwfSksbX0sdGQ9ZT0+e2xldCB0PWpyKGUpLHI9ZS5mb3JtYXQsbj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLG89ZS5kaWxhdGlvbnMsaT1lLmdyb3VwLGE9ZS5rZXJuZWxTaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud0lzQ29uc3QoKSxtPWUub3V0cHV0UGFkZGluZyx1PWUub3V0cHV0U2hhcGU7cmV0dXJue2F1dG9QYWQ6bixmb3JtYXQ6cixkaWxhdGlvbnM6byxncm91cDppLGtlcm5lbFNoYXBlOmEsb3V0cHV0UGFkZGluZzptLG91dHB1dFNoYXBlOnUscGFkczpkLHN0cmlkZXM6bCx3SXNDb25zdDpwLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sd2Y9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbj1lWzFdLmRpbXNbMF07aWYociE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgbz1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09bykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBpPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke2l9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5wYWRzLnJlZHVjZSgobSx1KT0+bSt1LDApPjAmJnQucGFkcy5sZW5ndGghPT1pKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke2kqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PWkmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LHJkPShlLHQscixuKT0+e2xldCBvPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sWzIsMywwLDFdKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9byk7bGV0IGk9W3RbMF0sb107dC5sZW5ndGg9PT0zJiZpLnB1c2godFsyXSksZS5jb21wdXRlKFh1KGkscixuKSx7aW5wdXRzOml9KX0sdmY9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJm4ucHVzaChlLmlucHV0c1syXSk7bGV0IG89dC5rZXJuZWxTaGFwZTsoby5sZW5ndGg9PT0wfHxvWzBdPT09MCkmJihvPVtlLmlucHV0c1sxXS5kaW1zWzJdXSk7bGV0IGk9dC5kaWxhdGlvbnM7KGkubGVuZ3RoPT09MHx8aVswXT09PTApJiYoaT1bMV0pO2xldCBhPXQuc3RyaWRlczsoYS5sZW5ndGg9PT0wfHxhWzBdPT09MCkmJihhPVsxXSk7bGV0IGQ9dC5wYWRzO2QubGVuZ3RoPT09MCYmKGQ9WzAsMF0pLGQ9WzAsZFswXSwwLGRbMV1dLGE9WzFdLmNvbmNhdChhKSxpPVsxXS5jb25jYXQoaSksbz1bMV0uY29uY2F0KG8pO2xldCBsPWVkKHsuLi50LHBhZHM6ZCxzdHJpZGVzOmEsZGlsYXRpb25zOmksa2VybmVsU2hhcGU6b30sbik7cmQoZSxuLGwscD0+cj9bcFswXSxwWzJdLHBbM11dOltwWzBdLHBbMV0scFszXV0pfSxuZD0oZSx0KT0+e2lmKHdmKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Myl2ZihlLHQpO2Vsc2V7bGV0IHI9ZWQodCxlLmlucHV0cyk7cmQoZSxlLmlucHV0cyxyKX19fSk7dmFyICRmLGlkLGFkLHNkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpOyRmPShlLHQscixuKT0+e2xldCBvPUMuc2l6ZSh0KSxpPXQubGVuZ3RoLGE9RShcImlucHV0XCIsZSxpKSxkPU0oXCJvdXRwdXRcIixlLGkpLGw9ci5kYXRhVHlwZT09PTY/ci5nZXRJbnQzMkFycmF5KClbMF06TnVtYmVyKHIuZ2V0QmlnSW50NjRBcnJheSgpWzBdKSxwPUMubm9ybWFsaXplQXhpcyhsLGkpLG09dT0+e2xldCBoPWAgaTMyKCR7YS5pbmRpY2VzR2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSkgYCxfPUYoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwidW5pZm9ybXMuYXhpc1wiLGkpLHk9bi5yZXZlcnNlP2grKG4uZXhjbHVzaXZlP1wiICsgMVwiOlwiXCIpOlwiMFwiLGc9bi5yZXZlcnNlP186aCsobi5leGNsdXNpdmU/XCJcIjpcIiArIDFcIik7cmV0dXJuYFxuICAgICAgICAgICAgICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYSxkKX1cbiAgICAgICAgICAgICAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7ZC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7eX07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7Z307XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHthLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpKVwiKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDdW1TdW1cIixzaGFkZXJDYWNoZTp7aGludDpuLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnB9LC4uLk4odCx0KV19KSxnZXRTaGFkZXJTb3VyY2U6bX19LGlkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHNbMF0uZGltcyxuPWUuaW5wdXRzWzBdLmRhdGFUeXBlLG89ZS5pbnB1dHNbMV07ZS5jb21wdXRlKCRmKG4scixvLHQpLHtpbnB1dHM6WzBdfSl9LGFkPWU9PntsZXQgdD1lLmV4Y2x1c2l2ZT09PTEscj1lLnJldmVyc2U9PT0xO3JldHVybiByZSh7ZXhjbHVzaXZlOnQscmV2ZXJzZTpyfSl9fSk7dmFyIHhmLFNmLFRmLHVkLGRkLGxkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO3hmPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkRlcHRoVG9TcGFjZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aFRvU3BhY2UgcmVxdWlyZXMgNEQgaW5wdXQuXCIpfSxTZj0oZSx0LHIsbik9PntsZXQgbz1bXTtvLnB1c2goYGZuIHBlcm0oaTogJHtuLnR5cGUuaW5kaWNlc30pIC0+ICR7ci50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtyLnR5cGUuaW5kaWNlc307YCk7Zm9yKGxldCBpPTA7aTx0OysraSlvLnB1c2goci5pbmRpY2VzU2V0KFwiYVwiLGVbaV0sYGlbJHtpfV1gKSk7cmV0dXJuIG8ucHVzaChcInJldHVybiBhO31cIiksby5qb2luKGBcbmApfSxUZj0oZSx0KT0+e2xldCByLG4sbyxpLGEsZCxsPXQuZm9ybWF0PT09XCJOSFdDXCIscD10LmJsb2Nrc2l6ZSxtPXQubW9kZT09PVwiRENSXCI7bD8oW3IsbixvLGldPWUuZGltcyxhPW0/W3IsbixvLHAscCxpL3AqKjJdOltyLG4sbyxpL3AqKjIscCxwXSxkPW0/WzAsMSwzLDIsNCw1XTpbMCwxLDQsMiw1LDNdKTooW3IsbixvLGldPVtlLmRpbXNbMF0sZS5kaW1zWzJdLGUuZGltc1szXSxlLmRpbXNbMV1dLGE9bT9bcixwLHAsaS9wKioyLG4sb106W3IsaS9wKioyLHAscCxuLG9dLGQ9bT9bMCwzLDQsMSw1LDJdOlswLDEsNCwyLDUsM10pO2xldCB1PWUucmVzaGFwZShhKSxoPXUuZGltcy5sZW5ndGgsXz1lLmRhdGFUeXBlLHk9RShcImFcIixfLGgpLGc9TShcIm91dHB1dFwiLF8saCkseD0kPT5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeSxnKX1cblxuICAke1NmKGQsaCx5LGcpfVxuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke2cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7Zy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix5LmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWA7cmV0dXJue25hbWU6XCJEZXB0aFRvU3BhY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtlLmRpbXN9OyR7dC5ibG9ja3NpemV9OyR7dC5tb2RlfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTokPT57bGV0IHY9bD9bcixuKnAsbypwLGkvcCoqMl06W3IsaS9wKioyLG4qcCxvKnBdLFM9Qy5zaXplKHYpLFQ9dS5kaW1zLEE9Qy5zb3J0QmFzZWRPblBlcm0oVCxkKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6dixkYXRhVHlwZTokWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoUy82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpTfSwuLi5OKFQsQSldfX0sZ2V0U2hhZGVyU291cmNlOnh9fSx1ZD0oZSx0KT0+e3hmKGUuaW5wdXRzKSxlLmNvbXB1dGUoVGYoZS5pbnB1dHNbMF0sdCkpfSxkZD1lPT5yZSh7YmxvY2tzaXplOmUuYmxvY2tzaXplLG1vZGU6ZS5tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIHZvLGVuLGNkLElmLENmLCRvLHhvLHBkLEFmLG1kLGZkLGhkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO3ZvPVwiW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuXCIsZW49XCIoXCIrdm8rXCIpK1wiLGNkPVwiXlwiK2VuK1wiJFwiLElmPVwiKFwiK2VuK1wiLCkqXCIrZW4sQ2Y9XCJeXCIrSWYrXCIkXCIsJG89Y2xhc3N7Y29uc3RydWN0b3IodD0tMSl7dGhpcy5zeW1ib2xUb0luZGljZXM9bmV3IE1hcCx0aGlzLmlucHV0SW5kZXg9dH1hZGRTeW1ib2wodCxyKXtsZXQgbj10aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQodCk7bj09PXZvaWQgMD9uPVtyXTpuLnB1c2gociksdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHQsbil9fSx4bz1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMuZXF1YXRpb249cjt0aGlzLmhhc0VsbGlwc2lzPSExLHRoaXMuc3ltYm9sVG9JbmZvPW5ldyBNYXAsdGhpcy5saHM9bmV3IEFycmF5LHRoaXMub3V0cHV0RGltcz1bXTtsZXRbbixvXT1yLmluY2x1ZGVzKFwiLT5cIik/ci5zcGxpdChcIi0+XCIsMik6W3IsXCJcIl07aWYoIW4ubWF0Y2goUmVnRXhwKENmKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtpZihuLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChkLGwpPT57bGV0IHA9dFtsXS5kaW1zLnNsaWNlKCk7aWYoIWQubWF0Y2goUmVnRXhwKGNkKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgbT10aGlzLnByb2Nlc3NUZXJtKGQsITAscCxsKTt0aGlzLmxocy5wdXNoKG0pfSksbz09PVwiXCIpbys9Wy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV0uZmlsdGVyKChbZCxsXSk9PmwuY291bnQ9PT0xfHxkPT09XCIuLi5cIikubWFwKChbZF0pPT5kKS5qb2luKFwiXCIpO2Vsc2UgaWYoIW8ubWF0Y2goUmVnRXhwKGVuKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFNcIik7by5tYXRjaChSZWdFeHAodm8sXCJnXCIpKT8uZm9yRWFjaChkPT57aWYoZD09PVwiLi4uXCIpdGhpcy5vdXRwdXREaW1zPXRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO2Vsc2V7bGV0IGw9dGhpcy5zeW1ib2xUb0luZm8uZ2V0KGQpO2lmKGw9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFMgc3ltYm9sXCIpO3RoaXMub3V0cHV0RGltcy5wdXNoKGwuZGltVmFsdWUpfX0pLHRoaXMucmhzPXRoaXMucHJvY2Vzc1Rlcm0obywhMSx0aGlzLm91dHB1dERpbXMpfWFkZFN5bWJvbCh0LHIsbil7bGV0IG89dGhpcy5zeW1ib2xUb0luZm8uZ2V0KHQpO2lmKG8hPT12b2lkIDApe2lmKG8uZGltVmFsdWUhPT1yJiZvLmNvdW50IT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzbWF0Y2hcIik7by5jb3VudCsrLG8uaW5wdXRJbmRpY2VzLnB1c2gobil9ZWxzZSBvPXtjb3VudDoxLGRpbVZhbHVlOnIsaW5wdXRJbmRpY2VzOltuXX07dGhpcy5zeW1ib2xUb0luZm8uc2V0KHQsbyl9cHJvY2Vzc1Rlcm0odCxyLG4sbz0tMSl7bGV0IGk9bi5sZW5ndGgsYT0hMSxkPVtdLGw9MDtpZighdC5tYXRjaChSZWdFeHAoY2QpKSYmIXImJnQhPT1cIlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IHA9dC5tYXRjaChSZWdFeHAodm8sXCJnXCIpKSxtPW5ldyAkbyhvKTtyZXR1cm4gcD8uZm9yRWFjaCgodSxoKT0+e2lmKHU9PT1cIi4uLlwiKXtpZihhKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm1cIik7YT0hMDtsZXQgXz1pLXAubGVuZ3RoKzE7aWYoXzwwKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG91dCBvZiBib3VuZHNcIik7aWYoZD1uLnNsaWNlKGwsbCtfKSx0aGlzLmhhc0VsbGlwc2lzKXtpZih0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGghPT1kLmxlbmd0aHx8dGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSE9PWQudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoXCIpfWVsc2UgaWYocil0aGlzLmhhc0VsbGlwc2lzPSEwLHRoaXMuZWxsaXBzaXNEaW1zPWQ7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTXCIpO2ZvcihsZXQgeT0wO3k8ZC5sZW5ndGg7eSsrKXtsZXQgZz1TdHJpbmcuZnJvbUNoYXJDb2RlKFwiMFwiLmNoYXJDb2RlQXQoMCkreSk7bS5hZGRTeW1ib2woZyxoK3kpLHRoaXMuYWRkU3ltYm9sKGcsbltsKytdLG8pfX1lbHNlIG0uYWRkU3ltYm9sKHUsaCsodGhpcy5oYXNFbGxpcHNpcz90aGlzLmVsbGlwc2lzRGltcy5sZW5ndGgtMTowKSksdGhpcy5hZGRTeW1ib2wodSxuW2wrK10sbyl9KSxtfX0scGQ9ZT0+ZStcIl9tYXhcIixBZj0oZSx0LHIsbik9PntsZXQgaT1lLm1hcChtPT5tLmxlbmd0aCkubWFwKChtLHUpPT5FKGBpbnB1dCR7dX1gLHQsbSkpLGE9Qy5zaXplKG4pLGQ9TShcIm91dHB1dFwiLHQsbi5sZW5ndGgpLGw9Wy4uLnIuc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKG09PiFyLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKG0pKSxwPW09PntsZXQgdT1bXSxoPVwidmFyIHByb2QgPSAxLjA7XCIsXz1cInZhciBzdW0gPSAwLjA7XCIseT1cInN1bSArPSBwcm9kO1wiLGc9W10seD1bXSwkPVtdLHY9W10sUz1yLnN5bWJvbFRvSW5mby5zaXplPT09ci5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7ci5zeW1ib2xUb0luZm8uZm9yRWFjaCgoQSxrKT0+e2lmKHIucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoaykpe2xldCBQPXIucmhzLnN5bWJvbFRvSW5kaWNlcy5nZXQoayk/LlswXTtQIT09dm9pZCAwJiZyLmxocy5mb3JFYWNoKChELFIpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoUikpe2xldCBHPUQuc3ltYm9sVG9JbmRpY2VzLmdldChrKTtpZihHPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0cuZm9yRWFjaChLPT57dS5wdXNoKGAke2lbUl0uaW5kaWNlc1NldChgaW5wdXQke1J9SW5kaWNlc2AsSyxkLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsUCkpfWApfSl9fSl9ZWxzZSByLmxocy5mb3JFYWNoKChQLEQpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoRCkpe2xldCBSPVAuc3ltYm9sVG9JbmRpY2VzLmdldChrKTtpZihSPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO1IuZm9yRWFjaChHPT57Zy5wdXNoKGAke2lbRF0uaW5kaWNlc1NldChgaW5wdXQke0R9SW5kaWNlc2AsRyxgJHtrfWApfWApfSksdi5wdXNoKGBwcm9kICo9ICR7aVtEXS5nZXRCeUluZGljZXMoYGlucHV0JHtEfUluZGljZXNgKX07YCl9fSkseC5wdXNoKGBmb3IodmFyICR7a306IHUzMiA9IDA7ICR7a30gPCB1bmlmb3Jtcy4ke3BkKGspfTsgJHtrfSsrKSB7YCksJC5wdXNoKFwifVwiKX0pO2xldCBUPVM/Wy4uLnUsYGxldCBzdW0gPSAke2kubWFwKChBLGspPT5BLmdldEJ5SW5kaWNlcyhgaW5wdXQke2t9SW5kaWNlc2ApKS5qb2luKFwiICogXCIpfTtgXTpbLi4udSxfLC4uLngsLi4uZyxoLC4uLnYseSwuLi4kXTtyZXR1cm5gXG4gICAgICAgICAgICAke20ucmVnaXN0ZXJVbmlmb3JtcyhsLm1hcChBPT4oe25hbWU6YCR7cGQoQSl9YCx0eXBlOlwidTMyXCJ9KSkpLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLmksZCl9XG5cbiAgICAgICAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgJHtpLm1hcCgoQSxrKT0+YHZhciBpbnB1dCR7a31JbmRpY2VzOiAke2lba10udHlwZS5pbmRpY2VzfTtgKS5qb2luKGBcbmApfVxuICAgICAgICAgICAgJHtULmpvaW4oYFxuYCl9O1xuICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJFaW5zdW1cIixzaGFkZXJDYWNoZTp7aGludDpyLmVxdWF0aW9uLGlucHV0RGVwZW5kZW5jaWVzOmUubWFwKCgpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9PntsZXQgbT1sLmZpbHRlcihoPT5yLnN5bWJvbFRvSW5mby5oYXMoaCkpLm1hcChoPT4oe3R5cGU6MTIsZGF0YTpyLnN5bWJvbFRvSW5mby5nZXQoaCk/LmRpbVZhbHVlfHwwfSkpO20ucHVzaCh7dHlwZToxMixkYXRhOmF9KTtsZXQgdT1lLm1hcCgoaCxfKT0+Wy4uLk4oaCldKS5yZWR1Y2UoKGgsXyk9PmguY29uY2F0KF8pLG0pO3JldHVybiB1LnB1c2goLi4uTihuKSkse291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6dH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dX19LGdldFNoYWRlclNvdXJjZTpwfX0sbWQ9KGUsdCk9PntsZXQgcj1uZXcgeG8oZS5pbnB1dHMsdC5lcXVhdGlvbiksbj1yLm91dHB1dERpbXMsbz1lLmlucHV0cy5tYXAoKGksYSk9PmkuZGltcyk7ZS5jb21wdXRlKEFmKG8sZS5pbnB1dHNbMF0uZGF0YVR5cGUscixuKSl9LGZkPWU9PntsZXQgdD1lLmVxdWF0aW9uLnJlcGxhY2UoL1xccysvZyxcIlwiKTtyZXR1cm4gcmUoe2VxdWF0aW9uOnR9KX19KTt2YXIga2YsZ2QsRWYsUGYsYmQseWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO2tmPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyAyIGlucHV0LlwiKTtsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbj1yLmxlbmd0aDx0Lmxlbmd0aD8wOnIubGVuZ3RoLXQubGVuZ3RoLG89dC5sZW5ndGg8ci5sZW5ndGg/MDp0Lmxlbmd0aC1yLmxlbmd0aDtmb3IoO248ci5sZW5ndGgmJm88dC5sZW5ndGg7KytuLCsrbylpZihyW25dIT09dFtvXSYmcltuXSE9PTEmJnRbb10hPT0xKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0XCIpfSxnZD0oZSx0KT0+e2xldCByPWUubGVuZ3RoLXQubGVuZ3RoLG49W107Zm9yKGxldCBvPTA7bzxyOysrbyluLnB1c2goZVtvXSk7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDsrK28pbi5wdXNoKHRbb109PT0xP2VbbytyXTp0W29dKTtyZXR1cm4gbn0sRWY9KGUsdCk9PmUubGVuZ3RoPnQubGVuZ3RoP2dkKGUsdCk6Z2QodCxlKSxQZj1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG49RWYodCxyKSxvPWVbMF0uZGF0YVR5cGUsaT1vPT09OXx8Qy5zaXplKHQpPT09MSxhPW89PT05fHx0Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wPzQ6MSxkPWl8fG4ubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0lND09PTA/NDoxLGw9TWF0aC5jZWlsKEMuc2l6ZShuKS9kKSxwPXU9PntsZXQgaD1FKFwiaW5wdXRcIixvLHQubGVuZ3RoLGEpLF89TShcIm91dHB1dFwiLG8sbi5sZW5ndGgsZCkseTtpZihvPT09OSl7bGV0IGc9KHgsJCx2PVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMkeyR9ID0gJHtfLm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHskfXVgKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7JH0gPSAke2guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMkeyR9YCxfKX07XG4gICAgICAgICAgbGV0IGluZGV4JHskfSA9IG9mZnNldCR7JH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHskfSA9IG9mZnNldCR7JH0gJSA0dTtcbiAgICAgICAgICAke3h9WyR7JH1dID0gJHt2fSgke2guZ2V0QnlPZmZzZXQoYGluZGV4JHskfWApfVtjb21wb25lbnQkeyR9XSk7XG4gICAgICAgIGA7eT1gXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtkfTtcbiAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7ZyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAke2coXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgJHtnKFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7ZyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWB9ZWxzZSB5PWBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtkfWApfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHtoLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLF8pfTtcbiAgICAgICAgbGV0IGRhdGEgPSAke18udHlwZS52YWx1ZX0oJHtoLmdldEJ5T2Zmc2V0KGBpbnB1dE9mZnNldCAvICR7YX1gKX0pO1xuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWA7cmV0dXJuYFxuICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCxfKX1cbiAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAke3l9YH0sbT1be3R5cGU6MTIsZGF0YTpsfSwuLi5OKHQsbildO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bi5sZW5ndGh9OyR7YX0ke2R9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6cCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pfX0sYmQ9ZT0+e2tmKGUuaW5wdXRzKSxlLmNvbXB1dGUoUGYoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHpmLF9kLHdkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtLcigpO3pmPWU9PntsZXQgdD1lWzBdLmRhdGFUeXBlLHI9Qy5zaXplKGVbMF0uZGltcyksbj1DLnNpemUoZVsxXS5kaW1zKSxvPW4lND09PTAsaT1hPT57bGV0IGQ9RShcInhcIix0LFsxXSw0KSxsPUUoXCJiaWFzXCIsdCxbMV0sNCkscD1NKFwieVwiLHQsWzFdLDQpLG09W3tuYW1lOlwib3V0cHV0X3ZlY19zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dLHU9Xz0+YFxuICAgICAgbGV0IGJpYXMke199X29mZnNldDogdTMyID0gKGdsb2JhbF9pZHggKiA0ICsgJHtffSkgJSB1bmlmb3Jtcy5iaWFzX3NpemU7XG4gICAgICBsZXQgYmlhcyR7X30gPSAke2wuZ2V0QnlPZmZzZXQoYGJpYXMke199X29mZnNldCAvIDRgKX1bYmlhcyR7X31fb2Zmc2V0ICUgNF07YCxoPW8/YFxuICAgICAgbGV0IGJpYXMgPSAke2wuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLmJpYXNfc2l6ZSAvIDQpXCIpfTtgOmAke3UoMCl9JHt1KDEpfSR7dSgyKX0ke3UoMyl9XG4gICAgICBsZXQgYmlhcyA9ICR7ZC50eXBlLnZhbHVlfShiaWFzMCwgYmlhczEsIGJpYXMyLCBiaWFzMyk7YDtyZXR1cm5gJHthLnJlZ2lzdGVyVW5pZm9ybXMobSkuZGVjbGFyZVZhcmlhYmxlcyhkLGwscCl9XG5cbiAgICAke21vKEVlKHQpKX1cblxuICAgICR7YS5tYWluU3RhcnQoa3QpfVxuICAgICAgJHthLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfdmVjX3NpemVcIil9XG5cbiAgICAgIGxldCB4ID0gJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAke2h9XG4gICAgICBsZXQgeF9pbiA9IHggKyBiaWFzO1xuICAgICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGZvKFwieF9pblwiKSl9XG4gICAgfWB9O3JldHVybntuYW1lOlwiRmFzdEdlbHVXaXRoQmlhc1wiLHNoYWRlckNhY2hlOntoaW50OmAke299YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6aSxnZXRSdW5EYXRhOmE9Pih7b3V0cHV0czpbe2RpbXM6YVswXS5kaW1zLGRhdGFUeXBlOmFbMF0uZGF0YVR5cGV9XSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKHIvNCl9LHt0eXBlOjEyLGRhdGE6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHIva3QvNCl9fSl9fSxfZD1lPT57ZS5pbnB1dHMubGVuZ3RoPDJ8fEMuc2l6ZShlLmlucHV0c1sxXS5kaW1zKT09PTA/aHUoZSk6ZS5jb21wdXRlKHpmKGUuaW5wdXRzKSl9fSk7dmFyIE9mLERmLHZkLCRkLHhkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO09mPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LERmPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89ci5sZW5ndGgsaT1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGE9ci5zbGljZSgwKTthLnNwbGljZShpLDEsLi4ubik7bGV0IGQ9cltpXSxsPWVbMF0uZGF0YVR5cGU9PT05PzQ6MSxwPU1hdGguY2VpbChDLnNpemUoYSkvbCksbT1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZTo2LGRhdGE6ZH0se3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMsYSldLHU9aD0+e2xldCBfPUUoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGwpLHk9RShcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksZz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCxsKSx4PXY9PntsZXQgUz1uLmxlbmd0aCxUPWB2YXIgaW5kaWNlc0luZGljZXMke3Z9ICA9ICR7eS50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBBPTA7QTxTO0ErKylUKz1gJHtTPjE/YGluZGljZXNJbmRpY2VzJHt2fVske0F9XWA6YGluZGljZXNJbmRpY2VzJHt2fWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVt1bmlmb3Jtcy5heGlzICsgJHtBfV1gOmBvdXRwdXRJbmRpY2VzJHt2fWB9O2A7VCs9YFxuICAgICAgICAgIHZhciBpZHgke3Z9ID0gJHt5LmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke3Z9YCl9O1xuICAgICAgICAgIGlmIChpZHgke3Z9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHt2fSA9IGlkeCR7dn0gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7dn0gOiAke18udHlwZS5pbmRpY2VzfTtcbiAgICAgICAgYDtmb3IobGV0IEE9MCxrPTA7QTxvO0ErKylBPT09aT8oVCs9YCR7bz4xP2BkYXRhSW5kaWNlcyR7dn1bJHtBfV1gOmBkYXRhSW5kaWNlcyR7dn1gfSA9IHUzMihpZHgke3Z9KTtgLGsrPVMpOihUKz1gJHtvPjE/YGRhdGFJbmRpY2VzJHt2fVske0F9XWA6YGRhdGFJbmRpY2VzJHt2fWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVske2t9XWA6YG91dHB1dEluZGljZXMke3Z9YH07YCxrKyspO3JldHVybiBUfSwkO2lmKGVbMF0uZGF0YVR5cGU9PT05KXtsZXQgdj0oUyxULEE9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7VH0gPSAke2cub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke1R9dWApfTtcbiAgICAgICAgICAke3goVCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke1R9ID0gJHtfLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke1R9YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7VH0gPSBvZmZzZXQke1R9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7VH0gPSBvZmZzZXQke1R9ICUgNHU7XG4gICAgICAgICAgJHtTfVske1R9XSA9ICR7QX0oJHtfLmdldEJ5T2Zmc2V0KGBpbmRleCR7VH1gKX1bY29tcG9uZW50JHtUfV0pO1xuICAgICAgICBgOyQ9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7bH07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHt2KFwidmFsdWVcIiwwLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwzLFwidTMyXCIpfVxuICAgICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgICAgIGB9ZWxzZSAkPWBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtnLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHt4KFwiXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Xy5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XG4gICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICBgO3JldHVybmBcbiAgICAgICR7aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoXyx5LGcpfVxuICAgICAgJHtoLm1haW5TdGFydCgpfVxuICAgICAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICR7JH1cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6dX19LHZkPWU9PnJlKHtheGlzOmUuYXhpc30pLCRkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7T2YociksZS5jb21wdXRlKERmKGUuaW5wdXRzLHQpKX19KTt2YXIgQmYsU2QsVGQsSWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0JmPShlLHQscixuLG8saSxhLGQsbCk9PntsZXQgcD1be3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfV0sbT1baV07cC5wdXNoKC4uLk4odC5kaW1zLG0pKTtsZXQgdT1oPT57bGV0IF89RShcImluZGljZXNfZGF0YVwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkseT1NKFwiaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhXCIsMTIsMSwxKSxnPVtfLHldLHg9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmF0Y2hfZGltc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ci5sZW5ndGh9LHtuYW1lOlwibnVtX3NsaWNlc19wZXJfYmF0Y2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaW5wdXRfYmF0Y2hfc3RyaWRlXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9zbGljZV9kaW1zXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke2gucmVnaXN0ZXJVbmlmb3Jtcyh4KS5kZWNsYXJlVmFyaWFibGVzKC4uLmcpfVxuICAke2gubWFpblN0YXJ0KCl9XG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLm51bV9zbGljZXNfcGVyX2JhdGNoO1xuICAgIGxldCBiYXNlX29mZnNldCA9IGJhdGNoX2lkeCAqIHVuaWZvcm1zLmlucHV0X2JhdGNoX3N0cmlkZTtcblxuICAgIGxldCBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm51bV9zbGljZV9kaW1zO1xuICAgIHZhciByZWxhdGl2ZV9zbGljZV9vZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGRpbV9pZHggPSAwdTsgZGltX2lkeCA8IHVuaWZvcm1zLm51bV9zbGljZV9kaW1zOyBkaW1faWR4ICsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc19kYXRhW2RpbV9pZHggKyBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0XS54KTtcbiAgICAgIGxldCBpbnB1dF9kaW1faWR4ID0gdW5pZm9ybXMuYmF0Y2hfZGltcyArIGRpbV9pZHg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICR7by5sZW5ndGg9PT0xP1wiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXMpO1wiOlwiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXNbaW5wdXRfZGltX2lkeF0pO1wifVxuICAgICAgfVxuICAgICAgJHtyLmxlbmd0aD09PTE/XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEpO1wiOlwicmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhW2RpbV9pZHhdKTtcIn1cbiAgICB9XG5cbiAgICBpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFbZ2xvYmFsX2lkeF0gPSAgYmFzZV9vZmZzZXQgKyB1MzIocmVsYXRpdmVfc2xpY2Vfb2Zmc2V0KTtcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJjb21wdXRlU2xpY2VPZmZzZXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7by5sZW5ndGh9XyR7ci5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6ZS5pbnB1dHNbMV0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6dX0se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF19LFNkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHMsbj1yWzBdLmRpbXMsbz1yWzBdLmRhdGFUeXBlLGk9clsxXS5kaW1zLGE9aVtpLmxlbmd0aC0xXSxkPUMuc2l6ZVRvRGltZW5zaW9uKGksaS5sZW5ndGgtMSksbD1DLnNpemVGcm9tRGltZW5zaW9uKG4sdC5iYXRjaERpbXMrYSkscD1DLnNpemVUb0RpbWVuc2lvbihuLHQuYmF0Y2hEaW1zKSxtPUMuc2l6ZUZyb21EaW1lbnNpb24obix0LmJhdGNoRGltcyksdT1kL3AsaD1uZXcgQXJyYXkoYSksXz1sO2ZvcihsZXQgVD0wO1Q8YTsrK1QpaFthLTEtVF09XyxfKj1uW3QuYmF0Y2hEaW1zK2EtMS1UXTtsZXQgeT1CZihlLHJbMV0saCx0LmJhdGNoRGltcyxuLGQsdSxtLGEpLGc9dC5iYXRjaERpbXMrYTtpZihnPm4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGluZGljZXMgbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gcmFuayBvZiBpbnB1dCB0ZW5zb3JcIik7bGV0IHg9aS5zbGljZSgwLC0xKS5jb25jYXQobi5zbGljZShnKSksJD1DLnNpemUoeCksdj1be3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOmx9LC4uLk4oclswXS5kaW1zLHkuZGltcyx4KV0sUz1UPT57bGV0IEE9RShcImRhdGFcIixyWzBdLmRhdGFUeXBlLHJbMF0uZGltcy5sZW5ndGgpLGs9RShcInNsaWNlX29mZnNldHNcIiwxMix5LmRpbXMubGVuZ3RoKSxQPU0oXCJvdXRwdXRcIixyWzBdLmRhdGFUeXBlLHgubGVuZ3RoKTtyZXR1cm5gXG4gICAgICAgICAgJHtULnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2xpY2Vfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoQSxrLFApfVxuICAgICAgICAgICAgJHtULm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtULmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICBsZXQgc2xpY2Vfb2Zmc2V0ID0gc2xpY2Vfb2Zmc2V0c1tnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZGF0YVt1MzIoc2xpY2Vfb2Zmc2V0KSArIGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkdhdGhlck5EXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOngsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKCQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dn0pLGdldFNoYWRlclNvdXJjZTpTfSx7aW5wdXRzOltyWzBdLHldfSl9LFRkPWU9Pih7YmF0Y2hEaW1zOmUuYmF0Y2hfZGltcyxjYWNoZUtleTpcIlwifSl9KTt2YXIgTWYsUmYsQ2QsQWQsa2Q9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7TWY9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIkdhdGhlckJsb2NrUXVhbnRpemVkIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHMuXCIpO2xldCByPUMubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxuPXQuYmxvY2tTaXplLG89ZVswXSxpPWVbMl0sYT1lLmxlbmd0aD09PTQ/ZVszXTp2b2lkIDA7aWYoaS5kaW1zLmxlbmd0aCE9PW8uZGltcy5sZW5ndGh8fCFvLmRpbXMubWFwKChkLGwpPT5sPT09cj9NYXRoLmNlaWwoZC9uKT09PWkuZGltc1tsXTpkPT09aS5kaW1zW2xdKS5yZWR1Y2UoKGQsbCk9PmQmJmwsITApKXRocm93IG5ldyBFcnJvcihcIlNjYWxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIGdhdGhlckF4aXMuXCIpO2lmKGEpe2lmKGEuZGF0YVR5cGUhPT1vLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIlplcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyB0aGUgaW5wdXQgdGVuc29yLlwiKTtpZihhLmRpbXMubGVuZ3RoIT09aS5kaW1zLmxlbmd0aHx8IWEuZGltcy5tYXAoKGQsbCk9PmQ9PT1pLmRpbXNbbF0pLnJlZHVjZSgoZCxsKT0+ZCYmbCwhMCkpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIHF1YW50aXplQXhpcy5cIil9fSxSZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMV0uZGltcyxvPXIubGVuZ3RoLGk9Qy5ub3JtYWxpemVBeGlzKHQuZ2F0aGVyQXhpcyxvKSxhPUMubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxvKSxkPXIuc2xpY2UoMCk7ZC5zcGxpY2UoaSwxLC4uLm4pO2xldCBsPUMuc2l6ZShkKSxwPWVbMl0uZGF0YVR5cGUsdT1lWzBdLmRhdGFUeXBlPT09MjIsaD1be3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTp0LmJsb2NrU2l6ZX0sLi4uTiguLi5lLm1hcCgoeSxnKT0+eS5kaW1zKSxkKV0sXz15PT57bGV0IGc9RShcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLHg9RShcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksJD1FKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSx2PWUubGVuZ3RoPjM/RShcInplcm9Qb2ludFwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwLFM9TShcIm91dHB1dFwiLHAsZC5sZW5ndGgpLFQ9W2cseCwkXTt2JiZULnB1c2godik7bGV0IEE9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicXVhbnRpemVfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJnYXRoZXJfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgICAke3kucmVnaXN0ZXJVbmlmb3JtcyhBKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQsUyl9XG4gICAgICAgICR7eS5tYWluU3RhcnQoKX1cbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICB2YXIgaW5kaWNlc19pbmRpY2VzID0gJHt4LnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICR7KCgpPT5uLmxlbmd0aD4xP2BcbiAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtuLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyBpXCIpfTtcbiAgICAgICAgICAgICR7eC5pbmRpY2VzU2V0KFwiaW5kaWNlc19pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgICAgfWA6YGluZGljZXNfaW5kaWNlcyA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzXCIpfTtgKSgpfTtcbiAgICAgICAgdmFyIGRhdGFfaW5kaWNlcyA9ICR7Zy50eXBlLmluZGljZXN9KDApO1xuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZ2F0aGVyX2F4aXM7IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4X2Zyb21faW5kaWNlcyA9ICR7eC5nZXRCeUluZGljZXMoXCJpbmRpY2VzX2luZGljZXNcIil9O1xuICAgICAgICBpZiAoaW5kZXhfZnJvbV9pbmRpY2VzIDwgMCkge1xuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke3JbaV19O1xuICAgICAgICB9XG4gICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpc1wiLFwidTMyKGluZGV4X2Zyb21faW5kaWNlcylcIil9O1xuICAgICAgICBmb3IgKHZhciBpID0gdW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyAxOyBpIDwgJHtkLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixgaSArICR7bi5sZW5ndGh9IC0gMWApfTtcbiAgICAgICAgICAke2cuaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhX29mZnNldCA9ICR7Zy5pbmRpY2VzVG9PZmZzZXQoXCJkYXRhX2luZGljZXNcIil9O1xuICAgICAgICBsZXQgZGF0YV9pbmRleCA9IGRhdGFfb2Zmc2V0ICUgODtcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHtnLmdldEJ5T2Zmc2V0KFwiZGF0YV9vZmZzZXQgLyA4XCIpfTtcbiAgICAgICAgbGV0IHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhID0gKHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID4+ICg0ICogKGRhdGFfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhX3ZlYyA9ICR7dT9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhKSk7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YSA9IHF1YW50aXplZF9kYXRhX3ZlY1tkYXRhX2luZGV4IC8gMl07XG4gICAgICAgIHZhciBzY2FsZV9pbmRpY2VzID0gZGF0YV9pbmRpY2VzO1xuICAgICAgICBsZXQgcXVhbnRpemVfYXhpc19pbmRleCA9ICR7JC5pbmRpY2VzR2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5xdWFudGl6ZV9heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICR7JC5pbmRpY2VzU2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMucXVhbnRpemVfYXhpc1wiLFwicXVhbnRpemVfYXhpc19pbmRleFwiKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7JC5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtcbiAgICAgICAgJHsoKCk9PnY/YFxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRpY2VzID0gc2NhbGVfaW5kaWNlcztcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHt2LmluZGljZXNUb09mZnNldChcInplcm9fcG9pbnRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gemVyb19wb2ludF9vZmZzZXQgJSA4O1xuICAgICAgICAgICAgICBsZXQgcGFja2VkXzRiaXRfemVyb19wb2ludHMgPSAke3YuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X29mZnNldCAvIDhcIil9O1xuICAgICAgICAgICAgICBsZXQgcGFja2VkXzhiaXRfemVyb19wb2ludHMgPSAocGFja2VkXzRiaXRfemVyb19wb2ludHMgPj4gKDQgKiAoemVyb19wb2ludF9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke3U/XCJ1bnBhY2s0eEk4XCI6XCJ1bnBhY2s0eFU4XCJ9KHUzMihwYWNrZWRfOGJpdF96ZXJvX3BvaW50cykpO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludCA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggLyAyXTtgOlwidmFyIHplcm9fcG9pbnQgPSAwXCIpKCl9O1xuICAgICAgICBsZXQgZGVxdWFudGl6ZWRfZGF0YSA9ICR7RWUocCl9KHF1YW50aXplZF9kYXRhIC0gemVyb19wb2ludCkgKiBzY2FsZTtcbiAgICAgICAgJHtTLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGVxdWFudGl6ZWRfZGF0YVwiKX07XG4gICAgfWB9O3JldHVybntuYW1lOlwiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske2UuZmlsdGVyKCh5LGcpPT5nIT09MSkubWFwKHk9PnkuZGltcy5qb2luKFwiX1wiKSkuam9pbihcIjtcIil9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheS5mcm9tKHtsZW5ndGg6ZS5sZW5ndGh9LCh5LGcpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTpwfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpofSksZ2V0U2hhZGVyU291cmNlOl99fSxDZD0oZSx0KT0+e2xldCByPWUuaW5wdXRzO01mKHIsdCksZS5jb21wdXRlKFJmKGUuaW5wdXRzLHQpKX0sQWQ9ZT0+cmUoe2Jsb2NrU2l6ZTplLmJsb2NrU2l6ZSxnYXRoZXJBeGlzOmUuZ2F0aGVyQXhpcyxxdWFudGl6ZUF4aXM6ZS5xdWFudGl6ZUF4aXN9KX0pO3ZhciBVZixOZixFZCxQZCx6ZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtVZj1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApfSxOZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMF0uZGF0YVR5cGUsbz1yLmxlbmd0aCxpPWVbMV0uZGltcyxhPWVbMV0uZGF0YVR5cGUsZD1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGw9cltkXSxwPWkuc2xpY2UoMCksbT1DLnNpemUocCksdT1FKFwiaW5wdXRcIixuLG8pLGg9RShcImluZGljZXNJbnB1dFwiLGEsaS5sZW5ndGgpLF89TShcIm91dHB1dFwiLG4scC5sZW5ndGgpLHk9W3t0eXBlOjEyLGRhdGE6bX0se3R5cGU6NixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6ZH1dO3JldHVybiB5LnB1c2goLi4uTihyLGkscCkpLHtuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KSxnZXRTaGFkZXJTb3VyY2U6JD0+YFxuICAgICAgJHskLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh1LGgsXyl9XG4gICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICB2YXIgaWR4ID0gJHtoLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHt1LnR5cGUuaW5kaWNlc30ob3V0cHV0SW5kaWNlcyk7XG4gICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGlkeClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHt1LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG5cbiAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9fSxFZD1lPT5yZSh7YXhpczplLmF4aXN9KSxQZD0oZSx0KT0+e2xldCByPWUuaW5wdXRzO1VmKHIpLGUuY29tcHV0ZShOZihlLmlucHV0cyx0KSl9fSk7dmFyIFZmLFdmLE9kLERkLEJkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtWZj1lPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8ZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0sV2Y9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKSxuPWVbMV0uZGltcy5zbGljZSgpLFtvLGksYV09VnIuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocix0LnRyYW5zQSxuLHQudHJhbnNCLGUubGVuZ3RoPT09Mz9lWzJdLmRpbXM6dm9pZCAwKSxkPVtvLGldO2lmKCFkKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBsPTE2LHA9TWF0aC5jZWlsKGkvbCksbT1NYXRoLmNlaWwoby9sKSx1PSEwLGg9Qy5zaXplKGQpLF89W3t0eXBlOjEyLGRhdGE6dT9wOmh9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEsZGF0YTp0LmFscGhhfSx7dHlwZToxLGRhdGE6dC5iZXRhfV0seT1bXCJ0eXBlXCIsXCJ0eXBlXCJdO2UubGVuZ3RoPT09MyYmKF8ucHVzaCguLi5OKGVbMl0uZGltcykpLHkucHVzaChcInJhbmtcIikpLF8ucHVzaCguLi5OKGQpKTtsZXQgZz0kPT57bGV0IHY9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/dj1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTtcIjp0LnRyYW5zQSYmIXQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07XCI6IXQudHJhbnNBJiZ0LnRyYW5zQj92PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYodj1cInZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIik7bGV0IFM9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiLFQ9RShcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksQT1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxrPVQudHlwZS52YWx1ZSxQPW51bGwsRD1bVCxBXTtlLmxlbmd0aD09PTMmJihQPUUoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxELnB1c2goUCkpO2xldCBSPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKTtELnB1c2goUik7bGV0IEc9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoRykuZGVjbGFyZVZhcmlhYmxlcyguLi5EKX1cblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7a30oMCk7XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICR7dn1cbiAgICB9XG5cbiAgICAke1N9XG4gICAgJHsoKCk9PlAhPW51bGw/YGxldCBjT2Zmc2V0ID0gJHtQLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwidmVjMihtLCBuKVwiLFIpfTsgdmFsdWUgKz0gJHtrfSh1bmlmb3Jtcy5iZXRhKSAqICR7UC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIikoKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWB9LHg9JD0+e2xldCB2PUUoXCJhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLFM9RShcImJcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksVD1udWxsLEE9W3YsU107ZS5sZW5ndGg9PT0zJiYoVD1FKFwiY1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksQS5wdXNoKFQpKTtsZXQgaz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLmxlbmd0aCk7QS5wdXNoKGspO2xldCBQPVt7bmFtZTpcIm51bV90aWxlX25cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dLEQ9XCJcIixSPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTp0LnRyYW5zQSYmIXQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO1wiKTohdC50cmFuc0EmJnQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTohdC50cmFuc0EmJiF0LnRyYW5zQiYmKFI9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpO2xldCBHPXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTtcIjtyZXR1cm5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm1zKFApLmRlY2xhcmVWYXJpYWJsZXMoLi4uQSl9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYTogYXJyYXk8YXJyYXk8JHt2LnR5cGUuc3RvcmFnZX0sICR7bH0+LCAke2x9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZV9iOiBhcnJheTxhcnJheTwke1MudHlwZS5zdG9yYWdlfSwgJHtsfT4sICR7bH0+O1xuICAkeyQubWFpblN0YXJ0KFtsLGwsMV0pfVxuICAgIGxldCB0aWxlX2NvbF9zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7bH07XG4gICAgbGV0IHRpbGVfcm93X3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLm51bV90aWxlX24pICogJHtsfTtcbiAgICBsZXQgbnVtX3RpbGVzID0gKHVuaWZvcm1zLksgLSAxKSAvICR7bH0gKyAxO1xuICAgIHZhciBrX3N0YXJ0ID0gMHU7XG4gICAgdmFyIHZhbHVlID0gJHtrLnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHQ6IHUzMiA9IDB1OyB0IDwgbnVtX3RpbGVzOyB0KyspIHtcbiAgICAgICR7Un1cbiAgICAgIGtfc3RhcnQgPSBrX3N0YXJ0ICsgJHtsfTtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke2x9OyBrKyspIHtcbiAgICAgICAgJHtEfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgICR7R31cbiAgICBsZXQgbSA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbiA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAkeygoKT0+VCE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke1QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsayl9OyB2YWx1ZSArPSAke2sudHlwZS52YWx1ZX0odW5pZm9ybXMuYmV0YSkgKiAke1QuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtgOlwiXCIpKCl9XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBvdXRwdXRbbSAqIHVuaWZvcm1zLk4gKyBuXSA9IHZhbHVlO1xuICAgIH1cbiAgfWB9O3JldHVybiB1P3tuYW1lOlwiR2VtbVNoYXJlZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6cCptfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTp4fTp7bmFtZTpcIkdlbW1cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6eX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOl99KSxnZXRTaGFkZXJTb3VyY2U6Z319LE9kPWU9PntsZXQgdD1lLnRyYW5zQSxyPWUudHJhbnNCLG49ZS5hbHBoYSxvPWUuYmV0YTtyZXR1cm57dHJhbnNBOnQsdHJhbnNCOnIsYWxwaGE6bixiZXRhOm8sY2FjaGVLZXk6YCR7ZS50cmFuc0F9OyR7ZS50cmFuc0J9OyR7ZS5hbHBoYT09PTF9YH19LERkPShlLHQpPT57VmYoZS5pbnB1dHMpLGUuY29tcHV0ZShXZihlLmlucHV0cyx0KSl9fSk7dmFyIGx0LF90LFV0LE50LExmLEdmLEhmLEZmLHFmLEtmLGpmLFlmLE1kLFJkLFVkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1tsdCxfdCxVdCxOdF09WzAsMSwyLDNdLExmPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IDQtRCB0ZW5zb3IgaXMgc3VwcG9ydGVkLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwgdG8gZ3JpZCBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltcy5sZW5ndGgtMiE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTFdKXRocm93IG5ldyBFcnJvcihgbGFzdCBkaW1lbnNpb24gb2YgZ3JpZCBtdXN0IGJlIGVxdWFsIHRvICR7ZVswXS5kaW1zLmxlbmd0aC0yfWApO2lmKGVbMF0uZGltc1swXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJncmlkIGJhdGNoIHNpemUgbXVzdCBtYXRjaCBpbnB1dCBiYXRjaCBzaXplXCIpfSxHZj1gXG4gIGZuIGdzX2dldF9jdWJpY19jb2VmZnMoeDogZjMyKSAtPiB2ZWM0PGYzMj4ge1xuICAgIGxldCBjdWJpY19hbHBoYSA9IC0wLjc1ZjtcbiAgICBsZXQgeF9hYnMgPSBhYnMoeCk7XG4gICAgdmFyIGNvZWZmczogdmVjNDxmMzI+O1xuICAgIGNvZWZmc1swXSA9ICgoKGN1YmljX2FscGhhICogKHhfYWJzICsgMSkgLSA1ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgKyA4ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgLSA0ICogY3ViaWNfYWxwaGEpO1xuICAgIGNvZWZmc1sxXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiB4X2FicyAtIChjdWJpY19hbHBoYSArIDMpKSAqIHhfYWJzICogeF9hYnMgKyAxKTtcbiAgICBjb2VmZnNbMl0gPSAoKChjdWJpY19hbHBoYSArIDIpICogKDEgLSB4X2FicykgLSAoY3ViaWNfYWxwaGEgKyAzKSkgKiAoMSAtIHhfYWJzKSAqICgxIC0geF9hYnMpICsgMSk7XG4gICAgY29lZmZzWzNdID0gKCgoY3ViaWNfYWxwaGEgKiAoMiAtIHhfYWJzKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSArIDggKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuYCxIZj1lPT5gXG4gIGZuIGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocDogbWF0NHg0PCR7ZX0+LCB4OiBmMzIsIHk6IGYzMikgLT4gJHtlfSB7XG4gICAgdmFyIHY6IHZlYzQ8ZjMyPjtcbiAgICB2YXIgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgdltpXSA9IGNvZWZmc1swXSAqIHBbaV1bMF0gKyBjb2VmZnNbMV0gKiBwW2ldWzFdICsgY29lZmZzWzJdICogcFtpXVsyXSArIGNvZWZmc1szXSAqIHBbaV1bM107XG4gICAgfVxuICAgIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeSk7XG4gICAgbGV0IHBpeGVsID0gJHtlfShjb2VmZnNbMF0gKiB2WzBdICsgY29lZmZzWzFdICogdlsxXSArIGNvZWZmc1syXSAqIHZbMl0gKyBjb2VmZnNbM10gKiB2WzNdKTtcbiAgICByZXR1cm4gcGl4ZWw7XG4gIH1cbmAsRmY9ZT0+YFxuICBmbiBnc19kZW5vcm1hbGl6ZShuOiBmMzIsIGxlbmd0aDogaTMyKSAtPiBmMzIge1xuICAgICR7ZS5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAvLyBhbGlnbkNvcm5lcnM6IGZhbHNlID0+IFstMSwgMV0gdG8gWy0wLjUsIGxlbmd0aCAtIDAuNV1cbiAgICByZXR1cm4gKChuICsgMS4wKSAqIGYzMihsZW5ndGgpIC0gMS4wKSAvIDIuMDtcbiAgICBgOmBcbiAgICAvLyBhbGlnbkNvcm5lcnM6IHRydWUgPT4gWy0xLCAxXSB0byBbMCwgbGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gKG4gKyAxLjApIC8gMi4wICogKGYzMihsZW5ndGggLSAxKSk7XG4gICAgYH1cbiAgfVxuYCxxZj1lPT5gXG4gICR7ZS5wYWRkaW5nTW9kZT09PVwicmVmbGVjdGlvblwiP2BcbiAgICAgIGZuIGdzX3JlZmxlY3QoeDogaTMyLCB4X21pbjogZjMyLCB4X21heDogZjMyKSAtPiB1MzIge1xuICAgICAgICB2YXIgZHggPSAwLjA7XG4gICAgICAgIHZhciBmeCA9IGYzMih4KTtcbiAgICAgICAgbGV0IHJhbmdlID0geF9tYXggLSB4X21pbjtcbiAgICAgICAgaWYgKGZ4IDwgeF9taW4pIHtcbiAgICAgICAgICBkeCA9IHhfbWluIC0gZng7XG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xuICAgICAgICAgIGlmIChuICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZ4ID4geF9tYXgpIHtcbiAgICAgICAgICBkeCA9IGZ4IC0geF9tYXg7XG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xuICAgICAgICAgIGlmIChuICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1MzIoZngpO1xuICAgICAgfWA6XCJcIn1cbmAsS2Y9KGUsdCxyKT0+YFxuICBmbiBwaXhlbF9hdF9ncmlkKHI6IGkzMiwgYzogaTMyLCBIOiBpMzIsIFc6IGkzMiwgYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBib3JkZXI6IHZlYzQ8ZjMyPikgLT4gJHt0fSB7XG4gICAgIHZhciBwaXhlbCA9ICR7dH0oMCk7XG4gICAgIHZhciBpbmRpY2VzID0gdmVjNDx1MzI+KDApO1xuICAgICBpbmRpY2VzWyR7bHR9XSA9IGJhdGNoO1xuICAgICBpbmRpY2VzWyR7X3R9XSA9IGNoYW5uZWw7YCsoKCk9Pntzd2l0Y2goci5wYWRkaW5nTW9kZSl7Y2FzZVwiemVyb3NcIjpyZXR1cm5gXG4gICAgICAgICAgaWYgKHIgPj0gMCAmJiByIDwgSCAmJiBjID49MCAmJiBjIDwgVykge1xuICAgICAgICAgICAgaW5kaWNlc1ske1V0fV0gPSB1MzIocik7XG4gICAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IHUzMihjKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7Y2FzZVwiYm9yZGVyXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtVdH1dID0gdTMyKGNsYW1wKHIsIDAsIEggLSAxKSk7XG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSB1MzIoY2xhbXAoYywgMCwgVyAtIDEpKTtcbiAgICAgICAgYDtjYXNlXCJyZWZsZWN0aW9uXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtVdH1dID0gZ3NfcmVmbGVjdChyLCBib3JkZXJbMV0sIGJvcmRlclszXSk7XG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSBnc19yZWZsZWN0KGMsIGJvcmRlclswXSwgYm9yZGVyWzJdKTtcbiAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcGFkZGluZyBtb2RlICR7ci5wYWRkaW5nTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrYFxuICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKX07XG4gIH1cbmAsamY9KGUsdCxyKT0+KCgpPT57c3dpdGNoKHIubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcGl4ZWxfYXRfZ3JpZChpMzIocm91bmQoeSkpLCBpMzIocm91bmQoeCkpLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgIGA7Y2FzZVwiYmlsaW5lYXJcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgxID0gaTMyKGZsb29yKHgpKTtcbiAgICAgICAgICBsZXQgeTEgPSBpMzIoZmxvb3IoeSkpO1xuICAgICAgICAgIGxldCB4MiA9IHgxICsgMTtcbiAgICAgICAgICBsZXQgeTIgPSB5MSArIDE7XG5cbiAgICAgICAgICBsZXQgcDExID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDEyID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIxID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIyID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcblxuICAgICAgICAgIGxldCBkeDIgPSAke3R9KGYzMih4MikgLSB4KTtcbiAgICAgICAgICBsZXQgZHgxID0gJHt0fSh4IC0gZjMyKHgxKSk7XG4gICAgICAgICAgbGV0IGR5MiA9ICR7dH0oZjMyKHkyKSAtIHkpO1xuICAgICAgICAgIGxldCBkeTEgPSAke3R9KHkgLSBmMzIoeTEpKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZHkyICogKGR4MiAqIHAxMSArIGR4MSAqIHAxMikgKyBkeTEgKiAoZHgyICogcDIxICsgZHgxICogcDIyKTtcbiAgICAgICAgYDtjYXNlXCJiaWN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgIGxldCB4MCA9IGkzMihmbG9vcih4KSkgLSAxO1xuICAgICAgICAgIGxldCB5MCA9IGkzMihmbG9vcih5KSkgLSAxO1xuICAgICAgICAgIHZhciBwOiBtYXQ0eDQ8JHt0fT47XG4gICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCA0OyBoKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgNDsgdysrKSB7XG4gICAgICAgICAgICAgIHBbaF1bd10gPSBwaXhlbF9hdF9ncmlkKGggKyB5MCwgdyArIHgwLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGR4ID0geCAtIGYzMih4MCArIDEpO1xuICAgICAgICAgIGxldCBkeSA9IHkgLSBmMzIoeTAgKyAxKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwLCBkeCwgZHkpO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBtb2RlICR7ci5tb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgJHtlLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwicmVzdWx0XCIpfWAsWWY9KGUsdCk9PntsZXQgcj1FKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksbj1bZVsxXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl1dLG89RShcImdyaWRcIixlWzFdLmRhdGFUeXBlLG4ubGVuZ3RoLDIpLGk9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV07dC5mb3JtYXQ9PT1cIk5IV0NcIiYmKGk9W2VbMF0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMF0uZGltc1szXV0sW2x0LF90LFV0LE50XT1bMCwzLDEsMl0pO2xldCBhPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGkubGVuZ3RoKSxkPXIudHlwZS52YWx1ZSxsPUMuc2l6ZShpKSxwPVt7dHlwZToxMixkYXRhOmx9LC4uLk4oZVswXS5kaW1zLG4saSldLG09dT0+YFxuICAke3UucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHIsbyxhKX1cbiAgJHtHZn1cbiAgJHtIZihkKX1cbiAgJHtGZih0KX1cbiAgJHtxZih0KX1cbiAgJHtLZihyLGQsdCl9XG5cbiAgJHt1Lm1haW5TdGFydCgpfVxuICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgSF9pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7VXR9XSk7XG4gICAgICBsZXQgV19pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7TnR9XSk7XG5cbiAgICAgICR7dC5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAgIGxldCB4X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAwLjU7XG4gICAgICBsZXQgeV9taW4gPSAtMC41O1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMC41O1xuICAgICAgYDpgXG4gICAgICBsZXQgeF9taW4gPSAwLjA7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAxLjA7XG4gICAgICBsZXQgeV9taW4gPSAwLjA7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAxLjA7XG4gICAgICBgfTtcbiAgICAgIGxldCBib3JkZXIgPSB2ZWM0PGYzMj4oeF9taW4sIHlfbWluLCB4X21heCwgeV9tYXgpO1xuXG4gICAgICBsZXQgaW5kaWNlcyA9ICR7YS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBncmlkX2luZGljZXMgPSB2ZWMzPHUzMj4oaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtVdH1dLCBpbmRpY2VzWyR7TnR9XSk7XG4gICAgICBsZXQgbnh5ID0gJHtvLmdldEJ5SW5kaWNlcyhcImdyaWRfaW5kaWNlc1wiKX07XG4gICAgICB2YXIgeCA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMF0pLCBXX2luKTtcbiAgICAgIHZhciB5ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVsxXSksIEhfaW4pO1xuXG4gICAgICAke2pmKGEsZCx0KX1cbiAgfWA7cmV0dXJue25hbWU6XCJHcmlkU2FtcGxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6dT0+e2xldCBoPUMuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTp1WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3JtczpwfX0sZ2V0U2hhZGVyU291cmNlOm19fSxNZD0oZSx0KT0+e0xmKGUuaW5wdXRzKSxlLmNvbXB1dGUoWWYoZS5pbnB1dHMsdCkpfSxSZD1lPT5yZSh7YWxpZ25Db3JuZXJzOmUuYWxpZ25fY29ybmVycyxtb2RlOmUubW9kZSxwYWRkaW5nTW9kZTplLnBhZGRpbmdfbW9kZSxmb3JtYXQ6ZS5mb3JtYXR9KX0pO3ZhciBCZSxYZixWZCxOZCxKZix0cixXZCxTbz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7TnIoKTtGcigpO2FlKCk7ZHQoKTtCZT0oZSx0KT0+ZS5sZW5ndGg+dCYmZVt0XS5kaW1zLmxlbmd0aD4wP2VbdF06dm9pZCAwLFhmPShlLHQpPT57bGV0IHI9ZVswXSxuPUJlKGUsMSksbz1CZShlLDIpLGk9QmUoZSwzKSxhPUJlKGUsNCksZD1CZShlLDUpLGw9QmUoZSw2KSxwPUJlKGUsNyk7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIklucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnNcIik7bGV0IG09ci5kaW1zWzBdLHU9ci5kaW1zWzFdLGg9ci5kaW1zLmxlbmd0aD09PTM/ci5kaW1zWzJdOnQubnVtSGVhZHMqci5kaW1zWzRdLF89dSx5PTAsZz0wLHg9TWF0aC5mbG9vcihoL3QubnVtSGVhZHMpO2lmKGwmJnAmJkMuc2l6ZShsLmRpbXMpJiZDLnNpemUocC5kaW1zKSl7aWYobC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihsLmRpbXNbMF0hPT1tfHxsLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxsLmRpbXNbM10hPT14KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYocC5kaW1zWzBdIT09bXx8cC5kaW1zWzFdIT09dC5udW1IZWFkc3x8cC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYobC5kaW1zWzJdIT09cC5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKScpO2lmKHAuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTt5PWwuZGltc1syXSxnPWwuZGltc1syXX1lbHNlIGlmKGwmJkMuc2l6ZShsLmRpbXMpfHxwJiZDLnNpemUocC5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0ICQ7aWYobiYmQy5zaXplKG4uZGltcyk+MCl7aWYoci5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtpZihuLmRpbXMubGVuZ3RoPDN8fG4uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO2lmKG4uZGltcy5sZW5ndGg9PT0zKXtpZihuLmRpbXNbMl0hPT1yLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTskPTIsXz1uLmRpbXNbMV19ZWxzZSBpZihuLmRpbXMubGVuZ3RoPT09NSl7aWYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09Mnx8bi5kaW1zWzRdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7aWYobyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7JD01LF89bi5kaW1zWzFdfWVsc2V7aWYobi5kaW1zWzFdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTskPTAsXz1uLmRpbXNbMl19fWVsc2V7aWYoci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtpZihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0zKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpOyQ9M31pZihpJiZDLnNpemUoaS5kaW1zKT4wKXtpZihpLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24nKTtpZihuJiZuLmRpbXMubGVuZ3RoPT09NSYmbi5kaW1zWzNdPT09Mil0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YuXCIpfWxldCB2PXkrXyxTPTA7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl7Uz04O2xldCBQPWEuZGltczt0aHJvdyBQLmxlbmd0aD09PTE/UFswXT09PW0/Uz0xOlBbMF09PT0zKm0rMiYmKFM9Myk6UC5sZW5ndGg9PT0yJiZQWzBdPT09bSYmUFsxXT09PXYmJihTPTUpLFM9PT04P25ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk6bmV3IEVycm9yKFwiTWFzayBub3Qgc3VwcG9ydGVkXCIpfWxldCBUPSExLEE9aDtpZihvJiZDLnNpemUoby5kaW1zKT4wKXtpZihvLmRpbXMubGVuZ3RoIT09MyYmby5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtpZihvLmRpbXMubGVuZ3RoPT09Myl7aWYoXyE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMl19ZWxzZXtpZihfIT09by5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1sxXSpvLmRpbXNbM10sVD0hMH19bGV0IGs9ITE7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl0aHJvdyBuZXcgRXJyb3IoXCJLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZCYmQy5zaXplKGQuZGltcyk+MCl7aWYoZC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihkLmRpbXNbMF0hPT1tfHxkLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxkLmRpbXNbMl0hPT11fHxkLmRpbXNbM10hPT12KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKX1yZXR1cm57YmF0Y2hTaXplOm0sc2VxdWVuY2VMZW5ndGg6dSxwYXN0U2VxdWVuY2VMZW5ndGg6eSxrdlNlcXVlbmNlTGVuZ3RoOl8sdG90YWxTZXF1ZW5jZUxlbmd0aDp2LG1heFNlcXVlbmNlTGVuZ3RoOmcsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTpoLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6eCx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTpTLHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczprLHBhc3NQYXN0SW5LdjpULHFrdkZvcm1hdDokfX0sVmQ9ZT0+cmUoey4uLmV9KSxOZD1yZSh7cGVybTpbMCwyLDEsM119KSxKZj0oZSx0LHIsbixvLGksYSk9PntsZXQgZD1bbixvLGldLGw9Qy5zaXplKGQpLHA9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOml9XSxtPXU9PntsZXQgaD1NKFwicWt2X3dpdGhfYmlhc1wiLHQuZGF0YVR5cGUsZCksXz1FKFwicWt2XCIsdC5kYXRhVHlwZSxkKSx5PUUoXCJiaWFzXCIsci5kYXRhVHlwZSxkKSxnPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfb2Zmc2V0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke3UucmVnaXN0ZXJVbmlmb3JtcyhnKS5kZWNsYXJlVmFyaWFibGVzKF8seSxoKX1cbiAgJHt1Lm1haW5TdGFydCgpfVxuICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIk11bHRpSGVhZEF0dGVudGlvbkFkZEJpYXNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTptfSx7aW5wdXRzOlt0LHJdLG91dHB1dHM6Wy0xXX0pWzBdfSx0cj0oZSx0LHIsbixvLGksYSxkKT0+e2xldCBsPWk7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl7aWYobj09PTEpdGhyb3cgbmV3IEVycm9yKFwiQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWXCIpO3JldHVybiBsPUpmKGUsaSxhLHQsbixyKm8sZCksbD1sLnJlc2hhcGUoW3QsbixyLG9dKSxyPT09MXx8bj09PTE/bDplLmNvbXB1dGUoUGUobCxOZC5wZXJtKSx7aW5wdXRzOltsXSxvdXRwdXRzOlstMV19KVswXX1lbHNlIHJldHVybiBpLmRpbXMubGVuZ3RoPT09MyYmKGw9aS5yZXNoYXBlKFt0LG4scixvXSkpLHI9PT0xfHxuPT09MT9sOmUuY29tcHV0ZShQZShsLE5kLnBlcm0pLHtpbnB1dHM6W2xdLG91dHB1dHM6Wy0xXX0pWzBdfSxXZD0oZSx0KT0+e2xldCByPVhmKGUuaW5wdXRzLHQpLG49ZS5pbnB1dHNbMF0sbz1CZShlLmlucHV0cywxKSxpPUJlKGUuaW5wdXRzLDIpLGE9QmUoZS5pbnB1dHMsMyksZD1CZShlLmlucHV0cyw0KSxsPUJlKGUuaW5wdXRzLDUpLHA9QmUoZS5pbnB1dHMsNiksbT1CZShlLmlucHV0cyw3KTtpZihuLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihvPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgdT1vJiZpJiZvLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zLmxlbmd0aD09PTQsaD10cihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5zZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLG4sYSwwKTtpZih1KXJldHVybiBSdChlLGgsbyxpLGQsdm9pZCAwLHAsbSxsLHIpO2lmKCFvfHwhaSl0aHJvdyBuZXcgRXJyb3IoXCJrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWRcIik7bGV0IF89dHIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLG8sYSxyLmhpZGRlblNpemUpLHk9dHIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLnZIZWFkU2l6ZSxpLGEsMipyLmhpZGRlblNpemUpO1J0KGUsaCxfLHksZCx2b2lkIDAscCxtLGwscil9fSk7dmFyIGVoLHRoLHJoLG5oLFRvLExkLEdkLElvPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO2VoPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sdGg9KGUsdCk9PntsZXQgcj1bXSxuPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG89PnIucHVzaChOdW1iZXIobykpKSxuPXIubGVuZ3RoKSxyZSh7bnVtT3V0cHV0czpuLGF4aXM6dC5heGlzLHNwbGl0U2l6ZXM6cn0pfSxyaD1lPT5gXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgJHtGKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJpXCIsZSl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xufWAsbmg9ZT0+e2xldCB0PWUubGVuZ3RoLHI9W107Zm9yKGxldCBuPTA7bjx0Oysrbil7bGV0IG89ZVtuXS5zZXRCeUluZGljZXMoXCJpbmRpY2VzXCIsXCJpbnB1dFtnbG9iYWxfaWR4XVwiKTt0PT09MT9yLnB1c2gobyk6bj09PTA/ci5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke259dSkgeyAke299IH1gKTpuPT09dC0xP3IucHVzaChgZWxzZSB7ICR7b30gfWApOnIucHVzaChgZWxzZSBpZiAob3V0cHV0X251bWJlciA9PSAke259KSB7ICR7b30gfWApfXJldHVybmBcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7ZVswXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcbiAgICAgICAgJHtyLmpvaW4oYFxuYCl9XG4gICAgICB9YH0sVG89KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1DLnNpemUociksbz1lWzBdLmRhdGFUeXBlLGk9Qy5ub3JtYWxpemVBeGlzKHQuYXhpcyxyLmxlbmd0aCksYT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxkPUUoXCJpbnB1dFwiLG8sci5sZW5ndGgpLGw9bmV3IEFycmF5KHQubnVtT3V0cHV0cykscD1bXSxtPVtdLHU9MCxoPVt7dHlwZToxMixkYXRhOm59XTtmb3IobGV0IHk9MDt5PHQubnVtT3V0cHV0czt5Kyspe3UrPXQuc3BsaXRTaXplc1t5XSxsW3ldPXU7bGV0IGc9ci5zbGljZSgpO2dbaV09dC5zcGxpdFNpemVzW3ldLG0ucHVzaChnKSxhW3ldPU0oYG91dHB1dCR7eX1gLG8sZy5sZW5ndGgpLHAucHVzaCh7ZGltczptW3ldLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KX1oLnB1c2goe3R5cGU6MTIsZGF0YTpsfSwuLi5OKHIsLi4ubSkpO2xldCBfPXk9PmBcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybShcImlucHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzaXplX2luX3NwbGl0X2F4aXNcIixcInUzMlwiLGwubGVuZ3RoKS5kZWNsYXJlVmFyaWFibGVzKGQsLi4uYSl9XG4gICR7cmgobC5sZW5ndGgpfVxuICAke25oKGEpfVxuXG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLmlucHV0X3NpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICB2YXIgaW5kZXggPSAke2QuaW5kaWNlc0dldChcImluZGljZXNcIixpKX07XG4gICAgbGV0IG91dHB1dF9udW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleCk7XG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xuICAgICAgaW5kZXggLT0gJHtGKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJvdXRwdXRfbnVtYmVyIC0gMXVcIixsLmxlbmd0aCl9O1xuICAgICAgJHtkLmluZGljZXNTZXQoXCJpbmRpY2VzXCIsaSxcImluZGV4XCIpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6XyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6cCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9KX19LExkPShlLHQpPT57ZWgoZS5pbnB1dHMpO2xldCByPWUuaW5wdXRzLmxlbmd0aD09PTE/dDp0aChlLmlucHV0cyx0KTtlLmNvbXB1dGUoVG8oZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sR2Q9ZT0+e2xldCB0PWUuYXhpcyxyPWUuc3BsaXRTaXplcyxuPWUubnVtT3V0cHV0czwwP3IubGVuZ3RoOmUubnVtT3V0cHV0cztpZihuIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiByZSh7YXhpczp0LG51bU91dHB1dHM6bixzcGxpdFNpemVzOnJ9KX19KTt2YXIgb2gsaWgsSGQsRmQscWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO1NlKCk7RnIoKTtTbygpO0lvKCk7ZHQoKTtvaD0oZSx0KT0+e2lmKHQuZG9Sb3RhcnkpdGhyb3cgbmV3IEVycm9yKFwiR3JvdXBRdWVycnlBdHRlbnRpb24gZG9fcm90YXJ5IGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuZG9Sb3RhcnkmJmUubGVuZ3RoPD03KXRocm93IG5ldyBFcnJvcihcImNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGlucHV0cyBhcmUgcmVxdWlyZWQgaWYgZG9fcm90YXJ5IGlzIHNwZWNpZmllZFwiKTtsZXQgcj1lWzBdLG49ZVsxXSxvPWVbMl0saT1lWzNdLGE9ZVs0XTtpZih0LmxvY2FsV2luZG93U2l6ZSE9PS0xKXRocm93IG5ldyBFcnJvcihcIkxvY2FsIGF0dGVudGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc29mdGNhcCE9PTApdGhyb3cgbmV3IEVycm9yKFwiU29mdGNhcCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQucm90YXJ5SW50ZXJsZWF2ZWQhPT0wKXRocm93IG5ldyBFcnJvcihcIlJvdGFyeSBpbnRlcmxlYXZlZCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc21vb3RoU29mdG1heCl0aHJvdyBuZXcgRXJyb3IoXCJTbW9vdGggc29mdG1heCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBkPSExLGw9ci5kaW1zWzBdLHA9ci5kaW1zWzFdLG09ci5kaW1zLmxlbmd0aD09PTM/ZD9yLmRpbXNbMl0vMzpyLmRpbXNbMl06dC5udW1IZWFkcypyLmRpbXNbNF0sdT1wLGg9MCxfPSFufHxuLmRpbXMubGVuZ3RoPT09MCx5PU1hdGguZmxvb3IoXz9tLyh0Lm51bUhlYWRzKzIqdC5rdk51bUhlYWRzKTptL3QubnVtSGVhZHMpO18mJihtPXkqdC5udW1IZWFkcyk7bGV0IGc9aSYmaS5kaW1zLmxlbmd0aCE9PTAseD1hJiZhLmRpbXMubGVuZ3RoIT09MDtpZihnJiZpLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zWzBdPT09bCYmaS5kaW1zWzFdIT09dC5rdk51bUhlYWRzJiZpLmRpbXNbMl09PT10Lmt2TnVtSGVhZHMmJmkuZGltc1szXT09PXkpdGhyb3cgbmV3IEVycm9yKFwiQlNOSCBwYXN0S2V5L3Bhc3RWYWx1ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGcmJngpe2lmKGkuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoYS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2g9aS5kaW1zWzJdfWVsc2UgaWYoZ3x8eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0IHY9MTtpZihuJiZuLmRpbXMubGVuZ3RoPjApe2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYobi5kaW1zLmxlbmd0aDwzfHxuLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09bi5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihuLmRpbXMubGVuZ3RoPT09Myl7aWYoci5kaW1zWzJdJW4uZGltc1syXSE9PTApdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO3U9bi5kaW1zWzFdfWVsc2UgaWYobi5kaW1zLmxlbmd0aD09PTUpe2lmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTJ8fG4uZGltc1s0XSE9PXkpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO3U9bi5kaW1zWzFdfWVsc2V7aWYobi5kaW1zWzFdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09eSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTt1PW4uZGltc1syXX19ZWxzZXtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKHIuZGltcy5sZW5ndGg9PT01JiYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09MykpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7dj0zfWxldCBTPTAsVD0hMSxBPXQua3ZOdW1IZWFkcz95KnQua3ZOdW1IZWFkczptO2lmKG8mJm8uZGltcy5sZW5ndGg+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKHUhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzJdfWVsc2V7aWYodSE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzFdKm8uZGltc1szXSxUPSEwfX1sZXQgaz1lLmxlbmd0aD40P2VbNV06dm9pZCAwO2lmKGsmJmsuZGltcy5sZW5ndGghPT0xJiZrLmRpbXNbMF0hPT1sKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJzZXFsZW5zXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbiBhbmQgdGhlIHNhbWUgZGltIDAgYXMgYmF0Y2hfc2l6ZScpO2xldCBQPS0xLEQ9LTEsUj0hMTtyZXR1cm57YmF0Y2hTaXplOmwsc2VxdWVuY2VMZW5ndGg6cCxwYXN0U2VxdWVuY2VMZW5ndGg6aCxrdlNlcXVlbmNlTGVuZ3RoOnUsdG90YWxTZXF1ZW5jZUxlbmd0aDpQLG1heFNlcXVlbmNlTGVuZ3RoOkQsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTptLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6eSx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3Qua3ZOdW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxrdk51bUhlYWRzOnQua3ZOdW1IZWFkcyxuUmVwczp0Lm51bUhlYWRzL3Qua3ZOdW1IZWFkcyxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tUeXBlOlMsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOlIscGFzc1Bhc3RJbkt2OlQscWt2Rm9ybWF0OnZ9fSxpaD1yZSh7cGVybTpbMCwyLDEsM119KSxIZD0oZSx0LHIpPT57bGV0IG49dCxvPXIua3ZOdW1IZWFkcztyZXR1cm4gdC5kaW1zLmxlbmd0aD09PTMmJnIua3ZTZXF1ZW5jZUxlbmd0aCE9PTAmJihuPXQucmVzaGFwZShbci5iYXRjaFNpemUsci5rdlNlcXVlbmNlTGVuZ3RoLG8sci5oZWFkU2l6ZV0pLG49ZS5jb21wdXRlKFBlKG4saWgucGVybSkse2lucHV0czpbbl0sb3V0cHV0czpbLTFdfSlbMF0pLG59LEZkPShlLHQpPT57bGV0IHI9b2goZS5pbnB1dHMsdCk7aWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKGUuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgbj1lLmlucHV0c1swXSxvPWUuaW5wdXRzWzFdJiZlLmlucHV0c1sxXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzFdOnZvaWQgMCxpPWUuaW5wdXRzWzJdJiZlLmlucHV0c1syXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzJdOnZvaWQgMCxhPWUuaW5wdXRzWzNdJiZlLmlucHV0c1szXS5kaW1zLmxlbmd0aCE9PTA/ZS5pbnB1dHNbM106dm9pZCAwLGQ9ZS5pbnB1dHNbNF0mJmUuaW5wdXRzWzRdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1s0XTp2b2lkIDAsbD1lLmlucHV0cy5sZW5ndGg+ND9lLmlucHV0c1s1XTp2b2lkIDAscD1lLmlucHV0cy5sZW5ndGg+NT9lLmlucHV0c1s2XTp2b2lkIDAsbT1yLmt2TnVtSGVhZHM/ci5rdk51bUhlYWRzOnIubnVtSGVhZHMsdT1yZSh7YXhpczoyLG51bU91dHB1dHM6MyxzcGxpdFNpemVzOltyLm51bUhlYWRzKnIuaGVhZFNpemUsbSpyLmhlYWRTaXplLG0qci5oZWFkU2l6ZV19KSxbaCxfLHldPSFvJiYhaT9lLmNvbXB1dGUoVG8oW25dLHUpLHtpbnB1dHM6W25dLG91dHB1dHM6Wy0xLC0xLC0xXX0pOltuLG8saV0sZz10cihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5zZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLGgsdm9pZCAwLDApO1J0KGUsZyxIZChlLF8sciksSGQoZSx5LHIpLHZvaWQgMCx2b2lkIDAsYSxkLHZvaWQgMCxyLGwscCl9fSk7dmFyIEtkLGFoLHNoLGpkLFlkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7ZHQoKTthZSgpO0tkPShlLHQscixuLG8saSxhLGQpPT57bGV0IGw9bWUoaSkscD1sPT09MT9cImYzMlwiOmB2ZWMke2x9ZmAsbT1sPT09MT9cInZlYzJmXCI6YG1hdDJ4JHtsfWZgLHU9byphLGg9NjQ7dT09PTEmJihoPTI1Nik7bGV0IF89W28sYSxpL2xdLHk9W28sYSwyXSxnPVtcInJhbmtcIixcInR5cGVcIixcInR5cGVcIl0seD1bXTt4LnB1c2goLi4uTihfLHkpKTtsZXQgJD12PT57bGV0IFM9RShcInhcIix0LmRhdGFUeXBlLDMsbCksVD1FKFwic2NhbGVcIixyLmRhdGFUeXBlLHIuZGltcyksQT1FKFwiYmlhc1wiLG4uZGF0YVR5cGUsbi5kaW1zKSxrPU0oXCJvdXRwdXRcIiwxLDMsMiksUD1bUyxULEEsa107cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkIDogYXJyYXk8JHttfSwgJHtofT47XG4gIGNvbnN0IHdvcmtncm91cF9zaXplID0gJHtofXU7XG4gICR7di5kZWNsYXJlVmFyaWFibGVzKC4uLlApfVxuICAke3YubWFpblN0YXJ0KGgpfVxuICAgIGxldCBiYXRjaCA9IHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSB3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBoaWdodCA9IHVuaWZvcm1zLnhfc2hhcGVbMl07XG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XG4gICAgdmFyIHN1bSA9ICR7cH0oMCk7XG4gICAgdmFyIHNxdWFyZWRfc3VtID0gJHtwfSgwKTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxfaWR4OyBoIDwgaGlnaHQ7IGggKz0gd29ya2dyb3VwX3NpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7cH0oJHtTLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSk7XG4gICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICBzcXVhcmVkX3N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSAke219KHN1bSwgc3F1YXJlZF9zdW0pO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwX3NpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxfaWR4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdICsgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbF9pZHggPT0gMCkge1xuICAgICAgbGV0IHN1bV9maW5hbCA9ICR7RmUoXCJ3b3JrZ3JvdXBfc2hhcmVkWzBdWzBdXCIsbCl9IC8gZjMyKGhpZ2h0ICogJHtsfSk7XG4gICAgICBsZXQgc3F1YXJlZF9zdW1fZmluYWwgPSAke0ZlKFwid29ya2dyb3VwX3NoYXJlZFswXVsxXVwiLGwpfSAvIGYzMihoaWdodCAqICR7bH0pO1xuXG4gICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkX3N1bV9maW5hbCAtIHN1bV9maW5hbCAqIHN1bV9maW5hbCArIGYzMigke2R9KSk7XG4gICAgICBsZXQgY2hhbm5lbF9zY2FsZSA9IGludl9zdGRfZGV2ICogZjMyKHNjYWxlW2NoYW5uZWxdKTtcbiAgICAgIGxldCBjaGFubmVsX3NoaWZ0ID0gZjMyKGJpYXNbY2hhbm5lbF0pIC0gc3VtX2ZpbmFsICogY2hhbm5lbF9zY2FsZTtcbiAgICAgIG91dHB1dFt3b3JrZ3JvdXBfaW5kZXhdID0gdmVjMmYoY2hhbm5lbF9zY2FsZSwgY2hhbm5lbF9zaGlmdCk7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OmAke2x9OyR7ZH07JHtofWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp5LGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4OnV9LHByb2dyYW1Vbmlmb3Jtczp4fSksZ2V0U2hhZGVyU291cmNlOiR9LHtpbnB1dHM6W3QscixuXSxvdXRwdXRzOlstMV19KVswXX0sYWg9KGUsdCxyKT0+e2xldCBuPXRbMF0uZGltcyxvPW4saT0yLGE9blswXSxkPW5bMV0sbD1DLnNpemVGcm9tRGltZW5zaW9uKG4saSkscD1tZShsKSxtPUMuc2l6ZShvKS9wLHU9S2QoZSx0WzBdLHRbMV0sdFsyXSxhLGwsZCxyLmVwc2lsb24pLGg9W2EsZCxsL3BdLF89W2EsZF0seT1bXCJ0eXBlXCIsXCJub25lXCJdLGc9eD0+e2xldCAkPUUoXCJ4XCIsdFswXS5kYXRhVHlwZSxoLmxlbmd0aCxwKSx2PUUoXCJzY2FsZV9zaGlmdFwiLDEsXy5sZW5ndGgsMiksUz1NKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxoLmxlbmd0aCxwKSxUPVskLHYsU107cmV0dXJuYFxuICAke3gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQpfVxuICAke3gubWFpblN0YXJ0KCl9XG4gICR7eC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIGxldCBiYXRjaCA9IG91dHB1dEluZGljZXNbMF07XG4gICAgICBsZXQgY2hhbm5lbCA9IG91dHB1dEluZGljZXNbMV07XG4gICAgICBsZXQgc2NhbGVfc2hpZnQgPSAke3YuZ2V0QnlJbmRpY2VzKFwidmVjMjx1MzI+KGJhdGNoLCBjaGFubmVsKVwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAkeyQuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfSAqICR7Uy50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC54KSArICR7Uy50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC55KTtcbiAgICAgICR7Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6bX0sLi4uTihoLF8saCldfSksZ2V0U2hhZGVyU291cmNlOmd9LHtpbnB1dHM6W3RbMF0sdV19KX0sc2g9KGUsdCxyKT0+e2xldCBuPXRbMF0uZGltcyxvPW4saT1uWzBdLGE9bltuLmxlbmd0aC0xXSxkPUMuc2l6ZUZyb21EaW1lbnNpb24obiwxKS9hLGw9bWUoYSkscD1DLnNpemUobykvbCxtPVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6TWF0aC5mbG9vcihhL2wpfV0sdT1bXCJ0eXBlXCIsXCJ0eXBlXCJdLGg9ITEsXz1bMCxuLmxlbmd0aC0xXTtmb3IobGV0ICQ9MDskPG4ubGVuZ3RoLTI7JCsrKWg9aHx8blskKzFdIT09MSxfLnB1c2goJCsxKTtoPWgmJm5bbi5sZW5ndGgtMV0hPT0xO2xldCB5PWg/ZS5jb21wdXRlKFBlKGUuaW5wdXRzWzBdLF8pLHtpbnB1dHM6W2UuaW5wdXRzWzBdXSxvdXRwdXRzOlstMV19KVswXTplLmlucHV0c1swXS5yZXNoYXBlKEFycmF5LmZyb20oe2xlbmd0aDpuLmxlbmd0aH0sKCQsdik9Pm5bX1t2XV0pKSxnPUtkKGUseSx0WzFdLHRbMl0saSxkLGEsci5lcHNpbG9uKSx4PSQ9PntsZXQgdj1fZSh0WzBdLmRhdGFUeXBlKSxTPWw9PT0xP1widmVjMmZcIjpgbWF0JHtsfXgyZmAsVD1QPT57bGV0IEQ9UD09PTA/XCJ4XCI6XCJ5XCIsUj1sPT09MT9cImYzMlwiOmB2ZWMke2x9ZmA7c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5gJHt2fSgke1J9KHNjYWxlLiR7RH0pKWA7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dn0+KCR7Un0oc2NhbGVbMF0uJHtEfSwgc2NhbGVbMV0uJHtEfSkpYDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt2fT4oJHtSfShzY2FsZVswXS4ke0R9LCBzY2FsZVsxXS4ke0R9LCBzY2FsZVsyXS4ke0R9LCBzY2FsZVszXS4ke0R9KSlgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIGNvbXBvZW50cyAke2x9YCl9fSxBPUUoXCJpbnB1dFwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLGwpLGs9TShcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsbyxsKTtyZXR1cm5gXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke0EudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVfaW5wdXQgOiBhcnJheTwke1N9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke2sudHlwZS5zdG9yYWdlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgIGxldCBjdXJyZW50X2ltYWdlX251bWJlciA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuQyAqIHVuaWZvcm1zLkgpO1xuICAgIGxldCBjdXJyZW50X2NoYW5uZWxfbnVtYmVyID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLkM7XG5cbiAgICBsZXQgc2NhbGVfb2Zmc2V0ID0gY3VycmVudF9pbWFnZV9udW1iZXIgKiB1bmlmb3Jtcy5DICsgY3VycmVudF9jaGFubmVsX251bWJlcjtcbiAgICBsZXQgc2NhbGUgPSBzY2FsZV9pbnB1dFtzY2FsZV9vZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtUKDApfSwgJHtUKDEpfSk7XG4gIH1gfTtlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25OSFdDXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bH1gLGlucHV0RGVwZW5kZW5jaWVzOnV9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOnh9LHtpbnB1dHM6W3RbMF0sZ119KX0samQ9KGUsdCk9Pnt0LmZvcm1hdD09PVwiTkhXQ1wiP3NoKGUsZS5pbnB1dHMsdCk6YWgoZSxlLmlucHV0cyx0KX19KTt2YXIgdWgsZGgsWmQsUWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3VoPWU9PntpZighZXx8ZS5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuXCIpfSxkaD0oZSx0LHIpPT57bGV0IG49dC5zaW1wbGlmaWVkLG89ZVswXS5kaW1zLGk9ZVsxXSxhPSFuJiZlWzJdLGQ9byxsPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsby5sZW5ndGgpLHA9Qy5zaXplVG9EaW1lbnNpb24obyxsKSxtPUMuc2l6ZUZyb21EaW1lbnNpb24obyxsKSx1PUMuc2l6ZShpLmRpbXMpLGg9YT9DLnNpemUoYS5kaW1zKTowO2lmKHUhPT1tfHxhJiZoIT09bSl0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke219LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHt1fSBhbmQgYmlhcyBzaXplIG9mICR7aH1gKTtsZXQgXz1bXTtmb3IobGV0IEE9MDtBPG8ubGVuZ3RoOysrQSlBPGw/Xy5wdXNoKG9bQV0pOl8ucHVzaCgxKTtsZXQgeT1tZShtKSxnPVtcInR5cGVcIixcInR5cGVcIl0seD1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6bX0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKG0veSl9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XTthJiZnLnB1c2goXCJ0eXBlXCIpO2xldCAkPXI+MSx2PXI+MixTPUE9PntsZXQgaz1fZShlWzBdLmRhdGFUeXBlKSxQPVtFKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHkpLEUoXCJzY2FsZVwiLGkuZGF0YVR5cGUsaS5kaW1zLHkpXTthJiZQLnB1c2goRShcImJpYXNcIixhLmRhdGFUeXBlLGEuZGltcyx5KSksUC5wdXNoKE0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQseSkpLCQmJlAucHVzaChNKFwibWVhbl9kYXRhX291dHB1dFwiLDEsXykpLHYmJlAucHVzaChNKFwiaW52X3N0ZF9vdXRwdXRcIiwxLF8pKTtsZXQgRD1be25hbWU6XCJub3JtX2NvdW50XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJub3JtX3NpemVfdmVjdG9yaXplZFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAke0EucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLlApfVxuICAke0EubWFpblN0YXJ0KCl9XG4gICAgJHtBLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5ub3JtX2NvdW50XCIpfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHt1byhcImYzMlwiLHkpfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHt1byhcImYzMlwiLHkpfTtcblxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGgrKykge1xuICAgICAgbGV0IHZhbHVlID0gJHtFdChrLHksXCJ4W2ggKyBvZmZzZXRdXCIpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtGZShcIm1lYW5fdmVjdG9yXCIseSl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7RmUoXCJtZWFuX3NxdWFyZV92ZWN0b3JcIix5KX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtuP1wiXCI6XCItIG1lYW4gKiBtZWFuXCJ9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtFdChrLHksXCJ4W2ogKyBvZmZzZXRdXCIpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7RXQoayx5LFwic2NhbGVbal1cIil9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtQWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke24/XCJcIjpcIi0gbWVhblwifSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXG4gICAgICAgICR7YT9gKyAke0V0KGsseSxcImJpYXNbal1cIil9YDpcIlwifVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAkeyQ/XCJtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhblwiOlwiXCJ9O1xuICAgICR7dj9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXZcIjpcIlwifTtcbiAgfWB9LFQ9W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiAkJiZULnB1c2goe2RpbXM6XyxkYXRhVHlwZToxfSksdiYmVC5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eX07JHtyfTske259YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnh9KSxnZXRTaGFkZXJTb3VyY2U6U319LFpkPShlLHQpPT57dWgoZS5pbnB1dHMpLGUuY29tcHV0ZShkaChlLmlucHV0cyx0LGUub3V0cHV0Q291bnQpKX19KTt2YXIgbGgsWGQsSmQ9VSgoKT0+e1widXNlIHN0cmljdFwiO29lKCk7UXIoKTtYcigpO2xoPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKX0sWGQ9ZT0+e2xoKGUuaW5wdXRzKTtsZXQgdD10dC5jYWxjU2hhcGUoZS5pbnB1dHNbMF0uZGltcyxlLmlucHV0c1sxXS5kaW1zLCEwKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCByPXRbdC5sZW5ndGgtMV0sbj1lLmlucHV0c1swXS5kaW1zW2UuaW5wdXRzWzBdLmRpbXMubGVuZ3RoLTFdO2lmKHI8OCYmbjw4KWUuY29tcHV0ZShacihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSk7ZWxzZXtsZXQgbz10W3QubGVuZ3RoLTJdLGk9Qy5zaXplKGUuaW5wdXRzWzBdLmRpbXMuc2xpY2UoMCwtMikpLGE9Qy5zaXplKGUuaW5wdXRzWzFdLmRpbXMuc2xpY2UoMCwtMikpO2lmKGkhPT0xJiZvPT09MSYmYT09PTEpe2xldCBkPWUuaW5wdXRzWzBdLnJlc2hhcGUoWzEsaSxuXSksbD1lLmlucHV0c1sxXS5yZXNoYXBlKFsxLG4scl0pLHA9WzEsaSxyXSxtPVtkLGxdO2UuY29tcHV0ZShlcihtLHthY3RpdmF0aW9uOlwiXCJ9LHQscCkse2lucHV0czptfSl9ZWxzZSBlLmNvbXB1dGUoZXIoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpfX19KTt2YXIgY2gscGgsbWgsZWwsdGwscmw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7Y2g9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIk1hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHNcIik7bGV0IHI9ZVswXSxuPXIuZGltcy5sZW5ndGg7aWYoci5kaW1zW24tMV0hPT10LmspdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlXCIpO2xldCBvPU1hdGguZmxvb3IoKHQuayt0LmJsb2NrU2l6ZS0xKS90LmJsb2NrU2l6ZSksaT10LmJsb2NrU2l6ZS84KnQuYml0cyxhPWVbMV07aWYoIUMuYXJlRXF1YWwoYS5kaW1zLFt0Lm4sbyxpXSkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplXCIpO2xldCBsPWVbMl0uZGltcztpZihDLnNpemUobCkhPT10Lm4qbyl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci5cIik7aWYoZS5sZW5ndGg9PT00KXtsZXQgbT1lWzNdLmRpbXMsdT10LmJpdHM+ND90Lm4qbzp0Lm4qTWF0aC5mbG9vcigobysxKS8yKTtpZihDLnNpemUobSkhPT11KXRocm93IG5ldyBFcnJvcihcInplcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci5cIil9fSxwaD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPXIubGVuZ3RoLG89cltuLTJdLGk9dC5rLGE9dC5uLGQ9ci5zbGljZSgwLG4tMiksbD1DLnNpemUoZCksbT1lWzFdLmRpbXNbMl0vNCx1PWVbMF0uZGF0YVR5cGUsaD1tZSh0LmspLF89bWUobSkseT1tZShhKSxnPWQuY29uY2F0KFtvLGFdKSx4PW8+MSYmYS95JTI9PT0wPzI6MSwkPUMuc2l6ZShnKS95L3gsdj02NCxTPVtdLFQ9W2wsbyxpL2hdLEE9Qy5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO0Euc3BsaWNlKC0xLDEsbS9fKSxTLnB1c2goLi4uTihUKSksUy5wdXNoKC4uLk4oQSkpLFMucHVzaCguLi5OKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmUy5wdXNoKC4uLk4oQy5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCBrPVtsLG8sYS95XTtTLnB1c2goLi4uTihrKSk7bGV0IFA9RD0+e2xldCBSPVQubGVuZ3RoLEc9RShcImFcIixlWzBdLmRhdGFUeXBlLFIsaCksSz1FKFwiYlwiLDEyLEEubGVuZ3RoLF8pLGo9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksVj1bRyxLLGpdLFE9ZS5sZW5ndGg9PT00P0UoXCJ6ZXJvX3BvaW50c1wiLDEyLGVbM10uZGltcy5sZW5ndGgpOnZvaWQgMDtRJiZWLnB1c2goUSk7bGV0IHNlPWsubGVuZ3RoLFk9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsc2UseSksZWU9X2UoZVswXS5kYXRhVHlwZSksSj0oKCk9Pntzd2l0Y2goaCl7Y2FzZSAxOnJldHVybmBhcnJheTwke2VlfSwgOD5gO2Nhc2UgMjpyZXR1cm5gbWF0NHgyPCR7ZWV9PmA7Y2FzZSA0OnJldHVybmBtYXQyeDQ8JHtlZX0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtofS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19KSgpLG5lPSgpPT57bGV0ICRlPWBcbiAgICAgICAgICAvLyByZXVzZSBhIGRhdGFcbiAgICAgICAgICAgIHZhciBpbnB1dF9vZmZzZXQgPSAke0cuaW5kaWNlc1RvT2Zmc2V0KGAke0cudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCB3b3JkX29mZnNldClgKX07XG4gICAgICAgICAgICB2YXIgYV9kYXRhOiAke0p9O1xuICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8ICR7OC9ofTsgaisrKSB7XG4gICAgICAgICAgICAgIGFfZGF0YVtqXSA9ICR7Ry5nZXRCeU9mZnNldChcImlucHV0X29mZnNldFwiKX07XG4gICAgICAgICAgICAgIGlucHV0X29mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7Zm9yKGxldCBsZT0wO2xlPHkqeDtsZSsrKSRlKz1gXG4gICAgICAgICAgICBiX3ZhbHVlID0gJHtfPT09MT9gYiR7bGV9X2RhdGFgOmBiJHtsZX1fZGF0YVtpXWB9O1xuICAgICAgICAgICAgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3F1YW50aXplZF92YWx1ZXMgPSAke0p9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChXLHEpPT5gJHtlZX0oYl92YWx1ZV9sb3dlclske3F9XSksICR7ZWV9KGJfdmFsdWVfdXBwZXJbJHtxfV0pYCkuam9pbihcIiwgXCIpfSk7XG4gICAgICAgICAgICBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9ICR7KCgpPT5oPT09MT9gJHtKfSgke0FycmF5LmZyb20oe2xlbmd0aDo4fSwoVyxxKT0+YChiX3F1YW50aXplZF92YWx1ZXNbJHtxfV0gLSAke1E/YHplcm9fcG9pbnQke2xlfWA6XCJ6ZXJvX3BvaW50XCJ9KSAqIHNjYWxlJHtsZX1gKS5qb2luKFwiLCBcIil9KTtgOmAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtKfSgke0FycmF5KDgpLmZpbGwoYCR7UT9gemVyb19wb2ludCR7bGV9YDpcInplcm9fcG9pbnRcIn1gKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlJHtsZX07YCkoKX07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke3h9ICsgJHtNYXRoLmZsb29yKGxlL3kpfV0ke3k+MT9gWyR7bGUleX1dYDpcIlwifSArPSAke0FycmF5LmZyb20oe2xlbmd0aDo4L2h9LChXLHEpPT5gJHtoPT09MT9gYV9kYXRhWyR7cX1dICogYl9kZXF1YW50aXplZF92YWx1ZXNbJHtxfV1gOmBkb3QoYV9kYXRhWyR7cX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske3F9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgIGA7cmV0dXJuICRlfSxiZT0oKT0+e2xldCAkZT1gXG4gICAgICAgICAgICB2YXIgY29sX2luZGV4ID0gY29sICogJHt5fTtcbiAgICAgICAgICAgICR7UT9gXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX2NvdW50OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgOmBcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2VlfSg4KTtgfVxuICAgICAgICAgICAgYDtmb3IobGV0IGxlPTA7bGU8eSp4O2xlKyspJGUrPWBcbiAgICAgICAgICAgIGxldCBzY2FsZSR7bGV9ID0gJHtqLmdldEJ5T2Zmc2V0KFwiY29sX2luZGV4ICogbkJsb2Nrc1BlckNvbCArIGJsb2NrXCIpfTtcbiAgICAgICAgICAgICR7UT9gXG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBjb2xfaW5kZXggKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZCA9ICR7US5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfd29yZF9pbmRleFwiKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtsZX0gPSAke2VlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6XCJcIn1cbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuICRlfSxPZT0oKT0+e2xldCAkZT1gY29sX2luZGV4ID0gY29sICogJHt5fTtgO2ZvcihsZXQgbGU9MDtsZTx5Kng7bGUrKykkZSs9YFxuICAgICAgICAgICAgbGV0IGIke2xlfV9kYXRhID0gJHtLLmdldEJ5SW5kaWNlcyhgJHtLLnR5cGUuaW5kaWNlc30oY29sX2luZGV4LCBibG9jaywgd29yZClgKX07XG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO3JldHVybiAkZSs9YFxuICAgICAgICAgICAgdmFyIGJfdmFsdWU6IHUzMjtcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfbG93ZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl9xdWFudGl6ZWRfdmFsdWVzOiAke0p9O1xuICAgICAgICAgICAgdmFyIGJfZGVxdWFudGl6ZWRfdmFsdWVzOiAke0p9O2AsJGV9O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZDogYXJyYXk8JHtZLnR5cGUudmFsdWV9LCAke3gqdn0+O1xuICAgICAgICAke0QuZGVjbGFyZVZhcmlhYmxlcyguLi5WLFkpfVxuICAgICAgICAke0QubWFpblN0YXJ0KFt2LDEsMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7WS5vZmZzZXRUb0luZGljZXMoYChnbG9iYWxfaWR4IC8gJHt2fSkgKiAke3h9YCl9O1xuICAgICAgICAgIGxldCBjb2wgPSBvdXRwdXRfaW5kaWNlc1syXTtcbiAgICAgICAgICBsZXQgcm93ID0gb3V0cHV0X2luZGljZXNbMV07XG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XG4gICAgICAgICAgbGV0IG5CbG9ja3NQZXJDb2wgPSB1bmlmb3Jtcy5iX3NoYXBlWzFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYmxvY2sgPSBsb2NhbF9pZC54OyBibG9jayA8IG5CbG9ja3NQZXJDb2w7IGJsb2NrICs9ICR7dn0pIHtcbiAgICAgICAgICAgIC8vcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldDogdTMyID0gYmxvY2sgKiAke3QuYmxvY2tTaXplL2h9O1xuICAgICAgICAgICAgJHtiZSgpfVxuICAgICAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7bX07IHdvcmQgKz0gJHtffSkge1xuICAgICAgICAgICAgICAke09lKCl9XG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke199OyBpKyspIHtcbiAgICAgICAgICAgICAgICAke25lKCl9XG4gICAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4L2h9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgIGlmIChsb2NhbF9pZC54IDwgJHt4fSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtZLnR5cGUudmFsdWV9ID0gJHtZLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgdmFyIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0OiB1MzIgPSBsb2NhbF9pZC54O1xuICAgICAgICAgICAgZm9yICh2YXIgYjogdTMyID0gMHU7IGIgPCAke3Z9dTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSB3b3JrZ3JvdXBfc2hhcmVkW3dvcmtncm91cF9zaGFyZWRfb2Zmc2V0XTtcbiAgICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQgKz0gJHt4fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7WS5zZXRCeUluZGljZXMoYCR7WS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkLngpYCxcIm91dHB1dF92YWx1ZVwiKX07XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJNYXRNdWxOQml0c1wiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske3QuYml0c307JHtofTske199OyR7eX07JHt4fTske3Z9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZyxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDokfSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTpQfX0sbWg9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1yLmxlbmd0aCxvPXJbbi0yXSxpPXQuayxhPXQubixkPXIuc2xpY2UoMCxuLTIpLGw9Qy5zaXplKGQpLG09ZVsxXS5kaW1zWzJdLzQsdT1lWzBdLmRhdGFUeXBlLGg9bWUodC5rKSxfPW1lKG0pLHk9ZC5jb25jYXQoW28sYV0pLGc9MTI4LHg9YSU4PT09MD84OmElND09PTA/NDoxLCQ9Zy94LHY9JCpfKjgsUz12L2gsVD12L3QuYmxvY2tTaXplLEE9Qy5zaXplKHkpL3gsaz1bXSxQPVtsLG8saS9oXSxEPUMuY29udmVydFNoYXBlKGVbMV0uZGltcykuc2xpY2UoKTtELnNwbGljZSgtMSwxLG0vXyksay5wdXNoKC4uLk4oUCkpLGsucHVzaCguLi5OKEQpKSxrLnB1c2goLi4uTihlWzJdLmRpbXMpKSxlLmxlbmd0aD09PTQmJmsucHVzaCguLi5OKEMuY29udmVydFNoYXBlKGVbM10uZGltcykpKTtsZXQgUj1bbCxvLGFdO2sucHVzaCguLi5OKFIpKTtsZXQgRz1LPT57bGV0IGo9UC5sZW5ndGgsVj1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsaixoKSxRPUUoXCJiXCIsMTIsRC5sZW5ndGgsXyksc2U9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksWT1bVixRLHNlXSxlZT1lLmxlbmd0aD09PTQ/RShcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO2VlJiZZLnB1c2goZWUpO2xldCBKPVIubGVuZ3RoLG5lPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLEopLGJlPV9lKGVbMF0uZGF0YVR5cGUpLE9lPSgpPT57c3dpdGNoKGgpe2Nhc2UgMTpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7YmV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyA0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA1XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA2XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA3XSk7YDtjYXNlIDI6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXRdLCBzdWJfYVt3b3JkX29mZnNldCArIDFdKTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHZlYzQ8JHtiZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO2A7Y2FzZSA0OnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtofS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gc3ViX2E6IGFycmF5PCR7Vi50eXBlLnZhbHVlfSwgJHtTfT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7bmUudHlwZS52YWx1ZX0sICR7JH0+LCAke3h9PjtcbiAgICAgICAgJHtLLmRlY2xhcmVWYXJpYWJsZXMoLi4uWSxuZSl9XG4gICAgICAgICR7Sy5tYWluU3RhcnQoWyQseCwxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtuZS5vZmZzZXRUb0luZGljZXMoYHdvcmtncm91cF9pbmRleCAqICR7eH1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbl9ibG9ja3NfcGVyX2NvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG4gICAgICAgICAgbGV0IG51bV90aWxlcyA9ICAobl9ibG9ja3NfcGVyX2NvbCAtIDEpIC8gJHtUfSArIDE7XG5cbiAgICAgICAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICAgICAgICBmb3IgKHZhciB0aWxlOiB1MzIgPSAwOyB0aWxlIDwgbnVtX3RpbGVzOyB0aWxlICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBhX2NvbF9zdGFydCA9IHRpbGUgKiAke1N9O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHtTfTsgYV9vZmZzZXQgKz0gJHtnfSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV0IGFfY29sID0gYV9jb2xfc3RhcnQgKyBhX29mZnNldDtcbiAgICAgICAgICAgICAgaWYgKGFfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsyXSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Vi5nZXRCeUluZGljZXMoYCR7Vi50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGFfY29sKWApfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke1YudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgICAgLy8gZWFjaCB0aHJlYWQgcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIGxldCBiX3JvdyA9IGNvbCArIGxvY2FsX2lkLnk7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aWxlICogJHtUfSArIGxvY2FsX2lkLng7XG4gICAgICAgICAgICAke2VlP2BcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobl9ibG9ja3NfcGVyX2NvbCArIDEpIC8gMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBiX3JvdyAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZCA9ICR7ZWUuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X3dvcmRfaW5kZXhcIil9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7YmV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtiZX0oOCk7YH1cbiAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7c2UuZ2V0QnlPZmZzZXQoXCJiX3JvdyAqIG5fYmxvY2tzX3Blcl9jb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtRLmdldEJ5SW5kaWNlcyhgJHtRLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldCA9IGxvY2FsX2lkLnggKiAke3QuYmxvY2tTaXplL2h9O1xuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7X307IGkrKykge1xuICAgICAgICAgICAgICAke09lKCl9XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlID0gJHtfPT09MT9cImJfZGF0YVwiOlwiYl9kYXRhW2ldXCJ9O1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl9xdWFudGl6ZWRfdmFsdWVzID0gbWF0Mng0PCR7YmV9Pigke0FycmF5LmZyb20oe2xlbmd0aDo0fSwoJGUsbGUpPT5gJHtiZX0oYl92YWx1ZV9sb3dlclske2xlfV0pLCAke2JlfShiX3ZhbHVlX3VwcGVyWyR7bGV9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke2JlfT4oJHtBcnJheSg4KS5maWxsKFwiemVyb19wb2ludFwiKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlO1xuICAgICAgICAgICAgICBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdICs9ICR7QXJyYXkuZnJvbSh7bGVuZ3RoOjJ9LCgkZSxsZSk9PmAke2Bkb3QoYV9kYXRhJHtsZX0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7bGV9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgvaH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkeCA8ICR7eH0pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7bmUudHlwZS52YWx1ZX0gPSAke25lLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHskfTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke25lLnNldEJ5SW5kaWNlcyhgJHtuZS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkeClgLFwib3V0cHV0X3ZhbHVlXCIpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQmxvY2t3aXNlTWF0TXVsTkJpdHMzMlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske2h9OyR7X307JHskfTske3h9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6eSxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDpBfSxwcm9ncmFtVW5pZm9ybXM6a30pLGdldFNoYWRlclNvdXJjZTpHfX0sZWw9KGUsdCk9PntjaChlLmlucHV0cyx0KSx0LmJsb2NrU2l6ZT09PTMyJiZlLmFkYXB0ZXJJbmZvLmlzVmVuZG9yKFwiaW50ZWxcIikmJmUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJnZW4tMTJscFwiKT9lLmNvbXB1dGUobWgoZS5pbnB1dHMsdCkpOmUuY29tcHV0ZShwaChlLmlucHV0cyx0KSl9LHRsPWU9PnJlKGUpfSk7dmFyIGZoLGhoLGdoLGJoLHloLF9oLHdoLHZoLG5sLG9sPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtmaD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxoaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7RihcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49IGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtGKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICB2YWx1ZSA9ICR7ZS50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYH0sZ2g9KGUsdCxyKT0+e2xldCBuPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbyluKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtGKFwidW5pZm9ybXMucGFkc1wiLG8scil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke0YoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxiaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke0YoXCJ1bmlmb3Jtcy5wYWRzXCIsbyxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7RihcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LHloPShlLHQscik9PntsZXQgbj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pbis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7RihcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7RihcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LF9oPShlLHQscik9Pntzd2l0Y2goci5tb2RlKXtjYXNlIDA6cmV0dXJuIGhoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDE6cmV0dXJuIGdoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDI6cmV0dXJuIGJoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDM6cmV0dXJuIHloKGUsdCxyLnBhZHMubGVuZ3RoKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LHdoPShlLHQpPT57bGV0IHI9Qy5wYWRTaGFwZShlWzBdLmRpbXMuc2xpY2UoKSx0LnBhZHMpLG49ZVswXS5kaW1zLG89Qy5zaXplKHIpLGk9W3t0eXBlOjEyLGRhdGE6b30se3R5cGU6NixkYXRhOnQucGFkc31dLGE9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YTt0Lm1vZGU9PT0wJiZpLnB1c2goe3R5cGU6YT9lWzJdLmRhdGFUeXBlOjEsZGF0YTp0LnZhbHVlfSksaS5wdXNoKC4uLk4oZVswXS5kaW1zLHIpKTtsZXQgZD1bXCJyYW5rXCJdLGw9cD0+e2xldCBtPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoKSx1PUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCksaD11LnR5cGUudmFsdWUsXz1faChtLG4ubGVuZ3RoLHQpLHk9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH1dO3JldHVybiB0Lm1vZGU9PT0wJiZ5LnB1c2goe25hbWU6XCJjb25zdGFudF92YWx1ZVwiLHR5cGU6YT9oOlwiZjMyXCJ9KSxgXG4gICAgICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKHUsbSl9XG4gICAgICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtofSgwKTtcbiAgICAgICAgICAgICR7X31cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0Lm1vZGV9JHthfWAsaW5wdXREZXBlbmRlbmNpZXM6ZH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUocikvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aX0pLGdldFNoYWRlclNvdXJjZTpsfX0sdmg9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1lWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxuPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE/ZVsyXS5kYXRhVHlwZT09PTEwP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTplWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsbz1lWzBdLmRpbXMubGVuZ3RoLGk9bmV3IEludDMyQXJyYXkoMipvKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgZD1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IGw9MDtsPGQubGVuZ3RoO2wrKylpW051bWJlcihkW2xdKV09TnVtYmVyKHJbbF0pLGlbTnVtYmVyKGRbbF0pK29dPU51bWJlcihyW2wrZC5sZW5ndGhdKX1lbHNlIHIuZm9yRWFjaCgoZCxsKT0+aVtOdW1iZXIobCldPU51bWJlcihkKSk7bGV0IGE9W107cmV0dXJuIGkuZm9yRWFjaChkPT5hLnB1c2goZCkpLHttb2RlOnQubW9kZSx2YWx1ZTpuLHBhZHM6YX19ZWxzZSByZXR1cm4gdH0sbmw9KGUsdCk9PntmaChlLmlucHV0cyk7bGV0IHI9dmgoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHdoKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHRuLGlsLGFsLHNsLHVsLCRoLHhoLGRsLGxsLGNsLHBsLG1sLGZsLGhsLGdsLGJsLHlsLF9sLHdsLHZsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7b2UoKTthZSgpO3RuPWU9PntpZih2ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJighZXx8ZS5sZW5ndGghPT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKX0saWw9KGUsdCxyKT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIsbz1lLmRpbXMuc2xpY2UoKTtuJiZvLnNwbGljZSgxLDAsby5wb3AoKSk7bGV0IGk9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSxhPXQua2VybmVsU2hhcGUuc2xpY2UoKSxkPXQuc3RyaWRlcy5zbGljZSgpLGw9aT90LmRpbGF0aW9ucy5zbGljZSgpOltdLHA9dC5wYWRzLnNsaWNlKCk7QXQuYWRqdXN0UG9vbEF0dHJpYnV0ZXMocixvLGEsZCxsLHApO2xldCBtPUF0LmNvbXB1dGVQb29sT3V0cHV0U2hhcGUocixvLGQsbCxhLHAsdC5hdXRvUGFkKSx1PU9iamVjdC5hc3NpZ24oe30sdCk7aT9PYmplY3QuYXNzaWduKHUse2tlcm5lbFNoYXBlOmEsc3RyaWRlczpkLHBhZHM6cCxkaWxhdGlvbnM6bCxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbih1LHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6ZCxwYWRzOnAsY2FjaGVLZXk6dC5jYWNoZUtleX0pO2xldCBoPW0uc2xpY2UoKTtyZXR1cm4gaC5wdXNoKGguc3BsaWNlKDEsMSlbMF0pLFt1LG4/aDptXX0sYWw9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49Qy5zaXplKGUpLG89Qy5zaXplKHQua2VybmVsU2hhcGUpLGk9W3t0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfV0sYT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwidTMyXCJ9XTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0IGQ9dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxsPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTFdLHA9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0xXSxtPXQucGFkc1t0LnBhZHMubGVuZ3RoLTFdLHU9ISEocCttKTtpLnB1c2goe3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTptfSksYS5wdXNoKHtuYW1lOlwia3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd0VuZFwiLHR5cGU6XCJ1MzJcIn0pO2xldCBoPSExO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IF89dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0yXSx5PXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTJdLGc9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0yXSx4PXQucGFkc1t0LnBhZHMubGVuZ3RoLTJdO2g9ISEoZyt4KSxpLnB1c2goe3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOnl9LHt0eXBlOjEyLGRhdGE6Z30se3R5cGU6MTIsZGF0YTp4fSksYS5wdXNoKHtuYW1lOlwia2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaEVuZFwiLHR5cGU6XCJ1MzJcIn0pfXJldHVybltpLGEsITAsdSxoXX1lbHNle2lmKHIpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBkPUMuY29tcHV0ZVN0cmlkZXModC5rZXJuZWxTaGFwZSk7aS5wdXNoKHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTp0LnBhZHN9LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSksYS5wdXNoKHtuYW1lOlwia2VybmVsU3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ZC5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSk7bGV0IGw9dC5wYWRzLnJlZHVjZSgocCxtKT0+cCttKTtyZXR1cm5baSxhLCEhbCwhMSwhMV19fSxzbD0oZSx0LHIsbixvLGksYSxkLGwscCxtLHUpPT57bGV0IGg9by5mb3JtYXQ9PT1cIk5IV0NcIixfPXQudHlwZS52YWx1ZSx5PU0oXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLG4pO2lmKG8ua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgZz1cIlwiLHg9XCJcIiwkPVwiXCIsdj1yLShoPzI6MSk7aWYobT9nPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7dn1dID0gaW5kaWNlc1ske3Z9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHt2fV0gPCAwIHx8IHhJbmRpY2VzWyR7dn1dXG4gICAgICAgICAgICAgICAgICAgICAgPj0gdW5pZm9ybXMueF9zaGFwZVske3Z9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgICAgIH1gOmc9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt2fV0gPSBpbmRpY2VzWyR7dn1dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgICAgfWAsby5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgVD1yLShoPzM6Mik7dT94PWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7VH1dID0gaW5kaWNlc1ske1R9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtUfV0gPCAwIHx8IHhJbmRpY2VzWyR7VH1dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtUfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgOng9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtUfV0gPSBpbmRpY2VzWyR7VH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICBgLCQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKGwpLmRlY2xhcmVWYXJpYWJsZXModCx5KX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7ZH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHt4fVxuICAgICAgICAgICAgICAke2d9XG4gICAgICAgICAgICAgICR7JH1cbiAgICAgICAgICAgICAgJHthfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9ZWxzZXtpZihoKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgZz1vLmtlcm5lbFNoYXBlLmxlbmd0aCx4PW8ucGFkcy5sZW5ndGgsJD1cIlwiO3JldHVybiBwPyQ9YFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgIH1gOiQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgIGAsYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMobCkuZGVjbGFyZVZhcmlhYmxlcyh0LHkpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke2d9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7ZH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke2ctMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke0YoXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsZyl9O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiAke0YoXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsZyl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7Zy0xfV0gPSBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke3ItZ311OyBqIDwgJHtyfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogJHtGKFwidW5pZm9ybXMuc3RyaWRlc1wiLGBqIC0gJHtyLWd9dWAsZyl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtyLWd9dV0gLSAke0YoXCJ1bmlmb3Jtcy5wYWRzXCIsXCJqIC0gMnVcIix4KX07XG4gICAgICAgICAgICAgICAgICAkeyR9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHthfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9fSx1bD1lPT5gJHtlLmZvcm1hdH07JHtlLmNlaWxNb2RlfTske2UuYXV0b1BhZH07JHtlLmtlcm5lbFNoYXBlLmxlbmd0aH1gLCRoPWU9PmAke3VsKGUpfTske2UuY291bnRJbmNsdWRlUGFkfWAseGg9ZT0+YCR7dWwoZSl9OyR7ZS5zdG9yYWdlT3JkZXJ9OyR7ZS5kaWxhdGlvbnN9YCxkbD1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxsbD0oZSx0LHIsbik9PntsZXRbbyxpXT1pbCh0LG4sciksYT1FKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCksZD1hLnR5cGUudmFsdWUsbD1cInZhbHVlICs9IHhfdmFsO1wiLHA9XCJcIjtvLmNvdW50SW5jbHVkZVBhZD9wKz1gdmFsdWUgLz0gJHtkfSh1bmlmb3Jtcy5rZXJuZWxTaXplKTtgOnArPWB2YWx1ZSAvPSAke2R9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtsZXRbbSx1LGgsXyx5XT1hbChpLG8pO20ucHVzaCguLi5OKHQuZGltcyxpKSk7bGV0IGc9W1wicmFua1wiXTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke24uY2FjaGVLZXl9OyR7aH07JHtffTske3l9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEMuc2l6ZShpKS82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOng9PnNsKHgsYSx0LmRpbXMubGVuZ3RoLGkubGVuZ3RoLG8sbCxwLDAsdSxoLF8seSl9fSxjbD1lPT57bGV0IHQ9ZS5jb3VudF9pbmNsdWRlX3BhZCE9PTAscj1kbChlKTtpZihyLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO2xldCBuPXtjb3VudEluY2x1ZGVQYWQ6dCwuLi5yLGNhY2hlS2V5OlwiXCJ9O3JldHVybnsuLi5uLGNhY2hlS2V5OiRoKG4pfX0scGw9KGUsdCk9Pnt0bihlLmlucHV0cyksZS5jb21wdXRlKGxsKFwiQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LG1sPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXX0sZmw9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5tbCxjYWNoZUtleTp0fX0saGw9KGUsdCk9Pnt0bihlLmlucHV0cyksZS5jb21wdXRlKGxsKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9LGdsPShlLHQscixuKT0+e2xldFtvLGldPWlsKHQsbixyKSxhPWBcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XG4gICAgYCxkPVwiXCIsbD1FKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkscD1bXCJyYW5rXCJdLFttLHUsaCxfLHldPWFsKGksbyk7cmV0dXJuIG0ucHVzaCguLi5OKHQuZGltcyxpKSkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHtuLmNhY2hlS2V5fTske2h9OyR7X307JHt5fWAsaW5wdXREZXBlbmRlbmNpZXM6cH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUoaSkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTpnPT5zbChnLGwsdC5kaW1zLmxlbmd0aCxpLmxlbmd0aCxvLGEsZCx0LmRhdGFUeXBlPT09MTA/LTY1NTA0Oi0xZTUsdSxoLF8seSl9fSxibD0oZSx0KT0+e3RuKGUuaW5wdXRzKSxlLmNvbXB1dGUoZ2woXCJNYXhQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSx5bD1lPT57bGV0IHQ9ZS5zdG9yYWdlX29yZGVyLHI9ZS5kaWxhdGlvbnMsbj1kbChlKTtpZih0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZihuLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7bGV0IG89e3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpyLC4uLm4sY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLm8sY2FjaGVLZXk6eGgobyl9fSxfbD1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLm1sLGNhY2hlS2V5OnR9fSx3bD0oZSx0KT0+e3RuKGUuaW5wdXRzKSxlLmNvbXB1dGUoZ2woXCJHbG9iYWxNYXhQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfX0pO3ZhciBUaCxJaCwkbCx4bCxTbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtUaD0oZSx0KT0+e2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiRGVxdWFudGl6ZUxpbmVhciByZXF1aXJlcyAyIG9yIDMgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMV0uZGltcz09PWVbMl0uZGltcyl0aHJvdyBuZXcgRXJyb3IoXCJ4LXNjYWxlIGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzBdLmRhdGFUeXBlPT09NiYmZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC5cIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTAmJmVbMV0uZGltcy5sZW5ndGghPT0xJiZlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBpbnB1dCBtdXN0IGJlIGEgc2NhbGFyLCBhIDFEIHRlbnNvciwgb3IgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKGUubGVuZ3RoPjIpe2lmKGVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsuXCIpO2lmKCFlWzFdLmRpbXMubWFwKChyLG4pPT5yPT09ZVsyXS5kaW1zW25dKS5yZWR1Y2UoKHIsbik9PnImJm4sITApKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpfWlmKHQuYmxvY2tTaXplPjApe2lmKGVbMV0uZGltcy5sZW5ndGg9PT0wfHxlWzFdLmRpbXMubGVuZ3RoPT09MSYmZVsxXS5kaW1zWzBdPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSBzZXQgb25seSBmb3IgYmxvY2sgcXVhbnRpemF0aW9uLlwiKTtpZighZVsxXS5kaW1zLm1hcCgobyxpKT0+aT09PXQuYXhpc3x8bz09PWVbMF0uZGltc1tpXSkucmVkdWNlKChvLGkpPT5vJiZpLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uLCBzY2FsZSBpbnB1dCBzaGFwZSB0byBtYXRjaCB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGZvciB0aGUgYXhpc1wiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay5cIik7bGV0IHI9ZVswXS5kaW1zW3QuYXhpc10sbj1lWzFdLmRpbXNbdC5heGlzXTtpZih0LmJsb2NrU2l6ZTxNYXRoLmNlaWwoci9uKXx8dC5ibG9ja1NpemU+TWF0aC5jZWlsKHIvKG4tMSktMSkpdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tTaXplIG11c3QgYmUgd2l0aCBpbiB0aGUgcmFuZ2UgW2NlaWwoZEkgLyBTaSksIGNlaWwoZEkgLyAoU2kgLSAxKSAtIDEpXS5cIil9fSxJaD0oZSx0KT0+e2xldCByPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsZVswXS5kaW1zLmxlbmd0aCksbj1lWzBdLmRhdGFUeXBlLG89bj09PTMsaT1lWzBdLmRpbXMsYT1lWzFdLmRhdGFUeXBlLGQ9Qy5zaXplKGkpLGw9bj09PTN8fG49PT0yLHA9bD9bTWF0aC5jZWlsKEMuc2l6ZShlWzBdLmRpbXMpLzQpXTplWzBdLmRpbXMsbT1lWzFdLmRpbXMsdT1lLmxlbmd0aD4yP2VbMl06dm9pZCAwLGg9dT9sP1tNYXRoLmNlaWwoQy5zaXplKHUuZGltcykvNCldOnUuZGltczp2b2lkIDAsXz1tLmxlbmd0aD09PTB8fG0ubGVuZ3RoPT09MSYmbVswXT09PTEseT1fPT09ITEmJm0ubGVuZ3RoPT09MSxnPW1lKGQpLHg9XyYmKCFsfHxnPT09NCksJD14P2c6MSx2PXgmJiFsP2c6MSxTPUUoXCJpbnB1dFwiLGw/MTI6bixwLmxlbmd0aCx2KSxUPUUoXCJzY2FsZVwiLGEsbS5sZW5ndGgpLEE9dT9FKFwiemVyb19wb2ludFwiLGw/MTI6bixoLmxlbmd0aCk6dm9pZCAwLGs9TShcIm91dHB1dFwiLGEsaS5sZW5ndGgsJCksUD1bUyxUXTtBJiZQLnB1c2goQSk7bGV0IEQ9W3AsbV07dSYmRC5wdXNoKGgpO2xldCBSPVt7dHlwZToxMixkYXRhOmQvJH0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5OKC4uLkQsaSldLEc9Sz0+e2xldCBqPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImF4aXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmxvY2tfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgICAgICR7Sy5yZWdpc3RlclVuaWZvcm1zKGopLmRlY2xhcmVWYXJpYWJsZXMoLi4uUCxrKX1cbiAgICAgICR7Sy5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke0suZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7ay5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgIC8vIFNldCBpbnB1dCB4XG4gICAgICAgICAgJHsoKCk9Pmw/YFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtTLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAvIDRcIil9O1xuICAgICAgICAgICAgbGV0IHhfdmVjID0gJHtvP1widW5wYWNrNHhJOChpbnB1dClcIjpcInVucGFjazR4VTgoaW5wdXQpXCJ9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAkeyQ9PT0xP1wieF92ZWNbZ2xvYmFsX2lkeCAlIDRdXCI6XCJ4X3ZlY1wifTtgOmBsZXQgeF92YWx1ZSA9ICR7Uy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O2ApKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHsoKCk9Pl8/YGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5T2Zmc2V0KFwiMFwiKX1gOnk/YFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtrLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7VC5nZXRCeU9mZnNldChcInNjYWxlX2luZGV4XCIpfTtgOmBcbiAgICAgICAgICAgIHZhciBzY2FsZV9pbmRpY2VzOiAke1QudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtULmluZGljZXNHZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICAgICAke1QuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcImluZGV4XCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2ApKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHplcm8tcG9pbnQgaW5wdXRcbiAgICAgICAgICAkeygoKT0+QT9fP2w/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiMFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWU9IHplcm9fcG9pbnRfdmVjWzBdYDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfWA6eT9sP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7ay5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAlIDRdYDpgXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAke2suaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfaW5kZXhcIil9O2A6bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtULmluZGljZXNUb09mZnNldChcInNjYWxlX2luZGljZXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9vZmZzZXQgLyA0XCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7bD9vP1wiaTMyXCI6XCJ1MzJcIjpTLnR5cGUudmFsdWV9KDApO2ApKCl9O1xuICAgICAgLy8gQ29tcHV0ZSBhbmQgd3JpdGUgb3V0cHV0XG4gICAgICAke2suc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYCR7ay50eXBlLnZhbHVlfSh4X3ZhbHVlIC0gemVyb19wb2ludF92YWx1ZSkgKiBzY2FsZV92YWx1ZWApfTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkRlcXVhbnRpemVMaW5lYXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOkE/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6RyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvJC82NCkseToxLHo6MX0scHJvZ3JhbVVuaWZvcm1zOlJ9KX19LCRsPShlLHQpPT57VGgoZS5pbnB1dHMsdCksZS5jb21wdXRlKEloKGUuaW5wdXRzLHQpKX0seGw9ZT0+cmUoe2F4aXM6ZS5heGlzLGJsb2NrU2l6ZTplLmJsb2NrU2l6ZX0pfSk7dmFyIENoLEFoLFRsLElsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7YWUoKTtDaD0oZSx0LHIpPT57bGV0IG49ZT09PXQsbz1lPHQmJnI8MCxpPWU+dCYmcj4wO2lmKG58fG98fGkpdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIil9LEFoPShlLHQscixuKT0+e2xldCBvPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9yKSksaT1bb10sYT1vLGQ9W3t0eXBlOjEyLGRhdGE6YX0se3R5cGU6bixkYXRhOmV9LHt0eXBlOm4sZGF0YTpyfSwuLi5OKGkpXSxsPXA9PntsZXQgbT1NKFwib3V0cHV0XCIsbixpLmxlbmd0aCksdT1tLnR5cGUudmFsdWUsaD1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0XCIsdHlwZTp1fSx7bmFtZTpcImRlbHRhXCIsdHlwZTp1fV07cmV0dXJuYFxuICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3JtcyhoKS5kZWNsYXJlVmFyaWFibGVzKG0pfVxuICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdW5pZm9ybXMuc3RhcnQgKyAke3V9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJSYW5nZVwiLHNoYWRlckNhY2hlOntoaW50OmAke259YH0sZ2V0U2hhZGVyU291cmNlOmwsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmR9KX19LFRsPWU9PntsZXQgdD0wLHI9MCxuPTA7ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT02Pyh0PWUuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXSxuPWUuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXSk6ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT0xJiYodD1lLmlucHV0c1swXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0pLHZlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmQ2godCxyLG4pLGUuY29tcHV0ZShBaCh0LHIsbixlLmlucHV0c1swXS5kYXRhVHlwZSkse2lucHV0czpbXX0pfX0pO3ZhciBraCxFaCxDbCxBbCxrbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtraD0oZSx0LHIsbik9PntpZihlIT09XCJub25lXCImJm4hPT1cImkzMlwiJiZuIT09XCJ1MzJcIiYmbiE9PVwiZjMyXCIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke259IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCByZWR1Y3Rpb24gJHtlfS5gKTtsZXQgbz1ge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgbG9vcCB7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWVGMzIgPWAsaT1gO1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gYml0Y2FzdDxpMzI+KG5ld1ZhbHVlRjMyKTtcbiAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrKCYke3R9LCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgcmVzLmV4Y2hhbmdlZCB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZXMub2xkX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfWA7c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm5gJHt0fT0ke3J9O2A7Y2FzZVwiYWRkXCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljQWRkKCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmBcbiAgICAgICAgICAgICAgJHtvfWJpdGNhc3Q8JHtufT4ob2xkVmFsdWUpICsgKCR7cn0pJHtpfWA7Y2FzZVwibWF4XCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljTWF4KCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmBcbiAgICAgICAgICAgICAgICAke299bWF4KGJpdGNhc3Q8ZjMyPihvbGRWYWx1ZSksICgke3J9KSkke2l9YDtjYXNlXCJtaW5cIjpyZXR1cm4gbj09PVwiaTMyXCJ8fG49PT1cInUzMlwiP2BhdG9taWNNaW4oJiR7dH0sIGJpdGNhc3Q8JHtufT4oJHtyfSkpO2A6YCR7b31taW4oYml0Y2FzdDwke259PihvbGRWYWx1ZSksICgke3J9KSkke2l9YDtjYXNlXCJtdWxcIjpyZXR1cm5gJHtvfShiaXRjYXN0PCR7bn0+KG9sZFZhbHVlKSAqICgke3J9KSkke2l9YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgUmVkdWN0aW9uICR7ZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LEVoPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89cixpPTEsYT1NYXRoLmNlaWwoQy5zaXplKG4pL2kpLGQ9bltuLmxlbmd0aC0xXSxsPUMuc2l6ZUZyb21EaW1lbnNpb24ocixkKSxwPVt7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfSwuLi5OKGVbMV0uZGltcyxlWzJdLmRpbXMsbyldLG09dT0+e2xldCBoPUUoXCJpbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxfPUUoXCJ1cGRhdGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGkpLHk9dC5yZWR1Y3Rpb24hPT1cIm5vbmVcIiYmdC5yZWR1Y3Rpb24hPT1cIlwiP3JzKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCk6TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsaSk7cmV0dXJuYFxuICAgICAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwibGFzdF9pbmRleF9kaW1lbnNpb25cIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJudW1fdXBkYXRlc19lbGVtZW50c1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCxfLHkpfVxuICAgICAgJHt1Lm1haW5TdGFydCgpfVxuICAgICAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcbiAgbGV0IGluZGljZXNfc3RhcnQgPSB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbiAqIGdsb2JhbF9pZHg7XG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgJHtlWzBdLmRpbXMubGVuZ3RoPT09MT9gXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXM7XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZTtgOmBcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlc1tpIC0gaW5kaWNlc19zdGFydF07XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVtpIC0gaW5kaWNlc19zdGFydCArIHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uXTtgfVxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBpZiAoaW5kZXggPj0gaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSBpMzIoZGltX3ZhbHVlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbmRleCA8IC1pMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCArPSBpMzIoZGltX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGF0YV9vZmZzZXQgKz0gdTMyKCh1MzIoaW5kZXgpICogZWxlbWVudF9jb3VudF9kaW0pKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwdTsgaSA8IHVuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzOyBpKyspIHtcbiAgICBsZXQgdmFsdWUgPSB1cGRhdGVzW3VuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzICogZ2xvYmFsX2lkeCArIGldO1xuICAgICR7a2godC5yZWR1Y3Rpb24sXCJvdXRwdXRbZGF0YV9vZmZzZXQgKyBpXVwiLFwidmFsdWVcIix5LnR5cGUudmFsdWUpfVxuICB9XG5cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlNjYXR0ZXJORFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dC5yZWR1Y3Rpb259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTptfX0sQ2w9ZT0+cmUoe3JlZHVjdGlvbjplLnJlZHVjdGlvbn0pLEFsPShlLHQpPT57ZS5jb21wdXRlKEVoKGUuaW5wdXRzLHQpLHtpbnB1dHM6W2UuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxvdXRwdXRzOltdfSl9fSk7dmFyIFBoLHpoLE9oLERoLEJoLE1oLFJoLFVoLE5oLFZoLFdoLEVsLExoLEdoLEhoLEZoLHFoLFBsLHpsLE9sPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1BoPShlLHQpPT57aWYoZS5ldmVyeShyPT5yPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTN8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MXx8ZS5sZW5ndGg9PT01JiZlWzBdPT09MSYmZVsxXT09PTEpKXRocm93IG5ldyBFcnJvcihgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCl9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSx6aD0oZSx0LHIpPT57dC5ldmVyeShvPT5vPj0wJiZvPHJ8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IG49bmV3IEFycmF5KHIpLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgobyxpKT0+bltvXT1lW2ldKSxufSxPaD0oZSx0LHIsbixvLGkpPT57bGV0W2EsZCxsXT1yPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0scD1lWzBdLmRpbXMubGVuZ3RoO2lmKGE+MCYmZS5sZW5ndGg+YSYmZVthXS5kaW1zLmxlbmd0aD4wKWVbYV0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5pLnB1c2gobSkpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYoZD4wJiZlLmxlbmd0aD5kJiZlW2RdLmRpbXMubGVuZ3RoPT09MSYmZVtkXS5kaW1zWzBdPjApe2lmKGVbZF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5uLnB1c2gobSkpLG4ubGVuZ3RoIT09MCYmbi5sZW5ndGghPT1wJiZyPj0xOCYmbi5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7UGgobix0KSx0LmF4ZXMubGVuZ3RoPjAmJnpoKG4sdC5heGVzLHApLmZvckVhY2goKG0sdSk9Pm5bdV09bSl9aWYobD4wJiZlLmxlbmd0aD5sJiZlW2xdLmRpbXMubGVuZ3RoPT09MSYmZVtsXS5kaW1zWzBdPjAmJihlW2xdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG09Pm8ucHVzaChOdW1iZXIobSkpKSxvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09cCYmcj49MTgmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO2lmKHQuYXhlcy5sZW5ndGg+MCl7aWYobi5sZW5ndGghPT0wJiZuLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtpZihvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKX1pZih0eXBlb2YgbjxcInVcIiYmdHlwZW9mIG88XCJ1XCImJm4ubGVuZ3RoPjAmJm8ubGVuZ3RoPnApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0sRGg9KGUsdCk9PmBmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IHUzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IHUzMixcbiAgICAgbGVuZ3RoT3JpZ2luYWw6IHUzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+ICR7dH0geyBgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJhc3ltbWV0cmljXCI6cmV0dXJuYHJldHVybiAke3R9KHhSZXNpemVkKSAvICR7dH0oeFNjYWxlKTtgO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkgLSAwLjU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIjpyZXR1cm5gcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSk7YDtjYXNlXCJhbGlnbl9jb3JuZXJzXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdob2xlID0gJHt0fSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgJSAobGVuZ3RoUmVzaXplZCAtIDEpKSAvICR7dH0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7dH0ocm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgke3R9KHhSZXNpemVkKSAqICR7dH0ocm9pRW5kIC0gcm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke3R9KHJvaVN0YXJ0ICsgcm9pRW5kKSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuYGNvbnN0IG91dHB1dFdpZHRoID0gJHt0fXhTY2FsZSAqICR7dH0obGVuZ3RoUmVzaXplZCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHt0fShsZW5ndGhSZXNpemVkKSAvIG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHt0fShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtjYXNlXCJoYWxmX3BpeGVsXCI6cmV0dXJuYHJldHVybiAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLEJoPShlLHQscik9PmBmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiAke3J9LCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+ICR7cn0ge2ArKCgpPT57c3dpdGNoKGUpe2Nhc2VcInJvdW5kX3ByZWZlcl9jZWlsXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgfVwiO2Nhc2VcImZsb29yXCI6cmV0dXJuXCJyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTtcIjtjYXNlXCJjZWlsXCI6cmV0dXJuXCJyZXR1cm4gY2VpbCh4T3JpZ2luYWwpO1wiO2Nhc2VcInJvdW5kX3ByZWZlcl9mbG9vclwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJzaW1wbGVcIjpkZWZhdWx0OmlmKHQ8MTEpcmV0dXJuXCJpZiAoaXNEb3duU2FtcGxlKSAgICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7ICAgICAgICAgICAgICAgICAgICAgfVwiO3Rocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsTWg9KGUsdCxyKT0+e2xldCBuPW5ldyBBcnJheShyKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkocikuZmlsbCgxKSksbz1lLmxlbmd0aD09PTA/bjplLnNsaWNlKCk7cmV0dXJuIHQubGVuZ3RoPjA/KHQuZm9yRWFjaCgoaSxhKT0+e25baV09b1thXSxuW2Ercl09b1t0Lmxlbmd0aCthXX0pLG4pOm99LFJoPShlLHQscixuKT0+e2xldCBvPVtdO2lmKHIubGVuZ3RoPjApaWYobi5sZW5ndGg+MCl7aWYoZS5mb3JFYWNoKGk9Pm8ucHVzaChpKSksTWF0aC5tYXgoLi4ubik+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBpcyBvdXQgb2YgYm91bmRcIik7bi5mb3JFYWNoKChpLGEpPT5vW2ldPXJbYV0pfWVsc2Ugci5mb3JFYWNoKGk9Pm8ucHVzaChpKSk7ZWxzZXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuXCIpO289ZS5tYXAoKGksYSk9Pk1hdGgucm91bmQoaSp0W2FdKSl9cmV0dXJuIG99LFVoPShlLHQscik9PntsZXQgbj0oKCk9Pntzd2l0Y2goci5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpe2Nhc2VcIm5vdF9sYXJnZXJcIjpyZXR1cm4gci5heGVzLmxlbmd0aD4wP01hdGgubWluKC4uLnIuYXhlcy5tYXAoaT0+dFtpXSksTnVtYmVyLk1BWF9WQUxVRSk6TWF0aC5taW4oLi4udCxOdW1iZXIuTUFYX1ZBTFVFKTtjYXNlXCJub3Rfc21hbGxlclwiOnJldHVybiByLmF4ZXMubGVuZ3RoPjA/TWF0aC5tYXgoLi4uci5heGVzLm1hcChpPT50W2ldKSxOdW1iZXIuTUlOX1ZBTFVFKTpNYXRoLm1heCguLi50LE51bWJlci5NSU5fVkFMVUUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHtyLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCk7dC5maWxsKDEsMCx0Lmxlbmd0aCk7bGV0IG89ZS5zbGljZSgpO3JldHVybiByLmF4ZXMubGVuZ3RoPjA/KHIuYXhlcy5mb3JFYWNoKGk9PnRbaV09biksci5heGVzLmZvckVhY2goaT0+b1tpXT1NYXRoLnJvdW5kKGVbaV0qdFtpXSkpKToodC5maWxsKG4sMCx0Lmxlbmd0aCksby5mb3JFYWNoKChpLGEpPT5vW2FdPU1hdGgucm91bmQoaSp0W2FdKSkpLG99LE5oPShlLHQscixuLG8pPT5gXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7ci5sZW5ndGh9PiB7XG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke3IubGVuZ3RofT47XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtGKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbil9O1xuICAgICAgICB2YXIgcm9pX2xvdyA9ICR7RihcInVuaWZvcm1zLnJvaVwiLFwiaVwiLG8pfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7RihcInVuaWZvcm1zLnJvaVwiLGBpICsgJHt0Lmxlbmd0aH1gLG8pfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSAke2UudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7RihcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke0YoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcbiAgICB9YCxWaD0oZSx0LHIsbixvLGksYSk9PmBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtGKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke0YoXCJ1bmlmb3Jtcy5yb2lcIixcImlcIixpKX07XG4gICAgICAgICAgdmFyIHJvaV9oaSA9ICR7RihcInVuaWZvcm1zLnJvaVwiLGBpICsgJHtyLmxlbmd0aH1gLGkpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7RihcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke0YoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHthfSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHt0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSAtIDEpKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZSA8IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCIgaW5wdXRfaW5kZXhcIil9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICB9YCxXaD0oZSx0KT0+YFxuICAgIGZuIGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBib29sIHtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gJHtlLmluZGljZXNHZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgaWYgKGlucHV0X2luZGV4IDwgMCB8fCBpbnB1dF9pbmRleCA+PSAke0YoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHQubGVuZ3RoKX0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gLEVsPShlLHQscixuKT0+ZS5yYW5rPm4/YFxuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHQsXCJjaGFubmVsXCIpfTtcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixyLFwiYmF0Y2hcIil9O1xuYDpcIlwiLExoPShlLHQscixuLG8pPT57bGV0W2EsZCxsLHBdPXIubGVuZ3RoPT09Mj9bLTEsMCwxLC0xXTpbMCwyLDMsMV0sbT1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7bX0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCxgbWF4KDAsIG1pbihyb3csICR7cltkXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixsLGBtYXgoMCwgbWluKGNvbCwgJHtyW2xdfSAtIDEpKWApfTtcbiAgICAgICR7RWwoZSxwLGEsMil9XG4gICAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgIH1cblxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7bX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciByb3c6JHttfSA9IG9yaWdpbmFsSW5kaWNlc1ske2R9XTtcbiAgICAgIHZhciBjb2w6JHttfSA9IG9yaWdpbmFsSW5kaWNlc1ske2x9XTtcbiAgICAgICR7bj9gaWYgKHJvdyA8IDAgfHwgcm93ID4gKCR7cltkXX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICgke3JbbF19IC0gMSkpIHtcbiAgICAgICAgcmV0dXJuICR7b307XG4gICAgICB9YDpcIlwifTtcbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke3JbZF19IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7cltsXX0gLSAxKSk7XG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHtwfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHthfV0pYDpcIjBcIn07XG4gICAgICB2YXIgeDExOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XG4gICAgICB2YXIgeDEyOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XG4gICAgICB2YXIgeDIyOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XG4gICAgICB2YXIgZHgxOiAke219ID0gYWJzKHJvdyAtICR7bX0ocm93MSkpO1xuICAgICAgdmFyIGR4MjogJHttfSA9IGFicygke219KHJvdzIpIC0gcm93KTtcbiAgICAgIHZhciBkeTE6ICR7bX0gPSBhYnMoY29sIC0gJHttfShjb2wxKSk7XG4gICAgICB2YXIgZHkyOiAke219ID0gYWJzKCR7bX0oY29sMikgLSBjb2wpO1xuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2wxID09IGNvbDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XG4gICAgfWB9LEdoPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtPXIubGVuZ3RoPT09Mix1PSEwLFtoLF9dPW0/WzAsMV06dT9bMiwzXTpbMSwyXSx5PWUudHlwZS52YWx1ZSxnPXg9PntsZXQgJD14PT09aD9cInJvd1wiOlwiY29sXCI7cmV0dXJuYFxuICAgICAgZm4gJHskfUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSwgb3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke3l9IHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIix4KX07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHt5fSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsICR7b1t4XX0sXG4gICAgICAgICR7blt4XX0sICR7clt4XX0sICR7aVt4XX0sICR7aVt4XX0gKyAke3IubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAke3l9ID0gb3JpZ2luYWxJZHggLSBmbG9vcihvcmlnaW5hbElkeCk7XG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xuXG4gICAgICAgIGlmICgke2R9ICYmIChvcmlnaW5hbElkeCA8IDAgfHwgb3JpZ2luYWxJZHggPiAoJHtyW3hdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke2x9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwke3l9LCA0PiA9IGFycmF5PCR7eX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyICR7JH06ICR7eX0gPSBvcmlnaW5hbElkeCArICR7eX0oaSk7XG4gICAgICAgICAgaWYgKCR7JH0gPCAwIHx8ICR7JH0gPj0gJHtyW3hdfSkge1xuICAgICAgICAgICAgJHsoKCk9PnA/YGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO2A6ZD9gcmV0dXJuICR7bH07YDpgJHskfSA9IG1heCgwLCBtaW4oJHskfSwgJHtyW3hdfSAtIDEpKTtgKSgpfTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcbiAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNfY29weVwiLHgsYHUzMigkeyR9KWApfTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7eD09PWg/ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIik6XCJyb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlc19jb3B5LCBvdXRwdXRfaW5kaWNlcylcIn07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gfTtyZXR1cm5gXG4gICAgJHtnKGgpfTtcbiAgICAke2coXyl9O1xuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiAke3l9KSAtPiBhcnJheTwke3l9LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHt5fSwgND4gPSBhcnJheTwke3l9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7eX0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7eX0gPSAyLjAgLSBhYnNTO1xuICAgIHZhciBvbmVQbHVzQWJzUzogJHt5fSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke2F9ICogb25lUGx1c0Fic1MgLSA1ICogJHthfSkgKiBvbmVQbHVzQWJzUyArIDggKiAke2F9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7YX07XG4gICAgY29lZmZzWzFdID0gKCgke2F9ICsgMikgKiBhYnNTIC0gKCR7YX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke2F9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHthfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke2F9ICogdHdvTWludXNBYnNTIC0gNSAqICR7YX0pICogdHdvTWludXNBYnNTICsgOCAqICR7YX0pICogdHdvTWludXNBYnNTIC0gNCAqICR7YX07XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7eX0sIDQ+LCBjb2VmczogYXJyYXk8JHt5fSwgND4pIC0+ICR7eX0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHt5fSA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHt5fSB7XG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzLCBvdXRwdXRfaW5kaWNlcyk7XG4gIH1cbiAgICBgfSxIaD0oZSx0LHIsbixvKT0+e2xldFthLGQsbCxwLG1dPXIubGVuZ3RoPT09Mz9bLTEsMCwxLDIsLTFdOlswLDIsMyw0LDFdLHU9ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHt1fSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLGBtYXgoMCwgbWluKGRlcHRoLCAke3JbZF19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsbCxgbWF4KDAsIG1pbihoZWlnaHQsICR7cltsXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixwLGBtYXgoMCwgbWluKHdpZHRoLCAke3JbcF19IC0gMSkpYCl9O1xuICAgICAgJHtFbChlLG0sYSwzKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gdHJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7dX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciBkZXB0aDoke3V9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZH1dO1xuICAgICAgdmFyIGhlaWdodDoke3V9ID0gb3JpZ2luYWxJbmRpY2VzWyR7bH1dO1xuICAgICAgdmFyIHdpZHRoOiR7dX0gPSBvcmlnaW5hbEluZGljZXNbJHtwfV07XG4gICAgICAke24/YGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtyW2RdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7cltsXX0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtyW3BdfSAtIDEpKSB7XG4gICAgICByZXR1cm4gJHtvfTtcbiAgICAgICAgfWA6XCJcIn07XG5cbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7cltkXX0gLSAxKSk7XG4gICAgICBoZWlnaHQgPSBtYXgoMCwgbWluKGhlaWdodCwgJHtyW2xdfSAtIDEpKTtcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtyW3BdfSAtIDEpKTtcbiAgICAgIHZhciBkZXB0aDE6IHUzMiA9IHUzMihkZXB0aCk7XG4gICAgICB2YXIgaGVpZ2h0MTogdTMyID0gdTMyKGhlaWdodCk7XG4gICAgICB2YXIgd2lkdGgxOiB1MzIgPSB1MzIod2lkdGgpO1xuICAgICAgdmFyIGRlcHRoMjogdTMyID0gdTMyKGRlcHRoICsgMSk7XG4gICAgICB2YXIgaGVpZ2h0MjogdTMyID0gdTMyKGhlaWdodCArIDEpO1xuICAgICAgdmFyIHdpZHRoMjogdTMyID0gdTMyKHdpZHRoICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtyLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7bX1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtyLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7YX1dKWA6XCIwXCJ9O1xuXG4gICAgICB2YXIgeDExMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgxMjE6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDEyMjogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMTI6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDIyMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIGR4MTogJHt1fSA9IGFicyhkZXB0aCAtICR7dX0oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke3V9ID0gYWJzKCR7dX0oZGVwdGgyKSAtIGRlcHRoKTtcbiAgICAgIHZhciBkeTE6ICR7dX0gPSBhYnMoaGVpZ2h0IC0gJHt1fShoZWlnaHQxKSk7XG4gICAgICB2YXIgZHkyOiAke3V9ID0gYWJzKCR7dX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHt1fSA9IGFicyh3aWR0aCAtICR7dX0od2lkdGgxKSk7XG4gICAgICB2YXIgZHoyOiAke3V9ID0gYWJzKCR7dX0od2lkdGgyKSAtIHdpZHRoKTtcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aDEgPT0gd2lkdGgyKSB7XG4gICAgICAgIGR6MSA9IDAuNTtcbiAgICAgICAgZHoyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xuICAgIH1gfSxGaD0oZSx0LHIsbixvLGkpPT57bGV0IGE9ZS5kaW1zLGQ9TWgoaSx0LmF4ZXMsYS5sZW5ndGgpLGw9UmgoYSxuLG8sdC5heGVzKSxwPW4uc2xpY2UoKTtuLmxlbmd0aD09PTAmJihwPWEubWFwKCh2LFMpPT52PT09MD8xOmxbU10vdiksdC5rZWVwQXNwZWN0UmF0aW9Qb2xpY3khPT1cInN0cmV0Y2hcIiYmKGw9VWgoYSxwLHQpKSk7bGV0IG09TShcIm91dHB1dFwiLGUuZGF0YVR5cGUsbC5sZW5ndGgpLHU9RShcImlucHV0XCIsZS5kYXRhVHlwZSxhLmxlbmd0aCksaD1DLnNpemUobCksXz1hLmxlbmd0aD09PWwubGVuZ3RoJiZhLmV2ZXJ5KCh2LFMpPT52PT09bFtTXSkseT10LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixnPXQuZXh0cmFwb2xhdGlvblZhbHVlLHg9dS50eXBlLnZhbHVlLCQ9dj0+YFxuICAgICAgJHtfP1wiXCI6YFxuICAgICAgJHtEaCh0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLHgpfTtcbiAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtXaCh1LGEpfTtcbiAgICAgICAgICAgICAgJHtCaCh0Lm5lYXJlc3RNb2RlLHIseCl9O1xuICAgICAgICAgICAgICAke1ZoKHUsbSxhLGwscC5sZW5ndGgsZC5sZW5ndGgseSl9O1xuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtOaChtLGEsbCxwLmxlbmd0aCxkLmxlbmd0aCl9O1xuICAgICAgICAgICAgICAkeygoKT0+e2lmKGEubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00KXJldHVybmAke0xoKHUsbSxhLHksZyl9YDtpZihhLmxlbmd0aD09PTN8fGEubGVuZ3RoPT09NSlyZXR1cm5gJHtIaCh1LG0sYSx5LGcpfWA7dGhyb3cgRXJyb3IoXCJMaW5lYXIgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiwgMywgNCBhbmQgNSBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xuICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcbiAgICAgICAgICAgICR7KCgpPT57aWYoYS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTQpcmV0dXJuYCR7R2godSxtLGEsbCxwLGQsdC5jdWJpY0NvZWZmQSx5LHQuZXh0cmFwb2xhdGlvblZhbHVlLHQuZXhjbHVkZU91dHNpZGUpfWA7dGhyb3cgRXJyb3IoXCJDdWJpYyBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyIGFuZCA0IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc2l6ZSBtb2RlXCIpfX0pKCl9O1xuICAgICAgYH1cbiAgICAgICR7di5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNjYWxlc1wiLFwiZjMyXCIscC5sZW5ndGgpLnJlZ2lzdGVyVW5pZm9ybShcInJvaVwiLFwiZjMyXCIsZC5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXModSxtKX1cbiAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgJHtfP1wib3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XCI6YFxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke3UudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dC5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVybmBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2EubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00P1wiYmlsaW5lYXJJbnRlcnBvbGF0aW9uXCI6XCJ0cmlsaW5lYXJJbnRlcnBvbGF0aW9uXCJ9KG91dHB1dF9pbmRpY2VzKTtgO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xuYH1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmVzaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtyfXwke3AubGVuZ3RoPjA/cDpcIlwifXwke28ubGVuZ3RoPjA/bzpcIlwifXwke2QubGVuZ3RoPjA/ZDpcIlwifXwke199fCR7YX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTokLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpofSx7dHlwZToxLGRhdGE6cH0se3R5cGU6MSxkYXRhOmR9LC4uLk4oYSxsKV19KX19LHFoPWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sUGw9KGUsdCk9PntsZXQgcj1bXSxuPVtdLG89W10saT1xaChlKTtpZih0LmFudGlhbGlhcyE9PTApdGhyb3cgRXJyb3IoXCJPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZFwiKTtPaChlLmlucHV0cyx0LGkscixuLG8pLGUuY29tcHV0ZShGaChlLmlucHV0c1swXSx0LGkscixuLG8pLHtpbnB1dHM6WzBdfSl9LHpsPWU9PntsZXQgdD1lLmFudGlhbGlhcyxyPWUuYXhlcyxuPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsbz1lLmN1YmljQ29lZmZBLGk9ZS5leGNsdWRlT3V0c2lkZSE9PTAsYT1lLmV4dHJhcG9sYXRpb25WYWx1ZSxkPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LGw9ZS5tb2RlLHA9ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiByZSh7YW50aWFsaWFzOnQsYXhlczpyLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOm4sY3ViaWNDb2VmZkE6byxleGNsdWRlT3V0c2lkZTppLGV4dHJhcG9sYXRpb25WYWx1ZTphLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpkLG1vZGU6bCxuZWFyZXN0TW9kZTpwfSl9fSk7dmFyIEtoLGpoLERsLEJsPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO0toPShlLHQpPT57bGV0W3IsbixvLGldPWUse251bUhlYWRzOmEscm90YXJ5RW1iZWRkaW5nRGltOmR9PXQ7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3gnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMsIGdvdCAke3IuZGltcy5sZW5ndGh9YCk7aWYoIUMuYXJlRXF1YWwobi5kaW1zLFtdKSYmIUMuYXJlRXF1YWwobi5kaW1zLFsxXSkmJm4uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAwLCAxLCBvciAyIGRpbWVuc2lvbnMsIGdvdCAke24uZGltcy5sZW5ndGh9YCk7aWYoby5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7by5kaW1zLmxlbmd0aH1gKTtpZihpLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdzaW5fY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtpLmRpbXMubGVuZ3RofWApO2lmKCFDLmFyZUVxdWFsKG8uZGltcyxpLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIklucHV0cyAnY29zX2NhY2hlJyBhbmQgJ3Npbl9jYWNoZScgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7aWYoZD4wJiZhPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJudW1faGVhZHMgbXVzdCBiZSBwcm92aWRlZCBpZiByb3RhcnlfZW1iZWRkaW5nX2RpbSBpcyBzcGVjaWZpZWRcIik7bGV0IGw9ci5kaW1zWzBdLHA9ci5kaW1zW3IuZGltcy5sZW5ndGgtMl0sbT1vLmRpbXNbMF0sdT1DLnNpemVGcm9tRGltZW5zaW9uKHIuZGltcywxKS9wLGg9ZD09PTA/by5kaW1zWzFdKjI6dS9hO2lmKGQ+aCl0aHJvdyBuZXcgRXJyb3IoXCJyb3RhcnlfZW1iZWRkaW5nX2RpbSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBoZWFkX3NpemVcIik7aWYobi5kaW1zLmxlbmd0aD09PTIpe2lmKGwhPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtuLmRpbXNbMF19YCk7aWYocCE9PW4uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBvZiBzaXplIHNlcXVlbmNlX2xlbmd0aCwgZ290ICR7bi5kaW1zWzFdfWApfWlmKGgvMiE9PW8uZGltc1sxXSYmZC8yIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgZGltZW5zaW9uIDEgc2hvdWxkIGJlIHNhbWUgYXMgaGVhZF9zaXplIC8gMiBvciByb3RhcnlfZW1iZWRkaW5nX2RpbSAvIDIsIGdvdCAke28uZGltc1sxXX1gKTtpZihwPm0pdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW4gUm90YXJ5RW1iZWRkaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkXCIpfSxqaD0oZSx0KT0+e2xldHtpbnRlcmxlYXZlZDpyLG51bUhlYWRzOm4scm90YXJ5RW1iZWRkaW5nRGltOm8sc2NhbGU6aX09dCxhPWVbMF0uZGltc1swXSxkPUMuc2l6ZUZyb21EaW1lbnNpb24oZVswXS5kaW1zLDEpLGw9ZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMl0scD1kL2wsbT1lWzJdLmRpbXNbMV0sdT1vPT09MD9tKjI6cC9uLGg9bmV3IEFycmF5KGEsbCxwL3UsdS1tKSxfPUMuY29tcHV0ZVN0cmlkZXMoaCkseT1be3R5cGU6MSxkYXRhOml9LHt0eXBlOjEyLGRhdGE6aH0se3R5cGU6MTIsZGF0YTpffSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09Mz9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbZCxwLHUsMV19KTpbXSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09ND9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbZCx1LGwqdSwxXX0pOltdLC4uLk4oZVswXS5kaW1zLGVbMV0uZGltcyxlWzJdLmRpbXMsZVszXS5kaW1zLGVbMF0uZGltcyldLGc9eD0+e2xldCAkPUUoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksdj1FKFwicG9zaXRpb25faWRzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxTPUUoXCJjb3NfY2FjaGVcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLFQ9RShcInNpbl9jYWNoZVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCksQT1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKTtyZXR1cm4geC5yZWdpc3RlclVuaWZvcm1zKFt7bmFtZTpcInNjYWxlXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImdsb2JhbF9zaGFwZVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6aC5sZW5ndGh9LHtuYW1lOlwiZ2xvYmFsX3N0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOl8ubGVuZ3RofSx7bmFtZTpcImlucHV0X291dHB1dF9zdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpfLmxlbmd0aH1dKSxgXG4gICAgICAgICR7eC5kZWNsYXJlVmFyaWFibGVzKCQsdixTLFQsQSl9XG5cbiAgICAgICAgJHt4Lm1haW5TdGFydChrdCl9XG4gICAgICAgICAgbGV0IGhhbGZfcm90YXJ5X2VtYl9kaW0gPSB1bmlmb3Jtcy4ke1MubmFtZX1fc2hhcGVbMV07XG4gICAgICAgICAgbGV0IGJzbmggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXMgJSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGU7XG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcbiAgICAgICAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInNpemVcIil9XG5cbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cbiAgICAgICAgICAgICAgICAke3YuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJic25oLnh5XCIsTShcIlwiLHYudHlwZS50ZW5zb3IsMikpfTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZCA9XG4gICAgICAgICAgICAgICAgdTMyKCR7di5nZXRCeU9mZnNldChcInBvc2l0aW9uX2lkc19pZHhcIil9KSArIHNlbGVjdCgwLCBic25oWzFdLCBwb3NpdGlvbl9pZHNfaWR4ID09IDApO1xuICAgICAgICAgICAgbGV0IGkgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgc2VsZWN0KDAsIGJzbmhbM10sICR7cn0pO1xuICAgICAgICAgICAgbGV0IGogPSBpICsgc2VsZWN0KGhhbGZfcm90YXJ5X2VtYl9kaW0sIDEsICR7cn0pO1xuICAgICAgICAgICAgbGV0IHJlID0gJHskLmdldEJ5T2Zmc2V0KFwiaVwiKX0gKiAke1MuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9IC1cbiAgICAgICAgICAgICAgICAkeyQuZ2V0QnlPZmZzZXQoXCJqXCIpfSAqICR7VC5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJpXCIsXCJyZVwiKX1cbiAgICAgICAgICAgIGxldCBpbSA9ICR7JC5nZXRCeU9mZnNldChcImlcIil9ICogJHtULmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfSArXG4gICAgICAgICAgICAgICAgJHskLmdldEJ5T2Zmc2V0KFwialwiKX0gKiAke1MuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9O1xuICAgICAgICAgICAgJHtBLnNldEJ5T2Zmc2V0KFwialwiLFwiaW1cIil9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIGhhbGZfcm90YXJ5X2VtYl9kaW07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJrXCIsJC5nZXRCeU9mZnNldChcImtcIikpfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiUm90YXJ5RW1iZWRkaW5nXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6cmUoe2ludGVybGVhdmVkOnJ9KS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6ZyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmVbMF0uZGltcyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoQy5zaXplKGgpL2t0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KX19LERsPShlLHQpPT57S2goZS5pbnB1dHMsdCksZS5jb21wdXRlKGpoKGUuaW5wdXRzLHQpKX19KTt2YXIgWWgsWmgsTWwsUmw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO1loPWU9PntpZighZXx8ZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuXCIpO2xldCB0PWVbMF0scj1lWzFdLG49ZVsyXTtpZih0LmRhdGFUeXBlIT09ci5kYXRhVHlwZXx8dC5kYXRhVHlwZSE9PW4uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlXCIpO2lmKHQuZGltcy5sZW5ndGghPT0zJiZ0LmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIDJEIG9yIDNEXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgYmUgMkQgb3IgM0RcIik7bGV0IG89dC5kaW1zW3QuZGltcy5sZW5ndGgtMV0saT10LmRpbXNbdC5kaW1zLmxlbmd0aC0yXTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMl0hPT1pKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dFwiKTtpZihuLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGJlIDFEXCIpO2lmKG4uZGltc1tuLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoZS5sZW5ndGg+Myl7bGV0IGE9ZVszXTtpZihhLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgYmUgMURcIik7aWYoYS5kaW1zW2EuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfWlmKGUubGVuZ3RoPjQpe2xldCBhPWVbNF07aWYoYS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGJlIDFEXCIpO2lmKGEuZGltc1thLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX19LFpoPShlLHQscixuKT0+e2xldCBvPXQuc2ltcGxpZmllZCxpPWVbMF0uZGltcyxhPUMuc2l6ZShpKSxkPWksbD1hLHA9aS5zbGljZSgtMSlbMF0sbT1uP2kuc2xpY2UoMCwtMSkuY29uY2F0KDEpOltdLHU9IW8mJmUubGVuZ3RoPjMsaD1lLmxlbmd0aD40LF89biYmcj4xLHk9biYmcj4yLGc9cj4zLHg9NjQsJD1tZShwKSx2PVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV0sUz1BPT57bGV0IGs9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiY29tcG9uZW50c1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV0sUD1bRShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcywkKSxFKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLCQpLEUoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLCQpXTt1JiZQLnB1c2goRShcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcywkKSksaCYmUC5wdXNoKEUoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsJCkpLFAucHVzaChNKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLCQpKSxfJiZQLnB1c2goTShcIm1lYW5fb3V0cHV0XCIsMSxtKSkseSYmUC5wdXNoKE0oXCJpbnZfc3RkX291dHB1dFwiLDEsbSkpLGcmJlAucHVzaChNKFwiaW5wdXRfc2tpcF9iaWFzX3N1bVwiLGVbMF0uZGF0YVR5cGUsZCwkKSk7bGV0IEQ9X2UoZVswXS5kYXRhVHlwZSksUj1fZSgxLCQpO3JldHVybmBcblxuICAgICAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoaykuZGVjbGFyZVZhcmlhYmxlcyguLi5QKX1cbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zaGFyZWQgOiBhcnJheTwke1J9LCAke3h9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7Un0sICR7eH0+O1xuXG4gICAgICAke0EubWFpblN0YXJ0KFt4LDEsMV0pfVxuICAgICAgICBsZXQgaXggPSBsb2NhbF9pZC54O1xuICAgICAgICBsZXQgaXkgPSBnbG9iYWxfaWQueCAvICR7eH07XG5cbiAgICAgICAgbGV0IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ6IHUzMiA9IHVuaWZvcm1zLmhpZGRlbl9zaXplIC8gdW5pZm9ybXMuY29tcG9uZW50cztcbiAgICAgICAgdmFyIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLyAke3h9O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gaXggKiBzdHJpZGUgKyBpeSAqIGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgICAgIGxldCBvZmZzZXQxZCA9IHN0cmlkZSAqIGl4O1xuICAgICAgICBpZiAoaXggPT0gJHt4LTF9KSB7XG4gICAgICAgICAgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAtIHN0cmlkZSAqIGl4O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIGxldCBza2lwX3ZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7aD9cImJpYXNbb2Zmc2V0MWQgKyBpXVwiOkQrXCIoMC4wKVwifTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtnP1wiaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7RXQoRCwkLFwidmFsdWVcIil9O1xuICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZTtcbiAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZSAqIGYzMl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZV9zaXplIDogdTMyID0gJHt4fTtcbiAgICAgICAgZm9yICh2YXIgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMTsgIGN1cnJfc2l6ZSA+IDA7IGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2Vfc2l6ZSA9IGN1cnJfc2l6ZSArIChyZWR1Y2Vfc2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChpeCA8IGN1cnJfc2l6ZSkge1xuICAgICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gc3VtX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gc3VtX3NxdWFyZWRfc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gc3VtX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IHNxdWFyZV9zdW0gPSBzdW1fc3F1YXJlZF9zaGFyZWRbMF07XG4gICAgICAgIGxldCBtZWFuID0gJHtGZShcInN1bVwiLCQpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSk7XG4gICAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7RmUoXCJzcXVhcmVfc3VtXCIsJCl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKSAke28/XCJcIjpcIi0gbWVhbiAqIG1lYW5cIn0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtfP1wibWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XG4gICAgICAgICR7eT9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7XCI6XCJcIn1cblxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldICR7bz9cIlwiOmAtICR7RH0obWVhbilgfSkgKlxuICAgICAgICAgICAgJHtEfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke3U/XCIrIGJldGFbb2Zmc2V0MWQgKyBpXVwiOlwiXCJ9O1xuICAgICAgICB9XG4gICAgICB9YH0sVD1be2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIHI+MSYmVC5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MiYmVC5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MyYmVC5wdXNoKHtkaW1zOmksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pLHtuYW1lOlwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAkeyR9OyR7X307JHt5fTske2d9YCxpbnB1dERlcGVuZGVuY2llczplLm1hcCgoQSxrKT0+XCJ0eXBlXCIpfSxnZXRTaGFkZXJTb3VyY2U6UyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsL3ApfSxwcm9ncmFtVW5pZm9ybXM6dn0pfX0sTWw9KGUsdCk9PntZaChlLmlucHV0cyk7bGV0IG49WzBdO2Uub3V0cHV0Q291bnQ+MSYmbi5wdXNoKC0zKSxlLm91dHB1dENvdW50PjImJm4ucHVzaCgtMyksZS5vdXRwdXRDb3VudD4zJiZuLnB1c2goMyksZS5jb21wdXRlKFpoKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCwhMSkse291dHB1dHM6bn0pfX0pO3ZhciBRaCxybixYaCxVbCxKaCxlZyxObCxWbCxXbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtRaD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2lmKHQuYXhlcy5sZW5ndGghPT0wKXtpZih0LmF4ZXMubGVuZ3RoIT09dC5zdGFydHMubGVuZ3RofHx0LmF4ZXMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKX1lbHNlIGlmKHQuc3RhcnRzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7ZS5zbGljZSgxKS5mb3JFYWNoKChyLG4pPT57aWYoZVtuKzFdLmRhdGFUeXBlIT09NiYmZVtuKzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7bn0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApfSl9LHJuPShlLHQpPT57bGV0IHI9W107aWYoZS5sZW5ndGg+dClpZihlW3RdLmRhdGFUeXBlPT09NyllW3RdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKTtlbHNlIGlmKGVbdF0uZGF0YVR5cGU9PT02KWVbdF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtyZXR1cm4gcn0sWGg9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1ybihlLDEpLG49cm4oZSwyKSxvPXJuKGUsMyk7cmV0dXJuIG8ubGVuZ3RoPT09MCYmKG89Wy4uLkFycmF5KGVbMF0uZGltcy5sZW5ndGgpLmtleXMoKV0pLHJlKHtzdGFydHM6cixlbmRzOm4sYXhlczpvfSl9ZWxzZSByZXR1cm4gdH0sVWw9KGUsdCxyLG4sbyk9PntsZXQgaT1lO3JldHVybiBlPDAmJihpKz1yW25bdF1dKSxvW3RdPDA/TWF0aC5tYXgoMCxNYXRoLm1pbihpLHJbblt0XV0tMSkpOk1hdGgubWF4KDAsTWF0aC5taW4oaSxyW25bdF1dKSl9LEpoPShlLHQscik9PmBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke3IubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtGKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke0YoXCJ1bmlmb3Jtcy5zdGVwc1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7RihcInVuaWZvcm1zLnNpZ25zXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7RihcInVuaWZvcm1zLnN0YXJ0c1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXggKiBzdGVwc19pICsgc3RhcnRzX2kgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRfaW5kZXggLyBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9pbmRleCAlIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpZiAoc2lnbnNfaSA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gaW5wdXRfaW5kZXggLSAxdSArIHN0YXJ0c19pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgICAgfWAsZWc9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1DLnNpemUociksbz10LmF4ZXMubGVuZ3RoPjA/Qy5ub3JtYWxpemVBeGVzKHQuYXhlcyxyLmxlbmd0aCk6Wy4uLkFycmF5KHIubGVuZ3RoKS5rZXlzKCldLGk9cm4oZSw0KTtpLmZvckVhY2goJD0+JCE9PTB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIDBcIil9KSksaS5sZW5ndGg9PT0wJiYoaT1BcnJheShvLmxlbmd0aCkuZmlsbCgxKSk7bGV0IGE9dC5zdGFydHMubWFwKCgkLHYpPT5VbCgkLHYscixvLGkpKSxkPXQuZW5kcy5tYXAoKCQsdik9PlVsKCQsdixyLG8saSkpO2lmKG8ubGVuZ3RoIT09YS5sZW5ndGh8fG8ubGVuZ3RoIT09ZC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXCIpO2lmKG8ubGVuZ3RoIT09ci5sZW5ndGgpZm9yKGxldCAkPTA7JDxyLmxlbmd0aDsrKyQpby5pbmNsdWRlcygkKXx8KGEuc3BsaWNlKCQsMCwwKSxkLnNwbGljZSgkLDAsclskXSksaS5zcGxpY2UoJCwwLDEpKTtsZXQgbD1pLm1hcCgkPT5NYXRoLnNpZ24oJCkpO2kuZm9yRWFjaCgoJCx2LFMpPT57aWYoJDwwKXtsZXQgVD0oZFt2XS1hW3ZdKS8kLEE9YVt2XSxrPUErVCppW3ZdO2Fbdl09ayxkW3ZdPUEsU1t2XT0tJH19KTtsZXQgcD1yLnNsaWNlKDApO28uZm9yRWFjaCgoJCx2KT0+e3BbJF09TWF0aC5jZWlsKChkWyRdLWFbJF0pL2lbJF0pfSk7bGV0IG09e2RpbXM6cCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSx1PU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHAubGVuZ3RoKSxoPUUoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksXz1DLnNpemUocCkseT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0c1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6YS5sZW5ndGh9LHtuYW1lOlwic2lnbnNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOmwubGVuZ3RofSx7bmFtZTpcInN0ZXBzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDppLmxlbmd0aH1dLGc9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTphfSx7dHlwZTo2LGRhdGE6bH0se3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxwKV0seD0kPT5gXG4gICAgICAkeyQucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKGgsdSl9XG4gICAgICAgICR7SmgoaCx1LHIpfVxuICAgICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7dS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICBsZXQgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgJHt1LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGguZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bC5sZW5ndGh9XyR7YS5sZW5ndGh9XyR7aS5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6eCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W21dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfSxwcm9ncmFtVW5pZm9ybXM6Z30pfX0sTmw9KGUsdCk9PntRaChlLmlucHV0cyx0KTtsZXQgcj1YaChlLmlucHV0cyx0KTtlLmNvbXB1dGUoZWcoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sVmw9ZT0+e2xldCB0PWUuc3RhcnRzLHI9ZS5lbmRzLG49ZS5heGVzO3JldHVybiByZSh7c3RhcnRzOnQsZW5kczpyLGF4ZXM6bn0pfX0pO3ZhciB0ZyxyZyxMbCxHbCxIbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7ZHQoKTthZSgpO3RnPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC5cIil9LHJnPShlLHQpPT57bGV0IHI9ZS5pbnB1dHNbMF0sbj1yLmRpbXMsbz1DLnNpemUobiksaT1uLmxlbmd0aCxhPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsaSksZD1hPG4ubGVuZ3RoLTEsbCxwPVtdO2Q/KHA9QXJyYXkuZnJvbSh7bGVuZ3RoOml9LChQLEQpPT5EKSxwW2FdPWktMSxwW2ktMV09YSxsPWUuY29tcHV0ZShQZShyLHApLHtpbnB1dHM6W3JdLG91dHB1dHM6Wy0xXX0pWzBdKTpsPXI7bGV0IG09bC5kaW1zLHU9bVtpLTFdLGg9by91LF89bWUodSkseT11L18sZz02NDtoPT09MSYmKGc9MjU2KTtsZXQgeD0oUCxEKT0+RD09PTQ/YG1heChtYXgoJHtQfS54LCAke1B9LnkpLCBtYXgoJHtQfS56LCAke1B9LncpKWA6RD09PTI/YG1heCgke1B9LngsICR7UH0ueSlgOkQ9PT0zP2BtYXgobWF4KCR7UH0ueCwgJHtQfS55KSwgJHtQfS56KWA6UCwkPUUoXCJ4XCIsbC5kYXRhVHlwZSxsLmRpbXMsXyksdj1NKFwicmVzdWx0XCIsbC5kYXRhVHlwZSxsLmRpbXMsXyksUz0kLnR5cGUudmFsdWUsVD1fZShsLmRhdGFUeXBlKT09PVwiZjMyXCI/YHZhciB0aHJlYWRNYXggPSAke1N9KC0zLjQwMjgyM2UrMzhmKTtgOmB2YXIgdGhyZWFkTWF4ID0gJHtTfSgtNjU1MDQuMGgpO2AsQT1QPT5gXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke1N9O1xuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHtTfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7U30sICR7Z30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHtTfSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke1N9KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgICR7UC5yZWdpc3RlclVuaWZvcm0oXCJwYWNrZWRDb2xzXCIsXCJpMzJcIikuZGVjbGFyZVZhcmlhYmxlcygkLHYpfVxuICAgICAgJHtQLm1haW5TdGFydChnKX1cbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWR4KTtcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZHgpO1xuICAgICAgICBjb25zdCB3ZyA9ICR7Z307XG4gICAgICAgIGxldCByb3cgPSBnaW5kZXggLyB3ZztcbiAgICAgICAgbGV0IGNvbHMgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuICAgICAgICBsZXQgcm93X3N0cmlkZSA6IGkzMiA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBtYXhcbiAgICAgICAgJHtUfVxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKTtcbiAgICAgICAgICB0aHJlYWRNYXggPSBtYXgodGhyZWFkTWF4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA8IGNvbHMpIHtcbiAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZE1heDtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oY29scywgd2cpO1xuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2VTaXplID0gY3VyclNpemUgKyAocmVkdWNlU2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSBtYXgodGhyZWFkU2hhcmVkW2xpbmRleF0sIHRocmVhZFNoYXJlZFtsaW5kZXggKyByZWR1Y2VTaXplXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dNYXhTaGFyZWQgPSAke1N9KCR7eChcInRocmVhZFNoYXJlZFswXVwiLF8pfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3Mgc3VtXG4gICAgICAgIHZhciB0aHJlYWRTdW0gPSAke1N9KDAuMCk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xuICAgICAgICAgIHRocmVhZFN1bSArPSBzdWJFeHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dTdW1TaGFyZWQgPSAke1N9KCR7RmUoXCJ0aHJlYWRTaGFyZWRbMF1cIixfKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWAsaz1lLmNvbXB1dGUoe25hbWU6XCJTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7X307JHtnfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczptLGRhdGFUeXBlOmwuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Omh9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6NixkYXRhOnl9XX0pLGdldFNoYWRlclNvdXJjZTpBfSx7aW5wdXRzOltsXSxvdXRwdXRzOltkPy0xOjBdfSlbMF07ZCYmZS5jb21wdXRlKFBlKGsscCkse2lucHV0czpba119KX0sTGw9KGUsdCk9Pnt0ZyhlLmlucHV0cykscmcoZSx0KX0sR2w9ZT0+cmUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgRmwsbmcsb2csaWcscWwsS2w9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0ZsPWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxuZz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwJiZlWzBdLmRhdGFUeXBlIT09NiYmZVswXS5kYXRhVHlwZSE9PTEyKXRocm93IG5ldyBFcnJvcihcIlRpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBmbG9hdDE2LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzXCIpO2lmKGVbMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGVcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRFwiKTtpZihGbChlWzFdKS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3JcIil9LG9nPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pci5wdXNoKGVbbl0qdFtuXSk7cmV0dXJuIHJ9LGlnPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49dD8/RmwoZVsxXSksbz1vZyhyLG4pLGk9Qy5zaXplKG8pLGE9ZVswXS5kYXRhVHlwZSxkPUUoXCJpbnB1dFwiLGEsci5sZW5ndGgpLGw9TShcIm91dHB1dFwiLGEsby5sZW5ndGgpLHA9bT0+YFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7ZC5pbmRpY2VzKC4uLnIpfTtcbiAgICAgICR7bS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZCxsKX1cbiAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtkLnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHtkLmluZGljZXNHZXQoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke2wuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfSAgJSBpbnB1dF9kaW1faTtcblxuICAgICAgICAke2QuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2RpbV92YWx1ZVwiKX1cbiAgICAgIH1cbiAgICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixkLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6aX0sLi4uTihlWzBdLmRpbXMsbyldfSksZ2V0U2hhZGVyU291cmNlOnB9fSxxbD1lPT57bmcoZS5pbnB1dHMpLGUuY29tcHV0ZShpZyhlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgYWcsc2csamwsWWw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO2FnPShlLHQscixuLG8pPT57bGV0IGk9TShcIm91dHB1dF9kYXRhXCIsbyxyLmxlbmd0aCw0KSxhPUUoXCJhX2RhdGFcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcy5sZW5ndGgsNCksZD1FKFwiYl9kYXRhXCIsdFsyXS5kYXRhVHlwZSx0WzJdLmRpbXMubGVuZ3RoLDQpLGw9RShcImNfZGF0YVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLmxlbmd0aCw0KSxwLG09KHUsaCxfKT0+YHNlbGVjdCgke2h9LCAke3V9LCAke199KWA7aWYoIW4pcD1pLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLG0oYS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksbC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2xldCB1PShoLF8seT1cIlwiKT0+e2xldCBnPWBhX2RhdGFbaW5kZXhfYSR7X31dW2NvbXBvbmVudF9hJHtffV1gLHg9YGJfZGF0YVtpbmRleF9iJHtffV1bY29tcG9uZW50X2Ike199XWAsJD1gYm9vbChjX2RhdGFbaW5kZXhfYyR7X31dICYgKDB4ZmZ1IDw8IChjb21wb25lbnRfYyR7X30gKiA4KSkpYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke199ID0gJHtpLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtffXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Eke199ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7X30gPSAke2QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsaSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHtffSA9ICR7bC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxpKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhfYSR7X30gPSBvZmZzZXRfYSR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHtffSA9IG9mZnNldF9iJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Mke199ID0gb2Zmc2V0X2Mke199IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Eke199ID0gb2Zmc2V0X2Eke199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike199ID0gb2Zmc2V0X2Ike199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Mke199ID0gb2Zmc2V0X2Mke199ICUgNHU7XG4gICAgICAgICAgICAke2h9WyR7X31dID0gJHt5fSgke20oZyx4LCQpfSk7XG4gICAgICAgICAgYH07bz09PTk/cD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dShcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt1KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3UoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dShcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDpwPWBcbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke3UoXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt1KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobCxhLGQsaSl9XG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHtwfVxuICAgICAgfWB9LHNnPWU9PntsZXQgdD1lWzFdLmRpbXMscj1lWzJdLmRpbXMsbj1lWzBdLmRpbXMsbz1lWzFdLmRhdGFUeXBlLGk9IShDLmFyZUVxdWFsKHQscikmJkMuYXJlRXF1YWwocixuKSksYT10LGQ9Qy5zaXplKHQpO2lmKGkpe2xldCBwPXR0LmNhbGNTaGFwZSh0dC5jYWxjU2hhcGUodCxyLCExKSxuLCExKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2E9cCxkPUMuc2l6ZShhKX1sZXQgbD1NYXRoLmNlaWwoZC80KTtyZXR1cm57bmFtZTpcIldoZXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpwPT5hZyhwLGUsYSxpLG8pLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmx9LC4uLk4obix0LHIsYSldfSl9fSxqbD1lPT57ZS5jb21wdXRlKHNnKGUuaW5wdXRzKSl9fSk7dmFyIFpsLFFsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtQcygpO0ZyKCk7RHMoKTtNcygpO3Z1KCk7enUoKTtCdSgpO1F1KCk7b2QoKTtzZCgpO2xkKCk7aGQoKTt5ZCgpO3dkKCk7eGQoKTtJZCgpO2tkKCk7emQoKTtCZCgpO1VkKCk7cWQoKTtZZCgpO1FkKCk7SmQoKTtybCgpO1NvKCk7b2woKTt2bCgpO1NsKCk7SWwoKTtrbCgpO0dyKCk7T2woKTtCbCgpO1JsKCk7V2woKTtIbCgpO0lvKCk7S2woKTtkdCgpO0tyKCk7WWwoKTtabD1uZXcgTWFwKFtbXCJBYnNcIixbUnNdXSxbXCJBY29zXCIsW1VzXV0sW1wiQWNvc2hcIixbTnNdXSxbXCJBZGRcIixbJHVdXSxbXCJBcmdNYXhcIixbRXMsY29dXSxbXCJBcmdNaW5cIixba3MsY29dXSxbXCJBc2luXCIsW1ZzXV0sW1wiQXNpbmhcIixbV3NdXSxbXCJBdGFuXCIsW0xzXV0sW1wiQXRhbmhcIixbR3NdXSxbXCJBdHRlbnRpb25cIixbenNdXSxbXCJBdmVyYWdlUG9vbFwiLFtwbCxjbF1dLFtcIkJhdGNoTm9ybWFsaXphdGlvblwiLFtPc11dLFtcIkJpYXNBZGRcIixbQnNdXSxbXCJCaWFzU3BsaXRHZWx1XCIsW3d1XV0sW1wiQ2FzdFwiLFtGcyxIc11dLFtcIkNlaWxcIixbS3NdXSxbXCJDbGlwXCIsW3FzXV0sW1wiQ29uY2F0XCIsW091LER1XV0sW1wiQ29udlwiLFt3byxfb11dLFtcIkNvbnZUcmFuc3Bvc2VcIixbbmQsdGRdXSxbXCJDb3NcIixbanNdXSxbXCJDb3NoXCIsW1lzXV0sW1wiQ3VtU3VtXCIsW2lkLGFkXV0sW1wiRGVwdGhUb1NwYWNlXCIsW3VkLGRkXV0sW1wiRGVxdWFudGl6ZUxpbmVhclwiLFskbCx4bF1dLFtcIkRpdlwiLFt4dV1dLFtcIkVpbnN1bVwiLFttZCxmZF1dLFtcIkVsdVwiLFtacyxYdF1dLFtcIkVxdWFsXCIsW1N1XV0sW1wiRXJmXCIsW1FzXV0sW1wiRXhwXCIsW1hzXV0sW1wiRXhwYW5kXCIsW2JkXV0sW1wiRmFzdEdlbHVcIixbX2RdXSxbXCJGbG9vclwiLFtKc11dLFtcIkZ1c2VkQ29udlwiLFt3byxfb11dLFtcIkdhdGhlclwiLFskZCx2ZF1dLFtcIkdhdGhlckVsZW1lbnRzXCIsW1BkLEVkXV0sW1wiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixbQ2QsQWRdXSxbXCJHYXRoZXJORFwiLFtTZCxUZF1dLFtcIkdlbHVcIixbZXVdXSxbXCJHZW1tXCIsW0RkLE9kXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbaGwsZmxdXSxbXCJHbG9iYWxNYXhQb29sXCIsW3dsLF9sXV0sW1wiR3JlYXRlclwiLFtBdV1dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW0V1XV0sW1wiR3JpZFNhbXBsZVwiLFtNZCxSZF1dLFtcIkdyb3VwUXVlcnlBdHRlbnRpb25cIixbRmRdXSxbXCJIYXJkU2lnbW9pZFwiLFt1dSxzdV1dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFtqZF1dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtaZF1dLFtcIkxlYWt5UmVsdVwiLFt0dSxYdF1dLFtcIkxlc3NcIixba3VdXSxbXCJMZXNzT3JFcXVhbFwiLFtQdV1dLFtcIkxvZ1wiLFtidV1dLFtcIk1hdE11bFwiLFtYZF1dLFtcIk1hdE11bE5CaXRzXCIsW2VsLHRsXV0sW1wiTWF4UG9vbFwiLFtibCx5bF1dLFtcIk11bFwiLFtUdV1dLFtcIk11bHRpSGVhZEF0dGVudGlvblwiLFtXZCxWZF1dLFtcIk5lZ1wiLFtudV1dLFtcIk5vdFwiLFtydV1dLFtcIlBhZFwiLFtubF1dLFtcIlBvd1wiLFtJdV1dLFtcIlF1aWNrR2VsdVwiLFt5dSxYdF1dLFtcIlJhbmdlXCIsW1RsXV0sW1wiUmVjaXByb2NhbFwiLFtvdV1dLFtcIlJlZHVjZU1pblwiLFt4c11dLFtcIlJlZHVjZU1lYW5cIixbeXNdXSxbXCJSZWR1Y2VNYXhcIixbJHNdXSxbXCJSZWR1Y2VTdW1cIixbVHNdXSxbXCJSZWR1Y2VQcm9kXCIsW1NzXV0sW1wiUmVkdWNlTDFcIixbX3NdXSxbXCJSZWR1Y2VMMlwiLFt3c11dLFtcIlJlZHVjZUxvZ1N1bVwiLFtDc11dLFtcIlJlZHVjZUxvZ1N1bUV4cFwiLFt2c11dLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFtJc11dLFtcIlJlbHVcIixbaXVdXSxbXCJSZXNpemVcIixbUGwsemxdXSxbXCJSb3RhcnlFbWJlZGRpbmdcIixbRGxdXSxbXCJTY2F0dGVyTkRcIixbQWwsQ2xdXSxbXCJTaWdtb2lkXCIsW2F1XV0sW1wiU2luXCIsW2R1XV0sW1wiU2luaFwiLFtsdV1dLFtcIlNsaWNlXCIsW05sLFZsXV0sW1wiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLFtNbF1dLFtcIlNwbGl0XCIsW0xkLEdkXV0sW1wiU3FydFwiLFtjdV1dLFtcIlNvZnRtYXhcIixbTGwsR2xdXSxbXCJTdWJcIixbQ3VdXSxbXCJUYW5cIixbcHVdXSxbXCJUYW5oXCIsW2Z1XV0sW1wiVGhyZXNob2xkZWRSZWx1XCIsW2d1LFh0XV0sW1wiVGlsZVwiLFtxbF1dLFtcIlRyYW5zcG9zZVwiLFtpcyxhc11dLFtcIldoZXJlXCIsW2psXV1dKX0pO3ZhciBubixYbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2UoKTtldCgpO2FlKCk7bm49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxyKXt0aGlzLnJlcG8uc2V0KHQscil9cnVuKHQscixuLG8saSl7VWUodC5wcm9ncmFtSW5mby5uYW1lKTtsZXQgYT10aGlzLmJhY2tlbmQuZGV2aWNlLGQ9dGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO3RoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpO2xldCBsPVtdO2ZvcihsZXQgbSBvZiByKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOm0uYnVmZmVyfX0pO2ZvcihsZXQgbSBvZiBuKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOm0uYnVmZmVyfX0pO2kmJmwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTppfSk7bGV0IHA9YS5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDp0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczpsLGxhYmVsOnQucHJvZ3JhbUluZm8ubmFtZX0pO2lmKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIil7bGV0IG09e2tlcm5lbElkOnRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQsY29tcHV0ZVBpcGVsaW5lOnQuY29tcHV0ZVBpcGVsaW5lLGJpbmRHcm91cDpwLGRpc3BhdGNoR3JvdXA6b307dGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKS5wdXNoKG0pfWQuc2V0UGlwZWxpbmUodC5jb21wdXRlUGlwZWxpbmUpLGQuc2V0QmluZEdyb3VwKDAscCksZC5kaXNwYXRjaFdvcmtncm91cHMoLi4ubyksdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5iYWNrZW5kLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCIpJiZ0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXImJnRoaXMuYmFja2VuZC5mbHVzaCgpLERlKHQucHJvZ3JhbUluZm8ubmFtZSl9ZGlzcG9zZSgpe31idWlsZCh0LHIpe1VlKHQubmFtZSk7bGV0IG49dGhpcy5iYWNrZW5kLmRldmljZSxvPVtdO1t7ZmVhdHVyZTpcInNoYWRlci1mMTZcIixleHRlbnNpb246XCJmMTZcIn0se2ZlYXR1cmU6XCJzdWJncm91cHNcIixleHRlbnNpb246XCJzdWJncm91cHNcIn0se2ZlYXR1cmU6XCJzdWJncm91cHMtZjE2XCIsZXh0ZW5zaW9uOlwic3ViZ3JvdXBzX2YxNlwifV0uZm9yRWFjaCh1PT57bi5mZWF0dXJlcy5oYXModS5mZWF0dXJlKSYmby5wdXNoKGBlbmFibGUgJHt1LmV4dGVuc2lvbn07YCl9KTtsZXQgYT1ucyhyLHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKSxkPXQuZ2V0U2hhZGVyU291cmNlKGEpLGw9YCR7by5qb2luKGBcbmApfVxuJHthLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XG4ke2R9YCxwPW4uY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmwsbGFiZWw6dC5uYW1lfSk7dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSAke3QubmFtZX0gc2hhZGVyIGNvZGU6ICR7bH1gKTtsZXQgbT1uLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOnAsZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wiLGxhYmVsOnQubmFtZX0pO3JldHVybiBEZSh0Lm5hbWUpLHtwcm9ncmFtSW5mbzp0LGNvbXB1dGVQaXBlbGluZTptLHVuaWZvcm1WYXJpYWJsZXNJbmZvOmEudmFyaWFibGVzSW5mb319bm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUodCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0Lngsbj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQueXx8MSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC56fHwxLGk9dGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247aWYocjw9aSYmbjw9aSYmbzw9aSlyZXR1cm5bcixuLG9dO2xldCBhPXIqbipvLGQ9TWF0aC5jZWlsKE1hdGguc3FydChhKSk7aWYoZD5pKXtpZihkPU1hdGguY2VpbChNYXRoLmNicnQoYSkpLGQ+aSl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uXCIpO3JldHVybltkLGQsZF19ZWxzZSByZXR1cm5bZCxkLDFdfX19KTt2YXIgdWcsZGcsQ28sQW8sb24sSmw9VSgoKT0+e1widXNlIHN0cmljdFwiO1dlKCk7dGUoKTtldCgpO0puKCk7SmEoKTtRbCgpO1hsKCk7dWc9KGUsdCk9PntpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5wdXREZXBlbmRlbmNpZXMgbGVuZ3RoICR7dC5sZW5ndGh9IGlzIG5vdCBlcXVhbCB0byBpbnB1dFRlbnNvcnMgbGVuZ3RoICR7ZS5sZW5ndGh9LmApO2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKXtsZXQgbz1lW25dLmRhdGFUeXBlO3N3aXRjaCh0W25dKXtjYXNlXCJub25lXCI6e3IucHVzaChcIlwiKTticmVha31jYXNlXCJ0eXBlXCI6e3IucHVzaChgJHtvfWApO2JyZWFrfWNhc2VcInJhbmtcIjp7bGV0IGk9ZVtuXS5kaW1zLmxlbmd0aDtyLnB1c2goYCR7b307JHtpfWApO2JyZWFrfWNhc2VcImRpbXNcIjp7bGV0IGk9ZVtuXS5kaW1zLmpvaW4oXCIsXCIpO3IucHVzaChgJHtvfTske2l9YCk7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7dFtuXX1gKX19cmV0dXJuIHIuam9pbihcInxcIil9LGRnPShlLHQscik9PntsZXQgbj1lLm5hbWU7cmV0dXJuIGUuc2hhZGVyQ2FjaGU/LmhpbnQmJihuKz1cIltcIitlLnNoYWRlckNhY2hlLmhpbnQrXCJdXCIpLG4rPVwiOlwiK3IrYDoke3VnKHQsZS5zaGFkZXJDYWNoZT8uaW5wdXREZXBlbmRlbmNpZXM/P25ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChcImRpbXNcIikpfWAsbn0sQ289Y2xhc3N7Y29uc3RydWN0b3IodCl7dCYmKHRoaXMuYXJjaGl0ZWN0dXJlPXQuYXJjaGl0ZWN0dXJlLHRoaXMudmVuZG9yPXQudmVuZG9yKX1pc0FyY2hpdGVjdHVyZSh0KXtyZXR1cm4gdGhpcy5hcmNoaXRlY3R1cmU9PT10fWlzVmVuZG9yKHQpe3JldHVybiB0aGlzLnZlbmRvcj09PXR9fSxBbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnN1Ymdyb3Vwc1N1cHBvcnRlZD10LmZlYXR1cmVzLmhhcyhcInN1Ymdyb3Vwc1wiKSx0aGlzLnN1Ymdyb3Vwc0YxNlN1cHBvcnRlZD10LmZlYXR1cmVzLmhhcyhcInN1Ymdyb3Vwc1wiKTtsZXQgcj10LmxpbWl0czshdGhpcy5zdWJncm91cHNTdXBwb3J0ZWR8fCFyLm1pblN1Ymdyb3VwU2l6ZXx8IXIubWF4U3ViZ3JvdXBTaXplP3RoaXMuc3ViZ3JvdXBTaXplUmFuZ2U9dm9pZCAwOnRoaXMuc3ViZ3JvdXBTaXplUmFuZ2U9W3IubWluU3ViZ3JvdXBTaXplLHIubWF4U3ViZ3JvdXBTaXplXX19LG9uPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPW51bGw7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbDt0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGw7dGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbDt0aGlzLm1heERpc3BhdGNoTnVtYmVyPTE2O3RoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTA7dGhpcy5wZW5kaW5nS2VybmVscz1bXTt0aGlzLnBlbmRpbmdRdWVyaWVzPW5ldyBNYXA7dGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwiO3RoaXMuY2FwdHVyZWRDb21tYW5kTGlzdD1uZXcgTWFwO3RoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscz1uZXcgTWFwO3RoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc9bmV3IE1hcH1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZD09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IHQ9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIHR8fCh0PXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsdCkpLHR9YXN5bmMgaW5pdGlhbGl6ZSh0LHIpe3RoaXMuZW52PXQ7bGV0IG49W10sbz17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOnIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxtYXhCdWZmZXJTaXplOnIubGltaXRzLm1heEJ1ZmZlclNpemUsbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOnIubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn0scmVxdWlyZWRGZWF0dXJlczpufSxpPWE9PnIuZmVhdHVyZXMuaGFzKGEpJiZuLnB1c2goYSkmJiEwO2koXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIil8fGkoXCJ0aW1lc3RhbXAtcXVlcnlcIiksaShcInNoYWRlci1mMTZcIiksaShcInN1Ymdyb3Vwc1wiKSYmaShcInN1Ymdyb3Vwcy1mMTZcIiksdGhpcy5kZXZpY2U9YXdhaXQgci5yZXF1ZXN0RGV2aWNlKG8pLHRoaXMuZGV2aWNlSW5mbz1uZXcgQW8odGhpcy5kZXZpY2UpLHRoaXMuYWRhcHRlckluZm89bmV3IENvKHIuaW5mb3x8YXdhaXQgci5yZXF1ZXN0QWRhcHRlckluZm8oKSksdGhpcy5ncHVEYXRhTWFuYWdlcj1YYSh0aGlzKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBubih0aGlzKSx0aGlzLmtlcm5lbHM9bmV3IE1hcCx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhPW5ldyBNYXAsdGhpcy5rZXJuZWxDdXN0b21EYXRhPW5ldyBNYXAsUnIodC5sb2dMZXZlbCwhIXQuZGVidWcpLHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yPWE9PnthLmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yJiZjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke2EuZXJyb3IubWVzc2FnZX1gKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImRldmljZVwiLHt2YWx1ZTp0aGlzLmRldmljZSx3cml0YWJsZTohMSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJhZGFwdGVyXCIse3ZhbHVlOnIsd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITF9KSx0aGlzLnNldFF1ZXJ5VHlwZSgpfWRpc3Bvc2UoKXt0eXBlb2YgdGhpcy5xdWVyeVNldDxcInVcIiYmdGhpcy5xdWVyeVNldC5kZXN0cm95KCksdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCl9Z2V0Q29tbWFuZEVuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21tYW5kRW5jb2Rlcnx8KHRoaXMuY29tbWFuZEVuY29kZXI9dGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKSksdGhpcy5jb21tYW5kRW5jb2Rlcn1nZXRDb21wdXRlUGFzc0VuY29kZXIoKXtpZighdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpe2xldCB0PXRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKSxyPXt9O3RoaXMucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIiYmKHIudGltZXN0YW1wV3JpdGVzPXtxdWVyeVNldDp0aGlzLnF1ZXJ5U2V0LGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMixlbmRPZlBhc3NXcml0ZUluZGV4OnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMX0pLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPXQuYmVnaW5Db21wdXRlUGFzcyhyKX1yZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXJ9ZW5kQ29tcHV0ZVBhc3MoKXt0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciYmKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLmVuZCgpLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGwpfWZsdXNoKCl7aWYoIXRoaXMuY29tbWFuZEVuY29kZXIpcmV0dXJuO1VlKCksdGhpcy5lbmRDb21wdXRlUGFzcygpO2xldCB0O3RoaXMucXVlcnlUeXBlIT09XCJub25lXCImJih0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldCh0aGlzLnF1ZXJ5U2V0LDAsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMix0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwKSx0PXRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KSx0aGlzLnBlbmRpbmdRdWVyaWVzLnNldCh0LHRoaXMucGVuZGluZ0tlcm5lbHMpLHRoaXMucGVuZGluZ0tlcm5lbHM9W10sdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIodGhpcy5xdWVyeVJlc29sdmVCdWZmZXIsMCx0LDAsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMio4KSksdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKSx0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGwsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MCx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0Lm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKT0+e2xldCByPW5ldyBCaWdVaW50NjRBcnJheSh0LmdldE1hcHBlZFJhbmdlKCkpLG49dGhpcy5wZW5kaW5nUXVlcmllcy5nZXQodCk7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aC8yO28rKyl7bGV0IGk9bltvXSxhPWkua2VybmVsSWQsZD10aGlzLmtlcm5lbHMuZ2V0KGEpLGw9ZC5rZXJuZWxUeXBlLHA9ZC5rZXJuZWxOYW1lLG09aS5wcm9ncmFtTmFtZSx1PWkuaW5wdXRUZW5zb3JWaWV3cyxoPWkub3V0cHV0VGVuc29yVmlld3MsXz1yW28qMl0seT1yW28qMisxXTt0eXBlb2YgdGhpcy5xdWVyeVRpbWVCYXNlPlwidVwiJiYodGhpcy5xdWVyeVRpbWVCYXNlPV8pO2xldCBnPU51bWJlcihfLXRoaXMucXVlcnlUaW1lQmFzZSkseD1OdW1iZXIoeS10aGlzLnF1ZXJ5VGltZUJhc2UpO2lmKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihnKXx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKHgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5jb3JyZWN0IHRpbWVzdGFtcCByYW5nZVwiKTtpZih0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5vbmRhdGEpdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZy5vbmRhdGEoe3ZlcnNpb246MSxpbnB1dHNNZXRhZGF0YTp1Lm1hcCgkPT4oe2RpbXM6JC5kaW1zLGRhdGFUeXBlOmJ0KCQuZGF0YVR5cGUpfSkpLG91dHB1dHNNZXRhZGF0YTpoLm1hcCgkPT4oe2RpbXM6JC5kaW1zLGRhdGFUeXBlOmJ0KCQuZGF0YVR5cGUpfSkpLGtlcm5lbElkOmEsa2VybmVsVHlwZTpsLGtlcm5lbE5hbWU6cCxwcm9ncmFtTmFtZTptLHN0YXJ0VGltZTpnLGVuZFRpbWU6eH0pO2Vsc2V7bGV0ICQ9XCJcIjt1LmZvckVhY2goKFMsVCk9PnskKz1gaW5wdXRbJHtUfV06IFske1MuZGltc31dIHwgJHtidChTLmRhdGFUeXBlKX0sIGB9KTtsZXQgdj1cIlwiO2guZm9yRWFjaCgoUyxUKT0+e3YrPWBvdXRwdXRbJHtUfV06IFske1MuZGltc31dIHwgJHtidChTLmRhdGFUeXBlKX0sIGB9KSxjb25zb2xlLmxvZyhgW3Byb2ZpbGluZ10ga2VybmVsIFwiJHthfXwke2x9fCR7cH18JHttfVwiICR7JH0ke3Z9ZXhlY3V0aW9uIHRpbWU6ICR7eC1nfSBuc2ApfXdyKFwiR1BVXCIsYCR7bX06OiR7X306OiR7eX1gKX10LnVubWFwKCksdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUodCl9KSxEZSgpfXJ1bih0LHIsbixvLGksYSl7VWUodC5uYW1lKTtsZXQgZD1bXTtmb3IobGV0IFM9MDtTPHIubGVuZ3RoOysrUyl7bGV0IFQ9cltTXS5kYXRhO2lmKFQ9PT0wKWNvbnRpbnVlO2xldCBBPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KFQpO2lmKCFBKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke1R9YCk7ZC5wdXNoKEEpfWxldHtvdXRwdXRzOmwsZGlzcGF0Y2hHcm91cDpwLHByb2dyYW1Vbmlmb3JtczptfT10LmdldFJ1bkRhdGEociksdT1uLmxlbmd0aD09PTA/bC5tYXAoKFMsVCk9PlQpOm47aWYodS5sZW5ndGghPT1sLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7dS5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtsLmxlbmd0aH0uYCk7bGV0IGg9W10sXz1bXTtmb3IobGV0IFM9MDtTPGwubGVuZ3RoOysrUyl7aWYoIU51bWJlci5pc0ludGVnZXIodVtTXSl8fHVbU108LTN8fHVbU10+PWEpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHt1W1NdfWApO2lmKHVbU109PT0tMyljb250aW51ZTtsZXQgVD11W1NdPT09LTEsQT11W1NdPT09LTIsaz1UfHxBP2kobFtTXS5kYXRhVHlwZSxsW1NdLmRpbXMpOm8odVtTXSxsW1NdLmRhdGFUeXBlLGxbU10uZGltcyk7aWYoaC5wdXNoKGspLGsuZGF0YT09PTApY29udGludWU7bGV0IFA9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoay5kYXRhKTtpZighUCl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7ay5kYXRhfWApO2lmKFQmJnRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKFApLEEpe2xldCBEPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtEfHwoRD1bXSx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCxEKSksRC5wdXNoKFApfV8ucHVzaChQKX1pZihkLmxlbmd0aCE9PXIubGVuZ3RofHxfLmxlbmd0aCE9PWgubGVuZ3RoKXtpZihfLmxlbmd0aD09PTApcmV0dXJuIERlKHQubmFtZSksaDt0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gJHt0Lm5hbWV9IGhhcyB6ZXJvLXNpemVkIHRlbnNvcihzKSBpbiBpbnB1dHMgb3Igb3V0cHV0cy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIG5vdy5gKX1sZXQgeTtpZihtKXtsZXQgUz0wLFQ9W107bS5mb3JFYWNoKEQ9PntsZXQgUj10eXBlb2YgRC5kYXRhPT1cIm51bWJlclwiP1tELmRhdGFdOkQuZGF0YTtpZihSLmxlbmd0aD09PTApcmV0dXJuO2xldCBHPUQudHlwZT09PTEwPzI6NCxLLGo7RC50eXBlPT09MTA/KGo9Ui5sZW5ndGg+ND8xNjpSLmxlbmd0aD4yPzg6Ui5sZW5ndGgqRyxLPVIubGVuZ3RoPjQ/MTY6RypSLmxlbmd0aCk6KGo9Ui5sZW5ndGg8PTI/Ui5sZW5ndGgqRzoxNixLPTE2KSxTPU1hdGguY2VpbChTL2opKmosVC5wdXNoKFMpO2xldCBWPUQudHlwZT09PTEwPzg6NDtTKz1SLmxlbmd0aD40P01hdGguY2VpbChSLmxlbmd0aC9WKSpLOlIubGVuZ3RoKkd9KTtsZXQgQT0xNjtTPU1hdGguY2VpbChTL0EpKkE7bGV0IGs9bmV3IEFycmF5QnVmZmVyKFMpO20uZm9yRWFjaCgoRCxSKT0+e2xldCBHPVRbUl0sSz10eXBlb2YgRC5kYXRhPT1cIm51bWJlclwiP1tELmRhdGFdOkQuZGF0YTtpZihELnR5cGU9PT02KW5ldyBJbnQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MTIpbmV3IFVpbnQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MTApbmV3IFVpbnQxNkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MSluZXcgRmxvYXQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGU6ICR7YnQoRC50eXBlKX1gKX0pO2xldCBQPXRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKFMsR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7dGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoUC5idWZmZXIsMCxrLDAsUyksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKFAuaWQpLHk9e29mZnNldDowLHNpemU6UyxidWZmZXI6UC5idWZmZXJ9fWxldCBnPXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUocCkseD1nWzFdPT09MSYmZ1syXT09PTEsJD1kZyh0LHIseCksdj10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KCQpO2lmKHZ8fCh2PXRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQodCxnKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KCQsdiksdWUoXCJpbmZvXCIsKCk9PmBbYXJ0aWZhY3RdIGtleTogJHskfSwgcHJvZ3JhbU5hbWU6ICR7dC5uYW1lfWApKSxtJiZ2LnVuaWZvcm1WYXJpYWJsZXNJbmZvKXtpZihtLmxlbmd0aCE9PXYudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZXMgY291bnQgbWlzbWF0Y2g6IGV4cGVjdCAke3YudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7bS5sZW5ndGh9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKTtmb3IobGV0IFM9MDtTPG0ubGVuZ3RoO1MrKyl7bGV0IFQ9bVtTXSxBPVQudHlwZSxrPXR5cGVvZiBULmRhdGE9PVwibnVtYmVyXCI/MTpULmRhdGEubGVuZ3RoLFtQLERdPXYudW5pZm9ybVZhcmlhYmxlc0luZm9bU107aWYoQSE9PVB8fGshPT1EKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZSAke1N9IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke1B9IHdpdGggc2l6ZSAke0R9LCBnb3QgdHlwZSAke0F9IHdpdGggc2l6ZSAke2t9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKX19aWYodWUoXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHskfSkgd2l0aCAke2dbMF19eCR7Z1sxXX14JHtnWzJdfWApLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCJ8fHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCIpe2xldCBTPXtrZXJuZWxJZDp0aGlzLmN1cnJlbnRLZXJuZWxJZCxwcm9ncmFtTmFtZTp2LnByb2dyYW1JbmZvLm5hbWUsaW5wdXRUZW5zb3JWaWV3czpyLG91dHB1dFRlbnNvclZpZXdzOmh9O3RoaXMucGVuZGluZ0tlcm5lbHMucHVzaChTKSx0aGlzLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkucHVzaChTKX1yZXR1cm4gdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4odixkLF8sZyx5KSxEZSh0Lm5hbWUpLGh9dXBsb2FkKHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxyKX1tZW1jcHkodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LHIpfWFzeW5jIGRvd25sb2FkKHQscil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LHIpfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQscixuLG8pe2xldCBpPVpsLmdldCh0KTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTtsZXQgYT17a2VybmVsVHlwZTp0LGtlcm5lbE5hbWU6byxrZXJuZWxFbnRyeTppWzBdLGF0dHJpYnV0ZXM6W2lbMV0sbl19O3RoaXMua2VybmVscy5zZXQocixhKX1yZWxlYXNlS2VybmVsKHQpe2xldCByPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKHIpe2ZvcihsZXQgbiBvZiByKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShuLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LHIsbil7bGV0IG89dGhpcy5rZXJuZWxzLmdldCh0KTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldCBpPW8ua2VybmVsVHlwZSxhPW8ua2VybmVsTmFtZSxkPW8ua2VybmVsRW50cnksbD1vLmF0dHJpYnV0ZXM7aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7aX1dICR7YX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LGxbMF0mJihsWzFdPWxbMF0obFsxXSksbFswXT12b2lkIDApLHVlKFwiaW5mb1wiLCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske2l9XSAke2F9XCIuLi5gKTtsZXQgcD10aGlzLmVudi5kZWJ1Zzt0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBwJiZ0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZShcInZhbGlkYXRpb25cIiksZChyLGxbMV0pLDB9Y2F0Y2gobSl7cmV0dXJuIG4ucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske2l9XSAke2F9XCIgZmFpbGVkLiAke219YCkpLDF9ZmluYWxseXtwJiZuLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4obT0+bT9gR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske2l9XSAke2F9XCI6ICR7bS5tZXNzYWdlfWA6bnVsbCkpO2ZvcihsZXQgbSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKG0uaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX1yZWdpc3RlckJ1ZmZlcih0LHIsbixvKXtsZXQgaT10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtpfHwoaT1uZXcgTWFwLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHQsaSkpO2xldCBhPWkuZ2V0KHIpLGQ9dGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG4sbyxhKTtyZXR1cm4gaS5zZXQocixbZCxuXSksZH11bnJlZ2lzdGVyQnVmZmVycyh0KXtsZXQgcj10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtyJiYoci5mb3JFYWNoKG49PnRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG5bMF0pKSx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZSh0KSl9Z2V0QnVmZmVyKHQpe2xldCByPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHt0fWApO3JldHVybiByLmJ1ZmZlcn1jcmVhdGVEb3dubG9hZGVyKHQscixuKXtyZXR1cm4gYXN5bmMoKT0+e2xldCBvPWF3YWl0IG5vKHRoaXMsdCxyKTtyZXR1cm4gVXIoby5idWZmZXIsbil9fXdyaXRlVGltZXN0YW1wKHQpe3RoaXMucXVlcnlUeXBlPT09XCJpbnNpZGUtcGFzc2VzXCImJnRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLndyaXRlVGltZXN0YW1wKHRoaXMucXVlcnlTZXQsdCl9c2V0UXVlcnlUeXBlKCl7dGhpcy5xdWVyeVR5cGU9XCJub25lXCIsKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm1vZGU9PT1cImRlZmF1bHRcInx8KHR5cGVvZiB0aGlzLmVudi50cmFjZT5cInVcIj90aGlzLmVudi53YXNtLnRyYWNlOnRoaXMuZW52LnRyYWNlKSkmJih0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIik/dGhpcy5xdWVyeVR5cGU9XCJpbnNpZGUtcGFzc2VzXCI6dGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiYodGhpcy5xdWVyeVR5cGU9XCJhdC1wYXNzZXNcIiksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdHlwZW9mIHRoaXMucXVlcnlTZXQ+XCJ1XCImJih0aGlzLnF1ZXJ5U2V0PXRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHt0eXBlOlwidGltZXN0YW1wXCIsY291bnQ6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyfSksdGhpcy5xdWVyeVJlc29sdmVCdWZmZXI9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkV9KSkpfWNhcHR1cmVCZWdpbigpe3VlKFwiaW5mb1wiLFwiY2FwdHVyZUJlZ2luXCIpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJjYXB0dXJpbmdcIn1jYXB0dXJlRW5kKCl7dWUoXCJpbmZvXCIsXCJjYXB0dXJlRW5kXCIpLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9cmVwbGF5KCl7dWUoXCJpbmZvXCIsXCJyZXBsYXlcIiksdGhpcy5zZXNzaW9uU3RhdHVzPVwicmVwbGF5aW5nXCI7bGV0IHQ9dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLHI9dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLG49dC5sZW5ndGg7dGhpcy5wZW5kaW5nS2VybmVscz1bXTtmb3IobGV0IG89MDtvPG47bysrKXtsZXQgaT10aGlzLmdldENvbXB1dGVQYXNzRW5jb2RlcigpLGE9dFtvXTt0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpLGkuc2V0UGlwZWxpbmUoYS5jb21wdXRlUGlwZWxpbmUpLGkuc2V0QmluZEdyb3VwKDAsYS5iaW5kR3JvdXApLGkuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmEuZGlzcGF0Y2hHcm91cCksdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHJbb10pLCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiKSYmdGhpcy5lbmRDb21wdXRlUGFzcygpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLm1heERpc3BhdGNoTnVtYmVyJiZ0aGlzLmZsdXNoKCl9dGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIn1vbkNyZWF0ZVNlc3Npb24oKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm9uQ3JlYXRlU2Vzc2lvbigpfW9uUmVsZWFzZVNlc3Npb24odCl7dGhpcy51bnJlZ2lzdGVyQnVmZmVycyh0KSx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHQpJiZ0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZGVsZXRlKHQpLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5oYXModCkmJnRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5kZWxldGUodCksdGhpcy5ncHVEYXRhTWFuYWdlci5vblJlbGVhc2VTZXNzaW9uKHQpfW9uUnVuU3RhcnQodCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPXQsdGhpcy5zZXRRdWVyeVR5cGUoKX19fSk7dmFyIGxnLGVjLGNnLHRjLGFuLHNuLGtvLHJjLG5jPVUoKCk9PntcInVzZSBzdHJpY3RcIjtldCgpO2xnPTEsZWM9KCk9PmxnKyssY2c9bmV3IE1hcChbW1wiZmxvYXQzMlwiLDMyXSxbXCJmbG9hdDE2XCIsMTZdLFtcImludDMyXCIsMzJdLFtcInVpbnQzMlwiLDMyXSxbXCJpbnQ2NFwiLDY0XSxbXCJ1aW50NjRcIiw2NF0sW1wiaW50OFwiLDhdLFtcInVpbnQ4XCIsOF0sW1wiaW50NFwiLDRdLFtcInVpbnQ0XCIsNF1dKSx0Yz0oZSx0KT0+e2xldCByPWNnLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUuXCIpO3JldHVybiB0Lmxlbmd0aD4wP01hdGguY2VpbCh0LnJlZHVjZSgobixvKT0+bipvKSpyLzgpOjB9LGFuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbklkPXQuc2Vzc2lvbklkLHRoaXMubWxDb250ZXh0PXQuY29udGV4dCx0aGlzLm1sVGVuc29yPXQudGVuc29yLHRoaXMuZGF0YVR5cGU9dC5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlPXQuc2hhcGV9Z2V0IHRlbnNvcigpe3JldHVybiB0aGlzLm1sVGVuc29yfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMuZGF0YVR5cGV9Z2V0IHNoYXBlKCl7cmV0dXJuIHRoaXMudGVuc29yU2hhcGV9Z2V0IGJ5dGVMZW5ndGgoKXtyZXR1cm4gdGModGhpcy5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlKX1kZXN0cm95KCl7dWUoXCJ2ZXJib3NlXCIsKCk9PlwiW1dlYk5OXSBUZW5zb3JXcmFwcGVyLmRlc3Ryb3lcIiksdGhpcy5tbFRlbnNvci5kZXN0cm95KCl9d3JpdGUodCl7dGhpcy5tbENvbnRleHQud3JpdGVUZW5zb3IodGhpcy5tbFRlbnNvcix0KX1hc3luYyByZWFkKHQpe3JldHVybiB0P3RoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcix0KTp0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpfWNhblJldXNlVGVuc29yKHQscixuKXtyZXR1cm4gdGhpcy5tbENvbnRleHQ9PT10JiZ0aGlzLmRhdGFUeXBlPT09ciYmdGhpcy50ZW5zb3JTaGFwZS5sZW5ndGg9PT1uLmxlbmd0aCYmdGhpcy50ZW5zb3JTaGFwZS5ldmVyeSgobyxpKT0+bz09PW5baV0pfX0sc249Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLnRlbnNvck1hbmFnZXI9dDt0aGlzLndyYXBwZXI9cn1nZXQgdGVuc29yV3JhcHBlcigpe3JldHVybiB0aGlzLndyYXBwZXJ9cmVsZWFzZVRlbnNvcigpe3RoaXMudGVuc29yV3JhcHBlciYmKHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMudGVuc29yV3JhcHBlciksdGhpcy53cmFwcGVyPXZvaWQgMCl9YXN5bmMgZW5zdXJlVGVuc29yKHQscixuLG8pe2lmKHRoaXMud3JhcHBlcil7aWYodGhpcy53cmFwcGVyLmNhblJldXNlVGVuc29yKHQscixuKSlyZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtpZihvKXtpZih0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCE9PXRjKHIsbikpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgZGF0YSB0byB0ZW5zb3Igd2l0aCBkaWZmZXJlbnQgc2l6ZS5cIik7dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy53cmFwcGVyLnJlYWQoKSl9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy53cmFwcGVyKX1sZXQgaT10eXBlb2YgTUxUZW5zb3JVc2FnZT5cInVcIj92b2lkIDA6TUxUZW5zb3JVc2FnZS5SRUFEfE1MVGVuc29yVXNhZ2UuV1JJVEU7cmV0dXJuIHRoaXMud3JhcHBlcj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZ2V0Q2FjaGVkVGVuc29yKHIsbixpLCEwLCEwKSxvJiZ0aGlzLmFjdGl2ZVVwbG9hZCYmKHRoaXMud3JhcHBlci53cml0ZSh0aGlzLmFjdGl2ZVVwbG9hZCksdGhpcy5hY3RpdmVVcGxvYWQ9dm9pZCAwKSx0aGlzLndyYXBwZXIudGVuc29yfXVwbG9hZCh0KXtpZih0aGlzLndyYXBwZXIpaWYodC5ieXRlTGVuZ3RoPT09dGhpcy53cmFwcGVyLmJ5dGVMZW5ndGgpe3RoaXMud3JhcHBlci53cml0ZSh0KTtyZXR1cm59ZWxzZSB1ZShcInZlcmJvc2VcIiwoKT0+XCJEYXRhIHNpemUgZG9lcyBub3QgbWF0Y2ggdGVuc29yIHNpemUuIFJlbGVhc2luZyB0ZW5zb3IuXCIpLHRoaXMucmVsZWFzZVRlbnNvcigpO3RoaXMuYWN0aXZlVXBsb2FkP3RoaXMuYWN0aXZlVXBsb2FkLnNldCh0KTp0aGlzLmFjdGl2ZVVwbG9hZD1uZXcgVWludDhBcnJheSh0KX1hc3luYyBkb3dubG9hZCh0KXtpZih0aGlzLmFjdGl2ZVVwbG9hZClpZih0KXt0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/bmV3IFVpbnQ4QXJyYXkodCkuc2V0KHRoaXMuYWN0aXZlVXBsb2FkKTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKS5zZXQodGhpcy5hY3RpdmVVcGxvYWQpO3JldHVybn1lbHNlIHJldHVybiB0aGlzLmFjdGl2ZVVwbG9hZC5idWZmZXI7aWYoIXRoaXMud3JhcHBlcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaGFzIG5vdCBiZWVuIGNyZWF0ZWQuXCIpO3JldHVybiB0P3RoaXMud3JhcHBlci5yZWFkKHQpOnRoaXMud3JhcHBlci5yZWFkKCl9fSxrbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnRlbnNvclRyYWNrZXJzQnlJZD1uZXcgTWFwO3RoaXMuZnJlZVRlbnNvcnM9W107dGhpcy5leHRlcm5hbFRlbnNvcnM9bmV3IFNldH1yZXNlcnZlVGVuc29ySWQoKXtsZXQgdD1lYygpO3JldHVybiB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQodCxuZXcgc24odGhpcykpLHR9cmVsZWFzZVRlbnNvcklkKHQpe2xldCByPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtyJiYodGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZGVsZXRlKHQpLHIudGVuc29yV3JhcHBlciYmdGhpcy5yZWxlYXNlVGVuc29yKHIudGVuc29yV3JhcHBlcikpfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhVHlwZTogJHtyfSwgc2hhcGU6ICR7bn0sIGNvcHlPbGQ6ICR7b319YCk7bGV0IGk9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiBpLmVuc3VyZVRlbnNvcih0aGlzLmJhY2tlbmQuY3VycmVudENvbnRleHQscixuLG8pfXVwbG9hZCh0LHIpe2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtuLnVwbG9hZChyKX1hc3luYyBkb3dubG9hZCh0LHIpe3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmRvd25sb2FkIHt0ZW5zb3JJZDogJHt0fSwgZHN0QnVmZmVyOiAke3I/LmJ5dGVMZW5ndGh9fWApO2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyZXR1cm4gbi5kb3dubG9hZChyKX1yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCl7Zm9yKGxldCByIG9mIHRoaXMuZnJlZVRlbnNvcnMpci5zZXNzaW9uSWQ9PT10JiZyLmRlc3Ryb3koKTt0aGlzLmZyZWVUZW5zb3JzPXRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKHI9PnIuc2Vzc2lvbklkIT09dCl9cmVnaXN0ZXJUZW5zb3IodCxyLG4sbyl7bGV0IGk9ZWMoKSxhPW5ldyBhbih7c2Vzc2lvbklkOnRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLGNvbnRleHQ6dCx0ZW5zb3I6cixkYXRhVHlwZTpuLHNoYXBlOm99KTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KGksbmV3IHNuKHRoaXMsYSkpLHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmFkZChhKSxpfWFzeW5jIGdldENhY2hlZFRlbnNvcih0LHIsbixvLGkpe2xldCBhPXRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLGQ9dGhpcy5iYWNrZW5kLmN1cnJlbnRDb250ZXh0O2ZvcihsZXRbcCxtXW9mIHRoaXMuZnJlZVRlbnNvcnMuZW50cmllcygpKWlmKG0uY2FuUmV1c2VUZW5zb3IoZCx0LHIpKXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gUmV1c2luZyB0ZW5zb3Ige2RhdGFUeXBlOiAke3R9LCBzaGFwZTogJHtyfX1gKTtsZXQgdT10aGlzLmZyZWVUZW5zb3JzLnNwbGljZShwLDEpWzBdO3JldHVybiB1LnNlc3Npb25JZD1hLHV9dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIE1MQ29udGV4dC5jcmVhdGVUZW5zb3Ige2RhdGFUeXBlOiAke3R9LCBzaGFwZTogJHtyfX1gKTtsZXQgbD1hd2FpdCBkLmNyZWF0ZVRlbnNvcih7ZGF0YVR5cGU6dCxzaGFwZTpyLGRpbWVuc2lvbnM6cix1c2FnZTpuLHdyaXRhYmxlOm8scmVhZGFibGU6aX0pO3JldHVybiBuZXcgYW4oe3Nlc3Npb25JZDphLGNvbnRleHQ6ZCx0ZW5zb3I6bCxkYXRhVHlwZTp0LHNoYXBlOnJ9KX1yZWxlYXNlVGVuc29yKHQpe3RoaXMuZXh0ZXJuYWxUZW5zb3JzLmhhcyh0KSYmdGhpcy5leHRlcm5hbFRlbnNvcnMuZGVsZXRlKHQpLHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0KX19LHJjPSguLi5lKT0+bmV3IGtvKC4uLmUpfSk7dmFyIG9jLHBnLHVuLGljPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2d0KCk7Sm4oKTtuYygpO2V0KCk7b2M9bmV3IE1hcChbWzEsXCJmbG9hdDMyXCJdLFsxMCxcImZsb2F0MTZcIl0sWzYsXCJpbnQzMlwiXSxbMTIsXCJ1aW50MzJcIl0sWzcsXCJpbnQ2NFwiXSxbMTMsXCJ1aW50NjRcIl0sWzIyLFwiaW50NFwiXSxbMjEsXCJ1aW50NFwiXSxbMyxcImludDhcIl0sWzIsXCJ1aW50OFwiXSxbOSxcInVpbnQ4XCJdXSkscGc9KGUsdCk9PntpZihlPT09dClyZXR1cm4hMDtpZihlPT09dm9pZCAwfHx0PT09dm9pZCAwKXJldHVybiExO2xldCByPU9iamVjdC5rZXlzKGUpLnNvcnQoKSxuPU9iamVjdC5rZXlzKHQpLnNvcnQoKTtyZXR1cm4gci5sZW5ndGg9PT1uLmxlbmd0aCYmci5ldmVyeSgobyxpKT0+bz09PW5baV0mJmVbb109PT10W29dKX0sdW49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy50ZW5zb3JNYW5hZ2VyPXJjKHRoaXMpO3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQ9bmV3IE1hcDt0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dD1uZXcgTWFwO3RoaXMubWxDb250ZXh0Q2FjaGU9W107UnIodC5sb2dMZXZlbCwhIXQuZGVidWcpfWdldCBjdXJyZW50U2Vzc2lvbklkKCl7aWYodGhpcy5hY3RpdmVTZXNzaW9uSWQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIHNlc3Npb25cIik7cmV0dXJuIHRoaXMuYWN0aXZlU2Vzc2lvbklkfW9uUnVuU3RhcnQodCl7dGhpcy5hY3RpdmVTZXNzaW9uSWQ9dH1hc3luYyBjcmVhdGVNTENvbnRleHQodCl7aWYodCBpbnN0YW5jZW9mIEdQVURldmljZSl7bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5ncHVEZXZpY2U9PT10KTtpZihuIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtncHVEZXZpY2U6dCxtbENvbnRleHQ6b30pLG99fWVsc2UgaWYodD09PXZvaWQgMCl7bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5vcHRpb25zPT09dm9pZCAwJiZvLmdwdURldmljZT09PXZvaWQgMCk7aWYobiE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW25dLm1sQ29udGV4dDt7bGV0IG89YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHttbENvbnRleHQ6b30pLG99fWxldCByPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KG49PnBnKG4ub3B0aW9ucyx0KSk7aWYociE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW3JdLm1sQ29udGV4dDt7bGV0IG49YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQodCk7cmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7b3B0aW9uczp0LG1sQ29udGV4dDpufSksbn19Z2V0IGN1cnJlbnRDb250ZXh0KCl7bGV0IHQ9dGhpcy5nZXRNTENvbnRleHQodGhpcy5jdXJyZW50U2Vzc2lvbklkKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoYE5vIE1MQ29udGV4dCBmb3VuZCBmb3Igc2Vzc2lvbiAke3RoaXMuY3VycmVudFNlc3Npb25JZH1gKTtyZXR1cm4gdH1yZWdpc3Rlck1MQ29udGV4dCh0LHIpe3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuc2V0KHQscik7bGV0IG49dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KHIpO258fChuPW5ldyBTZXQsdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuc2V0KHIsbikpLG4uYWRkKHQpfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IHI9dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCk7aWYoIXIpcmV0dXJuO3RoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCksdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5kZWxldGUodCk7bGV0IG49dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KHIpO2lmKG4uZGVsZXRlKHQpLG4uc2l6ZT09PTApe3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmRlbGV0ZShyKTtsZXQgbz10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChpPT5pLm1sQ29udGV4dD09PXIpO28hPT0tMSYmdGhpcy5tbENvbnRleHRDYWNoZS5zcGxpY2UobywxKX19Z2V0TUxDb250ZXh0KHQpe3JldHVybiB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KX1yZXNlcnZlVGVuc29ySWQoKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpfXJlbGVhc2VUZW5zb3JJZCh0KXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVsZWFzZVRlbnNvcklkIHt0ZW5zb3JJZDogJHt0fX1gKSx0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHQpfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXtsZXQgaT1vYy5nZXQocik7aWYoIWkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yKHQsaSxuLG8pfXVwbG9hZFRlbnNvcih0LHIpe2lmKCFJZSgpLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcil0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gdXBsb2FkIHRvIGEgTUxUZW5zb3Igd2hpbGUgc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIGlzIGZhbHNlXCIpO3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSB1cGxvYWRUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhOiAke3IuYnl0ZUxlbmd0aH19YCksdGhpcy50ZW5zb3JNYW5hZ2VyLnVwbG9hZCh0LHIpfWFzeW5jIGRvd25sb2FkVGVuc29yKHQscil7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0LHIpfWNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0LHIpe3JldHVybiBhc3luYygpPT57bGV0IG49YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQpO3JldHVybiBVcihuLHIpfX1yZWdpc3Rlck1MVGVuc29yKHQscixuKXtsZXQgbz1vYy5nZXQocik7aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO2xldCBpPXRoaXMudGVuc29yTWFuYWdlci5yZWdpc3RlclRlbnNvcih0aGlzLmN1cnJlbnRDb250ZXh0LHQsbyxuKTtyZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxUZW5zb3Ige3RlbnNvcjogJHt0fSwgZGF0YVR5cGU6ICR7b30sIGRpbWVuc2lvbnM6ICR7bn19IC0+IHt0ZW5zb3JJZDogJHtpfX1gKSxpfXJlZ2lzdGVyTUxDb25zdGFudCh0LHIsbixvLGksYSl7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiRXh0ZXJuYWwgbW91bnRlZCBmaWxlcyBhcmUgbm90IGF2YWlsYWJsZS5cIik7bGV0IGQ9dDt0LnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGQ9dC5zdWJzdHJpbmcoMikpO2xldCBsPWEuZ2V0KGQpO2lmKCFsKXRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtkfSBub3QgZm91bmQgaW4gcHJlbG9hZGVkIGZpbGVzLmApO2lmKHIrbj5sLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLlwiKTtsZXQgcD1sLnNsaWNlKHIscituKS5idWZmZXIsbTtzd2l0Y2goaS5kYXRhVHlwZSl7Y2FzZVwiZmxvYXQzMlwiOm09bmV3IEZsb2F0MzJBcnJheShwKTticmVhaztjYXNlXCJmbG9hdDE2XCI6bT1uZXcgVWludDE2QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50MzJcIjptPW5ldyBJbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcInVpbnQzMlwiOm09bmV3IFVpbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcImludDY0XCI6bT1uZXcgQmlnSW50NjRBcnJheShwKTticmVhaztjYXNlXCJ1aW50NjRcIjptPW5ldyBCaWdVaW50NjRBcnJheShwKTticmVhaztjYXNlXCJpbnQ4XCI6bT1uZXcgSW50OEFycmF5KHApO2JyZWFrO2Nhc2VcImludDRcIjpjYXNlXCJ1aW50NFwiOmNhc2VcInVpbnQ4XCI6bT1uZXcgVWludDhBcnJheShwKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2kuZGF0YVR5cGV9IGluIGNyZWF0aW5nIFdlYk5OIENvbnN0YW50IGZyb20gZXh0ZXJuYWwgZGF0YS5gKX1yZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxDb25zdGFudCB7ZGF0YVR5cGU6ICR7aS5kYXRhVHlwZX0sIHNoYXBlOiAke2kuc2hhcGV9fX1gKSxvLmNvbnN0YW50KGksbSl9Zmx1c2goKXt9fX0pO3ZhciBhYz17fTtGdChhYyx7aW5pdDooKT0+bWd9KTt2YXIgcnIsRW8sbWcsc2M9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7SmwoKTtldCgpO29lKCk7aWMoKTtycj1jbGFzcyBle2NvbnN0cnVjdG9yKHQscixuLG8pe3RoaXMubW9kdWxlPXQ7dGhpcy5kYXRhVHlwZT1yO3RoaXMuZGF0YT1uO3RoaXMuZGltcz1vfWdldEZsb2F0MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUMuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgRmxvYXQzMkFycmF5Om5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRCaWdJbnQ2NEFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9Qy5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBCaWdJbnQ2NEFycmF5Om5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0SW50MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT02KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUMuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgSW50MzJBcnJheTpuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldFVpbnQxNkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEwJiZ0aGlzLmRhdGFUeXBlIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1DLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IFVpbnQxNkFycmF5Om5ldyBVaW50MTZBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfXJlc2hhcGUodCl7aWYoQy5zaXplKHQpIT09Qy5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBlKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLHQpfX0sRW89Y2xhc3N7Y29uc3RydWN0b3IodCxyLG4pe3RoaXMubW9kdWxlPXQ7dGhpcy5iYWNrZW5kPXI7dGhpcy5jdXN0b21EYXRhT2Zmc2V0PTA7dGhpcy5jdXN0b21EYXRhU2l6ZT0wO3RoaXMuYWRhcHRlckluZm89ci5hZGFwdGVySW5mbyx0aGlzLmRldmljZUluZm89ci5kZXZpY2VJbmZvO2xldCBvPXQuUFRSX1NJWkUsaT1uL3QuUFRSX1NJWkUsYT1vPT09ND9cImkzMlwiOlwiaTY0XCI7dGhpcy5vcEtlcm5lbENvbnRleHQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpO2xldCBkPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKTt0aGlzLm91dHB1dENvdW50PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKSx0aGlzLmN1c3RvbURhdGFPZmZzZXQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssXCIqXCIpKSx0aGlzLmN1c3RvbURhdGFTaXplPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKTtsZXQgbD1bXTtmb3IobGV0IHA9MDtwPGQ7cCsrKXtsZXQgbT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSksdT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxcIipcIikpLGg9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpLF89W107Zm9yKGxldCB5PTA7eTxoO3krKylfLnB1c2goTnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpKTtsLnB1c2gobmV3IHJyKHQsbSx1LF8pKX10aGlzLmlucHV0cz1sfWdldCBrZXJuZWxDdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1nZXQgY3VzdG9tRGF0YUJ1ZmZlcigpe3JldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LHRoaXMuY3VzdG9tRGF0YU9mZnNldCt0aGlzLmN1c3RvbURhdGFTaXplKX1jb21wdXRlKHQscil7bGV0IG49cj8uaW5wdXRzPy5tYXAoZD0+dHlwZW9mIGQ9PVwibnVtYmVyXCI/dGhpcy5pbnB1dHNbZF06ZCk/P3RoaXMuaW5wdXRzLG89cj8ub3V0cHV0cz8/W10saT0oZCxsLHApPT5uZXcgcnIodGhpcy5tb2R1bGUsbCx0aGlzLm91dHB1dChkLHApLHApLGE9KGQsbCk9PntsZXQgcD1DdChkLGwpO2lmKCFwKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2R9YCk7bGV0IG09cD4wP3RoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUocCkuaWQ6MDtyZXR1cm4gbmV3IHJyKHRoaXMubW9kdWxlLGQsbSxsKX07cmV0dXJuIHRoaXMuYmFja2VuZC5ydW4odCxuLG8saSxhLHRoaXMub3V0cHV0Q291bnQpfW91dHB1dCh0LHIpe2xldCBuPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtsZXQgbz10aGlzLm1vZHVsZS5QVFJfU0laRSxpPW89PT00P1wiaTMyXCI6XCJpNjRcIixhPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDErci5sZW5ndGgpKm8pO3RoaXMubW9kdWxlLnNldFZhbHVlKGEsci5sZW5ndGgsaSk7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aDtkKyspdGhpcy5tb2R1bGUuc2V0VmFsdWUoYStvKihkKzEpLHJbZF0saSk7cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LHQsYSl9Y2F0Y2gobyl7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtyfV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtvfWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKG4pfX19LG1nPWFzeW5jKGUsdCxyLG4pPT57bGV0IG89dC5qc2VwSW5pdDtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBKU0VQLiBUaGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydC5cIik7aWYoZT09PVwid2ViZ3B1XCIpe2xldCBpPW5ldyBvbjthd2FpdCBpLmluaXRpYWxpemUocixuKSxvKFwid2ViZ3B1XCIsW2ksYT0+aS5hbGxvYyhOdW1iZXIoYSkpLGE9PmkuZnJlZShhKSwoYSxkLGwscD0hMSk9PntpZihwKXVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0dwdTogc3JjPSR7TnVtYmVyKGEpfSwgZHN0PSR7TnVtYmVyKGQpfSwgc2l6ZT0ke051bWJlcihsKX1gKSxpLm1lbWNweShOdW1iZXIoYSksTnVtYmVyKGQpKTtlbHNle3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke051bWJlcihhKX0sIGdwdURhdGFJZD0ke051bWJlcihkKX0sIHNpemU9JHtOdW1iZXIobCl9YCk7bGV0IG09dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGE+Pj4wKSxOdW1iZXIoYT4+PjApK051bWJlcihsKSk7aS51cGxvYWQoTnVtYmVyKGQpLG0pfX0sYXN5bmMoYSxkLGwpPT57dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHthfSwgZGF0YU9mZnNldD0ke2R9LCBzaXplPSR7bH1gKSxhd2FpdCBpLmRvd25sb2FkKE51bWJlcihhKSwoKT0+dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGQpPj4+MCxOdW1iZXIoZCtsKT4+PjApKX0sKGEsZCxsKT0+aS5jcmVhdGVLZXJuZWwoYSxOdW1iZXIoZCksbCx0LlVURjhUb1N0cmluZyh0Ll9Kc2VwR2V0Tm9kZU5hbWUoTnVtYmVyKGQpKSkpLGE9PmkucmVsZWFzZUtlcm5lbChhKSwoYSxkLGwscCk9Pnt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtsfSwga2VybmVsPSR7YX0sIGNvbnRleHREYXRhT2Zmc2V0PSR7ZH1gKTtsZXQgbT1uZXcgRW8odCxpLE51bWJlcihkKSk7cmV0dXJuIGkuY29tcHV0ZUtlcm5lbChOdW1iZXIoYSksbSxwKX0sKCk9PmkuY2FwdHVyZUJlZ2luKCksKCk9PmkuY2FwdHVyZUVuZCgpLCgpPT5pLnJlcGxheSgpXSl9ZWxzZXtsZXQgaT1uZXcgdW4ocik7byhcIndlYm5uXCIsW2ksKCk9PmkucmVzZXJ2ZVRlbnNvcklkKCksYT0+aS5yZWxlYXNlVGVuc29ySWQoYSksYXN5bmMoYSxkLGwscCk9PmkuZW5zdXJlVGVuc29yKGEsZCxsLHApLChhLGQpPT57aS51cGxvYWRUZW5zb3IoYSxkKX0sYXN5bmMoYSxkKT0+aS5kb3dubG9hZFRlbnNvcihhLGQpXSl9fX0pO3ZhciBmZyxUcixJcixQdCxoZyxLdCxDcixBcix1YyxrcixFcixQcixxbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SGEoKTtxYSgpO3RlKCk7Z3QoKTtPcigpO1huKCk7Zmc9KGUsdCk9PntJZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZwZShcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxUcj1hc3luYyBlPT57ZmcoZS53YXNtLm51bVRocmVhZHMsWnQoZS5sb2dMZXZlbCkpfSxJcj1hc3luYyhlLHQpPT57e2xldCByPShzYygpLGJyKGFjKSkuaW5pdDtpZih0PT09XCJ3ZWJncHVcIil7aWYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5ncHUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR1BVIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTtsZXQgbj1lLndlYmdwdS5hZGFwdGVyO2lmKG4pe2lmKHR5cGVvZiBuLmxpbWl0cyE9XCJvYmplY3RcInx8dHlwZW9mIG4uZmVhdHVyZXMhPVwib2JqZWN0XCJ8fHR5cGVvZiBuLnJlcXVlc3REZXZpY2UhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdQVSBhZGFwdGVyIHNldCBpbiBgZW52LndlYmdwdS5hZGFwdGVyYC4gSXQgbXVzdCBiZSBhIEdQVUFkYXB0ZXIgb2JqZWN0LlwiKX1lbHNle2xldCBvPWUud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtpZihvIT09dm9pZCAwJiZvIT09XCJsb3ctcG93ZXJcIiYmbyE9PVwiaGlnaC1wZXJmb3JtYW5jZVwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke299XCJgKTtsZXQgaT1lLndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtpZihpIT09dm9pZCAwJiZ0eXBlb2YgaSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtpfVwiYCk7aWYobj1hd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKHtwb3dlclByZWZlcmVuY2U6byxmb3JjZUZhbGxiYWNrQWRhcHRlcjppfSksIW4pdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLiBZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyl9YXdhaXQgcihcIndlYmdwdVwiLEllKCksZSxuKX1pZih0PT09XCJ3ZWJublwiKXtpZih0eXBlb2YgbmF2aWdhdG9yPlwidVwifHwhbmF2aWdhdG9yLm1sKXRocm93IG5ldyBFcnJvcihcIldlYk5OIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTthd2FpdCByKFwid2Vibm5cIixJZSgpLGUpfX19LFB0PW5ldyBNYXAsaGc9ZT0+e2xldCB0PUllKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgbj10LlBUUl9TSVpFLG89dC5zdGFja0FsbG9jKDIqbik7dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLG8sbytuKSE9PTAmJnBlKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtsZXQgYT1uPT09ND9cImkzMlwiOlwiaTY0XCI7cmV0dXJuW051bWJlcih0LmdldFZhbHVlKG8sYSkpLE51bWJlcih0LmdldFZhbHVlKG8rbixhKSldfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fSxLdD1lPT57bGV0IHQ9SWUoKSxyPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKHI9PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxyKSxbcixlLmJ5dGVMZW5ndGhdfSxDcj1hc3luYyhlLHQpPT57bGV0IHIsbixvPUllKCk7QXJyYXkuaXNBcnJheShlKT9bcixuXT1lOmUuYnVmZmVyPT09by5IRUFQVTguYnVmZmVyP1tyLG5dPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbcixuXT1LdChlKTtsZXQgaT0wLGE9MCxkPTAsbD1bXSxwPVtdLG09W107dHJ5e2lmKFthLGxdPUZhKHQpLHQ/LmV4dGVybmFsRGF0YSYmby5tb3VudEV4dGVybmFsRGF0YSl7bGV0IHY9W107Zm9yKGxldCBTIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgVD10eXBlb2YgUz09XCJzdHJpbmdcIj9TOlMucGF0aDt2LnB1c2goUXQodHlwZW9mIFM9PVwic3RyaW5nXCI/UzpTLmRhdGEpLnRoZW4oQT0+e28ubW91bnRFeHRlcm5hbERhdGEoVCxBKX0pKX1hd2FpdCBQcm9taXNlLmFsbCh2KX1mb3IobGV0IHYgb2YgdD8uZXhlY3V0aW9uUHJvdmlkZXJzPz9bXSlpZigodHlwZW9mIHY9PVwic3RyaW5nXCI/djp2Lm5hbWUpPT09XCJ3ZWJublwiKXtpZihvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMSx0eXBlb2YgdiE9XCJzdHJpbmdcIil7bGV0IFQ9dixBPVQ/LmNvbnRleHQsaz1UPy5ncHVEZXZpY2UsUD1UPy5kZXZpY2VUeXBlLEQ9VD8ucG93ZXJQcmVmZXJlbmNlO0E/by5jdXJyZW50Q29udGV4dD1BOms/by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoayk6by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoe2RldmljZVR5cGU6UCxwb3dlclByZWZlcmVuY2U6RH0pfWVsc2Ugby5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoKTticmVha31pPWF3YWl0IG8uX09ydENyZWF0ZVNlc3Npb24ocixuLGEpLGk9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpLG8uanNlcE9uQ3JlYXRlU2Vzc2lvbj8uKCksby5jdXJyZW50Q29udGV4dCYmKG8uanNlcFJlZ2lzdGVyTUxDb250ZXh0KGksby5jdXJyZW50Q29udGV4dCksby5jdXJyZW50Q29udGV4dD12b2lkIDAsby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITApO2xldFt1LGhdPWhnKGkpLF89ISF0Py5lbmFibGVHcmFwaENhcHR1cmUseT1bXSxnPVtdLHg9W107Zm9yKGxldCB2PTA7djx1O3YrKyl7bGV0IFM9by5fT3J0R2V0SW5wdXROYW1lKGksdik7Uz09PTAmJnBlKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLHAucHVzaChTKSx5LnB1c2goby5VVEY4VG9TdHJpbmcoUykpfWZvcihsZXQgdj0wO3Y8aDt2Kyspe2xldCBTPW8uX09ydEdldE91dHB1dE5hbWUoaSx2KTtTPT09MCYmcGUoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLG0ucHVzaChTKTtsZXQgVD1vLlVURjhUb1N0cmluZyhTKTtnLnB1c2goVCk7e2lmKF8mJnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT09dm9pZCAwKXt4LnB1c2goXCJncHUtYnVmZmVyXCIpO2NvbnRpbnVlfWxldCBBPXR5cGVvZiB0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09XCJzdHJpbmdcIj90LnByZWZlcnJlZE91dHB1dExvY2F0aW9uOnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bVF0/P1wiY3B1XCI7aWYoQSE9PVwiY3B1XCImJkEhPT1cImNwdS1waW5uZWRcIiYmQSE9PVwiZ3B1LWJ1ZmZlclwiJiZBIT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS5gKTtpZihfJiZBIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7QX0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO3gucHVzaChBKX19bGV0ICQ9bnVsbDtyZXR1cm4geC5zb21lKHY9PnY9PT1cImdwdS1idWZmZXJcInx8dj09PVwibWwtdGVuc29yXCIpJiYoZD1vLl9PcnRDcmVhdGVCaW5kaW5nKGkpLGQ9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBJTyBiaW5kaW5nLlwiKSwkPXtoYW5kbGU6ZCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6eCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOngubWFwKHY9PlFuKHYpKX0pLFB0LnNldChpLFtpLHAsbSwkLF8sITFdKSxbaSx5LGddfWNhdGNoKHUpe3Rocm93IHAuZm9yRWFjaChoPT5vLl9PcnRGcmVlKGgpKSxtLmZvckVhY2goaD0+by5fT3J0RnJlZShoKSksZCE9PTAmJm8uX09ydFJlbGVhc2VCaW5kaW5nKGQpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpLGkhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbihpKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSx1fWZpbmFsbHl7by5fZnJlZShyKSxhIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKGEpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksbC5mb3JFYWNoKHU9Pm8uX2ZyZWUodSkpLG8udW5tb3VudEV4dGVybmFsRGF0YT8uKCl9fSxBcj1lPT57bGV0IHQ9SWUoKSxyPVB0LmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFtuLG8saSxhLGRdPXI7YSYmKGQmJnQuX09ydENsZWFyQm91bmRPdXRwdXRzKGEuaGFuZGxlKSE9PTAmJnBlKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksdC5fT3J0UmVsZWFzZUJpbmRpbmcoYS5oYW5kbGUpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpKSx0LmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oZSksby5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLGkuZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihuKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSxQdC5kZWxldGUoZSl9LHVjPShlLHQscixuLG8saT0hMSk9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgYT1JZSgpLGQ9YS5QVFJfU0laRSxsPWVbMF0scD1lWzFdLG09ZVszXSx1LGg7aWYobD09PVwic3RyaW5nXCImJihtPT09XCJncHUtYnVmZmVyXCJ8fG09PT1cIm1sLXRlbnNvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihpJiZtIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7b30gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZihtPT09XCJncHUtYnVmZmVyXCIpe2xldCBnPWVbMl0uZ3B1QnVmZmVyO2g9Q3QoWXQobCkscCk7bGV0IHg9YS5qc2VwUmVnaXN0ZXJCdWZmZXI7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTt1PXgobixvLGcsaCl9ZWxzZSBpZihtPT09XCJtbC10ZW5zb3JcIil7bGV0IGc9ZVsyXS5tbFRlbnNvcjtoPUN0KFl0KGwpLHApO2xldCB4PWEuanNlcFJlZ2lzdGVyTUxUZW5zb3I7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7dT14KGcsWXQobCkscCl9ZWxzZXtsZXQgZz1lWzJdO2lmKEFycmF5LmlzQXJyYXkoZykpe2g9ZCpnLmxlbmd0aCx1PWEuX21hbGxvYyhoKSxyLnB1c2godSk7Zm9yKGxldCB4PTA7eDxnLmxlbmd0aDt4Kyspe2lmKHR5cGVvZiBnW3hdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7eH0gaXMgbm90IGEgc3RyaW5nYCk7YS5zZXRWYWx1ZSh1K3gqZCxrZShnW3hdLHIpLFwiKlwiKX19ZWxzZSBoPWcuYnl0ZUxlbmd0aCx1PWEuX21hbGxvYyhoKSxyLnB1c2godSksYS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGcuYnVmZmVyLGcuYnl0ZU9mZnNldCxoKSx1KX1sZXQgXz1hLnN0YWNrU2F2ZSgpLHk9YS5zdGFja0FsbG9jKDQqcC5sZW5ndGgpO3RyeXtwLmZvckVhY2goKHgsJCk9PmEuc2V0VmFsdWUoeSskKmQseCxkPT09ND9cImkzMlwiOlwiaTY0XCIpKTtsZXQgZz1hLl9PcnRDcmVhdGVUZW5zb3IoWXQobCksdSxoLHkscC5sZW5ndGgsUW4obSkpO2c9PT0wJiZwZShgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7bn0sIGluZGV4PSR7b30uYCksdC5wdXNoKGcpfWZpbmFsbHl7YS5zdGFja1Jlc3RvcmUoXyl9fSxrcj1hc3luYyhlLHQscixuLG8saSk9PntsZXQgYT1JZSgpLGQ9YS5QVFJfU0laRSxsPVB0LmdldChlKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXQgcD1sWzBdLG09bFsxXSx1PWxbMl0saD1sWzNdLF89bFs0XSx5PWxbNV0sZz10Lmxlbmd0aCx4PW4ubGVuZ3RoLCQ9MCx2PVtdLFM9W10sVD1bXSxBPVtdLGs9YS5zdGFja1NhdmUoKSxQPWEuc3RhY2tBbGxvYyhnKmQpLEQ9YS5zdGFja0FsbG9jKGcqZCksUj1hLnN0YWNrQWxsb2MoeCpkKSxHPWEuc3RhY2tBbGxvYyh4KmQpO3RyeXthLmpzZXBPblJ1blN0YXJ0Py4ocCksWyQsdl09R2EoaSk7Zm9yKGxldCBWPTA7VjxnO1YrKyl1YyhyW1ZdLFMsQSxlLHRbVl0sXyk7Zm9yKGxldCBWPTA7Vjx4O1YrKyl1YyhvW1ZdLFQsQSxlLGcrbltWXSxfKTtmb3IobGV0IFY9MDtWPGc7VisrKWEuc2V0VmFsdWUoUCtWKmQsU1tWXSxcIipcIiksYS5zZXRWYWx1ZShEK1YqZCxtW3RbVl1dLFwiKlwiKTtmb3IobGV0IFY9MDtWPHg7VisrKWEuc2V0VmFsdWUoUitWKmQsVFtWXSxcIipcIiksYS5zZXRWYWx1ZShHK1YqZCx1W25bVl1dLFwiKlwiKTtpZihoJiYheSl7bGV0e2hhbmRsZTpWLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczpRLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6c2V9PWg7aWYobS5sZW5ndGghPT1nKXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtnfSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7bS5sZW5ndGh9KS5gKTtmb3IobGV0IFk9MDtZPGc7WSsrKXtsZXQgZWU9dFtZXTthd2FpdCBhLl9PcnRCaW5kSW5wdXQoVixtW2VlXSxTW1ldKSE9PTAmJnBlKGBDYW4ndCBiaW5kIGlucHV0WyR7WX1dIGZvciBzZXNzaW9uPSR7ZX0uYCl9Zm9yKGxldCBZPTA7WTx4O1krKyl7bGV0IGVlPW5bWV07b1tZXT8uWzNdP2EuX09ydEJpbmRPdXRwdXQoVix1W2VlXSxUW1ldLDApIT09MCYmcGUoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtZfV0gZm9yIHNlc3Npb249JHtlfS5gKTphLl9PcnRCaW5kT3V0cHV0KFYsdVtlZV0sMCxzZVtlZV0pIT09MCYmcGUoYENhbid0IGJpbmQgb3V0cHV0WyR7WX1dIHRvICR7UVtZXX0gZm9yIHNlc3Npb249JHtlfS5gKX1QdC5zZXQoZSxbcCxtLHUsaCxfLCEwXSl9bGV0IEs7aD9LPWF3YWl0IGEuX09ydFJ1bldpdGhCaW5kaW5nKHAsaC5oYW5kbGUseCxSLCQpOks9YXdhaXQgYS5fT3J0UnVuKHAsRCxQLGcsRyx4LFIsJCksSyE9PTAmJnBlKFwiZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuXCIpO2xldCBqPVtdO2ZvcihsZXQgVj0wO1Y8eDtWKyspe2xldCBRPU51bWJlcihhLmdldFZhbHVlKFIrVipkLFwiKlwiKSk7aWYoUT09PVRbVl0pe2oucHVzaChvW1ZdKTtjb250aW51ZX1sZXQgc2U9YS5zdGFja1NhdmUoKSxZPWEuc3RhY2tBbGxvYyg0KmQpLGVlPSExLEosbmU9MDt0cnl7YS5fT3J0R2V0VGVuc29yRGF0YShRLFksWStkLFkrMipkLFkrMypkKSE9PTAmJnBlKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7Vn0uYCk7bGV0IE9lPWQ9PT00P1wiaTMyXCI6XCJpNjRcIiwkZT1OdW1iZXIoYS5nZXRWYWx1ZShZLE9lKSk7bmU9YS5nZXRWYWx1ZShZK2QsXCIqXCIpO2xldCBsZT1hLmdldFZhbHVlKFkrZCoyLFwiKlwiKSxXPU51bWJlcihhLmdldFZhbHVlKFkrZCozLE9lKSkscT1bXTtmb3IobGV0IHdlPTA7d2U8Vzt3ZSsrKXEucHVzaChOdW1iZXIoYS5nZXRWYWx1ZShsZSt3ZSpkLE9lKSkpO2EuX09ydEZyZWUobGUpIT09MCYmcGUoXCJDYW4ndCBmcmVlIG1lbW9yeSBmb3IgdGVuc29yIGRpbXMuXCIpO2xldCBoZT1xLnJlZHVjZSgod2UseWUpPT53ZSp5ZSwxKTtKPWJ0KCRlKTtsZXQgR2U9aD8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW25bVl1dO2lmKEo9PT1cInN0cmluZ1wiKXtpZihHZT09PVwiZ3B1LWJ1ZmZlclwifHxHZT09PVwibWwtdGVuc29yXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IHdlPVtdO2ZvcihsZXQgeWU9MDt5ZTxoZTt5ZSsrKXtsZXQgWWU9YS5nZXRWYWx1ZShuZSt5ZSpkLFwiKlwiKSxMdD1hLmdldFZhbHVlKG5lKyh5ZSsxKSpkLFwiKlwiKSxmbj15ZT09PWhlLTE/dm9pZCAwOkx0LVllO3dlLnB1c2goYS5VVEY4VG9TdHJpbmcoWWUsZm4pKX1qLnB1c2goW0oscSx3ZSxcImNwdVwiXSl9ZWxzZSBpZihHZT09PVwiZ3B1LWJ1ZmZlclwiJiZoZT4wKXtsZXQgd2U9YS5qc2VwR2V0QnVmZmVyO2lmKCF3ZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7bGV0IHllPXdlKG5lKSxZZT1DdCgkZSxoZSk7aWYoWWU9PT12b2lkIDB8fCFCcihKKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtKfWApO2VlPSEwLGoucHVzaChbSixxLHtncHVCdWZmZXI6eWUsZG93bmxvYWQ6YS5qc2VwQ3JlYXRlRG93bmxvYWRlcih5ZSxZZSxKKSxkaXNwb3NlOigpPT57YS5fT3J0UmVsZWFzZVRlbnNvcihRKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSB0ZW5zb3IuXCIpfX0sXCJncHUtYnVmZmVyXCJdKX1lbHNlIGlmKEdlPT09XCJtbC10ZW5zb3JcIiYmaGU+MCl7bGV0IHdlPWEuanNlcEVuc3VyZVRlbnNvcjtpZighd2UpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtpZihDdCgkZSxoZSk9PT12b2lkIDB8fCFNcihKKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtKfWApO2xldCBZZT1hd2FpdCB3ZShuZSwkZSxxLCExKTtlZT0hMCxqLnB1c2goW0oscSx7bWxUZW5zb3I6WWUsZG93bmxvYWQ6YS5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKG5lLEopLGRpc3Bvc2U6KCk9PnthLmpzZXBSZWxlYXNlVGVuc29ySWQobmUpLGEuX09ydFJlbGVhc2VUZW5zb3IoUSl9fSxcIm1sLXRlbnNvclwiXSl9ZWxzZXtsZXQgd2U9RHIoSikseWU9bmV3IHdlKGhlKTtuZXcgVWludDhBcnJheSh5ZS5idWZmZXIseWUuYnl0ZU9mZnNldCx5ZS5ieXRlTGVuZ3RoKS5zZXQoYS5IRUFQVTguc3ViYXJyYXkobmUsbmUreWUuYnl0ZUxlbmd0aCkpLGoucHVzaChbSixxLHllLFwiY3B1XCJdKX19ZmluYWxseXthLnN0YWNrUmVzdG9yZShzZSksSj09PVwic3RyaW5nXCImJm5lJiZhLl9mcmVlKG5lKSxlZXx8YS5fT3J0UmVsZWFzZVRlbnNvcihRKX19cmV0dXJuIGgmJiFfJiYoYS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaC5oYW5kbGUpIT09MCYmcGUoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSxQdC5zZXQoZSxbcCxtLHUsaCxfLCExXSkpLGp9ZmluYWxseXthLnN0YWNrUmVzdG9yZShrKSxTLmZvckVhY2goSz0+YS5fT3J0UmVsZWFzZVRlbnNvcihLKSksVC5mb3JFYWNoKEs9PmEuX09ydFJlbGVhc2VUZW5zb3IoSykpLEEuZm9yRWFjaChLPT5hLl9mcmVlKEspKSwkIT09MCYmYS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoJCksdi5mb3JFYWNoKEs9PmEuX2ZyZWUoSykpfX0sRXI9ZT0+e2xldCB0PUllKCkscj1QdC5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBuPXJbMF0sbz10Ll9PcnRFbmRQcm9maWxpbmcobik7bz09PTAmJnBlKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKG8pfSxQcj1lPT57bGV0IHQ9W107Zm9yKGxldCByIG9mIGUpe2xldCBuPXJbMl07IUFycmF5LmlzQXJyYXkobikmJlwiYnVmZmVyXCJpbiBuJiZ0LnB1c2gobi5idWZmZXIpfXJldHVybiB0fX0pO3ZhciB6dCxMZSxucixsbixjbixkbixQbyx6byxWdCxXdCxiZyxkYyxsYyxjYyxwYyxtYyxmYyxoYyxPbz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2UoKTtxbigpO2d0KCk7eHIoKTt6dD0oKT0+ISF2ZS53YXNtLnByb3h5JiZ0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIsbnI9ITEsbG49ITEsY249ITEsem89bmV3IE1hcCxWdD0oZSx0KT0+e2xldCByPXpvLmdldChlKTtyP3IucHVzaCh0KTp6by5zZXQoZSxbdF0pfSxXdD0oKT0+e2lmKG5yfHwhbG58fGNufHwhTGUpdGhyb3cgbmV3IEVycm9yKFwid29ya2VyIG5vdCByZWFkeVwiKX0sYmc9ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6bnI9ITEsZS5kYXRhLmVycj8oY249ITAsUG9bMV0oZS5kYXRhLmVycikpOihsbj0hMCxQb1swXSgpKSxkbiYmKFVSTC5yZXZva2VPYmplY3RVUkwoZG4pLGRuPXZvaWQgMCk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOmNhc2VcImNvcHktZnJvbVwiOmNhc2VcImNyZWF0ZVwiOmNhc2VcInJlbGVhc2VcIjpjYXNlXCJydW5cIjpjYXNlXCJlbmQtcHJvZmlsaW5nXCI6e2xldCB0PXpvLmdldChlLmRhdGEudHlwZSk7ZS5kYXRhLmVycj90LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6dC5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrfWRlZmF1bHQ6fX0sZGM9YXN5bmMoKT0+e2lmKCFsbil7aWYobnIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZihjbil0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO2lmKG5yPSEwLHp0KCkpcmV0dXJuIG5ldyBQcm9taXNlKChlLHQpPT57TGU/LnRlcm1pbmF0ZSgpLFZhKCkudGhlbigoW3Isbl0pPT57dHJ5e0xlPW4sTGUub25lcnJvcj1pPT50KGkpLExlLm9ubWVzc2FnZT1iZyxQbz1bZSx0XTtsZXQgbz17dHlwZTpcImluaXQtd2FzbVwiLGluOnZlfTshby5pbi53YXNtLndhc21QYXRocyYmKHJ8fGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpKSYmKG8uaW4ud2FzbS53YXNtUGF0aHM9e3dhc206bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmfSksTGUucG9zdE1lc3NhZ2UobyksZG49cn1jYXRjaChvKXt0KG8pfX0sdCl9KTt0cnl7YXdhaXQgU3IodmUud2FzbSksYXdhaXQgVHIodmUpLGxuPSEwfWNhdGNoKGUpe3Rocm93IGNuPSEwLGV9ZmluYWxseXtucj0hMX19fSxsYz1hc3luYyBlPT57aWYoenQoKSlyZXR1cm4gV3QoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1Z0KFwiaW5pdC1lcFwiLFt0LHJdKTtsZXQgbj17dHlwZTpcImluaXQtZXBcIixpbjp7ZXBOYW1lOmUsZW52OnZlfX07TGUucG9zdE1lc3NhZ2Uobil9KTthd2FpdCBJcih2ZSxlKX0sY2M9YXN5bmMgZT0+enQoKT8oV3QoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1Z0KFwiY29weS1mcm9tXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiY29weS1mcm9tXCIsaW46e2J1ZmZlcjplfX07TGUucG9zdE1lc3NhZ2UobixbZS5idWZmZXJdKX0pKTpLdChlKSxwYz1hc3luYyhlLHQpPT57aWYoenQoKSl7aWYodD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7cmV0dXJuIFd0KCksbmV3IFByb21pc2UoKHIsbik9PntWdChcImNyZWF0ZVwiLFtyLG5dKTtsZXQgbz17dHlwZTpcImNyZWF0ZVwiLGluOnttb2RlbDplLG9wdGlvbnM6ey4uLnR9fX0saT1bXTtlIGluc3RhbmNlb2YgVWludDhBcnJheSYmaS5wdXNoKGUuYnVmZmVyKSxMZS5wb3N0TWVzc2FnZShvLGkpfSl9ZWxzZSByZXR1cm4gQ3IoZSx0KX0sbWM9YXN5bmMgZT0+e2lmKHp0KCkpcmV0dXJuIFd0KCksbmV3IFByb21pc2UoKHQscik9PntWdChcInJlbGVhc2VcIixbdCxyXSk7bGV0IG49e3R5cGU6XCJyZWxlYXNlXCIsaW46ZX07TGUucG9zdE1lc3NhZ2Uobil9KTtBcihlKX0sZmM9YXN5bmMoZSx0LHIsbixvLGkpPT57aWYoenQoKSl7aWYoci5zb21lKGE9PmFbM10hPT1cImNwdVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtpZihvLnNvbWUoYT0+YSkpdGhyb3cgbmV3IEVycm9yKFwicHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtyZXR1cm4gV3QoKSxuZXcgUHJvbWlzZSgoYSxkKT0+e1Z0KFwicnVuXCIsW2EsZF0pO2xldCBsPXIscD17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6bCxvdXRwdXRJbmRpY2VzOm4sb3B0aW9uczppfX07TGUucG9zdE1lc3NhZ2UocCxQcihsKSl9KX1lbHNlIHJldHVybiBrcihlLHQscixuLG8saSl9LGhjPWFzeW5jIGU9PntpZih6dCgpKXJldHVybiBXdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57VnQoXCJlbmQtcHJvZmlsaW5nXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOmV9O0xlLnBvc3RNZXNzYWdlKG4pfSk7RXIoZSl9fSk7dmFyIGdjLHlnLHBuLGJjPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO09vKCk7dGUoKTskcigpO1huKCk7Z2M9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuW2UudHlwZSxlLmRpbXMsZS5kYXRhLFwiY3B1XCJdO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7Z3B1QnVmZmVyOmUuZ3B1QnVmZmVyfSxcImdwdS1idWZmZXJcIl07Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse21sVGVuc29yOmUubWxUZW5zb3J9LFwibWwtdGVuc29yXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0seWc9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IEhlKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIUJyKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6cixkb3dubG9hZDpuLGRpc3Bvc2U6b309ZVsyXTtyZXR1cm4gSGUuZnJvbUdwdUJ1ZmZlcihyLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpuLGRpc3Bvc2U6b30pfWNhc2VcIm1sLXRlbnNvclwiOntsZXQgdD1lWzBdO2lmKCFNcih0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIE1MVGVuc29yIHRlbnNvcmApO2xldHttbFRlbnNvcjpyLGRvd25sb2FkOm4sZGlzcG9zZTpvfT1lWzJdO3JldHVybiBIZS5mcm9tTUxUZW5zb3Iocix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6bixkaXNwb3NlOm99KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2VbM119YCl9fSxwbj1jbGFzc3thc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KXtyZXR1cm4gY2MoYXdhaXQgUXQodCkpfWFzeW5jIGxvYWRNb2RlbCh0LHIpe1VlKCk7bGV0IG47dHlwZW9mIHQ9PVwic3RyaW5nXCI/ITE/bj1hd2FpdCBRdCh0KTpuPWF3YWl0IHRoaXMuZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCk6bj10LFt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgcGMobixyKSxEZSgpfWFzeW5jIGRpc3Bvc2UoKXtyZXR1cm4gbWModGhpcy5zZXNzaW9uSWQpfWFzeW5jIHJ1bih0LHIsbil7VWUoKTtsZXQgbz1bXSxpPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goaD0+e2xldCBfPWhbMF0seT1oWzFdLGc9dGhpcy5pbnB1dE5hbWVzLmluZGV4T2YoXyk7aWYoZz09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtffSdgKTtvLnB1c2goeSksaS5wdXNoKGcpfSk7bGV0IGE9W10sZD1bXTtPYmplY3QuZW50cmllcyhyKS5mb3JFYWNoKGg9PntsZXQgXz1oWzBdLHk9aFsxXSxnPXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihfKTtpZihnPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtffSdgKTthLnB1c2goeSksZC5wdXNoKGcpfSk7bGV0IGw9by5tYXAoKGgsXyk9PmdjKGgsKCk9PmBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW2lbX11dfVwiYCkpLHA9YS5tYXAoKGgsXyk9Pmg/Z2MoaCwoKT0+YG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1tkW19dXX1cImApOm51bGwpLG09YXdhaXQgZmModGhpcy5zZXNzaW9uSWQsaSxsLGQscCxuKSx1PXt9O2ZvcihsZXQgaD0wO2g8bS5sZW5ndGg7aCsrKXVbdGhpcy5vdXRwdXROYW1lc1tkW2hdXV09YVtoXT8/eWcobVtoXSk7cmV0dXJuIERlKCksdX1zdGFydFByb2ZpbGluZygpe31lbmRQcm9maWxpbmcoKXtoYyh0aGlzLnNlc3Npb25JZCl9fX0pO3ZhciBfYz17fTtGdChfYyx7T25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQ6KCk9Pm1uLGluaXRpYWxpemVGbGFnczooKT0+eWMsd2FzbUJhY2tlbmQ6KCk9Pl9nfSk7dmFyIHljLG1uLF9nLHdjPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO09vKCk7YmMoKTt5Yz0oKT0+e2lmKCh0eXBlb2YgdmUud2FzbS5pbml0VGltZW91dCE9XCJudW1iZXJcInx8dmUud2FzbS5pbml0VGltZW91dDwwKSYmKHZlLndhc20uaW5pdFRpbWVvdXQ9MCksdmUud2FzbS5zaW1kPT09ITEmJmNvbnNvbGUud2FybignRGVwcmVjYXRlZCBwcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gZmFsc2UuIG5vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyksdHlwZW9mIHZlLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYodmUud2FzbS5wcm94eT0hMSksdHlwZW9mIHZlLndhc20udHJhY2UhPVwiYm9vbGVhblwiJiYodmUud2FzbS50cmFjZT0hMSksdHlwZW9mIHZlLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIodmUud2FzbS5udW1UaHJlYWRzKXx8dmUud2FzbS5udW1UaHJlYWRzPD0wKWlmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKXZlLndhc20ubnVtVGhyZWFkcz0xO2Vsc2V7bGV0IGU9dHlwZW9mIG5hdmlnYXRvcj5cInVcIj9ObihcIm5vZGU6b3NcIikuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTt2ZS53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGV8fDEpLzIpKX19LG1uPWNsYXNze2FzeW5jIGluaXQodCl7eWMoKSxhd2FpdCBkYygpLGF3YWl0IGxjKHQpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQscil7bGV0IG49bmV3IHBuO3JldHVybiBhd2FpdCBuLmxvYWRNb2RlbCh0LHIpLFByb21pc2UucmVzb2x2ZShuKX19LF9nPW5ldyBtbn0pO1dlKCk7V2UoKTtXZSgpO3ZhciBDYT1cIjEuMjEuMC1kZXYuMjAyNTAxMTQtMjI4ZGQxNjg5M1wiO3ZhciAkMT1Gbjt7bGV0IGU9KHdjKCksYnIoX2MpKS53YXNtQmFja2VuZDtTdChcIndlYmdwdVwiLGUsNSksU3QoXCJ3ZWJublwiLGUsNSksU3QoXCJjcHVcIixlLDEwKSxTdChcIndhc21cIixlLDEwKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodmUudmVyc2lvbnMsXCJ3ZWJcIix7dmFsdWU6Q2EsZW51bWVyYWJsZTohMH0pO2V4cG9ydHtGcCBhcyBJbmZlcmVuY2VTZXNzaW9uLHdyIGFzIFRSQUNFLFVlIGFzIFRSQUNFX0ZVTkNfQkVHSU4sRGUgYXMgVFJBQ0VfRlVOQ19FTkQsSGUgYXMgVGVuc29yLCQxIGFzIGRlZmF1bHQsdmUgYXMgZW52LFN0IGFzIHJlZ2lzdGVyQmFja2VuZH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?79d7\n");

/***/ })

}]);